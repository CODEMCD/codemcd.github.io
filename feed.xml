<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="https://codemcd.github.io/pages/CODEMCD/feed.xml" rel="self" type="application/atom+xml" /><link href="https://codemcd.github.io/pages/CODEMCD/" rel="alternate" type="text/html" /><updated>2018-10-12T14:19:20+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/</id><title type="html">CODEMCD’s Tech Blog</title><subtitle>My Tech Blog</subtitle><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><entry><title type="html">[ALGOSPOT]WORDCHAIN</title><link href="https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-WORDCHAIN/" rel="alternate" type="text/html" title="[ALGOSPOT]WORDCHAIN" /><published>2018-10-11T00:00:00+09:00</published><updated>2018-10-11T00:00:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-WORDCHAIN</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-WORDCHAIN/">&lt;h1 id=&quot;단어-제한-끝말잇기&quot;&gt;단어 제한 끝말잇기&lt;/h1&gt;

&lt;h2 id=&quot;문제-링크&quot;&gt;문제 링크&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://algospot.com/judge/problem/read/WORDCHAIN&quot;&gt;https://algospot.com/judge/problem/read/WORDCHAIN&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드-분석&quot;&gt;코드 분석&lt;/h2&gt;
&lt;h3 id=&quot;1-해밀토니안-경로hamiltonian-path&quot;&gt;1. 해밀토니안 경로(Hamiltonian path)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;그래프의 모든 정점을 정확히 한 번씩 지나는 경로&lt;/li&gt;
  &lt;li&gt;해밀토니안 경로를 찾는 유일한 방법은 조합 탐색으로, 모든 정점의 배열을 하나하나 시도하며 이들이 경로가 되는지 확인하는 것이다.
    &lt;ul&gt;
      &lt;li&gt;시간 복잡도: 최악의 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;O(N!)&lt;/code&gt;이다.&lt;/li&gt;
      &lt;li&gt;이 문제 최대 크기인 100인 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;100!&lt;/code&gt;이므로, 시간안에 절대 해결할 수 없다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;예제 그림&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/44067837-560a5d24-9fb2-11e8-86b2-ba00d44078ef.JPG&quot; alt=&quot;wordchain1&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;구현 코드&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define N 101
bool check[N];
int adj[N][N];
vector&amp;lt;string&amp;gt; sv, ans;
int n;

//행의 마지막 글자가 열의 첫 번째 글자와 일치하면 1값을 넣어,
//각각 단어를 이을 수 있는 지를 그래프로 표현한다.(인접 행렬)
void makeAdj() {
	for (int i = 0; i &amp;lt; n; ++i)
		for (int j = 0; j &amp;lt; n; ++j)
			if (i != j) {
				char iBackCh = sv[i][(int)sv[i].size() - 1];
				char jFrontCh = sv[j][0];
				if (iBackCh == jFrontCh)
					adj[i][j] = 1;
			}
}

//단어 정점을 하나씩 방문하며 경로가 되는지 검사한다.(DFS)
bool dfs(int here) {
	check[here] = true;
	ans.push_back(sv[here]);

	bool flag = true;
	for (int j = 0; j &amp;lt; n; ++j)
		if (!check[j]) {
			flag = false;
			break;
		}
	if (flag) return true;

	for (int there = 0; there &amp;lt; n; ++there) {
		if (!check[there] &amp;amp;&amp;amp; adj[here][there]) {
			if (dfs(there)) return true;
			check[there] = false;
		}
	}
	return false;
}

//모든 정점에서 경로를 만들 수 있는지 검사한다.
bool dfsAll() {
	makeAdj();
	for (int i = 0; i &amp;lt; n; ++i) {
		memset(check, false, sizeof(check));
		ans.clear();
		if (dfs(i))
			return true;
	}
	return false;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2-오일러-트레일-혹은-서킷&quot;&gt;2. 오일러 트레일 혹은 서킷&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;입력으로 주어진 각 단어를 정점이 아닌 간선으로 갖는 방향 그래프를 만든다.&lt;/li&gt;
  &lt;li&gt;각 정점은 알파벳으로 이루어져 있고, 각 단어의 첫글자에서 마지막 글자로 가는 간선을 만든다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/44067839-5638e540-9fb2-11e8-86a2-ed8191c53558.JPG&quot; alt=&quot;wordchain2&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;위 그림에서와 같은 그래프에서 오일러 트레일 혹은 서킷을 활용하면, 답이 될 수 있는 것을 알 수 있다.&lt;/li&gt;
  &lt;li&gt;오일러 서킷 및 트레일의 자세한 내용은 링크: (추가 예정)&lt;/li&gt;
  &lt;li&gt;방향 그래프에서의 오일러 서킷
    &lt;ul&gt;
      &lt;li&gt;무향 그래프에서는 각 정점에서ㅓ 인접하나 간선이 짝수 개여야 하지만, 방향 그래프에서는 둘 중 한 방향만 쓸 수 있기 때문에 &lt;strong&gt;각 정점에 들어오는 간선의 수와 나가는 간선의 수가 같아야 한다.&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;방향 그래프에서 오일러 서킷을 통해 오일러 트레일(a에서 시작, b에 도착)을 찾는 방법
        &lt;ul&gt;
          &lt;li&gt;간선 (b, a)를 추가 한다.&lt;/li&gt;
          &lt;li&gt;정점 a에서는 나가는 간선이 들어오는 간선보다 하나 많고, 정점 b는 들어오는 간선이 나가는 간선보다 하나 많아야 한다.&lt;/li&gt;
          &lt;li&gt;위 두 정점을 제외한 나머지 정점은 나가는 간선과 들어오는 간선의 수가 같아야 한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;구현 코드
```
#define _CRT_SECURE_NO_WARNINGS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
using namespace std;&lt;/algorithm&gt;&lt;/string&gt;&lt;/vector&gt;&lt;/cstring&gt;&lt;/cstdio&gt;&lt;/iostream&gt;&lt;/p&gt;

&lt;p&gt;/* 끝말잊기 문제의 입력을 그래프로 만들기*/
//그래프의 인점 행렬 표현, adj[i][j] = i와 j사이의 간선의 수
vector&amp;lt;vector&lt;int&gt;&amp;gt; adj;
//graph[i][j] = i로 시작해서 j로 끝나는 단어의 수
vector&lt;string&gt; graph[26][26];
//indegree[i] = i로 시작하는 단어의 수
//outdegree[i] = i로 끝나는 단어의 수
vector&lt;int&gt; indegree, outdegree;
void makeGraph(const vector&lt;string&gt; &amp;amp;words) {
	//전역 변수 초기화
	for (int i = 0; i &amp;lt; 26; ++i)
		for (int j = 0; j &amp;lt; 26; ++j)
			graph[i][j].clear();
	adj = vector&amp;lt;vector&lt;int&gt;&amp;gt;(26, vector&lt;int&gt;(26, 0));
	indegree = outdegree = vector&lt;int&gt;(26, 0);
	//각 단어를 그래프에 추가한다.
	for (int i = 0; i &amp;lt; words.size(); ++i) {
		int a = words[i][0] - 'a';
		int b = words[i][words[i].size() - 1] - 'a';
		graph[a][b].push_back(words[i]);
		adj[a][b]++;
		outdegree[a]++;
		indegree[b]++;
	}
}&lt;/int&gt;&lt;/int&gt;&lt;/int&gt;&lt;/string&gt;&lt;/int&gt;&lt;/string&gt;&lt;/int&gt;&lt;/p&gt;

&lt;p&gt;/* 방향 그래프에서 오일러 서킷 혹은 트레일 찾아내기 */
//유향 그래프의 인접 행렬 adj가 주어질 때 오일러 서킷 혹은 트레일을 계산한다.
void getEulerCircuit(int here, vector&lt;int&gt; &amp;amp;circuit) {
	for (int there = 0; there &amp;lt; adj.size(); ++there)
		while (adj[here][there] &amp;gt; 0) {
			adj[here][there]--;  //간선을 지운다
			getEulerCircuit(there, circuit);
		}
	circuit.push_back(here);
}&lt;/int&gt;&lt;/p&gt;

&lt;p&gt;//현재 그래프의 오일러 트레일이나 서킷을 반환한다.
vector&lt;int&gt; getEulerTrailOrCircuit() {
	vector&lt;int&gt; circuit;
	//우선 트레일을 찾아본다: 시작점이 존재하는 경우
	for(int i = 0; i &amp;lt; 26; ++i)
		if (outdegree[i] == indegree[i] + 1) {
			getEulerCircuit(i, circuit);
			return circuit;
		}
	//아니면 서킷이니, 간선에 인접한 아무 정점에서나 시간한다.
	for(int i = 0; i &amp;lt; 26; ++i)
		if (outdegree[i]) {
			getEulerCircuit(i, circuit);
			return circuit;
		}
	//모두 실패한 경우 빈 배열을 반환한다.
	return circuit;
}&lt;/int&gt;&lt;/int&gt;&lt;/p&gt;

&lt;p&gt;/* 끝말잇기 문제를 오일러 트레일 문제로 바꿔 해결하는 알고리즘 */&lt;/p&gt;

&lt;p&gt;string solve(const vector&lt;string&gt; &amp;amp;words) {
	makeGraph(words);
	//오일러 서킷이나 트레일으르 찾아낸다.
	vector&lt;int&gt; circuit = getEulerTrailOrCircuit();
	//모든 간선을 방문하지 못했으면 실패
	if (circuit.size() != words.size() + 1) return &quot;IMPOSSIBLE&quot;;
	//아닌 경우 방문 순서를 뒤집은 뒤 간선들을 모아 문자열로 만들어 반환한다.
	reverse(circuit.begin(), circuit.end());
	string ret;
	for (int i = 1; i &amp;lt; circuit.size(); ++i) {
		int a = circuit[i - 1], b = circuit[i];
		if (ret.size()) ret += &quot; &quot;;
		ret += graph[a][b].back();
		graph[a][b].pop_back();
	}
	return ret;
}&lt;/int&gt;&lt;/string&gt;&lt;/p&gt;

&lt;p&gt;int main()
{
	int tc; scanf(“%d”, &amp;amp;tc);
	while (tc–) {
		vector&lt;string&gt; sv;
		int n;  scanf(&quot;%d&quot;, &amp;amp;n);
		for (int i = 0; i &amp;lt; n; ++i) {
			string str;
			cin &amp;gt;&amp;gt; str;
			sv.push_back(str);
		}
		cout &amp;lt;&amp;lt; solve(sv) &amp;lt;&amp;lt; endl;
	}&lt;/string&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;return 0; } ```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;예외-사항&quot;&gt;예외 사항&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;위 오일러 서킷 및 트레일 코드에 예외 사항이 발생한다.
    &lt;ul&gt;
      &lt;li&gt;결과는 정답으로 나온다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;getEulerCircuit()&lt;/code&gt;함수에서 갈 수 없는 경로를 가는 경우가 발생하여 vector에 추가하지 못하는데, &lt;code class=&quot;highlighter-rouge&quot;&gt;solve()&lt;/code&gt;함수에서 정답을 출력하려 하기 때문에 존재하지 않는 vector 인덱스에 접근하여 오류로 강제 종료된다.&lt;/li&gt;
  &lt;li&gt;예외 테스트 케이스
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1
5
god
dog
gun
new
nurse
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;나중에 수정 및 해결 해볼것…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://codemcd.github.io/&quot;&gt;HOME&lt;/a&gt;&lt;/p&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="Algospot" /><summary type="html">단어 제한 끝말잇기</summary></entry><entry><title type="html">[ALGOSPOT]WILDCARD</title><link href="https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-WILDCARD/" rel="alternate" type="text/html" title="[ALGOSPOT]WILDCARD" /><published>2018-10-11T00:00:00+09:00</published><updated>2018-10-11T00:00:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-WILDCARD</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-WILDCARD/">&lt;h1 id=&quot;wildcard&quot;&gt;WILDCARD&lt;/h1&gt;

&lt;h2 id=&quot;문제-링크&quot;&gt;문제 링크&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://algospot.com/judge/problem/read/WILDCARD&quot;&gt;https://algospot.com/judge/problem/read/WILDCARD&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드-분석&quot;&gt;코드 분석&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;완전 탐색: 4가지 경우
1) s[pos]와 w[pos]가 대응되지 않는다.: 대응 실패
2) w 끝에 도달했다.: 패턴에 *가 하나도 없는 경우, 패턴과 문자열의 길이가 정확히 같아야 대응 할 수 있다.
3) s 끝에 도달했다.: 패턴은 남아있지만 문자열은 끝난 경우, 남은 패턴이 모두 *면 대응 가능하지만 아니면 대응 실패이다.
4) &lt;strong&gt;w[pos]가 *인 경우&lt;/strong&gt;: *가 몇 글자에 대응될지 모르기 때문에, 0 글자부터 남은 문자열의 길이까지를 순회하며 모든 가능성을 검사해야한다.
이때 w는 pos+1이후를 패턴 w’으로 하고, s의 pos + skip(현재 인덱스(pos) 이후 문자열 끝까지) 이후를 문자열 s’로 하여 match(w’, s’)로
재귀 호출했을 때 답이 하나라도 참이면 대응 가능하다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DP&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;w와 s는 각각 최대 101개이다.&lt;/li&gt;
      &lt;li&gt;match()가 &lt;code class=&quot;highlighter-rouge&quot;&gt;101 * 101 = 10201&lt;/code&gt;번 이상 호출되었다면 비둘기집의 원리에 따라 어떤 부분 문제가 반드시 여러 번 계산되고 있다는 뜻이다.&lt;/li&gt;
      &lt;li&gt;중복되는 계산은 메모이제이션을 사용하여 해결 가능하다.&lt;/li&gt;
      &lt;li&gt;w는 항상 전체 패턴 W의 접미사이기 때문에 w의 길이가 결정되면 w 또한 결정된다. 이를 이용하여 101 X 101 크기의 배열에 모든 부분 문제를 저장할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;결과-코드&quot;&gt;결과 코드&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;완전 탐색&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define _CRT_SECURE_NO_WARNINGS

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
#define N 1001
vector&amp;lt;string&amp;gt; res;

//와일드카드 패턴 w가 문자열 s에 대응되는지 여부를 반환한다.
bool match(const string &amp;amp;w, const string &amp;amp;s)
{
	//w[pos]와 s[pos]를 맞춰나간다.
	int pos = 0;
	while (pos &amp;lt; (int)s.size() &amp;amp;&amp;amp; pos &amp;lt; (int)w.size() &amp;amp;&amp;amp;
		(w[pos] == '?' || w[pos] == s[pos]))
		++pos;
	//더이상 대응할 수 없으면 왜 while문이 끝났는지 확인한다.
	//2. 패턴 끝에 도달해서 끝난 경우: 문자열도 끝났어야 대응됨
	if (pos == w.size())
		return pos == s.size();
	//4. *를 만나서 끝난 경우: *에 몇 글자를 대응해야 할지 재귀 호출하면서 확인한다.
	if (w[pos] == '*')
		for (int skip = 0; pos + skip &amp;lt;= (int)s.size(); ++skip)
			//하나라도 대응되는 것이 있으면 TRUE 반환
			if (match(w.substr(pos + 1), s.substr(pos + skip)))
				return true;
	//이 외의 경우에는 모두 대응되지 않는다.
	return false;
}

int main(void)
{
	int tc;
	scanf(&quot;%d&quot;, &amp;amp;tc);
	while (tc--) {
		string wild;
		cin &amp;gt;&amp;gt; wild;
		int n;
		scanf(&quot;%d&quot;, &amp;amp;n);
		while (n--) {
			string file;
			cin &amp;gt;&amp;gt; file;

			if (match(wild, file))
				res.push_back(file);
		}
		sort(res.begin(), res.end());
		for (int i = 0; i &amp;lt; (int)res.size(); i++)
			cout &amp;lt;&amp;lt; res[i] &amp;lt;&amp;lt; endl;
		res.clear();
	}

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;DP
```
#define _CRT_SECURE_NO_WARNINGS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
using namespace std;
#define N 101
vector&lt;string&gt; res;
//-1: 아직 답이 계산되지 않음
//1: 해당 입력들이 서로 대응됨
//0: 해당 입력들이 서로 대응되지 않음
int cache[N][N];
//패턴과 문자열
string W, S;
//와일드카드 패턴 W[w...]가 문자열 S[s...]에 대응되는지 여부를 반환
int matchMemoized(int w, int s)
{
	//메모이제이션
	int &amp;amp;ret = cache[w][s];
	if(ret != -1) return ret;
	//W[w]와 S[s]를 맞춰나간다.
	while (s &amp;lt; (int)S.size() &amp;amp;&amp;amp; w &amp;lt; (int)W.size() &amp;amp;&amp;amp;
		(W[w] == '?' || W[w] == S[s])) {
		++w;
		++s;
	}
	//더이상 대응할 수 없으면 왜 while문이 끝났는지 확인한다.
	//2. 패턴 끝에 도달해서 끝난 경우: 문자열도 끝났어야 참이다.
	if (w == W.size()) return ret = (s == (int)S.size());
	//4. *를 만나서 끝난 경우: *에 몇 글자를 대응해야 할지 재귀 호출하면서 확인한다.
	if (W[w] == '*')
		for (int skip = 0; skip + s &amp;lt;= (int)S.size(); ++skip)
			if (matchMemoized(w + 1, s + skip))
				return ret = 1;
	//3. 이 외의 경우에는 모두 대응되지 않는다.
	return ret = 0;
}&lt;/string&gt;&lt;/algorithm&gt;&lt;/string&gt;&lt;/vector&gt;&lt;/cstring&gt;&lt;/cstdio&gt;&lt;/iostream&gt;&lt;/p&gt;

&lt;p&gt;int main(void)
{
	int tc;
	scanf(“%d”, &amp;amp;tc);
	while (tc–) {
		cin » W;
		int n;
		scanf(“%d”, &amp;amp;n);
		while (n–) {
			memset(cache, -1, sizeof(cache));
			cin » S;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;		if (matchMemoized(0, 0))
			res.push_back(S);
		S.clear();
	}
	sort(res.begin(), res.end());
	for (int i = 0; i &amp;lt; (int)res.size(); i++)
		cout &amp;lt;&amp;lt; res[i] &amp;lt;&amp;lt; endl;
	res.clear();
	W.clear();
}

return 0; } ```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;결과-분석&quot;&gt;결과 분석&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;완전 탐색
    &lt;ul&gt;
      &lt;li&gt;소요 시간: 44ms&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;DP
    &lt;ul&gt;
      &lt;li&gt;소요 시간: 4ms&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://codemcd.github.io/&quot;&gt;HOME&lt;/a&gt;&lt;/p&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="Algospot" /><summary type="html">WILDCARD</summary></entry><entry><title type="html">[ALGOSPOT]TRIANGLEPATH</title><link href="https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-TRIANCLEPATH/" rel="alternate" type="text/html" title="[ALGOSPOT]TRIANGLEPATH" /><published>2018-10-11T00:00:00+09:00</published><updated>2018-10-11T00:00:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-TRIANCLEPATH</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-TRIANCLEPATH/">&lt;h1 id=&quot;trianglepath&quot;&gt;TRIANGLEPATH&lt;/h1&gt;

&lt;h2 id=&quot;문제-링크&quot;&gt;문제 링크&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://algospot.com/judge/problem/read/TRIANGLEPATH&quot;&gt;https://algospot.com/judge/problem/read/TRIANGLEPATH&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드-분석&quot;&gt;코드 분석&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Bottom-up
    &lt;ul&gt;
      &lt;li&gt;DP[y][x] = (y,x)일 때, 최대합&lt;/li&gt;
      &lt;li&gt;DP[0][0] = triangle[0][0]&lt;/li&gt;
      &lt;li&gt;DP[y][x] = triangle[y][x] + max(DP[y-1][x], DP[y-1][x-1])&lt;/li&gt;
      &lt;li&gt;시간복잡도: O(n^2), 부분 문제 수 n^2 * 부분 문제 계산 2&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Top-down + 메모이제이션
    &lt;ul&gt;
      &lt;li&gt;y, x는 재귀 호출이 풀어야 할 부분 문제를 지정한다. 즉, 이들은 앞으로 풀어야 할 조각들에 대한 정볼르 주는 입력들이다.&lt;/li&gt;
      &lt;li&gt;path(y,x)는 (y,x)에서 시작해서 맨 아래줄까지 내려가는 부분 경로의 최대합을 반환한다.&lt;/li&gt;
      &lt;li&gt;점화식: path(y,x) = trinangle[y][x] + max(path(y+1,x), path(y+1, x+1))&lt;/li&gt;
      &lt;li&gt;시간복잡도: O(n^2), 부분 문제수 n^2 * 부분 문제 계산 시간 M(상수)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;최적 부분 구조&lt;/em&gt;&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;동적 계획법의 중요한 요소로서, 어떤 문제와 분할 방식에 성립하는 조건이다.&lt;/li&gt;
      &lt;li&gt;각 부분 문제의 최적해만 있으면 전체 문제의 최적해를 쉽게 얻어낼 수 있는 경우이다.&lt;/li&gt;
      &lt;li&gt;대두분의 최적 부분 구조는 직관적으로 이해할 수 있지만, 그렇지 않은 경우는 대게 귀류법이나 대우를 이용해 증명할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;결과-코드&quot;&gt;결과 코드&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Bottom-up
```
#define _CRT_SECURE_NO_WARNINGS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;
#define N 101
int dp[N][N];
int tri[N][N];
int mj[2] = { -1, 0 };
int mi[2] = { -1, -1 };&lt;/cstring&gt;&lt;/cstdio&gt;&lt;/iostream&gt;&lt;/p&gt;

&lt;p&gt;int main(void)
{
	int tc;
	scanf(“%d”, &amp;amp;tc);
	while (tc–) {
		memset(dp, 0, sizeof(dp));
		memset(tri, 0, sizeof(dp));
		int n;
		scanf(“%d”, &amp;amp;n);
		for (int i = 0; i &amp;lt; n; i++) {
			for (int j = 0; j &amp;lt; n; j++) {
				if (j &amp;gt; i)
					break;
				scanf(“%d”, &amp;amp;tri[i][j]);
			}
		}
		//윗 줄부터 차례대로 내려가면서 최대합을 계산한다.
		dp[0][0] = tri[0][0];
		for (int i = 1; i &amp;lt; n; i++) {
			for (int j = 0; j &amp;lt; n; j++) {
				if (j &amp;gt; i)
					break;
				for (int f = 0; f &amp;lt; 2; f++) {
					int fi = i + mi[f];
					int fj = j + mj[f];
					if (fj &amp;gt;= 0 &amp;amp;&amp;amp; fj &amp;lt; i)
						if (dp[i][j] &amp;lt; (tri[i][j] + dp[fi][fj]))
							dp[i][j] = tri[i][j] + dp[fi][fj];
				}
			}
		}
		/&lt;em&gt;for (int i = 0; i &amp;lt; n; i++) {
		for (int j = 0; j &amp;lt; n; j++)
		printf(“%d “, dp[i][j]);
		printf(“\n”);
		}&lt;/em&gt;/
		int max = 0;
		for (int i = 0; i &amp;lt; n; i++) {
			if (max &amp;lt; dp[n - 1][i])
				max = dp[n - 1][i];
		}
		printf(“%d\n”, max);
	}&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;return 0; } ```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Top-down + 메모이제이션
```
#define _CRT_SECURE_NO_WARNINGS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;
#define N 100
#define max(a,b) ((a)&amp;gt;(b)?(a):(b))
int n, triangle[N][N];
int cache[N][N];&lt;/cstring&gt;&lt;/cstdio&gt;&lt;/iostream&gt;&lt;/p&gt;

&lt;p&gt;//(y, x) 위치부터 맨 아래줄까지 내려가면서 얻을 수 있는 최대 경로의 합을 반환한다.
int path(int y, int x)
{
	//기저 사례: 맨 아래 줄까지 도달했을 경우
	if (y == n - 1) return triangle[y][x];
	//메모이제이션
	int &amp;amp; ret = cache[y][x];
	if (ret != -1) return ret;
	return ret = max(path(y + 1, x), path(y + 1, x + 1))
		+ triangle[y][x];
}&lt;/p&gt;

&lt;p&gt;int main(void)
{
	int tc;
	scanf(“%d”, &amp;amp;tc);
	while (tc–) {
		memset(triangle, 0, sizeof(triangle));
		memset(cache, -1, sizeof(cache));
		scanf(“%d”, &amp;amp;n);
		for (int i = 0; i &amp;lt; n; i++) {
			for (int j = 0; j &amp;lt; n; j++) {
				if (j &amp;gt; i) break;
				scanf(“%d”, &amp;amp;triangle[i][j]);
			}
		}
		printf(“%d\n”, path(0, 0));
	}&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;return 0; } ```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;결과-분석&quot;&gt;결과 분석&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Bottom-up
    &lt;ul&gt;
      &lt;li&gt;시간: 12ms&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Top-down + 메모이제이션
    &lt;ul&gt;
      &lt;li&gt;시간: 8ms&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://codemcd.github.io/&quot;&gt;HOME&lt;/a&gt;&lt;/p&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="Algospot" /><summary type="html">TRIANGLEPATH</summary></entry><entry><title type="html">[ALGOSPOT]STRJOIN</title><link href="https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-STRJOIN/" rel="alternate" type="text/html" title="[ALGOSPOT]STRJOIN" /><published>2018-10-11T00:00:00+09:00</published><updated>2018-10-11T00:00:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-STRJOIN</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-STRJOIN/">&lt;h1 id=&quot;문자열-합치기&quot;&gt;문자열 합치기&lt;/h1&gt;

&lt;h2 id=&quot;문제-링크&quot;&gt;문제 링크&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://algospot.com/judge/problem/read/STRJOIN&quot;&gt;https://algospot.com/judge/problem/read/STRJOIN&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드-분석&quot;&gt;코드 분석&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;그리디 알고리즘&lt;/li&gt;
  &lt;li&gt;문자열 길이가 가장 짧은 2개를 계속 더해나간다.
    &lt;ul&gt;
      &lt;li&gt;더한 값 역시 문자열 길이가 저장되어 있는 배열에 갱신해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;vector로 구현
    &lt;ul&gt;
      &lt;li&gt;vector의 멤버함수인 push_back과 pop_back을 사용하기 위해 내림차순으로 정렬하여 구현하였다.&lt;/li&gt;
      &lt;li&gt;시간 복잡도: 내림차순 정렬&lt;code class=&quot;highlighter-rouge&quot;&gt;O(NlogN)&lt;/code&gt; + 문자열 길이 2개 더하고 vector 갱신하기&lt;code class=&quot;highlighter-rouge&quot;&gt;O(N)&lt;/code&gt; = &lt;code class=&quot;highlighter-rouge&quot;&gt;O(N^2 * logN)&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;우선순위 큐로 구현
    &lt;ul&gt;
      &lt;li&gt;시간복잡도: 우선순위 큐&lt;code class=&quot;highlighter-rouge&quot;&gt;O(logN)&lt;/code&gt; + 문자열 길이 2개 더하고 큐 갱신&lt;code class=&quot;highlighter-rouge&quot;&gt;O(N)&lt;/code&gt; = &lt;code class=&quot;highlighter-rouge&quot;&gt;O(NlogN)&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;허프만 압축 알고리즘을 응용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;결과-코드&quot;&gt;결과 코드&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;vector로 구현한 코드
```
#define _CRT_SECURE_NO_WARNINGS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;
vector&lt;int&gt; len;&lt;/int&gt;&lt;/algorithm&gt;&lt;/vector&gt;&lt;/cstdio&gt;&lt;/iostream&gt;&lt;/p&gt;

&lt;p&gt;//내림차순
bool compare(const int a, const int b)
{ return a &amp;gt; b; }&lt;/p&gt;

&lt;p&gt;int main()
{
	int tc; scanf(“%d”, &amp;amp;tc);
	while (tc–) {
		int n; scanf(“%d”, &amp;amp;n);
		for (int i = 0; i &amp;lt; n; i++) {
			int num; scanf(“%d”, &amp;amp;num);
			len.push_back(num);
		}
		int vlen = len.size();
		//내림차순 정렬
		sort(len.begin(), len.end(), compare);
		/&lt;em&gt;for (int i = 0; i &amp;lt; vlen; i++)
			printf(“%d “, len[i]);&lt;/em&gt;/
		int ans = 0, num1, num2, sum;
		//문자열 길이가 2개 이상이면 계속 더해나간다.
		while (vlen &amp;gt; 1) {
			//문자열 길이가 가장 짧은 2개를 뽑아서 더한다.
			num1 = len[vlen - 1];
			num2 = len[vlen - 2];
			len.pop_back();
			len.pop_back();
			sum = num1 + num2;
			ans += sum;
			//더한 값 역시 vector에 추가한다.
			len.push_back(sum);
			//vector 길이를 갱신한다.
			vlen = len.size();
			//다시 내림차순 정렬을 한다.
			sort(len.begin(), len.end(), compare);
		}
		printf(“%d\n”, ans);
		len.clear();
	}&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;return 0; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://codemcd.github.io/&quot;&gt;HOME&lt;/a&gt;&lt;/p&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="Algospot" /><summary type="html">문자열 합치기</summary></entry><entry><title type="html">[ALGOSPOT]SORTGAME</title><link href="https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-SORTGAME/" rel="alternate" type="text/html" title="[ALGOSPOT]SORTGAME" /><published>2018-10-11T00:00:00+09:00</published><updated>2018-10-11T00:00:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-SORTGAME</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-SORTGAME/">&lt;h1 id=&quot;sorting-game&quot;&gt;Sorting Game&lt;/h1&gt;

&lt;h2 id=&quot;문제-링크&quot;&gt;문제 링크&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://algospot.com/judge/problem/read/SORTGAME&quot;&gt;https://algospot.com/judge/problem/read/SORTGAME&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드-분석&quot;&gt;코드 분석&lt;/h2&gt;
&lt;h3 id=&quot;그래프화한-뒤-넓이-우선-탐색bfs-사용하기&quot;&gt;그래프화한 뒤 넓이 우선 탐색(BFS) 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1. 그래프로 바꾸기&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;각 배열을 정점으로 표현하고, 부분 구간을 뒤집어 한 배열에서 다른 배열을 만들 수 있을 때 두 정점을 간선으로 연결한다.&lt;/li&gt;
  &lt;li&gt;n원소가 있을 때 이들을 배열하는 방법은 &lt;code class=&quot;highlighter-rouge&quot;&gt;n!&lt;/code&gt;이며, 최대 정점의 개수도 이와 같다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/44374098-85173b80-a527-11e8-8296-76aa93b430b2.JPG&quot; alt=&quot;sortgame&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;위 그래프를 넓이 우선 탐색하면서 정렬된 상태를 나타내는 정점까지의 거리를 계산한다.&lt;/li&gt;
  &lt;li&gt;구현
    &lt;ul&gt;
      &lt;li&gt;그래프를 생성하는 과정은 생략하고, 입력 배열의 부분 구간을 뒤집으면서 그때 그때 그래프의 간선을 만들어 넓이 우선 탐색을 실행한다.&lt;/li&gt;
      &lt;li&gt;정점 큐의 각 원소를 정수 배열로 하며, 거리를 계산할 &lt;code class=&quot;highlighter-rouge&quot;&gt;distance[]&lt;/code&gt;는 정수 배열을 키(key)로 갖는 map을 사용한다.
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//perm을 정렬하기 위해 필요한 최소 뒤집기 연산의 수를 계산 후 반환한다.
int bfs(const vector&amp;lt;int&amp;gt; &amp;amp;perm) {
int n = perm.size();
//목표 정점을 미리 계산한다.(오름차순된 배열)
vector&amp;lt;int&amp;gt; sorted = perm;
sort(sorted.begin(), sorted.end());
//방문 목록(큐)
queue&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; q;
//시작점으로부터 각 정점까지의 거리(map)
map&amp;lt;vector&amp;lt;int&amp;gt;, int&amp;gt; distance;
//시작점의 거리는 0
distance[perm] = 0;
//시작점을 큐에 넣는다.
q.push(perm);
while (!q.empty()) {
    vector&amp;lt;int&amp;gt; here = q.front();
    q.pop();
    //목표 정점을 발견했으면 곧장 종료한다.
    if (here == sorted) return distance[here];
    int cost = distance[here];
    //가능한 모든 부분 구간을 뒤집어 본다.
    for (int i = 0; i &amp;lt; n; ++i) {
        //reverse함수의 배열 범위에 주의한다.
        for (int j = i + 1; j &amp;lt;= n; ++j) {
            reverse(here.begin() + i, here.begin() + j);
            if (distance.count(here) == 0) {
                distance[here] = cost + 1;
                q.push(here);
            }
            reverse(here.begin() + i, here.begin() + j);
        }
    }
}
//실행되지 않음
return -1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2. 더 빠른 해결방법&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위 방법은 최악의 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;8! = 40320&lt;/code&gt;개의 정점을 탐색하며, map에 접근해야한다. 그리고 최대 1000개의 테스트 케이스가 있기 때문에 시간안에 해결하기 힘들다.&lt;/li&gt;
  &lt;li&gt;위 알고리즘을 최적화하기 위해 2가지를 알고 있어야 한다.
    &lt;ul&gt;
      &lt;li&gt;숫자들이 다르더라도 상대적인 크기가 같은 배열들에 대한 답은 같다.
        &lt;ul&gt;
          &lt;li&gt;예를들어, 두 배열 {30, 40, 10, 20}과 {3, 4, 1, 2}는 모두 최소 연산수가 2이다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;이 문제의 그래프는 양방향 그래프이기 때문에, 시작 정점에서 목표 정점으로 가는 최단 거리는 그 반대인 목표 정점에서 시작 정점으로 가는 최단 거리와 같다.
        &lt;ul&gt;
          &lt;li&gt;한 배열을 정렬하는데 드는 연산의 수는 정렬된 배열을 원래 배열로 바꾸는데 드는 연산의 수와 같다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;위 2가지 속성을 이용하면, 모든 n(최대 크기 8)에 대해 정렬된 배열 [0, 1, 2, …, n-1]에서 모든 상태를 미리 계산한다.&lt;/li&gt;
  &lt;li&gt;입력 배열을 [0, n-1] 범위의 값으로 상대적인 크기를 유지한 상태로 바꾸면 위에서 미리 계산된 연산의 수로 답을 바로 알 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3. 구현 코드&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define _CRT_SECURE_NO_WARNINGS

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;map&amp;gt;
using namespace std;

map&amp;lt;vector&amp;lt;int&amp;gt;, int&amp;gt; toSort;
//[0, ..., n-1]의 모든 순열에 대해 toSort[]를 계산해 저장한다.
void precalc(int n) {
	vector&amp;lt;int&amp;gt; perm(n);
	for (int i = 0; i &amp;lt; n; ++i) perm[i] = i;
	queue&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; q;
	q.push(perm);
	toSort[perm] = 0;
	while (!q.empty()) {
		vector&amp;lt;int&amp;gt; here = q.front();
		q.pop();
		int cost = toSort[here];
		for (int i = 0; i &amp;lt; n; ++i) {
			for (int j = i + 1; j &amp;lt;= n; ++j) {
				reverse(here.begin() + i, here.begin() + j);
				if (toSort.count(here) == 0) {
					toSort[here] = cost + 1;
					q.push(here);
				}
				reverse(here.begin() + i, here.begin() + j);
			}
		}
	}
}

int solve(const vector&amp;lt;int&amp;gt; &amp;amp;perm) {
  //perm을 [0, ..., n-1]의 순열로 변환한다.
	int n = perm.size();
	vector&amp;lt;int&amp;gt; fixed(n);
	for (int i = 0; i &amp;lt; n; ++i) {
		int smaller = 0;
		for (int j = 0; j &amp;lt; n; ++j) {
			if (perm[j] &amp;lt; perm[i])
				smaller++;
		}
		fixed[i] = smaller;
	}
	return toSort[fixed];
}

int main()
{
	for (int i = 1; i &amp;lt;= 8; ++i)
		precalc(i);

	int tc; scanf(&quot;%d&quot;, &amp;amp;tc);
	while (tc--) {
		int n; scanf(&quot;%d&quot;, &amp;amp;n);
		vector&amp;lt;int&amp;gt; in(n);
		for (int i = 0; i &amp;lt; n; ++i)
			scanf(&quot;%d&quot;, &amp;amp;in[i]);
		printf(&quot;%d\n&quot;, solve(in));
	}

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://codemcd.github.io/&quot;&gt;HOME&lt;/a&gt;&lt;/p&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="Algospot" /><summary type="html">Sorting Game</summary></entry><entry><title type="html">[ALGOSPOT]SNAIL</title><link href="https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-SNAIL/" rel="alternate" type="text/html" title="[ALGOSPOT]SNAIL" /><published>2018-10-11T00:00:00+09:00</published><updated>2018-10-11T00:00:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-SNAIL</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-SNAIL/">&lt;h1 id=&quot;장마가-찾아왔다&quot;&gt;장마가 찾아왔다&lt;/h1&gt;

&lt;h2 id=&quot;문제-링크&quot;&gt;문제 링크&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://algospot.com/judge/problem/read/SNAIL&quot;&gt;https://algospot.com/judge/problem/read/SNAIL&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드-분석&quot;&gt;코드 분석&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;동적 계획법을 활용한 확률 계산&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;예제 문제: 우물의 깊이 n미터, 장마 기간 m일, 비가올 확률 50%, 달팽이는 비가 안올 때 1m 올라가고 비가 올 때 2m를 올라간다. 이때, 올라갈 수 있는
확률을 구하라.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int cache[N][2 * N + 1];
int n, m;
//달팽이가 days일 동안 climbed미터를 기어올라 왔다고 할 때,
//m일 전까지 n미터를 기어올라갈 수 있는 경우의 수
int climb(int days, int climbed)
{
  //기저 사례: m일이 모두 지난 경우
  if (days == m) return climbed &amp;gt;= n ? 1 : 0;
  //메모이제이션
  int &amp;amp;ret = cache[days][climbed];
  if (ret != -1) return ret;
  return ret = climb(days + 1, climbed + 2) + climb(days + 1, climbed + 1);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;완전 탐색 알고리즘에서 동적 계획법으로 순서
    &lt;ul&gt;
      &lt;li&gt;완전 탐색&lt;/li&gt;
      &lt;li&gt;climb(C): 지금까지 만든 날씨 조합C를 완성해서 원소의 합이 n이상이 되도록 하는 방법의 수&lt;/li&gt;
      &lt;li&gt;점화식: &lt;code class=&quot;highlighter-rouge&quot;&gt;climb(C) = climb(C + [1]) + climb(C + [2])&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;C + [x]는 배열 C의 맨 뒤에 x를 덧붙인 결과이다.&lt;/li&gt;
          &lt;li&gt;이 점화식은 C의 종류가 너무 많기 때문에 메모이제이션을 활용할 수 없다!&lt;/li&gt;
          &lt;li&gt;날씨 조합C =&amp;gt; C의 길이와 C의 원소의 합만을 활용한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;동적 계획법&lt;/li&gt;
      &lt;li&gt;climbed(days, climbed): 지금까지 만든 날씨 조합C의 크기가 days, 그 원소들의 합이 climbed일 때, C를 완성해서 원소의 합이 n이상이 되게 하는
방법의 수
        &lt;ul&gt;
          &lt;li&gt;최대 부분 문제의 수: &lt;code class=&quot;highlighter-rouge&quot;&gt;n * m&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;얻은 결과의 경우의 수를 &lt;code class=&quot;highlighter-rouge&quot;&gt;2^m&lt;/code&gt;으로 나누면 최종 확률을 얻을 수 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;SNAIL 문제&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위와 문제의 구조는 동일하지만, 비가 올 확률이 50%에서 75%으로 증가하였다.&lt;/li&gt;
  &lt;li&gt;점화식: &lt;code class=&quot;highlighter-rouge&quot;&gt;climb(days, climbed) = 0.25 * climb(days + 1, climbed + 1) + 0.75 * climb(days + 1, climbed + 2)&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;위의 예제와 달리 날씨의 조합마다 출현할 확률이 달라지므로, 재귀함수 결과를 경우의 수가 아닌 직접 확률을 계산해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;결과-코드&quot;&gt;결과 코드&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define _CRT_SECURE_NO_WARNINGS

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
using namespace std;
#define N 1001
double cache[N][2 * N + 1];
int n, m;

double climb(int days, int climbed)
{
	//기저 사례
	if (days == m) return climbed &amp;gt;= n ? 1. : 0.;
	//메모이제이션
	double &amp;amp;ret = cache[days][climbed];
	if (ret != -1.) return ret;
	return ret = 0.75 * climb(days + 1, climbed + 2) + 0.25 * climb(days + 1, climbed + 1);
}

int main(void)
{
	int tc;
	scanf(&quot;%d&quot;, &amp;amp;tc);
	while (tc--) {
		for (int i = 0; i &amp;lt; N; i++)
			for (int j = 0; j &amp;lt; 2 * N + 1; j++)
				cache[i][j] = -1.;
		scanf(&quot;%d %d&quot;, &amp;amp;n, &amp;amp;m);
		printf(&quot;%.10lf\n&quot;, climb(0, 0));
	}

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://codemcd.github.io/&quot;&gt;HOME&lt;/a&gt;&lt;/p&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="Algospot" /><summary type="html">장마가 찾아왔다</summary></entry><entry><title type="html">[ALGOSPOT]QUANTIZE</title><link href="https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-QUANTIZE/" rel="alternate" type="text/html" title="[ALGOSPOT]QUANTIZE" /><published>2018-10-11T00:00:00+09:00</published><updated>2018-10-11T00:00:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-QUANTIZE</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-QUANTIZE/">&lt;h1 id=&quot;quantize&quot;&gt;QUANTIZE&lt;/h1&gt;

&lt;h2 id=&quot;문제-링크&quot;&gt;문제 링크&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://algospot.com/judge/problem/read/QUANTIZE&quot;&gt;https://algospot.com/judge/problem/read/QUANTIZE&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드-분석&quot;&gt;코드 분석&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;완전 탐색
    &lt;ul&gt;
      &lt;li&gt;시간복잡도: O(1000C10^n)이고, 최대 연산수 &lt;code class=&quot;highlighter-rouge&quot;&gt;1000C10^100&lt;/code&gt;이므로 시간안에 풀 수 없다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;동적 계획법(메모이제이션)
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;&lt;em&gt;주어진 수열을 오름차순 or 내림차순으로 정렬하면, 같은 숫자로 양자화되는 숫자들은 항상 인접해 있다!&lt;/em&gt;&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;예를들어, a &amp;lt; b에 대해 a에 대응되는 숫자가 b에 대응되는 숫자보다 커서는 안된다.&lt;/li&gt;
          &lt;li&gt;이는 몇 개의 작은 입력들을 풀어보면 알 수 있는 조건이며, 시간내에 풀기 위해 알아야하는 중요한 조건이다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;기본 테스트 케이스의 한 예를 사용하면, {1, 4, 6, 744, 755, 777, 890, 897, 902} =&amp;gt; {1, 4, 6}: 4, {744, 755, 777}: 759, {890, 897, 902}: 896 로 대응된다.&lt;/li&gt;
      &lt;li&gt;이를 형식화하면, from번째 이후의 숫자들을 parts개의 묶음으로 묶을 때, 최소 오류 제곱 합을 반환하는 함수 quantize(from, parts)가 있다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;&lt;em&gt;quantize(from, parts) = min[minError(from, from + size - 1) + quantize(from + size, parts - 1)], size: 1 ~ n-from&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;minError(a,b): a번째 숫자부터 b번째 숫자까지 하나의 수로 표현했을 때의 최소 오류를 반환하는 함수
        &lt;ol&gt;
          &lt;li&gt;주어진 구간을 어떤 수로 표현해야 할지 결정하기&lt;/li&gt;
          &lt;li&gt;결정한 수 m으로 해당 구간을 표현했을 때 오차를 계산하기&lt;/li&gt;
        &lt;/ol&gt;
        &lt;ul&gt;
          &lt;li&gt;위의 역할을 완전 탐색으로 구현하여도 시간안에 해결할 수 있지만, 밑의 구현 코드는 좀 더 복잡하며 효율적인 방법을 사용한다.&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;&lt;em&gt;이는 오차 제곱의 합을 미분하여 값을 도출하며, 이를 부분 합 계산 방식으로 시간복잡도 O(1)의 방법으로 푸는 방법이며, 이 설명은 추후 추가할 예정이다.&lt;/em&gt;&lt;/strong&gt;
시간복잡도: 부분 문제의 수 ns개를 각각 n번 계산해야 하기 때문에 총 O(sn^2)이다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;결과-코드&quot;&gt;결과 코드&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;링크:
```
#define _CRT_SECURE_NO_WARNINGS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
#define N 10001
#define min(a,b) ((a)&amp;lt;(b)?(a):(b))&lt;/algorithm&gt;&lt;/cstring&gt;&lt;/cstdio&gt;&lt;/iostream&gt;&lt;/p&gt;

&lt;p&gt;const int INF = 987654321;
//A[]: 양자화해야 할 수열, 정렬한 상태
//pSum[]: A[]의 부분합을 저장한다. pSum[i]는 A[0]…A[i]의 합
//qSuSum[]: A[]제곱의 부분합을 저장한다. pSqSum[i]는 A[0]^2…A[i]^2의 합
int n;
int A[N], pSum[N], pSqSum[N];&lt;/p&gt;

&lt;p&gt;//A를 정렬하고 가가 부분합을 계산한다.
void precalc()
{
	sort(A, A + n);
	pSum[0] = A[0];
	pSqSum[0] = A[0] * A[0];
	for (int i = 1; i &amp;lt; n; i++) {
		pSum[i] = pSum[i - 1] + A[i];
		pSqSum[i] = pSqSum[i - 1] + A[i] * A[i];
	}
}&lt;/p&gt;

&lt;p&gt;//A[lo]…A[hi] 구간을 하나의 숫자로 표현할 때 최소 오차 합을 반환한다.
int minError(int lo, int hi)
{
	//부분합을 이용해 A[lo] ~ A[hi]까지의 합을 구한다.
	int sum = pSum[hi] - (lo == 0 ? 0 : pSum[lo - 1]);
	int sqSum = pSqSum[hi] - (lo == 0 ? 0 : pSqSum[lo - 1]);
	//평균을 반올림한 값으로 이 수 들을 표현한다.
	int m = int(0.5 + (double)sum / (hi - lo + 1));
	//sum(A[i] - m)^2를 전개한 결과를 부분 합으로 표현
	int ret = sqSum - 2 * m *sum + m *m *(hi - lo + 1);
	return ret;
}&lt;/p&gt;

&lt;p&gt;int cache[N][11];
int quantize(int from, int parts)
{
	//기저 사례: 모든 숫자들 양자화했을 떄
	if (from == n) return 0;
	//기저 사례: 숫자는 아직 남았는데 더 묶을 수 없을 때 아주 큰 값으르 반환한다.
	if (parts == 0) return INF;
	int &amp;amp;ret = cache[from][parts];
	if (ret != -1) return ret;
	ret = INF;
	//조각의 길이를 변화시켜 가며 최소값을 찾는다.
	for (int partSize = 1; from + partSize &amp;lt;= n; partSize++)
		ret = min(ret, minError(from, from + partSize - 1)
			+ quantize(from + partSize, parts - 1));
	return ret;
}&lt;/p&gt;

&lt;p&gt;int main(void)
{
	int tc;
	scanf(“%d”, &amp;amp;tc);
	while (tc–) {
		memset(cache, -1, sizeof(cache));
		memset(A, 0, sizeof(A));
		memset(pSum, 0, sizeof(pSum));
		memset(pSqSum, 0, sizeof(pSqSum));
		int s;
		scanf(“%d %d”, &amp;amp;n, &amp;amp;s);
		for (int i = 0; i &amp;lt; n; i++)
			scanf(“%d”, &amp;amp;A[i]);
		precalc();
		printf(“%d\n”, quantize(0, s));
	}&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;return 0; } ```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://codemcd.github.io/&quot;&gt;HOME&lt;/a&gt;&lt;/p&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="Algospot" /><summary type="html">QUANTIZE</summary></entry><entry><title type="html">[ALGOSPOT]QUADTREE</title><link href="https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-QUADTREE/" rel="alternate" type="text/html" title="[ALGOSPOT]QUADTREE" /><published>2018-10-11T00:00:00+09:00</published><updated>2018-10-11T00:00:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-QUADTREE</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-QUADTREE/">&lt;h1 id=&quot;quadtree&quot;&gt;QUADTREE&lt;/h1&gt;

&lt;h2 id=&quot;문제-링크&quot;&gt;문제 링크&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://algospot.com/judge/problem/read/QUADTREE&quot;&gt;https://algospot.com/judge/problem/read/QUADTREE&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드-분석&quot;&gt;코드 분석&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;출처: 알고리즘 문제해결전략, 분할정복&lt;/li&gt;
  &lt;li&gt;재귀 호출을 이용해 네 부분을 각각 상하로 뒤집은 결과를 얻은 뒤, 이들을 병합한다.&lt;/li&gt;
  &lt;li&gt;STL의 string 함수 사용&lt;/li&gt;
  &lt;li&gt;STL의 문자열에서 지원하는 반복자(iterator) 활용&lt;/li&gt;
  &lt;li&gt;시간복잡도 분석: O(n)
    &lt;ul&gt;
      &lt;li&gt;주어진 문자열 길이: n&lt;/li&gt;
      &lt;li&gt;재귀 함수를 호출할 때 마다 주어진 문자열의 한 글자씩을 사용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;결과-코드&quot;&gt;결과 코드&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define _CRT_SECURE_NO_WARNINGS

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;string&amp;gt;
using namespace std;

string reserve(string::iterator &amp;amp;it)
{
	char head = *it;
	++it;
	if (head == 'b' || head == 'w')
		return string(1, head);
	string upperLeft = reserve(it);
	string upperRight = reserve(it);
	string lowerLeft = reserve(it);
	string lowerRight = reserve(it);

	//각각 위와 아래 조각들의 위치를 바꾼다.
	return string(&quot;x&quot;) + lowerLeft + lowerRight +
		upperLeft + upperRight;
}

int main(void)
{
	int tc;
	scanf(&quot;%d&quot;, &amp;amp;tc);

	while (tc--) {
		string map;
		cin &amp;gt;&amp;gt; map;

		string::iterator it = map.begin();
		cout &amp;lt;&amp;lt; reserve(it) &amp;lt;&amp;lt; endl;
	}

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;결과-분석&quot;&gt;결과 분석&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;수행시간: 4ms&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://codemcd.github.io/&quot;&gt;HOME&lt;/a&gt;&lt;/p&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="Algospot" /><summary type="html">QUADTREE</summary></entry><entry><title type="html">[ALGOSPOT]PICNIC</title><link href="https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-PICNIC/" rel="alternate" type="text/html" title="[ALGOSPOT]PICNIC" /><published>2018-10-11T00:00:00+09:00</published><updated>2018-10-11T00:00:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-PICNIC</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-PICNIC/">&lt;h1 id=&quot;picnic&quot;&gt;PICNIC&lt;/h1&gt;

&lt;h2 id=&quot;문제-링크&quot;&gt;문제 링크&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://algospot.com/judge/problem/read/PICNIC&quot;&gt;https://algospot.com/judge/problem/read/PICNIC&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;내-코드-분석&quot;&gt;내 코드 분석&lt;/h2&gt;

&lt;h3 id=&quot;논리-분석&quot;&gt;논리 분석&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;입력받은 친구가 가능한 쌍을 2차원 배열에 중복없이 저장한다. ((1,0), (0,1)도 중복으로 처리한다.)&lt;/li&gt;
  &lt;li&gt;경우의 수를 체크하기 위해 가능한 쌍의 최대 크기(45)만큼 가로, 세로 크기를 갖는 2차원 배열을 선언한다.&lt;/li&gt;
  &lt;li&gt;모든 친구들이 쌍을 이루었는지 체크하는 1차원 배열을 선언한다.&lt;/li&gt;
  &lt;li&gt;최대 시간복잡도는 O(m^2)로 예상한다. (최대 반복 수는 45 * (45 + 45) 로 예사됨)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;구현-코드&quot;&gt;구현 코드&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define _CRT_SECURE_NO_WARNINGS

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
using namespace std;
#define N 11  //최대 친구 수
#define M 46  //최대 친구 쌍의 수
bool checkF[N];  //모든 친구들이 짝이 만들어졌는지 체크
bool checkP[M][M];  //짝지을 수 있는 방법을 저장할 배열(중복되지 않음)
int _pair[M][2];   //가능한 친구 쌍을 저장할 배열
bool tmp[M];  //짝지을 방법를 임시로 저장할 배열

void init_checkF_tmp(void)
{
	for (int i = 0; i &amp;lt; N; i++)
		checkF[i] = false;
	for (int i = 0; i &amp;lt; M; i++)
		tmp[i] = false;
}

void init_pair(void)
{
	for (int i = 0; i &amp;lt; M; i++) {
		_pair[i][0] = 0;
		_pair[i][1] = 0;
		for (int j = 0; j &amp;lt; M; j++)
			checkP[i][j] = false;
	}
}

bool full_checkF(int n)
{
	for (int i = 0; i &amp;lt; n; i++) {
		if (!checkF[i])
			return false;
	}
	return true;
}

//n은 현재 방법의 수
bool check_pair(int n, int m)
{
	bool flag = false;
	for (int i = 0; i &amp;lt; n; i++) {
		for (int j = 0; j &amp;lt; m; j++) {
			//하나라도 다른 부분이 있다면 다음 방법으로 넘어가서 검사한다.
			if (tmp[j] == checkP[i][j])
				flag = true;
			else {
				flag = false;
				break;
			}
		}
		//완전히 같으면 FALSE 반환
		if (flag) return false;
	}
	return true;
}

int main(void)
{
	int tc;
	scanf(&quot;%d&quot;, &amp;amp;tc);
	while (tc--) {
		init_pair();

		int n, m;
		scanf(&quot;%d %d&quot;, &amp;amp;n, &amp;amp;m);
		bool repet_flag = false;
		int repet_cnt = 0;
		for (int i = 0; i &amp;lt; m; i++) {
			int f, s;
			scanf(&quot;%d %d&quot;, &amp;amp;f, &amp;amp;s);
			//(0, 1), (1, 0)과 같은 중복을 방지하기 위해 서로 같은 쌍은 입력하지 않는다.
			repet_flag = false;
			for (int j = 0; j &amp;lt; i; j++) {
				if (_pair[j][0] == f &amp;amp;&amp;amp; _pair[j][1] == s) repet_flag = true;
				if (_pair[j][0] == s &amp;amp;&amp;amp; _pair[j][1] == f) repet_flag = true;
			}
			if (repet_flag)
				repet_cnt++;
			else {
				_pair[i - repet_cnt][0] = f;
				_pair[i - repet_cnt][1] = s;
			}
		}
		m -= repet_cnt;

		int ans = 0;
		for (int i = 0; i &amp;lt; m; i++) {
			init_checkF_tmp();
			checkF[_pair[i][0]] = true;
			checkF[_pair[i][1]] = true;
			tmp[i] = true;
			for (int j = 0; j &amp;lt; m; j++) {
				//중복을 피해기 위함
				if (i == j)
					continue;
				//친구쌍의 두 친구가 모두 check배열에 false면 해당 쌍을 사용한다.(중복검사)
				if (!checkF[_pair[j][0]] &amp;amp;&amp;amp; !checkF[_pair[j][1]]) {
					checkF[_pair[j][0]] = true;
					checkF[_pair[j][1]] = true;
					tmp[j] = true;
				}
			}
			//모든 친구들이 짝을 이루었고, 이전에 방법과 다르다면 새로운 방법이다.
			if (full_checkF(n) &amp;amp;&amp;amp; check_pair(ans, m)) {
				for (int j = 0; j &amp;lt; m; j++)
					checkP[ans][j] = tmp[j];
				ans++;
			}
		}
		printf(&quot;%d\n&quot;, ans);
	}

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;결과&quot;&gt;결과&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;수행시간 : 0ms&lt;/li&gt;
  &lt;li&gt;오답&lt;/li&gt;
  &lt;li&gt;디버깅과 다른 예제를 만들어서 테스트한 결과 틀린 부분을 찾을 수 없었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;알아둘-점&quot;&gt;알아둘 점&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;재귀에 관한 이해가 더욱 필요하다.&lt;/li&gt;
  &lt;li&gt;위의 문제도 책의 해답에서는 재귀를 사용하였다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;해답&quot;&gt;해답&lt;/h2&gt;
&lt;h3 id=&quot;코드&quot;&gt;코드&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;출처 : 알고리즘 문제해결전략 책
~~~
#define _CRT_SECURE_NO_WARNINGS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;
#define N 10
int n;
bool areFriends[N][N];
//taken[i] = i번째 학생이 짝을 이미 찾았으면 true, 아니면 false
int countPairings(bool taken[N])
{
	//남은 학생들 중 가장 번호가 빠른 학생을 찾는다.
	int firstFree = -1;
	for (int i = 0; i &amp;lt; n; i++) {
		if (!taken[i]) {
			firstFree = i;
			break;
		}
	}
	//기저 사례 : 모든 학생이 짝을 찾았으면 한 가지 방법을 찾았으니 종료한다.
	if (firstFree == -1) return 1;
	int ret = 0;
	//이 학생과 짝지을 학생을 결정한다.
	for (int pairWith = firstFree + 1; pairWith &amp;lt; n; pairWith++) {
		if (!taken[pairWith] &amp;amp;&amp;amp; areFriends[firstFree][pairWith]) {
			taken[firstFree] = taken[pairWith] = true;
			ret += countPairings(taken);
			//모든 경우의 수를 구해야하기 때문에 초기화해야함
			taken[firstFree] = taken[pairWith] = false;
		}
	}
	return ret;
}&lt;/cstdio&gt;&lt;/iostream&gt;&lt;/p&gt;

&lt;p&gt;int main(void)
{
	int tc;
	scanf(“%d”, &amp;amp;tc);
	while (tc–) {
		for (int i = 0; i &amp;lt; N; i++)
			for (int j = 0; j &amp;lt; N; j++)
				areFriends[i][j] = false;
		int m;
		scanf(“%d %d”, &amp;amp;n, &amp;amp;m);
		for (int i = 0; i &amp;lt; m; i++) {
			int f, s;
			scanf(“%d %d”, &amp;amp;f, &amp;amp;s);
			areFriends[f][s] = areFriends[s][f] = true;
		}
		bool taken[10] = { false, };
		int ans = countPairings(taken);
		printf(“%d\n”, ans);
	}&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;return 0; } ~~~
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;결과-및-코드-분석&quot;&gt;결과 및 코드 분석&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;수행 시간 : 0ms&lt;/li&gt;
  &lt;li&gt;최대 시간 복잡도 : 열 명의 학생이 모두 친구인 경우(9 * 7 * 5 * 3 * 1 = 945)&lt;/li&gt;
  &lt;li&gt;재귀 함수 사용&lt;/li&gt;
  &lt;li&gt;공간 복잡도면에서, 2차원 배열 1개와 1차원 배열 1개를 사용하여 내가 구현한 코드보다 더 효율적이다.&lt;/li&gt;
  &lt;li&gt;친구 쌍이 가능한지를 저장하는 2차원 배열에서 그 반대의 경우도 모두 저장해주어야 정확한 답이 나온다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;알아둘-점-1&quot;&gt;알아둘 점&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1) 재귀 함수 구현 능력&lt;/strong&gt;
&amp;lt;/br&amp;gt;&lt;strong&gt;2) 재귀 함수를 사용하기 위한 입력 형식을 만드는 방법&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://codemcd.github.io/&quot;&gt;HOME&lt;/a&gt;&lt;/p&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="Algospot" /><summary type="html">PICNIC</summary></entry><entry><title type="html">[ALGOSPOT]PI</title><link href="https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-PI/" rel="alternate" type="text/html" title="[ALGOSPOT]PI" /><published>2018-10-11T00:00:00+09:00</published><updated>2018-10-11T00:00:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-PI</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-PI/">&lt;h1 id=&quot;pi&quot;&gt;PI&lt;/h1&gt;

&lt;h2 id=&quot;문제-링크&quot;&gt;문제 링크&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://algospot.com/judge/problem/read/PI&quot;&gt;https://algospot.com/judge/problem/read/PI&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;테스트-케이스&quot;&gt;테스트 케이스&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;기본 테스트 케이스
    &lt;ul&gt;
      &lt;li&gt;입력
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;5
12341234
11111222
12122222
22222222
12673939
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;출력
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;4
2
5
2
14
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;코드-분석&quot;&gt;코드 분석&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;동적 계획법(메모이제이션)
    &lt;ul&gt;
      &lt;li&gt;첫 조각의 길이는 3, 4, 5 중의 하나이므로 각 경우마다 하나씩의 부분 문제를 해결한다, 이때 세 개의 부분 문제의 최적화(최소값)을 각각 구하면 전체 문제의 최적해가 된다.
        &lt;ol&gt;
          &lt;li&gt;길이 3인 조각의 난이도 +3글자 빼고 나머지 수열에 대한 최적해&lt;/li&gt;
          &lt;li&gt;길이 4인 조각의 난이도 +4글자 빼고 나머지 수열에 대한 최적해&lt;/li&gt;
          &lt;li&gt;길이 5인 조각의 난이도 +5글자 빼고 나머지 수열에 대한 최적해&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;begin: 부분 수열의 시작 위치, memorize(): 최소 난이도를 반환하는 함수, returnLevel(): 해당 수열의 난이도를 반환하는 함수&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;&lt;em&gt;memorize(begin) = min(memorize(begin + L) + returnLevel(N[begin…begin + L])), L: 3 ~ 5&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;returnLevel() 함수
    &lt;ul&gt;
      &lt;li&gt;checkLevel() 함수
        &lt;ol&gt;
          &lt;li&gt;수열의 길이 3, 4, 5에 대해서만 적용할 수 있는 함수이다.&lt;/li&gt;
          &lt;li&gt;시간복잡도면에서 효율적이다. (소요시간: 24ms)&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;classify() 함수
        &lt;ol&gt;
          &lt;li&gt;모든 수열의 길이에 대해 적용 가능하다.&lt;/li&gt;
          &lt;li&gt;시간이 오래 걸린다. (소요시간: 250ms)&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;결과-코드&quot;&gt;결과 코드&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;링크:
```
#define _CRT_SECURE_NO_WARNINGS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;limits.h&gt;
using namespace std;
#define N 10001
#define min(a, b) ((a) &amp;lt; (b) ? (a) : (b))
string arr;
const int INF = 987654321;
int cache[N];&lt;/limits.h&gt;&lt;/cmath&gt;&lt;/cstring&gt;&lt;/string&gt;&lt;/cstdio&gt;&lt;/iostream&gt;&lt;/p&gt;

&lt;p&gt;//1) arr[s]부터 size만큼 크기의 난이도를 반환
int checkLevel(int s, int size)
{
	if (size == 3) {
		int s1, s2, s3;
		s1 = arr[s]; s2 = arr[s + 1]; s3 = arr[s + 2];
		if (s1 == s2 &amp;amp;&amp;amp; s2 == s3)
			return 1;
		int d1, d2;
		d1 = s2 - s1; d2 = s3 - s2;
		if (d1 == d2) {
			if (d1 == 1 || d1 == -1)
				return 2;
			else
				return 5;
		}
		if (s1 == s3)
			return 4;
	}
	else if (size == 4) {
		int s1, s2, s3, s4;
		s1 = arr[s]; s2 = arr[s + 1]; s3 = arr[s + 2]; s4 = arr[s + 3];
		if (s1 == s2 &amp;amp;&amp;amp; s2 == s3 &amp;amp;&amp;amp; s3 == s4)
			return 1;
		int d1, d2, d3;
		d1 = s2 - s1; d2 = s3 - s2; d3 = s4 - s3;
		if (d1 == d2 &amp;amp;&amp;amp; d2 == d3) {
			if (d1 == 1 || d1 == -1)
				return 2;
			else
				return 5;
		}
		if (s1 == s3 &amp;amp;&amp;amp; s2 == s4)
			return 4;
	}
	else if (size == 5) {
		int s1, s2, s3, s4, s5;
		s1 = arr[s]; s2 = arr[s + 1]; s3 = arr[s + 2];
		s4 = arr[s + 3]; s5 = arr[s + 4];
		if (s1 == s2 &amp;amp;&amp;amp; s2 == s3 &amp;amp;&amp;amp; s3 == s4 &amp;amp;&amp;amp; s4 == s5)
			return 1;
		int d1, d2, d3, d4;
		d1 = s2 - s1; d2 = s3 - s2; d3 = s4 - s3; d4 = s5 - s4;
		if (d1 == d2 &amp;amp;&amp;amp; d2 == d3 &amp;amp;&amp;amp; d3 == d4) {
			if (d1 == 1 || d1 == -1)
				return 2;
			else
				return 5;
		}
		if ((s1 == s3 &amp;amp;&amp;amp; s3 == s5) &amp;amp;&amp;amp; s2 == s4)
			return 4;
	}
	return 10;
}&lt;/p&gt;

&lt;p&gt;//2) arr[a,b]구간의 난이도를 반환한다.
int classify(int a, int b)
{
	//숫자 조각을 가져온다.
	string M = arr.substr(a, b - a + 1);
	//첫 글자만으로 이루어진 문자열과 같은으면 난이도 1
	if (M == string(M.size(), M[0])) return 1;
	//등차수열인지 검사한다.
	bool progressive = true;
	for (int i = 0; i &amp;lt; (int)M.size() - 1; i++)
		if (M[i + 1] - M[i] != M[1] - M[0])
			progressive = false;
	//등차수열이고 공차가 1 or -1 이면 난이도 2
	if (progressive &amp;amp;&amp;amp; abs(M[1] - M[0]) == 1)
		return 2;
	//두 수가 번갈아 등장하는지 확인한다.
	bool alternating = true;
	for (int i = 0; i &amp;lt; (int)M.size(); i++)
		if (M[i] != M[i % 2])
			alternating = false;
	if (alternating) return 4;  //두 수가 번갈아 등장하면 난이도 4
	if (progressive) return 5;  //공차가 1 아닌 등차수열이면 난이도 5
	return 10;                  //이 외는 모두 난이도 10
}&lt;/p&gt;

&lt;p&gt;//수열 arr[begin…]를 외우는 방법 중 난이도의 최소 합을 출력한다.
int memorize(int begin)
{
	//기저 사례: 수열의 끝에 도달했을 경우
	if (begin == arr.size()) return 0;
	//메모이제이션
	int &amp;amp;ret = cache[begin];
	if (ret != -1) return ret;
	ret = INF;
	for (int L = 3; L &amp;lt;= 5; ++L) {
		if (begin + L &amp;lt;= (int)arr.size())
			ret = min(ret, memorize(begin + L) + checkLevel(begin, L));              //방법 1)
			//ret = min(ret, memorize(begin + L) + classify(begin, begin + L - 1));  //방법 2)
	}
	return ret;
}&lt;/p&gt;

&lt;p&gt;int main(void)
{
	int tc;
	scanf(“%d”, &amp;amp;tc);
	while (tc–) {
		memset(cache, -1, sizeof(cache));
		arr.clear();
		cin » arr;
		printf(“%d\n”, memorize(0));
	}&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;return 0; } ```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://codemcd.github.io/&quot;&gt;HOME&lt;/a&gt;&lt;/p&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="Algospot" /><summary type="html">PI</summary></entry></feed>