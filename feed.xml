<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://codemcd.github.io/pages/CODEMCD/feed.xml" rel="self" type="application/atom+xml" /><link href="https://codemcd.github.io/pages/CODEMCD/" rel="alternate" type="text/html" /><updated>2019-05-05T17:18:02+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/feed.xml</id><title type="html">CODEMCD’s Tech BLOG</title><subtitle>My Tech Blog</subtitle><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><entry><title type="html">[운영체제] # 17 프레임 할당(Allocation of Frames)</title><link href="https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-17%EC%9E%A5-%ED%94%84%EB%A0%88%EC%9E%84-%ED%95%A0%EB%8B%B9/" rel="alternate" type="text/html" title="[운영체제] # 17 프레임 할당(Allocation of Frames)" /><published>2019-05-04T07:30:00+09:00</published><updated>2019-05-04T07:30:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-17%EC%9E%A5-%ED%94%84%EB%A0%88%EC%9E%84%20%ED%95%A0%EB%8B%B9</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-17%EC%9E%A5-%ED%94%84%EB%A0%88%EC%9E%84-%ED%95%A0%EB%8B%B9/">&lt;h1 id=&quot;global-vs-local-replacement&quot;&gt;Global VS Local Replacement&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Global Replacement: 메모리 상의 모든 프로세스 페이지에 대한 교체 작업을 수행한다.&lt;/li&gt;
  &lt;li&gt;Local Replacement: 메모리 상의 자기 자신의 프로세스 페이지에 대해서만 교체 작업을 수행한다.
메모리 사용 효율은 일반적으로 Global Replacement이 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;프레임-할당allocation-of-frames&quot;&gt;프레임 할당(Allocation of Frames)&lt;/h1&gt;
&lt;h2 id=&quot;쓰레싱thrashing&quot;&gt;쓰레싱(Thrashing)&lt;/h2&gt;
&lt;p&gt;일반적으로 메모리에 올라가는 프로세스 개수가 증가할수록 CPU의 이용률은 올라갈 것이라 예상한다. 왜냐하면 프로세스가 많을 수록 CPU의 할 일 역시 증가하기때문이다. 이는 일정 범위까지는 맞는 예상이지만, 그 &lt;strong&gt;범위를 넘어서면 오히려 CPU 이용률이 감소하는 현상&lt;/strong&gt; 이 나타난다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57186861-717afc00-6f21-11e9-8002-7b4130f361c2.png&quot; alt=&quot;OS17-1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 이러한 현상을 그래프로 나타낸 것이다. 이와 같은 현상이 발생하는 이유는 프로세스가 증가할수록 메인 메모리의 비어있는 프레임 개수는 줄어들게 되고 결국 모든 프레임이 가득 차게 된다. 그 후에도 계속 프로세스가 증가한다면 &lt;strong&gt;메모리와 backing store 사이에 page in/out 작업&lt;/strong&gt; 이 발생하는데, 프로세스가 많아질수록 이 작업 역시 증가한다. page in/out은 디스크 I/O 작업으로 CPU를 사용하지 않는 작업이다. 그러므로 이 작업이 많아질수록 CPU는 그동안 아무것도 하지 않게 된다.&lt;/p&gt;

&lt;p&gt;위 그래프에서도 나와있듯이, I/O 작업이 증가하여 CPU 이용률이 떨어지는 현상을 &lt;strong&gt;Thrashing&lt;/strong&gt; 이라 한다.&lt;/p&gt;

&lt;p&gt;쓰레싱을 해결하는 방법은 크게 두 가지가 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Global Replacement보다 Local Replacement를 사용하는 것이다. 하지만 이 경우에는 메모리 사용 효율이 떨어지는 단점이 있다.&lt;/li&gt;
  &lt;li&gt;프로세스당 &lt;strong&gt;충분한/적절한 수의 프레임(메모리)을 할당&lt;/strong&gt; 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그렇다면, 적절한 프레임의 수는 어떻게 정하는 것일까?&lt;/p&gt;

&lt;p&gt;프레임 할당은 크게 정적 할당과 동적 할당으로 나뉜다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;정적 할당(Static Allocation)
    &lt;ul&gt;
      &lt;li&gt;동일 할당(Equal Allocation): 모든 프로세스에게 똑같은 수의 프레임을 할당한다. 이 방식은 프로세스의 크기에 따라 매우 비효율적이다.&lt;/li&gt;
      &lt;li&gt;비례 할당(Proportional Allocation): 프로세스의 크기에 따라 프레임을 할당한다. 이 방식 역시 단점이 있다. 프로세스 크기가 크더라도 모든 기능을 사용하지 않기 때문에 이 방식 또한 비효율적이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이처럼 정적 할당은 한계가 뚜렷하다. 이를 해결하기 위한 방법은 &lt;strong&gt;실행 중에 프레임을 할당하는 동적 할당&lt;/strong&gt; 이다.&lt;/p&gt;

&lt;h2 id=&quot;동적-할당dynamic-allocation&quot;&gt;동적 할당(Dynamic Allocation)&lt;/h2&gt;
&lt;h3 id=&quot;working-set-model&quot;&gt;Working Set Model&lt;/h3&gt;
&lt;p&gt;프로세스가 실행 중일 때 어느 페이지를 사용하는지 실험한 결과에서 &lt;strong&gt;Locality&lt;/strong&gt; 성질이 성립한다는 것을 발견할 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57186862-717afc00-6f21-11e9-8bbb-794e7ac36f1e.png&quot; alt=&quot;OS17-2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그래프는 프로세스가 실행 중에 어떤 프로세스를 사용하는지 표시한 것으로, 특정 시간에는 일정 범위의 페이지를 주로 참조하는 것을 알 수 있다. 이러한 성질은 캐시에서도 볼 수 있다. 이를 통해 특정 시간에 따라 사용하는 페이지의 개수만큼 프레임을 할당해줄 수 있다.&lt;/p&gt;

&lt;p&gt;이 방법 역시 치명적인 단점이 있다. 바로 프로세스를 미리 수행해봐야 할 수 있다는 것이다. 그리고 프로세스를 수행할 때마다 사용하는 기능이 달라질 수 있으므로, Locality를 이용하는 방법은 비현실적이다.&lt;/p&gt;

&lt;p&gt;이를 해결하기 위해 나온 것이 &lt;strong&gt;working set&lt;/strong&gt; 이다. working set은 위의 locality의 방식과 유사한데, 미래가 아닌 과거를 보는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57186863-717afc00-6f21-11e9-8f9c-d580494fa04c.png&quot; alt=&quot;OS17-3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 working set을 사용하는 모습이다. working set은 &lt;strong&gt;현재 시간에서 일정 시간(△) 이전동안 사용되었던 페이지의 집합&lt;/strong&gt; 이다. △(델타)는 운영체제 내부에서 정하는 기준에 따라 다르며, 이를 &lt;strong&gt;working set window&lt;/strong&gt; 라 한다. 마지막으로 working set의 개수만큼 프레임을 할당한다.&lt;/p&gt;

&lt;p&gt;만약 현재 시간이 t1이라면 working set = {1, 2, 5, 6, 7}이다. 이 때 working set의 개수는 총 5개이므로 프레임 역시 5개를 할당해주면 된다.&lt;/p&gt;

&lt;h2 id=&quot;page-fault-frequencypff&quot;&gt;Page-Fault Frequency(PFF)&lt;/h2&gt;
&lt;p&gt;페이지 부재의 비율은 프로세스에 할당된 프레임의 수에 반비례한다. 즉, 할당된 프레임의 수가 적을수록 페이지 부재 비율은 늘어난다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57186864-717afc00-6f21-11e9-9c69-5f6e1a1e0f20.png&quot; alt=&quot;OS17-4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 이와 같은 현상을 그래프로 나타낸 것이다. 세로축은 페이지 부재 비율이고, 가로축은 할당된 프레임의 수이다. 여기서 운영체제 내부에서 해당 프로세스의 페이지 부재 횟수를 계속 검사한다. 그러면 위와 같은 그래프처럼 나오는데, 여기서 &lt;strong&gt;상한선(upper bound)과 하한선(lower bound)를 설정&lt;/strong&gt; 한다.&lt;/p&gt;

&lt;p&gt;만약 상한선보다 많은 페이지 부재가 발생하면 프레임을 더 많이 할당해주고, 하한선보다 적게 페이지 부재가 발생하면 할당된 프레임 개수를 줄여준다.&lt;/p&gt;

&lt;h1 id=&quot;페이지-크기&quot;&gt;페이지 크기&lt;/h1&gt;
&lt;p&gt;현재 페이지의 일반적인 크기는 &lt;strong&gt;4KB ~ 4MB&lt;/strong&gt; 이다. 이는 과거에서부터 점점 커져왔고, 현재에도 메모리 크기가 증가하면서 커지고 있다.&lt;/p&gt;

&lt;p&gt;페이지 크기에 따라 성능에는 어떤 영향을 미치는지 알아보자.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;내부단편화&lt;/strong&gt;: 내부단편화를 줄이려면 페이지 크기는 작은 것이 좋다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Page-in, page-out 시간&lt;/strong&gt;: 페이지의 in/out 시간을 결정하는 가장 큰 요인은 하드디스크 기준으로 하드디스크의 헤더가 움직이는 시간이다.(&lt;strong&gt;seek time&lt;/strong&gt;) 페이지 크기가 크면 클수록 한 번의 seek time마다 큰 페이지를 읽을 수 있으므로, 페이지 부재 빈도가 줄어든다.(데이터를 읽는 시간은 크기에 따라 차이가 매우 적다.)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;페이지 테이블 크기&lt;/strong&gt;: 페이지 크기가 클수록 페이지 개수가 줄어들기 때문에 그만큼 페이지 테이블 크기도 줄일 수 있다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Memory resolution(해상도)&lt;/strong&gt;: Memory resolution은 해당 메모리에 필요한 데이터가 있는 확률이다. 이는 페이지 크기가 작을수록 resolution을 높일 수 있다. 만약 페이지 크기가 크면 다른 필요없는 부분이 있을 확률이 크기 때문이다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Page fault 발생 확률&lt;/strong&gt;: Page fault 발생 확률을 줄이려면 페이지 크기가 큰 것이 좋다. 이는 locality 성질과도 관련이 있는데, 대부분 프로세스는 필요한 부분이 일정 범위 이내인 경우가 많으므로 페이지 크기가 클수록 필요한 부분이 있을 확률이 크다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;페이지-테이블&quot;&gt;페이지 테이블&lt;/h2&gt;
&lt;p&gt;반도체 기술의 발달로 TLB 역시 CPU의 내장 칩 형태로 만들어져있다.&lt;/p&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="Study_OperatingSystem" /><summary type="html">최신 업데이트 날짜: 2019-05-03</summary></entry><entry><title type="html">[운영체제] # 16 페이지 교체 알고리즘(Page Replacement Algorithm)</title><link href="https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-16%EC%9E%A5-%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/" rel="alternate" type="text/html" title="[운영체제] # 16 페이지 교체 알고리즘(Page Replacement Algorithm)" /><published>2019-05-04T05:30:00+09:00</published><updated>2019-05-04T05:30:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-16%EC%9E%A5-%ED%8E%98%EC%9D%B4%EC%A7%80%20%EA%B5%90%EC%B2%B4%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-16%EC%9E%A5-%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">&lt;p&gt;페이지 교체 알고리즘을 살펴보기 전에 &lt;strong&gt;Page reference string&lt;/strong&gt; 이라는 용어를 알아야 한다. CPU가 내는 주소는 이진수 단위이지만, 페이지 교체 알고리즘을 계산하기 위해서는 이진수 주소 단위가 아닌 페이지 단위로 계산해야한다.&lt;/p&gt;

&lt;p&gt;예를 들어, CPU가 내는 주소를 간단히 십진수로 표현하여 {100, 101, 102, 432, 612, 103, 104, 611, 612} 라고 하자. 만약 페이지 크기가 100bytes라면, 위 주소를 페이지 번호로 나타내면 {1, 1, 1, 4, 6, 1, 1, 6, 6} 이다. 주소 100번지는 1번 페이지에서 offset이 0인 위치이고, 101은 1번 페이지의 offset 1인 위치라고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;마지막으로 페이지 번호로 나타낸 것을 page reference string으로 나타내면 {1, 4, 6, 1, 6}이다. 이는 간단히 말하면 &lt;strong&gt;연속된 페이지는 생략하고 하나의 페이지 번호만&lt;/strong&gt; 나타낸 것으로 볼 수 있다. 이 이유는 연속된 페이지를 참조할 때는 한 번 page fault가 발생하면 같은 페이지를 사용하는 동안에는 절대 page fault가 발생할 수 없기 때문이다.&lt;/p&gt;

&lt;p&gt;정리하면, page size = 100bytes 일때&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CPU 주소              = {100, 101, 102, 432, 612, 103, 104, 611, 612}
Page 번호             = {1, 1, 1, 4, 6, 1, 1, 6, 6}
Page reference string = {1, 4, 6, 1, 6}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;first-in-first-outfifo&quot;&gt;First-In First-Out(FIFO)&lt;/h1&gt;
&lt;p&gt;FIFO은 가장 간단한 알고리즘이다. 가장 먼저 page-in 한 페이지를 먼저 page-out 시킨다. 이를 사용한 이유는 초기화 코드가 더 이상 사용되지 않을 것이라는 아이디어에서 시작되었다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;예제
페이지 참조열(page reference string): {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 7, 0, 1}
프레임 개수(number of frame): 3
조건은 위와 같고 최초의 메모리는 비어있는 상태이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;4&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;5&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;6&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;7&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;8&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;9&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;10&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;11&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;12&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;13&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;14&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;15&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;16&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;17&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;18&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;19&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;프레임 상태: {}&lt;/li&gt;
  &lt;li&gt;Page-in: 7 =&amp;gt; 프레임 상태: {7}        Page fault 수: 1                First Page: 7&lt;/li&gt;
  &lt;li&gt;Page-in: 0 =&amp;gt; 프레임 상태: {7, 0}     Page fault 수: 2                First Page: 7&lt;/li&gt;
  &lt;li&gt;Page-in: 1 =&amp;gt; 프레임 상태: {7, 0, 1}  Page fault 수: 3                First Page: 7&lt;/li&gt;
  &lt;li&gt;Page-in: 2 =&amp;gt; 프레임 상태: {2, 0, 1}  Page fault 수: 4   Page-out: 7  First Page: 0&lt;/li&gt;
  &lt;li&gt;Page-in: 0 =&amp;gt; 프레임 상태: {2, 0, 1}  Page fault 수: 4                First Page: 0&lt;/li&gt;
  &lt;li&gt;Page-in: 3 =&amp;gt; 프레임 상태: {2, 3, 1}  Page fault 수: 5   Page-out: 0  First Page: 1&lt;/li&gt;
  &lt;li&gt;Page-in: 0 =&amp;gt; 프레임 상태: {2, 3, 0}  Page fault 수: 6   Page-out: 1  First Page: 2&lt;/li&gt;
  &lt;li&gt;Page-in: 4 =&amp;gt; 프레임 상태: {4, 3, 0}  Page fault 수: 7   Page-out: 2  First Page: 3&lt;/li&gt;
  &lt;li&gt;Page-in: 2 =&amp;gt; 프레임 상태: {4, 2, 1}  Page fault 수: 8   Page-out: 3  First Page: 1&lt;/li&gt;
  &lt;li&gt;Page-in: 3 =&amp;gt; 프레임 상태: {4, 2, 3}  Page fault 수: 9   Page-out: 1  First Page: 4&lt;/li&gt;
  &lt;li&gt;Page-in: 0 =&amp;gt; 프레임 상태: {0, 2, 3}  Page fault 수: 10  Page-out: 4  First Page: 2&lt;/li&gt;
  &lt;li&gt;Page-in: 3 =&amp;gt; 프레임 상태: {0, 2, 3}  Page fault 수: 10               First Page: 2&lt;/li&gt;
  &lt;li&gt;Page-in: 2 =&amp;gt; 프레임 상태: {0, 2, 3}  Page fault 수: 10               First Page: 2&lt;/li&gt;
  &lt;li&gt;Page-in: 1 =&amp;gt; 프레임 상태: {0, 1, 3}  Page fault 수: 11  Page-out: 2  First Page: 3&lt;/li&gt;
  &lt;li&gt;Page-in: 2 =&amp;gt; 프레임 상태: {0, 1, 2}  Page fault 수: 12  Page-out: 3  First Page: 0&lt;/li&gt;
  &lt;li&gt;Page-in: 0 =&amp;gt; 프레임 상태: {0, 1, 2}  Page fault 수: 12               First Page: 0&lt;/li&gt;
  &lt;li&gt;Page-in: 7 =&amp;gt; 프레임 상태: {7, 1, 2}  Page fault 수: 13  Page-out: 0  First Page: 1&lt;/li&gt;
  &lt;li&gt;Page-in: 0 =&amp;gt; 프레임 상태: {7, 0, 2}  Page fault 수: 14  Page-out: 1  First Page: 2&lt;/li&gt;
  &lt;li&gt;Page-in: 1 =&amp;gt; 프레임 상태: {7, 0, 1}  Page fault 수: 15  Page-out: 2  First Page: 7&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;결과는 최종 page fault 수는 15이다. 예제를 수행하면서, 이전에 page-out한 페이지를 그 다음 바로 page-in을 하려한다면 다시 page fault가 발생하기 때문에 비효율적인 모습을 볼 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;beladys-anomaly&quot;&gt;Belady’s Anomaly&lt;/h2&gt;
&lt;p&gt;프레임 수가 증가하면(= 메모리 용량이 증가하면) page fault 수가 줄어드는 것이 정상적이지만, 특정한 페이지 참조열에 대해서는 프레임 수가 증가해도 page fault 수가 오히려 증가하는 이상 현상이 발생한다. 이를 Belady’s Anomaly라 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57186860-70e26580-6f21-11e9-8633-6012ad59eb3d.png&quot; alt=&quot;OS16-1&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;optimalopt&quot;&gt;Optimal(OPT)&lt;/h1&gt;
&lt;p&gt;OPT는 말그대로 가장 효율적인 페이지 교체 알고리즘이다. 이 알고리즘은 &lt;strong&gt;가장 오랫동안 사용되지 않을&lt;/strong&gt; 페이지를 희생양 페이지로 선택한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;예제
페이지 참조열(page reference string): {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 7, 0, 1}
프레임 개수(number of frame): 3
여기서 가장 오랫동안 사용되지 않을 페이지를 계산하기 위해 &lt;strong&gt;현재 시점 에서 그 이후에 최초로 나타나는 시점의 거리&lt;/strong&gt; 를 dist로 둔다. 이 값이 가장 큰 페이지가 가장 오랫동안 사용되지 않은 페이지로 정한다.(해당 페이지가 이후에 나오지 않는 경우는 INF로 가장 큰 값으로 한다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;4&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;5&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;6&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;7&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;8&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;9&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;10&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;11&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;12&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;13&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;14&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;15&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;16&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;17&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;18&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;19&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;프레임 상태: {}&lt;/li&gt;
  &lt;li&gt;Page-in: 7 =&amp;gt; 프레임 상태: {7}        Page fault 수: 1                dist: {15}&lt;/li&gt;
  &lt;li&gt;Page-in: 0 =&amp;gt; 프레임 상태: {7, 0}     Page fault 수: 2                dist: {14, 3}&lt;/li&gt;
  &lt;li&gt;Page-in: 1 =&amp;gt; 프레임 상태: {7, 0, 1}  Page fault 수: 3                dist: {13, 2, 11}&lt;/li&gt;
  &lt;li&gt;Page-in: 2 =&amp;gt; 프레임 상태: {2, 0, 1}  Page fault 수: 4   Page-out: 7  dist: {5, 1, 10}&lt;/li&gt;
  &lt;li&gt;Page-in: 0 =&amp;gt; 프레임 상태: {2, 0, 1}  Page fault 수: 4                dist: {4, 2, 9}&lt;/li&gt;
  &lt;li&gt;Page-in: 3 =&amp;gt; 프레임 상태: {2, 0, 3}  Page fault 수: 5   Page-out: 1  dist: {3, 1, 4}&lt;/li&gt;
  &lt;li&gt;Page-in: 0 =&amp;gt; 프레임 상태: {2, 0, 3}  Page fault 수: 5                dist: {2, 4, 3}&lt;/li&gt;
  &lt;li&gt;Page-in: 4 =&amp;gt; 프레임 상태: {2, 4, 3}  Page fault 수: 6   Page-out: 0  dist: {1, INF, 2}&lt;/li&gt;
  &lt;li&gt;Page-in: 2 =&amp;gt; 프레임 상태: {2, 4, 3}  Page fault 수: 6                dist: {4, INF, 1}&lt;/li&gt;
  &lt;li&gt;Page-in: 3 =&amp;gt; 프레임 상태: {2, 4, 3}  Page fault 수: 6                dist: {3, INF, 2}&lt;/li&gt;
  &lt;li&gt;Page-in: 0 =&amp;gt; 프레임 상태: {2, 0, 3}  Page fault 수: 7   Page-out: 4  dist: {2, 5, 1}&lt;/li&gt;
  &lt;li&gt;Page-in: 3 =&amp;gt; 프레임 상태: {2, 0, 3}  Page fault 수: 7                dist: {1, 4, INF}&lt;/li&gt;
  &lt;li&gt;Page-in: 2 =&amp;gt; 프레임 상태: {2, 0, 3}  Page fault 수: 7                dist: {2, 3, INF}&lt;/li&gt;
  &lt;li&gt;Page-in: 1 =&amp;gt; 프레임 상태: {2, 0, 1}  Page fault 수: 8   Page-out: 3  dist: {1, 2, 5}&lt;/li&gt;
  &lt;li&gt;Page-in: 2 =&amp;gt; 프레임 상태: {2, 0, 1}  Page fault 수: 8                dist: {INF, 1, 4}&lt;/li&gt;
  &lt;li&gt;Page-in: 0 =&amp;gt; 프레임 상태: {2, 0, 1}  Page fault 수: 8                dist: {INF, 2, 3}&lt;/li&gt;
  &lt;li&gt;Page-in: 7 =&amp;gt; 프레임 상태: {7, 0, 1}  Page fault 수: 9   Page-out: 2  dist: {INF, 1, 2}&lt;/li&gt;
  &lt;li&gt;Page-in: 0 =&amp;gt; 프레임 상태: {7, 0, 1}  Page fault 수: 9                dist: {INF, INF, 1}&lt;/li&gt;
  &lt;li&gt;Page-in: 1 =&amp;gt; 프레임 상태: {7, 0, 1}  Page fault 수: 9                dist: {INF, INF, INF}&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;OPT의 결과는 총 9번의 page fault가 발생했다. 이는 FIFO의 15번보다 크게 줄어든 모습을 볼 수 있다. 하지만 OPT의 방법은 &lt;strong&gt;현실적으로 불가능하다.&lt;/strong&gt; 실제 컴퓨터에서는 미래에 어떤 프로세스가 사용되는지 알 수 없다. 그러므로 어느 프로세스가 가장 오래 사용안되는 지를 계산할 수 없다.&lt;/p&gt;

&lt;h1 id=&quot;least-recently-usedlru&quot;&gt;Least-Recently-Used(LRU)&lt;/h1&gt;
&lt;p&gt;OPT는 최적해를 구할 수 있지만 미래를 알 수 없으므로 현실적으로 불가능한 방법이었는데, 최적의 해는 아니더라도 근사의 해를 구하기 위해서 LRU가 나왔다. LRU는 &lt;strong&gt;최근에 사용되지 않으면 나중에도 사용되지 않을 것&lt;/strong&gt; 이라는 개념으로 과거의 페이지 기록을 통해 희생양 페이지를 선태한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;예제&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;LRU는 근사 해를 구하므로 OPT보다는 page fault가 많이 발생하지만, FIFO보다는 일반적으로 적게 일어난다. 그러므로 현재 대부분 환경에서는 LRU를 사용하고 있다.&lt;/p&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="Study_OperatingSystem" /><summary type="html">최신 업데이트 날짜: 2019-05-03</summary></entry><entry><title type="html">[운영체제] # 15 가상메모리(Virtual Memory)</title><link href="https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-15%EC%9E%A5-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC/" rel="alternate" type="text/html" title="[운영체제] # 15 가상메모리(Virtual Memory)" /><published>2019-05-04T00:30:00+09:00</published><updated>2019-05-04T00:30:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-15%EC%9E%A5-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-15%EC%9E%A5-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC/">&lt;p&gt;가상 메모리는 물리 메모리 크기의 한계를 극복하기 위해 나온 기술이다. 즉, 물리 메모리보다 큰 프로세스를 수행하기 위해 가상 메모리를 사용한다. 예를 들어, 100MB 메모리 크기에서 200MB 크기의 프로세스를 수행할 수 있도록 하는 것이다.&lt;/p&gt;

&lt;p&gt;이러한 방식이 어떻게 가능할까? 앞서 메모리 낭비 방지의 동적 할당에서도 봤듯이, &lt;strong&gt;필요한 부분만&lt;/strong&gt; 메모리에 적재하는 것이다. 프로세스를 실행할 때, 실행에 필요한 부분만 메모리에 올리는 것이다. 이러한 프로세스의 일부분은 페이지 단위일 수도 있고, 세그먼트 단위일 수도 있지만 현재 대부분은 페이지 단위를 사용한다. 이처럼 현재 필요한(요구되어지는) 페이지만 메모리에 올리는 것을 &lt;strong&gt;Demanding Paging(요구 페이징)&lt;/strong&gt; 이라고 한다.&lt;/p&gt;

&lt;h1 id=&quot;demanding-paging&quot;&gt;Demanding Paging&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57119450-47043400-6da5-11e9-8810-c6a981a1d689.png&quot; alt=&quot;OS15-1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 요구 페이징의 모습이다. 두 프로세스 P1, P2는 각각 필요한 페이지만 메모리에 할당하였다. 여기서 위 그림의 테이블은 P1이 수행 중일 때의 페이지 테이블이다. 기존의 페이지 테이블과 다른 점은 &lt;strong&gt;valid bit&lt;/strong&gt; 가 추가된 모습이다. 이는 현재 메모리에 페이지가 있는지 없는지를 나타내는 비트이다. 현재 페이지가 메모리에 있다면 1, 없다면 0값을 갖는다.&lt;/p&gt;

&lt;p&gt;만약, CPU에서 P1의 3번째 페이지에 접근하는데, valid bit값이 0이다. 그러면 &lt;strong&gt;CPU에 인터럽트 신호를 발생하여 운영체제 내부의 ISR로 점프&lt;/strong&gt; 한다. 여기서 디스크 내부의 프로세스 P1에 있는 2번째 페이지를 메모리에 할당하는 작업을 처리한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57119451-47043400-6da5-11e9-9ca3-d0b250683bf0.png&quot; alt=&quot;OS15-2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 P1의 3번째 페이지를 메모리에 올린 후 모습이다.&lt;/p&gt;

&lt;p&gt;가상 메모리를 만드는 방법은 대표적으로 두 가지가 존재하지만, 대부분 &lt;strong&gt;요구 페이징을 사용&lt;/strong&gt; 하므로 가상 메모리와 요구 페이징을 같은 용어로 사용하는 경우가 많다.&lt;/p&gt;

&lt;h2 id=&quot;page-fault페이지-부재&quot;&gt;Page Fault(페이지 부재)&lt;/h2&gt;
&lt;p&gt;페이지 부재는 위에서 살펴본 &lt;strong&gt;CPU가 접근하려는 페이지가 메모리에 없는 경우&lt;/strong&gt; 이다. 즉, 페이지 테이블의 valid bit값이 0인 경우이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57119452-479cca80-6da5-11e9-9c9e-50c3a3e74f53.png&quot; alt=&quot;OS15-3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 page fault가 발생했을 때 처리하는 과정을 나타낸 것이다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;해당 페이지가 메모리에 있는지 valid bit를 확인한다.&lt;/li&gt;
  &lt;li&gt;valid bit가 0이라면 CPU에 인터럽트 신호를 보내어 운영체제 내부 해당 ISR로 점프한다.&lt;/li&gt;
  &lt;li&gt;해당 ISR에서 backing store(디스크)를 탐색하여 해당 프로세스의 페이지를 찾는다.&lt;/li&gt;
  &lt;li&gt;해당 페이지를 비어있는 프레임에 할당한다.&lt;/li&gt;
  &lt;li&gt;페이지 테이블을 갱신한다.(프레임 번호 설정, valid bit 1로 변경)&lt;/li&gt;
  &lt;li&gt;다시 명령어로 돌아가서 실행한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;pure-demanding-paging&quot;&gt;Pure Demanding Paging&lt;/h3&gt;
&lt;p&gt;Pure Demanding Paging은 &lt;strong&gt;프로세스가 최초로 실행될 때는 어떤 페이지가 필요한지 알 수 없으므로, 아무 페이지도 올리지 않는다.&lt;/strong&gt; 그러므로 프로그램을 실행하자마자 page fault가 발생한다. 즉, 순수하게 필요한 페이지만 올리는 것을 말한다. Pure Demanding Paging의 장점은 메모리를 최대한 효율적으로 사용할 수 있다. 하지만 시작부터 page fault가 발생하므로 속도면에서 느리다.&lt;/p&gt;

&lt;h3 id=&quot;prepaging&quot;&gt;Prepaging&lt;/h3&gt;
&lt;p&gt;Prepaging은 pure demanding paging과 반대대는 개념이다. 프로그램을 실행할 때 &lt;strong&gt;필요할 것이라 판단되는 페이지를 미리 올리는 것&lt;/strong&gt; 이다. 이것의 장점은 page fault가 발생할 확률이 적으므로 속도면에서 빠르지만, 단점으로 미리 올라간 페이지를 사용하지 않는다면 메모리가 낭비된다.&lt;/p&gt;

&lt;h3 id=&quot;swapping-vs-demanding-paging&quot;&gt;Swapping VS Demanding Paging&lt;/h3&gt;
&lt;p&gt;Swapping와 Demanding Paging의 공통점은 둘 다 메모리와 backing store 사이를 서로 오고 가는 기능을 수행하지만, &lt;strong&gt;Swapping은 프로세스 단위&lt;/strong&gt; 로 이동하고 &lt;strong&gt;Demanding Paging은 페이지 단위&lt;/strong&gt; 로 이동하는 차이점이 있다.&lt;/p&gt;

&lt;h3 id=&quot;유효-접근-시간effective-access-time&quot;&gt;유효 접근 시간(Effective Access Time)&lt;/h3&gt;
&lt;p&gt;Demending Paing은 페이지 테이블에 해당 페이지가 없으면 backing store에서 메모리로 가져오는 과정이 있으므로, 페이지 테이블에 해당 페이지가 있을 때와 없을 때 시간 차이가 발생한다. 이러한 시간 차이를 고려하여 평균적으로 어느정도 소요되는지 계산하는 것을 유효 접근 시간이라 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;p: 페이지 부재 확률(probability of a page fault = page fault rate)&lt;/li&gt;
  &lt;li&gt;Tm: 메모리를 읽는 시간&lt;/li&gt;
  &lt;li&gt;Tp: Page fault가 발생했을 때 소요되는 시간(대부분 backing store(하드디스크)를 읽는 시간이 차지한다.)&lt;/li&gt;
  &lt;li&gt;T = (1-p)Tm + pTp&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예제를 살펴보자.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Tm = 200nsec (DRAM)&lt;/li&gt;
  &lt;li&gt;Tp = 8msec (seek time + rotational delay + transfer time)&lt;/li&gt;
  &lt;li&gt;T = (1-p) * 200 + p * 8,000,000 = 200 + 7,999,800 * p&lt;/li&gt;
  &lt;li&gt;p = 1/1,000 =&amp;gt; T = 8.2usec (40배 정도 느림)&lt;/li&gt;
  &lt;li&gt;p = 1/399,990 =&amp;gt; T = 220nsec (10% 정도 느림)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 예제를 보았을 때, page fault는 매우 적은 확률로 발생해야 효율적이다. 그러면 현실적으로 페이지 부재는 어느정도로 발생할까? 이는 &lt;strong&gt;지역성의 원리(Locality of reference)&lt;/strong&gt; 로 인해 페이지 부재 확률은 매우 낮다. 지역성의 원리는 &lt;strong&gt;메모리 접근은 시간적 지역성과 공간적 지역성을 가진다&lt;/strong&gt; 는 의미이다.&lt;/p&gt;

&lt;p&gt;시간적 지역성은 CPU는 어느 메모리 공간을 읽은 후, 시간이 지나도 그 공간을 다시 읽을 확률이 매우 높다는 것을 말한다. 공간적 지역성은 CPU가 메모리 공간을 읽을 때는 인접한 범위 내에서 읽는다는 의미이다. 시간적 지역성의 대표적인 예는 반복문이다. 반복문은 하나의 코드 공간을 여러 번 읽는다. 공간적 지역성은 프로그램은 대부분 절차적으로 구현되어 있으므로 순서대로 읽는 경우가 빈번한다.&lt;/p&gt;

&lt;p&gt;이와 같이 페이지 부재가 현실적으로 발생할 확률은 매우 낮으므로 예제와 같이 40배로 느려지는 일을 거의 없다. 여기서 더 효율적으로 사용하기 위해서는 페이지 부재일 때 소요되는 시간을 줄일 수 있는데, backing store로 HDD를 사용하기 보다는 더욱 빠르게 동작하는 SSD나 저가 DRAM과 같은 것을 사용하는 방법이 있다.&lt;/p&gt;

&lt;h2 id=&quot;페이지-교체page-replacement&quot;&gt;페이지 교체(Page Replacement)&lt;/h2&gt;
&lt;p&gt;Demanding Paging은 요구되어지는 페이지만 backing store에서 가져온다. 하지만 프로그램들이 계속 실행함에 따라 요구 페이지도 계속 늘어나고, 언젠가는 메모리가 가득 차게 될 것이다.(memory full) 여기서 다른 프로그램이 새로 실행되거나 실행중인 프로세스가 다른 페이지를 요구한다면 &lt;strong&gt;이미 메모리에 있는 페이지 중 하나를 다시 backing store에 보내고(page-out), 새로운 페이지를 메모리에 올려야한다.(page-in)&lt;/strong&gt; 이를 페이지 교체라고 한다. 여기서 backing store로 page-out이 된 페이지를 &lt;strong&gt;victim page&lt;/strong&gt; 라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;victim-page희생양-페이지&quot;&gt;Victim Page(희생양 페이지)&lt;/h3&gt;
&lt;p&gt;희생양 페이지는 어떤 페이지로 하는 것이 좋을까? 먼저 생각할 수 있는 것은 메모리에 올라가 있는 페이지 중 &lt;strong&gt;CPU에 수정(modify)되지 않는 페이지&lt;/strong&gt; 를 고르는 것이 효율적으로 보인다. 수정되지 않은 페이지는 page-out이 될 때 backing store에 쓰기(write) 연산을 할 필요가 없기 때문이다. backing store는 읽는 시간도 느리지만, 거기에 더해 쓰기 작업까지 한다면 더욱 비효율적일 것이다.&lt;/p&gt;

&lt;p&gt;그러면 해당 페이지가 수정되었는지 안되었는지를 판단할 수 있어야 하는데, 이를 위해 페이지 테이블에 &lt;strong&gt;modified bit(=dirty bit)&lt;/strong&gt; 를 추가하여 이를 검사한다. 해당 페이지가 수정되었다면 이 비트를 1로 두고, 수정되지 않으면 0으로 둔다. 이를 이용해서 victim page는 최대한 수정되지 않은 페이지를 선택한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57119453-479cca80-6da5-11e9-83e7-cd46f595422d.png&quot; alt=&quot;OS15-4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 modified bit를 추가한 페이지 테이블의 모습이다. 여기서 수정되지 않은 페이지는 0, 2, 3번 3개의 페이지가 존재하는데 이 중에서는 어떤 페이지를 선택해야 할까?&lt;/p&gt;

&lt;p&gt;제일 간단한 방법은 랜덤하게 선택하는 것이지만, 이는 성능을 보장할 수 없다. 그 다음은 가장 먼저 메모리에 올라온 페이지를 희생양 페이지로 선택하는 것이다. 이는 아주 유명한 FIFO(First-In First-Out) 방식이다. 이 외에도 여러가지 방법이 존재한다.&lt;/p&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="Study_OperatingSystem" /><summary type="html">최신 업데이트 날짜: 2019-05-03</summary></entry><entry><title type="html">[운영체제] # 14 세그먼테이션(Segmentation)</title><link href="https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-14%EC%9E%A5-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98/" rel="alternate" type="text/html" title="[운영체제] # 14 세그먼테이션(Segmentation)" /><published>2019-05-03T21:30:00+09:00</published><updated>2019-05-03T21:30:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-14%EC%9E%A5-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-14%EC%9E%A5-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98/">&lt;p&gt;지금까지 살펴본 페이징은 프로세스를 물리적으로 일정한 크기로 나눠서 메모리에 할당하였다. 반면에 세그먼테이션은 프로세스를 &lt;strong&gt;논리적 내용을 기반&lt;/strong&gt; 으로 나눠서 메모리에 배치하는 것을 말한다.&lt;/p&gt;

&lt;p&gt;세그먼테이션은 프로세스를 세그먼트(segment)의 집합으로 만들고, 각 세그먼트의 크기는 일반적으로 같지 않다. 프로세스를 code + data + stack 으로 나누는 것 역시 세그먼테이션의 모습이다. 물론 code, data, stack 각각 내부에서 더 작은 세그먼트로 나눌 수도 있다.&lt;/p&gt;

&lt;p&gt;세그먼트를 메모리에 할당할 때는 페이지를 할당하는 것과 동일하다. 하지만 테이블은 조금 다른데, 세그먼테이션을 위한 테이블은 &lt;strong&gt;세그먼트 테이블&lt;/strong&gt; 이라고한다. 그리고 세그먼트 테이블은 세그먼트 번호와 시작 주소(base), 세그먼트 크기(limit)를 엔트리로 갖는다.&lt;/p&gt;

&lt;p&gt;세그먼트에서 주소변환 역시, 페이징과 유사하다. 한 가지 주의할 점은 세그먼트의 크기는 일정하지 않기 때문에, 테이블에 &lt;strong&gt;limit&lt;/strong&gt; 정보가 주어진다. 그리고 CPU에서 해당 세그먼트의 크기를 넘어서는 주소가 들어오면 인터럽트가 발생해서 해당 프로세스를 강제로 종료시킨다. 그러면 세그먼트 주소변환 예제를 하나 살펴보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57119448-47043400-6da5-11e9-95da-91cb808de992.png&quot; alt=&quot;OS14-1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 세그먼트 테이블과 프로세스가 할당된 메모리의 모습이다. 페이징 주소변환과 동일하게 d는 논리주소와 물리주소가 동일하다. 물리주소 a는 &lt;strong&gt;base[s] + d&lt;/strong&gt; 로 계산된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;논리주소 (2, 100) =&amp;gt; 물리주소 4400번지&lt;/li&gt;
  &lt;li&gt;논리주소 (1, 500) =&amp;gt; 인터럽트로 인해 프로세스 강제 종료(범위를 벗어남)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;세그먼테이션에서-보호와-공유&quot;&gt;세그먼테이션에서 보호와 공유&lt;/h1&gt;
&lt;p&gt;먼저, 결론부터 말하면 페이징보다 세그먼테이션에서의 보호와 공유는 더 효율적이다.&lt;/p&gt;

&lt;p&gt;보호에서는 세그먼테이션 역시 r, w, x 비트를 테이블에 추가하는데, 세그먼테이션은 논리적으로 나누기 때문에 해당 비트를 설정하기 매우 간단하고 안전하다. 페이징은 code + data + stack 영역이 있을 때 이를 일정한 크기로 나누므로 두 가지 영역이 섞일 수가 있다. 그러면 비트를 설정하기가 매우 까다롭다.&lt;/p&gt;

&lt;p&gt;공유에서도 마찬가지다. 페이징에서는 code 영역을 나눈다해도 다른 영역이 포함될 확률이 매우 높다. 하지만 세그먼테이션은 정확히 code 영역만 나누기 때문에 더 효율적으로 공유를 수행할 수 있다.&lt;/p&gt;

&lt;h1 id=&quot;세그먼테이션과-페이징&quot;&gt;세그먼테이션과 페이징&lt;/h1&gt;
&lt;p&gt;세그먼테이션은 페이징과 유사하고 보호와 공유에서는 더 나은 성능을 보여주었지만, 현재 &lt;strong&gt;대부분은 페이징 기법을 사용한다.&lt;/strong&gt; 그 이유는 세그먼테이션에는 치명적인 단점이 있기 때문이다.&lt;/p&gt;

&lt;p&gt;메모리 할당을 처음 시작할 때 다중 프로그래밍에서의 문제는 크기가 서로 다른 프로세스로 인해 여러 크기의 hole이 발생한다. 이로 인해 어느 hole에 프로세스를 할당하는 것에 대한 최적화 알고리즘이 존재하지 않고, 외부 단편화로 인해 메모리 낭비가 크다고 했었다.&lt;/p&gt;

&lt;p&gt;세그먼테이션도 똑같은 문제점이 발생한다. 왜냐하면 세그먼테이션은 논리적인 단위로 나누기 때문에 세그먼트의 &lt;strong&gt;크기가 다양하다.&lt;/strong&gt; 이로 인해 다양한 크기의 hole이 발생하므로 같은 문제가 발생한다.&lt;/p&gt;

&lt;p&gt;결론적으로 세그먼테이션은 보호와 공유에서 효율적이고, 페이징은 외부 단편화 문제를 해결할 수 있다. 그러므로 두 가지를 합쳐서 사용하는 방법이 나왔다. 두 장점을 합치기 위해서는 &lt;strong&gt;세그먼트를 페이징 기법으로 나누는 것이다.(Paged segmentation)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;하지만 이 역시 단점이 존재한다. 세그먼트와 페이지가 동시에 존재하기 때문에 주소 변환도 두 번해야한다. 즉 CPU에서 세그먼트 테이블에서 주소 변환을 하고, 그 다음 페이지 테이블에서 또 주소 변환을 해야한다.&lt;/p&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="Study_OperatingSystem" /><summary type="html">최신 업데이트 날짜: 2019-05-03</summary></entry><entry><title type="html">다익스트라(Dijkstra) 알고리즘</title><link href="https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/" rel="alternate" type="text/html" title="다익스트라(Dijkstra) 알고리즘" /><published>2019-05-03T21:06:00+09:00</published><updated>2019-05-03T21:06:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">&lt;p&gt;다익스트라 알고리즘은 &lt;strong&gt;단일 시작점 최단 경로 알고리즘&lt;/strong&gt; 으로, 시작 정점 s에서부터 다른 정점들까지의 최단 거리를 계산한다. 하지만 이 알고리즘은 음수 간선이 있는 그래프(특히, 음수 사이클)에 대해서는 최단거리를 계산하지 못한다. 만약 음수 간선이 사이클을 이루지 않는다면, 계산을 할 수 있는 경우가 있지만 시간복잡도는 지수적으로 증가한다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;이에 대한 부분은 https://www.acmicpc.net/board/view/19865 이 링크에서 자세하게 토론을 하고 있다. 한 번 읽어보면 좋을 듯 하다.&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;기본적인-다익스트라-알고리즘&quot;&gt;기본적인 다익스트라 알고리즘&lt;/h2&gt;
&lt;p&gt;다익스트라 알고리즘은 너비 우선 탐색(BFS)처럼 시작점에서 가까운 순서대로 정점을 방문한다. BFS와 다른 점은 가중치가 있는 그래프에 적용하며, BFS로는 아래와 같은 그래프에서 최단 거리를 찾을 수 없다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57118124-297e9c80-6d9c-11e9-90c4-21ebb461c96d.JPG&quot; alt=&quot;dijkstra1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그래프에서 최단 경로는 &lt;strong&gt;s-a-b-c&lt;/strong&gt; 이다. 하지만 BFS를 사용하면 시작점과 인접한 정점을 방문하므로 b정점을 통한 최단 경로를 계산할 수 없다. 이러한 경우 다익스트라 알고리즘을 사용할 수 있다. 그러면 기본적으로 다익스트라 알고리즘이 어떻게 동작하는지 예제를 통해 살펴보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57118125-2a173300-6d9c-11e9-9fd2-dccf0a61fdd3.JPG&quot; alt=&quot;dijkstra2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그래프에서 시작점은 1번 정점으로 하여 모든 정점에 대해서 최단 거리를 구해보자. 다익스트라 알고리즘은 위에서 말했듯이 BFS와 같이 인접한 정점에서 가장 가까운 정점을 선택한다. 그리고 그 정점 중 최단 거리를 갱신해나아간다. 그러기 위해 시작점을 제외한 아직 방문하지 않은 정점은 &lt;strong&gt;가장 큰 수(INF)&lt;/strong&gt; 로 초기화 한다. 따라서 초기 모습은 다음과 같다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;횟수/정점&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;4&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;5&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;6&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;표에서 확정된 정점의 최단 거리는 &lt;strong&gt;진한 검정색&lt;/strong&gt; 으로 표시한다. 그리고 인접한 정점까지의 거리와 현재 표의 거리 중 &lt;strong&gt;더 짧은 거리로 갱신한다.&lt;/strong&gt; 그 다음 확정되지 않은 정점 중 가장 짧은 정점으로 이동한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1번 정점과 인접한 정점 (정점, 거리)
    &lt;ul&gt;
      &lt;li&gt;(2, 0 + 7),   &lt;code class=&quot;highlighter-rouge&quot;&gt;min(INF, 7) = 7&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;(3, 0 + 9),   &lt;code class=&quot;highlighter-rouge&quot;&gt;min(INF, 9) = 9&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;(6, 0 + 14),  &lt;code class=&quot;highlighter-rouge&quot;&gt;min(INF, 14) = 14&lt;/code&gt;
1번 정점과 인접한 정점까지 거리를 계산하여 표와 비교한 후 더 짧은 거리로 갱신한다. 그 다음 &lt;strong&gt;확정되지 않은 정점 중 가장 짧은 거리를 가진 정점으로 이동한다.&lt;/strong&gt; 선택된 정점은 시작점과 최단 거리임을 확정하고 그 정점에서 위와 같이 인접한 정점과 거리 계산 과정을 반복한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;횟수/정점&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;4&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;5&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;6&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;14&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;2번 정점과 인접한 정점
    &lt;ul&gt;
      &lt;li&gt;(3, 7 + 10),   &lt;code class=&quot;highlighter-rouge&quot;&gt;min(9, 17) = 9&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;(4, 7 + 15),   &lt;code class=&quot;highlighter-rouge&quot;&gt;min(INF, 22) = 22&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;횟수/정점&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;4&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;5&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;6&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;14&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;9&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;22&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;14&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그 결과, 최단 거리로 확정되지 않은 정점 중 3번 정점이 가장 짧으므로 이를 확정시키고 3번 정점과 인접한 정점을 계산한다. 이와 같은 계산 과정을 모든 정점이 최단 거리로 확정될 때까지 반복한다. 모든 결과를 표로 나타내면 다음과 같다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;횟수/정점&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;4&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;5&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;6&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;14&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;9&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;22&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;14&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;9&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;20&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;11&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;9&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;20&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;20&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;11&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;9&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;20&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;20&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;11&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;하지만 이 방법은 확정되지 않은 정점 중 가장 짧은 거리의 정점을 찾기 위해 시간복잡도 O(N)으로 순차적으로 탐색한다. 이를 최적화하기 위해 &lt;strong&gt;우선 순위 큐&lt;/strong&gt; 를 사용하여 가장 짧은 거리의 정점을 시간복잡도 O(logN) 으로 찾을 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;우선-순위-큐를-이용한-다익스트라-알고리즘&quot;&gt;우선 순위 큐를 이용한 다익스트라 알고리즘&lt;/h2&gt;
&lt;p&gt;우선 순위 큐를 사용하더라도 알고리즘 로직은 바뀌지 않는다. 다만, 확정할 정점을 찾는데 소요되는 시간을 O(N)에서 O(logN)으로 줄인 것이다. 그러면 이를 구현한 코드를 살펴보자.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//정점의 개수
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//그래프의 인접 리스트 (연결된 정점 번호, 간선 가중치) 쌍을 담는다.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pair&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX_V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//다익스트라, 최단 거리 배열을 반환한다.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dijkstra&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//INF: 매우 큰 값
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;dist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//(해당 정점까지 최단 거리, 해당 정점)쌍
&lt;/span&gt;  	&lt;span class=&quot;c1&quot;&gt;//STL내부에서 pair의 첫번째 원소부터 크기 비교를 하기 때문에, 거리값을 첫 원소로 해야 한다.
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;priority_queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pair&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;pq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;make_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;here&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cost&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;pq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;//만약 지금 꺼낸 것보다 더 짧은 경로를 알고 있다면 지금 꺼낸 것을 무시한다.
&lt;/span&gt;		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;here&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cost&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;//인접한 정점들을 모두 검사한다.
&lt;/span&gt;		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;here&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;there&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;here&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextDist&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cost&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;here&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;//더 짧은 경로를 발견하면, dist[]를 갱신하고 우선순위 큐에 넣는다.
&lt;/span&gt;			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;there&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextDist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;dist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;there&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextDist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;pq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;make_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextDist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;there&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;코드를 살펴보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;dist[]&lt;/code&gt;은 매개변수로 전달받은 시작점 &lt;code class=&quot;highlighter-rouge&quot;&gt;src&lt;/code&gt; 정점에서 모든 정점까지 최단 거리를 저장한 배열이다. 그리고 구현의 편의성을 위해 몇가지 사용한 방법이 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;C++ STL pair는 첫 번째 원소를 비교하므로 (거리, 정점) 쌍으로 저장한다.&lt;/li&gt;
  &lt;li&gt;C++ STL 우선순위 큐는 기본적으로 내림차순이므로 거리의 부호를 바꾸는 것으로 간단하게 사용할 수 있다.&lt;/li&gt;
  &lt;li&gt;중복된 정점의 계산을 피하기 위해 현재 거리보다 긴 경우는 모두 무시한다.(따라서, 저장할 때 정점 중복 검사는 하지 않아도 된다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;시간복잡도&quot;&gt;시간복잡도&lt;/h3&gt;
&lt;p&gt;간선의 개수를 E라고 할 때, 각 정점마다 인접한 간선들을 모두 검사하는 작업은 O(|E|) 이고, 우선 순위 큐에 추가 및 삭제하는 연산은 O(logE)이다. 따라서 전체 시간복잡도는 &lt;strong&gt;O(ElogE)&lt;/strong&gt; 이다. 여기서 대부분의 그래프에서 &lt;strong&gt;간선의 개수는 정점의 개수(V) 제곱보다 작으므로&lt;/strong&gt; 최대 원소의 개수가 전체 간선의 수가 아닌 전체 정점의 수로 볼 수 있다. 따라서, 시간복잡도를 &lt;strong&gt;O(ElogV)&lt;/strong&gt; 로 계산할 수도 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;O(VlogV) 다익스트라 알고리즘
중복 원소를 우선순위 큐에 넣지 않도록 수정하면 시간복잡도는 O(VlogV)로 만들 수 있다. 이를 위해 피보나치 힙이나 이진 검색 트리를 사용해서 우선 순위 큐를 구현하면 중복 원소를 제거할 수 있지만, 구현이 복잡하고 실제로 시간이 더 오래 걸리는 경우가 많다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="Algorithm_Algorithm" /><summary type="html">최신 업데이트 날짜: 2019-05-03</summary></entry><entry><title type="html">LIS(Longest Increasing Subsequence) 알고리즘</title><link href="https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-LIS%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/" rel="alternate" type="text/html" title="LIS(Longest Increasing Subsequence) 알고리즘" /><published>2019-05-01T00:45:00+09:00</published><updated>2019-05-01T00:45:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-LIS%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-LIS%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">&lt;p&gt;LIS 알고리즘은 &lt;strong&gt;가장 긴 증가하는(최장증가) 부분 수열&lt;/strong&gt; 이다. 아래의 그림 처럼 부분 수열이므로 연속적이지 않아도 된다. (2번 째 배열의 노란색 박스가 LIS이다.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/46916274-410a5980-cff3-11e8-948a-31488df44de1.JPG&quot; alt=&quot;lis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;LIS 알고리즘을 해결하는 방법은 시간복잡도가 O(N^2)과 O(NlogN) 두 가지 방법이 대표적이다.&lt;/p&gt;

&lt;h2 id=&quot;해결-방법1-동적-계획법&quot;&gt;해결 방법1: 동적 계획법&lt;/h2&gt;
&lt;p&gt;동적 계획법을 이용한 해결 방법은 시간복잡도 O(N^2)에 속한다. 동적 계획법에서도 Bottom-up 방식과 Top-down 방식 두 가지 모두 알아보자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DP[i] = i 번째 위치일 때, 최장 증가 부분 수열의 개수 (cache 배열도 동일)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;bottom-up&quot;&gt;Bottom-up&lt;/h3&gt;
&lt;p&gt;Bottom-up은 반복문을 사용하는 동적 계획법이다. 현재 위치 이전의 값들을 차례대로 순회하면서 현재 위치에서 최장증가 부분 수열의 개수를 갱신한다. 이는 말보다 코드로 이해하는 것이 쉽다.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// num[]: 숫자 배열
// n: num 배열의 크기
// lis: 가장 긴 증가하는 부분 수열의 개수 (0으로 초기화)
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 0 ~ i - 1 위치까지 반복
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 1) 현재 위치의 값보다 작고,
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 2) 최장증가부분 수열 개수가 1개 증가했을 때, 현재 가지고 있는 수열 개수보다 크다면
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;lis&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lis&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;top-down&quot;&gt;Top-down&lt;/h3&gt;
&lt;p&gt;Top-down은 재귀를 사용한 메모이제이션 방식이다. 이 방식은 대부분 완전탐색에서 최적화한 모습이므로 완전탬색 코드와 유사한 로직을 가진다. 여기서는 전체 배열을 탐색하는 구현을 간단히 하기 위해 &lt;strong&gt;-1&lt;/strong&gt; 부터 시작한다.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// cache[]: -1으로 초기화
// 가장 긴 증가하는 부분 수열의 개수 반환(start 초기값은 -1)
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Memoization&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;candidate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Memoization&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;candidate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;candidate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;해결-방법2-이분-탐색&quot;&gt;해결 방법2: 이분 탐색&lt;/h2&gt;
&lt;p&gt;LIS는 이분 탐색을 사용하여 시간복잡도 O(NlogN)으로 해결할 수 있다. 이는 &lt;strong&gt;lower_bound&lt;/strong&gt; 를 사용하는 것으로, lower_bound는 찾으려는 값과 같으면 그 위치를 반환하고 없다면 이 값보다 큰 수 중 가장 작은 값의 위치를 반환한다. 이는 이분 탐색으로 찾기 때문에 O(logN)의 시간복잡도는 가지고 있다. 그러면 예제를 살펴보자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;10, 20, 10, 30, 20, 50
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 예제에서 처음 위치부터 끝까지 순회하면서 해당 숫자의 위치를 vector에 저장한다. 이를 계산한 표를 살펴보자.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;i/num[]&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;10&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;20&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;10&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;30&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;20&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;50&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;20&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;20&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;20&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;30&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;20&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;30&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;20&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;30&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;50&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;i = 0: 처음 위치는 바로 vector에 삽입한다.&lt;/li&gt;
  &lt;li&gt;i = 1: 숫자 20은 vector안에 존재하는 10보다 크므로 그 뒤에 삽입한다.&lt;/li&gt;
  &lt;li&gt;i = 2: 숫자 10은 vector안에 이미 존재하므로 이를 대체한다.(무시하는 것과 같다.)&lt;/li&gt;
  &lt;li&gt;i = 3: 숫자 30은 vector안에 존재하는 마지막 숫자 20보다 크므로 그 뒤에 삽입한다.&lt;/li&gt;
  &lt;li&gt;i = 4: 숫자 20은 vector안에 이미 존재하므로 이를 대체한다.&lt;/li&gt;
  &lt;li&gt;i = 5: 숫자 50은 vector안에 존재하는 마지막 숫자 30보다 크므로 그 뒤에 삽입한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위처럼 배열 크기만큼 순회하면서 그 때마다 해당 숫자의 위치를 lower_bound로 탐색하므로 시간복잡도 O(NlogN)을 보장한다.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;lis&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lower_bound&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lis&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lis&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lis&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;lis&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="Algorithm_Algorithm" /><summary type="html">최신 업데이트 날짜: 2019-04-30</summary></entry><entry><title type="html">LCS 알고리즘</title><link href="https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-LCS%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/" rel="alternate" type="text/html" title="LCS 알고리즘" /><published>2019-04-30T23:00:00+09:00</published><updated>2019-04-30T23:00:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-LCS%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-LCS%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">&lt;p&gt;LCS 알고리즘은 총 2가지로 나뉜다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;LCS(Longest Common Substring): 최장 공통 부분 문자열&lt;/li&gt;
  &lt;li&gt;LCS(Longest Common Subsequence): 최장 공통 부분 수열
이 둘의 차이점은 1번은 &lt;strong&gt;연속적&lt;/strong&gt; 이고, 2번은 비연속적이다. 하지만 1번과 2번 모두 &lt;strong&gt;동적 계획법&lt;/strong&gt; 으로 해결할 수 있다는 공통점을 가지고 있다. 먼저, 예를 보자.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ABCDEFGHI
BCDGHD
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 예제에서 1번과 2번의 결과는 아래와 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BCD&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BCDGH&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;최장 공통 부분 문자열은 연속적이어야 하기 때문에 총 2가지 경우가 있다. &lt;code class=&quot;highlighter-rouge&quot;&gt;BCD&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;GH&lt;/code&gt;이다. 여기서 BCD가 더 길기때문에 답이 된다.&lt;/p&gt;

&lt;p&gt;최장 공통 부분 수열은 비연속적이기 때문에 문자가 서로 떨어져 있다고 해도 같다면 같은 수열에 속한다. 따라서, 답은 &lt;code class=&quot;highlighter-rouge&quot;&gt;BCDGH&lt;/code&gt;이 된다.&lt;/p&gt;

&lt;p&gt;하지만 대부분 LCS 알고리즘이라고 하면 &lt;strong&gt;Longest Common Subsequence&lt;/strong&gt; 로 즉, 최장 공통 부분 수열을 말한다.&lt;/p&gt;

&lt;h2 id=&quot;longest-common-substring&quot;&gt;Longest Common Substring&lt;/h2&gt;
&lt;p&gt;최장 공통 부분 문자열은 최장 공통 부분 수열보다 간단하다. 연속적인 부분만 보면 되므로 O(N^2)으로 해결할 수 있다. 접근법은 위에서 말했듯이 동적 계획법으로 접근한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DP[i][j] = 문자열 S1의 위치 i, 문자열 S2의 위치 j일 때, 최장 공통 부분 문자열의 길이
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;DP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LCS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;LCS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;longest-common-subsequence&quot;&gt;Longest Common Subsequence&lt;/h2&gt;
&lt;p&gt;최장 공통 부분 수열은 연속적이지 않은 부분을 모두 고려해야 하므로 최장 공통 부분 문자열보다 복잡하다. 하지만 이 역시 동적 계획법으로 해결 가능하며 DP(cache)배열의 역할 역시 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DP[i][j] = 문자열 S1의 위치 i, 문자열 S2의 위치 j일 때, 최장 공통 부분 문자열의 길이
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;bottom-up-방식&quot;&gt;Bottom-up 방식&lt;/h3&gt;
&lt;p&gt;먼저, 반복문을 사용하는 Bottom-up 방식의 동적 계획법을 살펴보자. 여기서 점화식은 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if i == 0 or j == 0
  DP[i][j] = 0
else if S1[i] == S2[j]
  DP[i][j] = DP[i - 1][j - 1] + 1
else if S1[i] != S2[j]
  DP[i][j] = max(DP[i][j - 1], DP[i - 1][j])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 점화식에서 DP배열의 첫 번째에 0값을 삽입하는 것은 구현의 편의를 위해서이다. 이를 적용하여 아래의 예제를 풀어보자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ACAYKP
CAPCAK
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;0&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;C&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Y&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;K&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;P&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;C&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;A&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;C&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;A&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;K&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;위 예제를 점화식을 적용하여 직접 모두 풀어보면 위와 같은 2차원 배열을 얻을 수 있다. 위 예제의 LCS는 두 문자열의 끝이므로 답은 4인 것을 볼 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// DP 배열 0으로 초기화
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;DP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;DP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;top-down-방식&quot;&gt;Top-down 방식&lt;/h3&gt;
&lt;p&gt;이번에는 재귀를 사용하여 해결해보자. 재귀를 이용할 때는 대부분 완전탐색의 코드에서 최적화를 해나아가는 방식을 사용한다. 그러면 먼저 완전 탐색 코드를 보자.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;BruteForce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lcs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lcs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;BruteForce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lcs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;BruteForce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lcs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;BruteForce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lcs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드는 S1, S2 문자열이 있을 때, S1 문자열의 위치부터 옮기면서 진행하며 만약 현재 S1, S2 문자열의 위치에서 해당 문자가 서로 같다면, 두 문자열 모두 위치를 한 칸 옮긴다. 그리고 다시 한 문자열의 위치를 옮겨나간다.(S1 문자열의 위치를 끝까지 옮긴 후에는 S2를 한 칸 옮기고 다시 S1의 위치를 옮기는 방식으로 동작한다.)&lt;/p&gt;

&lt;p&gt;완전 탐색으로는 문자열의 길이가 조금만 길어져도 시간이 매우 오래 걸린다. 그리고 위 코드를 직접 트리로 표현하면 수 많은 중복이 발생한다는 것을 알 수 있다. 이 때 사용하는 최적화가 동적 계획법이다. 메모이제이션을 사용한 코드는 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX_LEN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX_LEN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Memoization&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;solve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;solve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;solve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="Algorithm_Algorithm" /><summary type="html">최신 업데이트 날짜: 2019-04-30</summary></entry><entry><title type="html">[Reference] Blog에 post 올리기</title><link href="https://codemcd.github.io/pages/CODEMCD/toy/Blog-Reference-Blog%EC%97%90-post-%EC%98%AC%EB%A6%AC%EA%B8%B0/" rel="alternate" type="text/html" title="[Reference] Blog에 post 올리기" /><published>2019-04-30T23:00:00+09:00</published><updated>2019-04-30T23:00:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/toy/Blog-%5BReference%5D%20Blog%EC%97%90%20post%20%EC%98%AC%EB%A6%AC%EA%B8%B0</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/toy/Blog-Reference-Blog%EC%97%90-post-%EC%98%AC%EB%A6%AC%EA%B8%B0/">&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;이 자료는 해당 블로그 전용입니다. 다른 블로그와 설정이 다를 수 있씁니다.&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;post&quot;&gt;POST&lt;/h1&gt;
&lt;p&gt;Jekyll 블로그에서 post란 일반적으로 블로그에서 쓰는 글이다. 하지만 jekyll에서는 post가 마크다운(Markdown) 으로 작성되고, 기본적으로 몇 가지 규칙이 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;모든 post는 &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; 파일안에 있어야 한다.&lt;/li&gt;
  &lt;li&gt;모든 post의 파일 이름은 &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-TITLE.md&lt;/code&gt; 양식을 따라야한다. 예를 들어 &lt;code class=&quot;highlighter-rouge&quot;&gt;2018-07-15-test.md&lt;/code&gt;로 쓸 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;front-matter&quot;&gt;Front matter&lt;/h1&gt;
&lt;p&gt;Front matter(머리말) 은 jekyll이 마크다운을 해석할 때, 사용하는 메타 정보이다. 이는 반드시 아래와 같이 2가지를 지켜서 사용해야 한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;post 가장 맨 첫 부분에 위치해야한다.&lt;/li&gt;
  &lt;li&gt;시작과 끝을 3개의 대쉬(—)로 감싸주어야 한다.
Front matter 은 YAML 형식이고, 비워도 상관없다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;front-matter-설정&quot;&gt;Front matter 설정&lt;/h2&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;POST&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;제목&quot;&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;excerpt&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;POST&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;설명&quot;&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;date&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;YYYY-MM-DD hh:mm:ss&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;categories&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;category1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;tags&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;tag1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;sidebar_main&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;use_math&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;toc&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Front matter 의 예시는 위와 같다. 현재 사용중인 옵션을 모두 보여준 것이다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;title: POST의 제목&lt;/li&gt;
  &lt;li&gt;excerpt: POST의 간단한 설명 (현재는 최신 업데이트 날짜로 통일하였다.)&lt;/li&gt;
  &lt;li&gt;date: 포스트를 작성 및 업데이트한 날짜&lt;/li&gt;
  &lt;li&gt;categories: 카테고리를 설정 (여러 개를 적을 수도 있다.)&lt;/li&gt;
  &lt;li&gt;tags: 테그를 설정&lt;/li&gt;
  &lt;li&gt;search: 현재 POST를 검색이 가능하도록 할지 설정하는 부분이다. true 값을 넣으면 해당 POST를 검색할 수 있다.&lt;/li&gt;
  &lt;li&gt;sidebar_main: 현재 POST에서 사이드바를 표시할지 설정하는 부분이다.&lt;/li&gt;
  &lt;li&gt;use_math: 현재 POST에서 MathJax 기능을 사용할지 설정하는 부분이다.&lt;/li&gt;
  &lt;li&gt;toc: POST 맨 첫 부분에 해당 POST의 각 header(‘#’, ‘##’, …)에 바로 가는 기능을 사용할지 설정하는 부분이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;category와-tag&quot;&gt;Category와 Tag&lt;/h1&gt;
&lt;p&gt;현재 블로그 post를 원하는 방식으로 분류하기 위해 카테고리와 테그 설정을 고정적으로 설정하였다. 먼저, 카테고리는 3개로 정하였다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Toy: 토이 프로젝트&lt;/li&gt;
  &lt;li&gt;Algorithm: 알고리즘, PS&lt;/li&gt;
  &lt;li&gt;Study: 각종 프로그래밍 관련 공부&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위와 같이, 카테고리는 3개만 가능하고 테그 양식은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Category_Tag&lt;/code&gt; 로 사용해야 한다. 예를 들어, 토이 프로젝트의 블로그 개발 관련 post를 작성하였다면 카테고리는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Toy&lt;/code&gt;, 테그는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Toy_Blog&lt;/code&gt; 와 같이 작성하여야 한다. 실제 블로그에서 테그는 앞의 카테고리는 나타나지 않게 설정하였다. 즉, “Blog” 라는 글자만 볼 수 있다.&lt;/p&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="Toy_Blog" /><summary type="html">최신 업데이트 날짜: 2019-04-30</summary></entry><entry><title type="html">[운영체제] # 13 페이징</title><link href="https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-13%EC%9E%A5-%ED%8E%98%EC%9D%B4%EC%A7%95/" rel="alternate" type="text/html" title="[운영체제] # 13 페이징" /><published>2019-03-22T22:09:00+09:00</published><updated>2019-03-22T22:09:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-13%EC%9E%A5-%ED%8E%98%EC%9D%B4%EC%A7%95</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-13%EC%9E%A5-%ED%8E%98%EC%9D%B4%EC%A7%95/">&lt;h1 id=&quot;페이징paging&quot;&gt;페이징(Paging)&lt;/h1&gt;
&lt;p&gt;외부 단편화로 인한 메모리 낭비는 매우 심하다는 것을 살펴보았다. Compaction을 사용하면 외부 단편화는 해결할 수 있지만, 그로 인해 발생하는 오버헤드와 비효율적인 성능으로 사용하기는 어렵다. 그 이후에 연구를 통해 나온 것이 &lt;strong&gt;페이징&lt;/strong&gt; 이다. 페이징은 hole을 가지고 해결하려 한 것이 아니라 &lt;strong&gt;프로세스를 작은 크기로 나눠서&lt;/strong&gt; 외부 단편화를 해결하려고 하였다.&lt;/p&gt;

&lt;p&gt;페이징은 프로세스를 일정한 작은 크기로 나누는데, 프로세스뿐아니라 hole도 같은 크기로 나눈다. 이러한 작은 조각들의 크기를 맞춰서 메모리에 할당한다. 하지만, 하나의 프로세스는 연속적인 동작을 수행하는데 이를 작은 조각으로 나누어서 여기저기 흩어진다면 프로세스가 정상적으로 동작할까?&lt;/p&gt;

&lt;p&gt;메모리상에 여러 곳에 흩어진 프로세스를 수행하기 위해 CPU를 속여야한다. 이전 다중프로그래밍을 살펴봤을 때 MMU를 통해 논리 주소와 물리 주소를 나눠서 사용한다고 했었다. 이역시 CPU를 속이는 행동이다. 실제 메모리는 전혀 연속적이지 않는데, CPU는 연속적으로 사용하고 있다는 것을 보장받으며 정상적으로 수행한다.&lt;/p&gt;

&lt;p&gt;페이징으로 작은 크기로 나눈 것도 위와 같은 방법으로 할 수 있다. 만약 50byte 크기의 프로세스가 있다고 하자. 페이징의 크기는 각 10byte로 나눈다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/54821888-d9191700-4ce6-11e9-8b11-7af6fdbcbe06.png&quot; alt=&quot;OS13-1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림과 같이 프로세스 P1은 5개의 페이지로 나눌 수 있다. 이를 메인 메모리 5곳에 나눠서 할당하였다. CPU는 논리 주소로 프로그램이 설정한대로 연속적인 주소값으로 명령을 내리고 이는 메모리로 가기전에 각 페이지의 실제 메모리 주소가 저장되어 있는 &lt;strong&gt;테이블에서 물리 주소로 변경되어야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;프로세스를 나눈 조각을 &lt;strong&gt;page&lt;/strong&gt; 라 하고, 메모리를 나눈 조각을 &lt;strong&gt;frame&lt;/strong&gt; 이라 한다. 프로세스는 페이지의 집합이고, 메모리는 프레임의 집합이다. 프로세스를 정상적으로 사용하기 위해 MMU의 재배치 레지스터를 여러개 사용해서 위의 그림과 같이 각 페이지의 실제 주소로 변경해준다. 이러한 여러 개의 재배치 레지스터를 &lt;strong&gt;페이지 테이블(Page Table)&lt;/strong&gt; 이라 한다.&lt;/p&gt;

&lt;h2 id=&quot;주소-변환address-translation&quot;&gt;주소 변환(Address Translation)&lt;/h2&gt;
&lt;p&gt;페이징 기법을 사용하기 위해서는 여러 개로 흩어진 페이지에 CPU가 접근하기 위해서 페이지 테이블을 통해 주소를 변환해야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;논리 주소(Logical address)&lt;/strong&gt;
CPU가 내는 주소는 2진수로 표현되고 이를 m비트가 있다고 가정하자. 여기서 하위 n비트는 오프셋(offset) 또는 변위(displacement)라고 한다. 그리고 상위 m-n 비트는 페이지의 번호에 해당한다.(n = d, m-n = p)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;논리주소를 물리주소(physical address)로 변환하기 위해서 페이지 번호(p)는 페이지 테이블의 인덱스 값이고, p에 해당되는 테이블 내용은 메모리의 프레임 번호이다. 변위(d)는 변하지 않는 값이다. 이 규칙에 대한 예제를 살펴보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Page size = 16bytes&lt;/li&gt;
  &lt;li&gt;Page Table: 5, 3, 2, 8, 1, 4&lt;/li&gt;
  &lt;li&gt;논리 주소 50번지는 물리주소 몇 번지인가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/54821891-d9191700-4ce6-11e9-98a4-425903e14323.png&quot; alt=&quot;OS13-2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 프로세스 P가 메모리에 할당된 모습이다. CPU가 50번지에 접근하려고 한다. 그러면 페이지 테이블의 정보를 읽기 위해 논리 주소를 p와 d값으로 나눠야 한다.&lt;/p&gt;

&lt;p&gt;d는 페이지 크기에 따라 달라지는데, 현재 페이지 크기는 16byte이다. 이는 &lt;strong&gt;2^4이므로 d = 4&lt;/strong&gt; 이다.&lt;/p&gt;

&lt;p&gt;p는 d를 제외한 나머지 크기이다.&lt;/p&gt;

&lt;p&gt;그러면 실제로 p, d를 계산해보자. 현재 논리 주소는 50이며, 이진수로 나타내면 &lt;code class=&quot;highlighter-rouge&quot;&gt;110010&lt;/code&gt;이다. 먼저 d는 4이므로 이 이진수의 뒤에서 4칸이 d이다. d를 제외한 나머지 2칸이 p가 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;50 = 110010
p = 11
d = 0010
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;p는 이진수로 11이고, 십진수로 3이다. 즉, 페이지 테이블의 페이지 번호 3번을 가리킨다. 페이지 3번에 해당하는 프레임 번호는 8번이므로, 물리주소를 구성하는 f값은 8이 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;f = 1000
d = 0010
물리주소 = 10000010
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;최종적으로 물리주소는 f와 d로 구성되어 있으므로 물리주소는 &lt;strong&gt;이진수로 10000010 이 되고, 십진수로 130 번지&lt;/strong&gt; 가 된다. 즉, 변위는 2이므로 8번째 프레임의 시작주소는 128번지(16 * 8)가 된다.&lt;/p&gt;

&lt;p&gt;연속 메모리 할당을 하면서 외부 단편화가 발생하여 이를 해결하기 위해 페이징 기법이 나왔다. 하지만 페이징은 외부 단편화가 아닌 &lt;strong&gt;내부 단편화&lt;/strong&gt; 가 발생한다.&lt;/p&gt;

&lt;h2 id=&quot;내부단편화internal-fragment&quot;&gt;내부단편화(Internal Fragment)&lt;/h2&gt;
&lt;p&gt;내부단편화는 프로세스 크기가 페이지 크기의 배수가 아닐 경우, 마지막 페이지는 한 프레임을 다 채울 수 없다. 이로 인해 발생하는 공간은 결국 메모리 낭비로 이어진다.&lt;/p&gt;

&lt;p&gt;예를 들어, 15bytes 크기의 프로세스 P가 있다. 페이지 크기(프레임 크기)는 4bytes로 P를 페이지로 나누면 &lt;strong&gt;4, 4, 4, 3&lt;/strong&gt; 의 크기로 총 4개의 페이지가 만들어진다. 여기서 마지막 3bytes 페이지는 프레임 크기보다 1byte작으므로, 이 만큼 메모리 공간이 비게 된다. 이렇게 비어진 공간은 프로세스 P에서도 쓰지 않고, 다른 프로세스에서도 쓰지 못하는 낭비되는 공간이 된다.&lt;/p&gt;

&lt;p&gt;내부단편화는 해결할 방법이 없다. 하지만 내부단편화는 외부단편화에 비해 낭비되는 메모리 공간은 매우 적다. 내부단편화의 &lt;strong&gt;최대 낭비되는 크기는 page size - 1&lt;/strong&gt; 이 된다.(외부 단편화는 최대 전체 메모리의 1/3이 낭비된다고 이전에 살펴봤다.) 이는 무시할 정도로 작은 크기이다.&lt;/p&gt;

&lt;h2 id=&quot;페이지-테이블-만들기&quot;&gt;페이지 테이블 만들기&lt;/h2&gt;
&lt;p&gt;페이지 테이블을 만드는 방법은 여러 가지가 있다. 먼저, CPU 내부에 페이지 테이블을 만들 수 있다. CPU 내부의 기억장치는 레지스터로, 여러 개의 레지스터로 페이지 테이블을 만드는 것이다. CPU 내부에 페이지 테이블을 만들면, 장점은 주소 변환 속도가 빠르다. 하지만 단점은 CPU 내부에 사용할 수 있는 레지스터는 한정되어 있으므로 페이지 테이블의 크기가 매우 제한된다.&lt;/p&gt;

&lt;p&gt;반대로, 페이지 테이블을 메모리 내부에서 만들 수도 있다. 메모리 내부에 만드는 것의 장단점은 CPU와 정 반대이다. 즉, 장점은 페이지 테이블의 크기에 제한이 없는 것이고, 단점은 주소 변환 속도가 느리다는 것이다. CPU는 프로세스의 주소에 접근하기 위해서 메모리에 위치한 페이지 테이블에 한 번, 실제 주소로 접근하는데 한 번해서 &lt;strong&gt;메모리에 총 2번 접근해야하므로 속도 역시 2배로 느려진다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;페이지 테이블을 CPU에 만들 때나 메모리에 만들 때 둘 다 장단점이 확실하기 때문에, 이를 해결하기 위해 페이지 테이블도 캐시로 만들어 해결하였다. 페이지 테이블을 별도의 칩(SRAM)으로 만들어서 CPU와 메모리 사이에 위치시키는 것이다. 이러한 테이블을 &lt;strong&gt;TLB(Translation Look-aside Buffer)&lt;/strong&gt; 라고 부른다. 이는 CPU보다 변환 속도는 느리고 메모리보다 테이블 크기는 작지만, CPU보다 테이블 크기가 크고 메모리보다 변환 속도가 빠르다.&lt;/p&gt;

&lt;p&gt;TLB는 캐시와 역할이 동일하므로, 실제 전체 페이지 테이블은 메모리에 위치해 있고 테이블의 일부를 TLB에 가져와서 사용한다. 그러므로 TLB에 유효한 페이지가 있을 때와 없을 때의 속도 차이가 발생한다.&lt;/p&gt;

&lt;p&gt;그렇다면, TLB의 효율을 알아보기 위해 Effective Memory Access Time을 계산해보자.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;메모리를 읽는 시간(Tm) = 100ns&lt;/li&gt;
  &lt;li&gt;TLB를 읽는 시간(Tb) = 20ns&lt;/li&gt;
  &lt;li&gt;TLB에 유효한 페이지 엔트리가 있을 확률(hit ratio) = 80%&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;먼저, EMAT의 정형화된 식을 보자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;EMAT = h(Tb + Tm) + (1 - h)(Tb + Tm + Tm), h는 hit ratio
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;실제 유효한 메모리에 접근하는 시간은 위와 같다. TLB에 유효한 페이지가 있다면 TLB를 읽는 시간과 실제 메모리를 읽는 시간만 있으면 된다. 하지만, TLB에 유효한 페이지가 없다면 이를 다시 메모리에서 가져와야 하므로 메모리를 총 2번 읽어야 한다.&lt;/p&gt;

&lt;p&gt;예제를 계산해보면, &lt;code class=&quot;highlighter-rouge&quot;&gt;0.8 * (20 + 100) + 0.2 * (20 + 100 + 100) = 140ns&lt;/code&gt; 이다. hit ratio는 실제로 평균 95%이상이므로 충분히 효율적으로 동작한다고 볼 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;보호와-공유&quot;&gt;보호와 공유&lt;/h2&gt;
&lt;h3 id=&quot;보호protection&quot;&gt;보호(Protection)&lt;/h3&gt;
&lt;p&gt;모든 주소는 페이지 테이블을 경유하므로, 테이블을 이용해서 보호 기능을 수행할 수 있다. 대표적으로 페이지 테이블마다 r(read), w(write), x(execute) 비트를 두어, 해당 비트가 켜져있을 때 그 수행이 가능하도록한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57119533-f6410b00-6da5-11e9-884d-00e325b21912.png&quot; alt=&quot;OS13-3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 페이지 테이블에 r,w,x 비트를 추가한 모습이다. 만약, 1번 페이지 엔트리처럼 쓰기 비트가 꺼져있는 페이지에 쓰기 작업을 시도하면 CPU에 인터럽트가 발생하여 ISR에서 강제로 해당 프로세스를 종료시킨다.&lt;/p&gt;

&lt;h3 id=&quot;공유sharing&quot;&gt;공유(Sharing)&lt;/h3&gt;
&lt;p&gt;공유는 메모리 낭비를 방지하기 위함이다. 같은 프로그램을 쓰는 복수 개의 프로세스가 있다면, 프로세스의 메모리는 code + data + stack 영역으로 나뉘는데 프로그램이 같다면 code 영역은 같을 것이다. 그러므로 하나의 code 영역을 복수 개의 프로세스가 공유하여 메모리 낭비를 줄이는 것이다. 단, code가 공유되려면 code가 변하지 않는 프로그램이어야 한다. 이를 &lt;strong&gt;non-self-modifying code = reentrant code(재진입가능 코드) = pure code&lt;/strong&gt; 라고 한다.&lt;/p&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="Study_OperatingSystem" /><summary type="html">최신 업데이트 날짜: 2019-03-22</summary></entry><entry><title type="html">[운영체제] # 12 주기억장치 관리</title><link href="https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-12%EC%9E%A5-%EC%A3%BC%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98-%EA%B4%80%EB%A6%AC/" rel="alternate" type="text/html" title="[운영체제] # 12 주기억장치 관리" /><published>2019-03-22T21:09:00+09:00</published><updated>2019-03-22T21:09:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-12%EC%9E%A5-%EC%A3%BC%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98%20%EA%B4%80%EB%A6%AC</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-12%EC%9E%A5-%EC%A3%BC%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98-%EA%B4%80%EB%A6%AC/">&lt;p&gt;메모리는 CPU 자원만큼 컴퓨터를 사용하는데 매우 중요한 자원 중 하나이다. 이전에는 운영체제에서 CPU 자원을 관리하는 프로세스 관리에 대해 살펴보았고, 지금부터는 메인 메모리를 관리하는 기능에 대해 살펴볼 것이다. 특히, 과거에는 메모리가 매우 비싼 자원이었고 크기 또한 작았기 때문에, 운영체제에서 메모리에 대한 관리가 지금보다 더 중요하였다.&lt;/p&gt;

&lt;p&gt;현재에는 과거보다 훨씬 큰 메모리를 저렴하게 사용하지만, 지금도 메모리는 부족하다. 메모리가 커져온 만큼 프로그램의 크기와 처리하는 데이터의 크기는 그보다 더욱 빠른 속도로 커져왔다. 그러므로 현재에도 여전히 메모리를 최대한 효율적으로 사용하기 위해 여러 방법들이 연구되고 있고, 운영체제 기능에서도 매우 중요한 위치를 차지하고 있다.&lt;/p&gt;

&lt;h1 id=&quot;메모리에-프로그램-할당하기&quot;&gt;메모리에 프로그램 할당하기&lt;/h1&gt;
&lt;p&gt;메모리는 기본적으로 &lt;strong&gt;주소(Address)&lt;/strong&gt; 와 &lt;strong&gt;데이터(Data)&lt;/strong&gt; 로 구성되어 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/54821877-d74f5380-4ce6-11e9-8888-e63816796f65.png&quot; alt=&quot;OS12-1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CPU와 메모리는 양방향으로 위 그림과 같이 주고 받는다. CPU는 주소를 가지고 메인 메모리에 요청을하거나 해당 주소에 계산 결과를 저장하고, 메모리는 요구하는 주소에 저장되어 있는 데이터를 CPU에게 전달한다.&lt;/p&gt;

&lt;p&gt;프로그램을 빌드하는 과정은 소스파일, 목적파일, 실행파일 순서로 생성된다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;소스파일(Source file): 고수준언어 또는 어셈블리어&lt;/li&gt;
  &lt;li&gt;목적파일(Object file): 컴파일 또는 어셈블 결과&lt;/li&gt;
  &lt;li&gt;실행파일(Executable file): 링크 결과&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/54821878-d74f5380-4ce6-11e9-98e8-a43b086a4837.png&quot; alt=&quot;OS12-2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 프로그램이 만들어지는 과정을 그림으로 표현한 것이다. 소스파일은 컴파일러(compiler)에 의해 컴파일 수행 결과로 목적 파일을 생성한다.(어셈블리어는 어셈블러가 어셈블을 수행하여 기계어로 변환한다.) 프로그래밍을 하면서 외부의 라이브러리를 사용할 때가 빈번한데, 컴파일 단계에서는 이를 추가하지 않기 때문에 목적파일에는 이에 대한 정보가 없다. 그대신 위 그림에서 보이듯이, 링크 단계에서 하드디스크에서 프로그래머가 추가한 라이브러리를 찾아 정보를 추가하여, 실행 파일을 만든다.(링크 단계는 링커(linker)가 수행한다.) 이 프로그램을 실행하면 로더(loader)에 의해 메인 메모리에 할당된다.&lt;/p&gt;

&lt;p&gt;그리고 생성된 프로그램은 code, data, stack 영역으로 나뉘어져 있다. 단순히 생성된 프로그램에는 code와 data영역만 존재하며, 메모리에 적재되었을 때는 실제로 실행을 해야하므로 stack영역에 추가되어야 한다.&lt;/p&gt;

&lt;p&gt;그러면, 프로그램을 실제로 메모리에 올리기 위해서는 좀 더 복잡한 과정이 필요하다. 먼저, 이 프로그램은 메모리에 몇 번지에 할당될까? 이 질문은 운영체제가 없다면, 프로그래머가 직접 이를 처리해주어야 할 것이다. 하지만 운영체제가 존재하므로 실제 프로그래머는 이를 신경쓸 필요가 없다. 그러므로 프로그래밍을 할 때 주소를 사용하는 경우가 있는데, 프로그램이 메모리에 올라가는 주소를 고려하지 않고 프로그래밍이 가능한 것이다.(고수준언어에서는 직접 주소를 다루지 않는 경우가 많다.)&lt;/p&gt;

&lt;p&gt;또한, 다중 프로그래밍 환경에서는 여러 프로그램이 메모리에 올라가고 내려가고를 반복하기 때문에, 한 프로그램은 고정적인 공간을 사용할 수 없다. 이러한 여러 고려 사항을 해결해주는 것이 전에도 살펴봤던 MMU이다. 그리고 MMU에는 프로그램이 메모리에 할당될 때마다 다른 주소공간을 사용하기 때문에 &lt;strong&gt;재배치 레지스터(Relocation register)&lt;/strong&gt; 가 별도로 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/54821879-d7e7ea00-4ce6-11e9-9ad0-ffe02008d6a9.png&quot; alt=&quot;OS12-3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 MMU의 모습이다. 프로그램은 메인 메모리에 해당 주소를 사용할 수 있는지 여부를 생각하지 않고 주소를 사용한다. 만약 해당 프로그램이 사용하는 시작주소가 0번지라고 할 때, 실제 메인 메모리에서는 할당되는 주소가 유동적이기 때문에 0번지이라는 주소를 실제 할당된 주소로 변경해주어야 한다. 이때 재배치 레지스터를 이용한다.&lt;/p&gt;

&lt;p&gt;만약, 프로그램이 메인 메모리 500번지에 할당되어 재배치 레지스터값이 500으로 설정되었다면, CPU에서 프로그램의 0번지를 사용할 때 MMU를 통과하면 재배치 레지스터에 의해 500번지로 변경된다. 그 결과 CPU는 0번지를 사용하는 것으로 알고 있지만, 실제 메모리에서는 MMU에 의해 500번지를 사용하고 있는 것이다.&lt;/p&gt;

&lt;p&gt;MMU(Memory Management Unit)의 기능을 살펴보면, 이전에 메모리 보호를 위해 base와 limit 레지스터가 있었다. 이는 CPU에서 주소를 사용하는데 이 주소가 해당 프로그램의 base나 limit 범위를 벗어나면 인터럽트가 발생하여 그 프로그램을 강제로 종료시킨다.&lt;/p&gt;

&lt;p&gt;MMU는 이 기능 이외에도 재배치 레지스터를 사용해서 프로그램이 어느 주소를 사용하더라도 실제 메인 메모리에 할당된 주소를 찾아갈 수 있도록 &lt;strong&gt;address translation&lt;/strong&gt; 동작을 수행한다. 즉, CPU는 프로그램에 설정된 주소를 계속 사용하고 메모리에 명령을 보내지만, MMU에 의해 실제로 프로그램이 할당된 메모리 주소로 변환해서 사용할 수 있는 것이다. 그 결과, &lt;strong&gt;프로그램의 실제 메모리 주소 공간의 위치는 CPU에 전혀 영향을 미치지 않고&lt;/strong&gt; 정상적으로 사용할 수 있는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/54821880-d7e7ea00-4ce6-11e9-944e-3be89338213f.png&quot; alt=&quot;OS12-4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;MMU에 의해 위 그림과 같이 주소는 두 가지로 구분된다. CPU에서 사용하는 주소는 &lt;strong&gt;논리 주소(logical address)&lt;/strong&gt; 라고 하고, 메모리가 사용하는 주소는 &lt;strong&gt;물리 주소(physical address)&lt;/strong&gt; 라고 한다.&lt;/p&gt;

&lt;h1 id=&quot;메모리-낭비-방지&quot;&gt;메모리 낭비 방지&lt;/h1&gt;
&lt;p&gt;운영체제는 메모리를 효율적으로 사용하기 위해 메모리 공간을 낭비하지 않는 것이 중요하다.&lt;/p&gt;

&lt;h2 id=&quot;동적-적재dynamic-loading&quot;&gt;동적 적재(Dynamic Loading)&lt;/h2&gt;
&lt;p&gt;동적 적재는 &lt;strong&gt;프로그램이 실행하는데 반드시 필요한 루틴/데이터만 적재(load)&lt;/strong&gt; 하는 것이다. 프로그램의 전체 코드에서 모든 루틴이 다 사용되는 것은 아니다. 대표적으로 오류 처리 구문이다. 오류 처리 구문은 if문과 같이 오류가 발생할 때만 해당 내부 코드가 실행되는 것을 말한다. 그러므로 동적 적재를 수행하면 프로그램의 실제 메모리에는 이러한 오류 구문을 제외하고 적재한다. 이러한 상태에서 실행하다가 오류가 발생하면 그 때 해당 오류 구문을 찾아 메모리에 올린다.&lt;/p&gt;

&lt;p&gt;데이터도 마찬가지다. 모든 데이터가 반드시 사용되는 것이 아니기 때문에, 특히 배열과 클래스의 경우는 필요한 부분만 메모리에 올려두고, 실행 도중 필요할 때마다 해당 부분을 찾아 메모리에 올려준다.&lt;/p&gt;

&lt;p&gt;반대로, 모든 루틴과 데이터를 적재하는 것을 정적 적재(static loading)이라고 한다. 현대 운영체제는 대부분 동적 적재를 사용한다.&lt;/p&gt;

&lt;h2 id=&quot;동적-연결dynamic-linking&quot;&gt;동적 연결(Dynamic Linking)&lt;/h2&gt;
&lt;p&gt;동적 연결은 여러 프로그램에 공통으로 사용되는 라이브러리를 중복으로 메모리에 올리는 것이 아니라 &lt;strong&gt;하나&lt;/strong&gt; 만 올리도록 하는 것이다.&lt;/p&gt;

&lt;p&gt;예를 들어, 아래와 같은 코드의 P1, P2 프로세스가 있다고 하자.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// P1
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// P2
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 두 소스파일을 컴파일하면 목적파일이 생성되고, 여기서 사용된 라이브러리를 링크하여 실행파일을 만든 다음 메모리에 적재한다. 두 프로세스가 적재되었을 때, &lt;code class=&quot;highlighter-rouge&quot;&gt;printf()&lt;/code&gt; 를 사용하는 라이브러리는 메모리에 중복되어서 적재되어있다.&lt;/p&gt;

&lt;p&gt;이와 같이, 똑같은 라이브러리를 사용하는 프로그램은 흔히 볼 수 있다. 이러한 같은 라이브러리를 하나만 메모리에 올린 후, 이를 사용하는 프로그램이 하나의 메모리에 접근하도록 하면 메모리 낭비를 줄일 수 있다.&lt;/p&gt;

&lt;p&gt;동적 연결은 같은 라이브러리가 중복으로 메모리에 올라가는 것을 방지하기 위해 &lt;strong&gt;프로그램이 메모리에 적재된 후에 링크(link) 작업을 수행한다.&lt;/strong&gt; 기존에는 실행 파일이 만들어지기 전에 링크 과정을 수행하였는데, 이를 정적 연결이라고 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/54821881-d7e7ea00-4ce6-11e9-9038-3359ab7d12f2.png&quot; alt=&quot;OS12-5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 예제에서 살펴 본 P1, P2 프로세스가 동적 연결을 통해 공통 라이브러리(printf() 라이브러리)를 연결한 모습을 볼 수 있다. 이러한 라이브러리를 Linux에서는 &lt;strong&gt;공유 라이브러리(Shared Library)&lt;/strong&gt;, Windows에서는 &lt;strong&gt;동적 연결 라이브러리(Dynamic Linking Library, DLL)&lt;/strong&gt; 라고 부른다.&lt;/p&gt;

&lt;h2 id=&quot;swapping&quot;&gt;Swapping&lt;/h2&gt;
&lt;p&gt;Swapping은 메모리에 적재되어 있는 프로세스 중에서 오랫동안 사용하지 않은 프로세스를 프로세스 이미지 형태로 만든 후 하드디스크(Backing store)에 내려보낸다. 메모리에서 Backing store로 가는 것을 &lt;strong&gt;swap-out&lt;/strong&gt;, 다시 Backing store에서 메모리로 가는 것을 &lt;strong&gt;swap-in&lt;/strong&gt; 이라고 한다.&lt;/p&gt;

&lt;p&gt;여기서, 프로세스 이미지는 해당 프로그램이 메모리에 적재된 후 실행되면서 데이터를 추가하거나 변경하는 등의 과정을 거치는데, 현재 데이터의 상태를 프로세스 이미지라고 부른다. 그러므로 이는 단순히, 하드디스크에 존재하는 프로그램(exe파일)과는 전혀 다른 데이터이므로, 따로 저장해야한다. 이와 같은 swapping 과정으로 인한 프로세스 이미지를 저장하기 위해 하드디스크의 일부분을 분리하여 사용하는데, 이를 &lt;strong&gt;backing store&lt;/strong&gt; 또는 &lt;strong&gt;swap device&lt;/strong&gt; 라고 부른다.&lt;/p&gt;

&lt;p&gt;Backing store의 크기는 대략 메인 메모리 크기 정도로 예상할 수 있다. 메모리의 모든 프로세스가 쫓겨난다고 해도 메인 메모리 크기를 넘지 않기 때문이다. 메인 메모리 크기가 크지 않는 PC나 스마트폰은 하드디스크의 일부를 backing store로 사용하지만, 메모리 크기가 크다면 따로 하드디스크 자체를 backing store로 사용하는 경우도 있다.&lt;/p&gt;

&lt;p&gt;Swap-out된 프로세스는 다시 swap-in을 할 때, 이전의 메모리 주소 공간이 아닌 새로운 주소 공간으로 갈 수도 있다. 이는 해당 프로세스가 backing store에 있는 동안 다른 프로세스가 해당 주소 공간을 사용할 수 있기 때문에다. 하지만 이는 MMU의 재배치 레지스터로 인해 어디에 적재되는지 상관없이 정상적으로 수행할 수 있다.&lt;/p&gt;

&lt;p&gt;현재는 프로세스의 크기가 커지고, 하드디스크는 메인 메모리보다 속도면에서 매우 느리므로 swapping 동작의 오버헤드는 크다고 볼 수 있다. 하지만 이로 인해 얻는 이득이 더 많으므로 대부분 운영체제는 이를 사용하고 있고, 속도가 중요한 서버 컴퓨터나 슈퍼 컴퓨터는 backing store를 하드디스크가 아닌 좀 더 빠른 저장 장치를 사용하기도 한다.&lt;/p&gt;

&lt;h1 id=&quot;연속-메모리-할당contiguous-memory-allocation&quot;&gt;연속 메모리 할당(Contiguous Memory Allocation)&lt;/h1&gt;
&lt;p&gt;과거에는 메모리에 프로세스가 하나만 올라가는 형태였다. 하지만 현재에는 메모리에 여러 프로세스가 할당되는 다중 프로그래밍 환경이 되었다.&lt;/p&gt;

&lt;p&gt;부팅 직후에 메모리 상태를 살펴보면, 운영체제만 할당되어 있고 비어있는 상태일 것이다. 이러한 비어있는 공간을 &lt;strong&gt;hole&lt;/strong&gt; 이라 부른다. 즉, 부팅 직후에는 운영체제와 big single hole이 있는 상태이다. 시간이 지나면서 프로세스가 생성되고 종료하고를 반복하면, 여러 곳에 서로 다른 크기의 홀(hole)이 존재할 것이다. 이러한 상태를 scattered holes라고 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/54821882-d8808080-4ce6-11e9-8ff3-193fa79c04a3.png&quot; alt=&quot;OS12-6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 부팅 직후 상태에서 시간이 경과하면서 프로세스들이 생성, 종료를 반복한 후의 상태이다. 이와 같이 hole들이 불연속하게 흩어져 있는 상태를 &lt;strong&gt;메모리 단편화(Memory fragmentation)&lt;/strong&gt; 라고 한다.&lt;/p&gt;

&lt;p&gt;메모리 단편화로 인해서 여러 곳에 hole이 흩어져 있는 상태에서 하나의 프로세스가 메모리에 할당되려하면 문제가 발생할 수 있다. 예를 들어, hole이 3개가 있고 각 크기는 50byte, 50byte, 80byte이다. 그런데 할당하려는 프로세스의 크기는 150byte이다. 각 hole들을 하나로 합치면 230byte로 이 프로세스를 할당할 수 있는데 실재로는 나누어져 있으므로 할당되지 못한다. 이러한 현상을 &lt;strong&gt;외부 단편화(External fragmentation)&lt;/strong&gt; 라고 한다. 외부 단편화를 줄이기 위해서는 어떤 해결 방법이 있을까?&lt;/p&gt;

&lt;h2 id=&quot;연속-메모리-할당-방식&quot;&gt;연속 메모리 할당 방식&lt;/h2&gt;
&lt;p&gt;외부 단편화의 해결방법을 살펴보기 전에 연속 메모리 할당 방식을 먼저 살펴보자. 연속 메모리 할당 방식에는 3가지가 있다. First-fit, Best-fit, Worst-fit 이 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;First-fit(최초 적합)&lt;/strong&gt;: 최초 적합은 할당할 프로세스 크기보다 크거나 같은 hole을 탐색하는 순서 중에서 가장 먼저 찾은 hole에 프로세스를 할당하는 것이다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Best-fit(최적 적합)&lt;/strong&gt;: 최적 적합은 할당할 프로세스 크기와 hole 크기의 차이가 가장 작은 hole에 프로세스를 할당하는 것이다.(hole크기는 프로세스 크기보다 반드시 커야 한다.)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Worst-fit(최악 적합)&lt;/strong&gt;: 최적 적합과 반대로, 할당할 프로세스 크기와 hole 크기의 차이가 가장 큰 hole에 프로세스를 할당하는 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그러면 예제를 살펴보자. Hole은 100KB, 500KB, 600KB, 300KB, 200KB 총 5개가 있고, 프로세스는 P1, P2, P3, P4 총 4개가 있는데 각 크기는 212KB, 417KB, 112KB, 426KB이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;First-fit&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/54821883-d8808080-4ce6-11e9-8c2d-c84b878d21ea.png&quot; alt=&quot;OS12-7&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Best-fit&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/54821885-d8808080-4ce6-11e9-9473-db032d7eeb3a.png&quot; alt=&quot;OS12-8&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Worst-fit&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/54821887-d9191700-4ce6-11e9-9b00-fa92272b8b7d.png&quot; alt=&quot;OS12-9&quot; /&gt;&lt;/p&gt;

&lt;p&gt;각 3가지 방식대로 프로세스를 할당한 모습을 볼 수 있다. 예제의 결과를 보면 Best-fit은 4개의 프로세스를 모두 할당할 수 있었고, 나머지 2개는 마지막 P4를 할당하지 못했다. 모든 hole을 합치면 P4를 할당할 수 있지만, hole들은 각각 나눠져 있기 때문에 할당할 수 없었다.(외부 단편화)&lt;/p&gt;

&lt;p&gt;각 할당 방식의 일반적인 성능을 비교해보면, 속도면에서는 first-fit이 가장 빠르다. 메모리 이용률면에서는 first-fit, best-fit이 비슷한 성능을 낸다고 알려져있다. 하지만 여러 실험을 통해 best-fit을 사용하더라도 외부 단편화로 인해 &lt;strong&gt;전체 메모리의 1/3 정도를 낭비&lt;/strong&gt; 한다고 한다. 이는 거의 사용이 불가능한 수준이다.&lt;/p&gt;

&lt;p&gt;이를 해결하는 방법 중 하나는 &lt;strong&gt;Compaction&lt;/strong&gt; 이다. compaction은 여러 곳에 흩어져있는 hole들을 강제로 하나로 합치는 것이다. 하지만 hole을 옮기는 오버헤드가 너무 크고, 어느 hole을 옮겨야 빠르게 합칠 수 있는지에 대한 최적 알고리즘이 존재하지 않는 큰 단점이 존재한다.&lt;/p&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="Study_OperatingSystem" /><summary type="html">최신 업데이트 날짜: 2019-03-22</summary></entry></feed>