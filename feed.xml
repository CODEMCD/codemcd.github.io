<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://codemcd.github.io/pages/CODEMCD/feed.xml" rel="self" type="application/atom+xml" /><link href="https://codemcd.github.io/pages/CODEMCD/" rel="alternate" type="text/html" /><updated>2019-05-06T16:56:40+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/feed.xml</id><title type="html">CODEMCD’s Tech BLOG</title><subtitle>My Tech Blog</subtitle><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><entry><title type="html">[데이터베이스] 트랜잭션(Transaction)</title><link href="https://codemcd.github.io/pages/CODEMCD/study/Database-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/" rel="alternate" type="text/html" title="[데이터베이스] 트랜잭션(Transaction)" /><published>2019-05-06T00:09:00+09:00</published><updated>2019-05-06T00:09:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/study/Database-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/study/Database-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/">&lt;p&gt;트랜잭션은 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 &lt;strong&gt;논리적인 단위&lt;/strong&gt; 로 일련의 연산들의 집합이다. 예를 들어, 계좌 간의 자금 이체가 있다. 입금 할 때, 데이터베이스 내부의 상대방 계좌 정보를 검색하고 자신과 상대방의 계좌 금액을 변경하는 등 여러 가지 연산이 필요하다. 하지만 이러한 작업의 중간 단계에서 멈추거나 오류가 발생하면 데이터에 매우 큰 영향을 미친다. 그러므로 이러한 작업은 정상적으로 전체 작업이 완료되거나 그럴 수 없는 경우 아무 것도 실행하지 않은 처음 상태로 되돌려져야 한다. 이러한 작업 단위를 트랜잭션이라 하고 이는 사람이 정하는 기준에 따라 달라 질 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;트랜잭션-특징&quot;&gt;트랜잭션 특징&lt;/h2&gt;
&lt;p&gt;트랜잭션의 특징은 4 가지가 있다. 일반적으로 &lt;strong&gt;ACID&lt;/strong&gt; 성질이라고 하며, 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Atomicity(원자성)&lt;/strong&gt;: 트랜잭션의 모든 연산들이 정상적으로 수행 완료되거나 아니면 어떠한 연산도 수행되지 않은 상태를 보장해야 한다. 입금 과정에서 트랜잭션이 실패하여 어느 한 계좌에만 작업이 적용되거나 하는 경우가 발생하면 안되기 때문에, 실패하면 어느 작업도 적용되지 않고 트랜잭션이 수행되기 전의 상태로 유지되어야 한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Consistency(일관성)&lt;/strong&gt;: 트랜잭션의 수행이 데이터베이스의 일관성을 유지해야 한다. 즉, 성공적으로 수행된 트랜잭션은 정당한 데이터들만을 데이터베이스에 반영해야 한다. 트랜잭션이 수행이 보존해야할 일관성은 기본 키, 외래 키 제약과 같은 &lt;strong&gt;명시적인 무결성 제약 조건&lt;/strong&gt; 과 자금 이체에서 두 계좌 간의 잔고 합은 이체 전후가 같아야 한다는 &lt;strong&gt;비명시적인 일관성 조건&lt;/strong&gt; 들도 있다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Isolation(독립성)&lt;/strong&gt;: 여러 트랜잭션이 동시에 수행되더라도 각각의 트랜잭션은 다른 트랜잭션의 수행에 영향을 받지 않고 독립적으로 수행되어야 한다. 이는 한 트랜잭션의 중간 결과가 다른 트랜잭션에게는 숨겨져야 한다는 의미이며, 이러한 성질이 보장되지 않으면 트랜잭션이 원래 상태로 되돌아갈 수 없게 된다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Durability(지속성)&lt;/strong&gt;: 트랜잭션이 성공적으로 완료되어 커밋(commit)되고 나면, 해당 트랜잭션에 의한 모든 변경은 향후 어떠한 소프트웨어나 하드웨어 장애가 발생되더라도 보존되어야 한다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="Study_Database" /><summary type="html">최신 업데이트 날짜: 2019-05-05</summary></entry><entry><title type="html">플로이드(Floyd)의 모든 쌍 최단 거리 알고리즘</title><link href="https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/" rel="alternate" type="text/html" title="플로이드(Floyd)의 모든 쌍 최단 거리 알고리즘" /><published>2019-05-05T21:06:00+09:00</published><updated>2019-05-05T21:06:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">&lt;h2 id=&quot;플로이드-알고리즘의-특징&quot;&gt;플로이드 알고리즘의 특징&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;모든 쌍의 최단 거리를 구할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;알고리즘이 간단하기 때문에, 모든 정점에서 다익스트라나 벨만-포드 알고리즘을 수행하는 것보다 훨씬 효율적이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;실제 경로를 계산할 수 있다.&lt;/li&gt;
  &lt;li&gt;가중치없는 그래프에서 각 정점 간의 도달 가능성 여부를 계산할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;너비 우선 탐색보다 구현이 간단하여 자주 사용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;경유점&quot;&gt;경유점&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;두 정점 u, v를 잇는 어떤 경로가 있을 때, 이 경로는 u, v외에도 다른 정점을 경유해서 가는 경로가 더 짧을 수도 있다.&lt;/li&gt;
  &lt;li&gt;위와 같이 경로가 거쳐가는 정점들을 경유점이라고 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/46916177-ef150400-cff1-11e8-90e1-9f75b37313ec.JPG&quot; alt=&quot;floyd1&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;위의 그림에서 볼 수 있듯이, 정점 u에서 v까지 가장 짧은 경로는 &lt;code class=&quot;highlighter-rouge&quot;&gt;u -&amp;gt; a -&amp;gt; b -&amp;gt; v&lt;/code&gt;인 것을 볼 수 있다.
    &lt;ul&gt;
      &lt;li&gt;여기서 경유점은 정점 a, b이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;플로이드 알고리즘은 시작 정점과 도착 정점 사이의 모든 경로점을 고려하는 것을 시각적으로 이해하기 쉽고 간단하게 구현된 알고리즘이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;플로이드-알고리즘-최적화-과정&quot;&gt;플로이드 알고리즘 최적화 과정&lt;/h2&gt;
&lt;h3 id=&quot;1-시간-복잡도-ov3-공간-복잡도-ov3&quot;&gt;1. 시간 복잡도: &lt;code class=&quot;highlighter-rouge&quot;&gt;O(|V|^3)&lt;/code&gt;, 공간 복잡도: &lt;code class=&quot;highlighter-rouge&quot;&gt;O(|V|^3)&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;어떤 정점 집합 S에 포함된 정점만을 경유점으로 사용해 u에서 v로 가는 최단 경로를 계산한다고 가정하자.&lt;/li&gt;
  &lt;li&gt;어떤 정점 x에 대해 2가지를 생각할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;경로가 x를 경유하지 않는다: 이 경로는 S - {x} 에 포함된 정점들만을 경유점으로 사용한다.&lt;/li&gt;
      &lt;li&gt;경로가 x를 경유한다.: 이 경로는 u에서 x의 구간과 x에서 v로 가는 구간으로 나눌 수 있다. 이 두개의 부분 경로는 각각 최단 경로임이 확실하며 x를 경유하지 않는다. 따라서 위와 같이 S - {x}에 포함된 정점들만을 경유점으로 사용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이를 활용하여, &lt;code class=&quot;highlighter-rouge&quot;&gt;S = { 0, 1, 2, ..., k }&lt;/code&gt;라 하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;C_k(u, v)&lt;/code&gt;는 정점 0번 부터 k번 정점까지만을 경유점을 썼을 때 u에서 v까지 가는 최단 경로의 길이라고 두면 다음과 같은 재귀적인 식이 만들 수 있다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C_k(u, v) = min(C_k-1(u, k) + C_k-1(k, v), C_k-1(u, v))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;C_k는 C_k-1에만 의존하기 때문에, 동적 계획법으로 구현할 수 있다. (&lt;code class=&quot;highlighter-rouge&quot;&gt;C[k][u][v]&lt;/code&gt;배열로 메모이제이션)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-시간-복잡도-ov3-공간-복잡도-ov2&quot;&gt;2. 시간 복잡도: &lt;code class=&quot;highlighter-rouge&quot;&gt;O(|V|^3)&lt;/code&gt;, 공간 복잡도: &lt;code class=&quot;highlighter-rouge&quot;&gt;O(|V|^2)&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1번 알고리즘의 문제는 시간 복잡도보다 공간 복잡도이다.
    &lt;ul&gt;
      &lt;li&gt;정점의 개수가 1000개라고 가정하면, 시간은 10초가량 소요되지만, 배열 용량은 4GB가 정도가 필요하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;공간 복잡도를 줄이기 위해서는 위에서 세운 식의 문제점을 파악하면 쉽게 해결가능하다.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;C_k-1(u, k)&lt;/code&gt; = 시작점으로부터 k-1번 정점까지를 경유점으로 이용해 u에서 k로 가는 최단 경로의 길이&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;C_k(u, k)&lt;/code&gt; = 시작점으로부터 k번 정점까지를 경유점으로 이용해 u에서 k로 가는 최단 경로의 길이&lt;/li&gt;
      &lt;li&gt;위의 두 식을 보면, 출발점이나 도착점이 k번 정점일 때, 사용가능한 경유점의 목록에 k가 추가되는 것은 아무런 의미가 없다.&lt;/li&gt;
      &lt;li&gt;즉, 1번에서 C배열의 k가 전혀 필요하지 않다는 것이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;구현
    &lt;ul&gt;
      &lt;li&gt;별도의 배열 C를 만들지 않고, 인접 행렬adj에 직접 최단 거리를 계산한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//정점의 개수
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//그래프의 인접 행렬 표현
//adj[u][v] = u에서 v로 가는 가선의 가중치, 간선이 없으면 아주 큰 값으로 초기화
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX_V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX_V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//플로이드의 모든 쌍 최단 거리 알고리즘
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;floyd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;adj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;adj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3-시간-복잡도-최적화&quot;&gt;3. 시간 복잡도 최적화&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;플로이드 알고리즘의 3중 for문 중 2번째 for문 바로 다음에 i에서 k로 가는 경로가 실제 있는지를 확인한다.&lt;/li&gt;
  &lt;li&gt;i에서 k로 가는 경로가 없다면 j에 대한 for문은 수행할 필요가 없다.&lt;/li&gt;
  &lt;li&gt;이는 실제로 그래프에 간선이 적을수록 효과가 좋으며, 경우에 따라 10% ~ 20% 정도의 수행 시간으르 단축시킬 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;실제-경로-계산하기&quot;&gt;실제 경로 계산하기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;플로이드 알고리즘에서 실제 경로를 계산하기 위해서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;adj[u][v]&lt;/code&gt;를 갱신했을 때 사용했던 k의 값을 저장해두면 된다.
    &lt;ul&gt;
      &lt;li&gt;u에서 v로 가는 최단 거리를 정점 w일 때 갱신되었다면, u에서 w로 가는 최단 거리 경로점을 찾고 w에서 v로 가는 최단 거리를 경로점을 찾아 둘을 합치면 최종적으로 u에서 v로 가는 최단 경로를 찾을 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;구현&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//정점의 개수
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//그래프의 인접 행렬 표현
//adj[u][v] = u에서 v로 가는 가선의 가중치, 간선이 없으면 아주 큰 값으로 초기화
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX_V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX_V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//via[u][v] = u에서 v까지 가는 최단 경로가 경유하는 점 중 가장 번호가 큰 정점
//-1로 초기화한다.
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;via&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX_V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX_V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//플로이드의 모든 쌍 최단 거리 알고리즘
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;floyd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//via배열 초기화
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;memset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;via&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;via&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;adj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
					&lt;span class=&quot;n&quot;&gt;via&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
					&lt;span class=&quot;n&quot;&gt;adj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
				&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//u에서 v로 가는 최단 경로를 계산해 path에 저장한다.
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;reconstruct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//기저 사례
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;via&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;via&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;reconstruct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//w가 중복으로 들어가므로 지워준다.
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;reconstruct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;도달-가능성-확인하기&quot;&gt;도달 가능성 확인하기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;C_k(u, v)&lt;/code&gt;: 0번부터 k번 정점까지를 경유점으로 사용한다.&lt;/li&gt;
  &lt;li&gt;u에서 v로 가는 경로가 있는지 여부를 나타내는 식은 다음과 같다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C_k(u, v) = C_k-1(u, v) || (C_k-1(u ,k) &amp;amp;&amp;amp; C_k-1(k, v))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="Algorithm_Algorithm" /><summary type="html">최신 업데이트 날짜: 2019-05-05</summary></entry><entry><title type="html">[운영체제] # 19 디스크 스케줄 알고리즘(Disk Schedule Algorithm)</title><link href="https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-19%EC%9E%A5-%EB%94%94%EC%8A%A4%ED%81%AC-%EC%8A%A4%EC%BC%80%EC%A4%84-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/" rel="alternate" type="text/html" title="[운영체제] # 19 디스크 스케줄 알고리즘(Disk Schedule Algorithm)" /><published>2019-05-05T19:40:00+09:00</published><updated>2019-05-05T19:40:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-19%EC%9E%A5-%EB%94%94%EC%8A%A4%ED%81%AC%20%EC%8A%A4%EC%BC%80%EC%A4%84%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-19%EC%9E%A5-%EB%94%94%EC%8A%A4%ED%81%AC-%EC%8A%A4%EC%BC%80%EC%A4%84-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">&lt;h1 id=&quot;디스크-스케줄링&quot;&gt;디스크 스케줄링&lt;/h1&gt;
&lt;p&gt;보조기억장치는 현재 여러 가지 존재하지만 아직까지는 하드 디스크가 주로 사용된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57186873-7344bf80-6f21-11e9-83f3-27a558247925.png&quot; alt=&quot;OS19-1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;하드 디스크의 구조는 앞서 살펴봤듯이 위 그림과 같다. 디스크에 접근하는 시간은 &lt;strong&gt;Seek time(탐색 시간)&lt;/strong&gt; + rotational delay + transfer time 으로 계산할 수 있는데, 이 중에서 seek time(head를 움직이는 시간)이 가장 크다.&lt;/p&gt;

&lt;p&gt;현재 컴퓨터 환경은 대부분 다중 프로그래밍 환경이다. 그러므로 여러 프로세스가 메인 메모리에서 실행 중에 있는데, 이러한 여러 프로세스가 동시에 디스크를 읽으려는 요청이 올 수 있다. 이와 같은 요청이 오면 디스크 역시 CPU와 같이 &lt;strong&gt;디스크 큐(dist queue)&lt;/strong&gt; 에서 요청을 저장해두고 이를 처리해야 한다.&lt;/p&gt;

&lt;p&gt;여기서 컴퓨터의 성능을 위해 여러 요청들을 효율적으로 처리해야 한다. 디스크를 읽는 시간은 매우 오래 걸리는 작업이고 특히 탐색 시간이 오래걸리므로 최대한 이 시간을 줄이는 것이 중요하다. 이러한 방법들을 디스크 스케줄링 알고리즘이라 한다.&lt;/p&gt;

&lt;h2 id=&quot;fcfsfirst-come-first-served&quot;&gt;FCFS(First-Come First-Served)&lt;/h2&gt;
&lt;p&gt;이 방법은 어느 스케줄링 알고리즘에서도 존재하는 가장 간단하고 가장 공평한 방법이다. 바로 예제를 살펴보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;예제
200 cylinder dist: 0, 1, 2, …, 199
Disk queue: 98, 183, 37, 122, 14, 124, 65, 67
현재 헤드가 가리키는 실린더(cylinder) 위치: 53&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57186874-73dd5600-6f21-11e9-8a9a-1f2d7f3b22c6.png&quot; alt=&quot;OS19-2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;예제를 그림으로 나타내면 위 그림과 같다. 가로축은 0번부터 199번까지 실린더의 위치를 나타낸다. 여기서 파란색 선이 dist queue를 FCFS 방법으로 처리한 결과이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;헤드가 움직인 총 거리&lt;/strong&gt; = (98 - 53) + (183 - 98) + (183 - 37) + (122 - 37) + (122 - 14) + (124 - 14) + (124 - 65) + (67 - 65) = &lt;strong&gt;640 cylinders&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;위 그림의 결과를 본 것처럼 큐에 들어온 순서가 큰 값, 작은 값이 반복한다면 헤드가 움직이는 거리가 매우 커짐을 알 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;sstfshortest-seek-time-first&quot;&gt;SSTF(Shortest-Seek-Time-First)&lt;/h2&gt;
&lt;p&gt;SSTF 스케줄링 알고리즘은 가장 짧은 탐색 시간을 먼저 선택하는 것이다. 다시 말하면 현재 헤드가 다음 요청을 처리하기 위해 움직여야 하는 거리가 가장 짧은 것을 선택하는 것이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;예제
200 cylinder dist: 0, 1, 2, …, 199
Disk queue: 98, 183, 37, 122, 14, 124, 65, 67
현재 헤드가 가리키는 실린더(cylinder) 위치: 53&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57186875-73dd5600-6f21-11e9-86d1-1c9b73b375f2.png&quot; alt=&quot;OS19-3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 예제는 FCFS 스케줄링에서 본 예제와 같은 것이다. 처음 헤드 위치 53을 시작으로 dist queue에 있는 실린더 번호 중 53과 가장 가까운 65번 실린더를 선택한다. 65번에서는 가장 가까운 67번을 선택하고 같은 과정을 반복한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;헤드가 움직인 총 거리&lt;/strong&gt; = (65 - 53) + (67 - 65) + (67 - 37) + (37 - 14) + (98 - 14) + (122 - 98) + (124 - 122) + (183 - 124) = &lt;strong&gt;236 cylinders&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SSTF 스케줄링 알고리즘의 결과는 위 예제에서 FCFS 스케줄링보다 훨씬 적은 수의 실린더를 움직이는 것을 볼 수 있다. 하지만 SSTF 스케줄링의 큰 단점은 &lt;strong&gt;기아(starvation)&lt;/strong&gt; 가 발생할 수 있다. dist queue에는 지속적으로 새로운 프로세스의 요청이 들어오기 때문에 헤드와 멀리 떨어져 있는 실린더는 끝내 수행하지 못하는 현상이 발생하는데, 이를 starvation이라고 한다.&lt;/p&gt;

&lt;p&gt;그리고 SSTF 스케줄링이 현재와 가장 가까운 실린더를 선택한다고 해서 &lt;strong&gt;최적의 알고리즘은 아니다.&lt;/strong&gt; 위 예제에서도 가장 처음 위치인 53번 실린더에서 65번이 아닌 37번으로 이동한 후에 SSTF 알고리즘을 수행하면 &lt;strong&gt;208 cylinders&lt;/strong&gt; 가 나온다.&lt;/p&gt;

&lt;h2 id=&quot;scan&quot;&gt;Scan&lt;/h2&gt;
&lt;p&gt;Scan 스케줄링은 말그대로 헤드가 지속적으로 디스크를 앞뒤로 검사하는 것이다. 그래서 헤드가 앞으로 스캔할 때(번호가 작은 실린더 방향)와 뒤로 스캔할 때(번호가 큰 실린더 방향) 선택하는 실린더가 서로 다르다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;예제&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;200 cylinder dist: 0, 1, 2, …, 199
Disk queue: 98, 183, 37, 122, 14, 124, 65, 67
현재 헤드가 가리키는 실린더(cylinder) 위치: 53
스캔 방향: 0번 방향으로 움직임(번호가 작은 실린더 방향)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57186876-73dd5600-6f21-11e9-82f5-332c617c449f.png&quot; alt=&quot;OS19-4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 결과에서 볼 수 있듯이 스캔 방향이 0번 실린더 방향이므로 53번에서 작은 번호의 실린더로 향한 후에 큰 번호 실린더로 움직인 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;헤드가 움직인 총 거리&lt;/strong&gt; = (53 - 37) + (37 - 14) + (14 - 0) + (65 - 0) + (67 - 65) + (98 - 67) + (122 - 98) + (124 - 122) + (183 - 124) = &lt;strong&gt;236 cylinders&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;여기서 한 가지 생각해 볼 점은 일반적으로 프로세스들이 디스크에 요청할 때 그 위치를 종합해보면 실린더에 &lt;strong&gt;골고루 퍼져있다.&lt;/strong&gt; 그러므로 Scan 스케줄링 알고리즘처럼 앞뒤로 움직이는 것이아니라 처음부터 한 방향으로 끝까지 움직이고 다시 처음으로 되돌아가서 같은 방향으로 끝까지 움직이는 것이 더욱 효과적이다.(눈 오는 날 운동장에 눈을 치우는 것을 생각하면 이해하기 쉬울 것이다.)&lt;/p&gt;

&lt;p&gt;이러한 아이디어에서 나온 것이 &lt;strong&gt;Circular Scan&lt;/strong&gt; 스케줄링 알고리즘이다.&lt;/p&gt;

&lt;h2 id=&quot;scan-variants&quot;&gt;Scan Variants&lt;/h2&gt;
&lt;h3 id=&quot;c-scan&quot;&gt;C-Scan&lt;/h3&gt;
&lt;p&gt;이 방식은 위에서 말한 Circular Scan 스케줄링 알고리즘이다. 즉 한 방향으로 계속 움직이는 것이 마치 원형으로 움직인 것과 같은 모습이다. 움직이는 거리는 더 길어질 수 있지만 다시 처음 위치로 되돌아갈 때는 데이터를 읽지 않으므로 더 빠른 속도로 움직일 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;look&quot;&gt;Look&lt;/h3&gt;
&lt;p&gt;이 알고리즘은 위 Scan 스케줄링 예제에서 0번 실린더가 존재하지 않지만 0번까지 가는 모습을 보았다. 이러한 비효율적인 움직임을 없애기 위해 &lt;strong&gt;존재하는 실린더의 최소와 최대 범위&lt;/strong&gt; 만 움직이는 알고리즘을 Look 스케줄링 알고리즘이라고 한다. 하지만 이 범위를 알기 위해서 미리 큐를 검사해야한다.&lt;/p&gt;

&lt;h3 id=&quot;c-look&quot;&gt;C-Look&lt;/h3&gt;
&lt;p&gt;C-Look은 &lt;strong&gt;Circular Look&lt;/strong&gt; 을 말한다. Look은 위에서 Scan 스케줄링이 0번 부터 끝 실린더까지 움직이지 않고 존재하는 실린더의 최소에서 최대 범위를 움직인다고 하였는데, C-Look은 이 범위에서 C-Scan과 같이 한 방향으로만 움직이는 것을 말한다. 즉, 최대 실린더에서 최소 실린더 방향으로 움직인다고 할 때 최소 범위에 도달하면 다시 최대 범위로 되돌아가서 같은 방향으로 움직인다.&lt;/p&gt;

&lt;h2 id=&quot;elevator-algorithm&quot;&gt;Elevator Algorithm&lt;/h2&gt;
&lt;p&gt;Elevator Algorithm은 Scan과 파생되어 나온 알고리즘(C-scan, Look, C-Look)을 부르는 다른 용어이다. 위 Scan 스케줄링 알고리즘 예제 그림을 90도로 회전하면 엘리베이터의 모습과 유사하여 붙여진 이름이다.&lt;/p&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="Study_OperatingSystem" /><summary type="html">최신 업데이트 날짜: 2019-05-05</summary></entry><entry><title type="html">[운영체제] # 18 파일 할당(Allocation of Files)</title><link href="https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-18%EC%9E%A5-%ED%8C%8C%EC%9D%BC-%ED%95%A0%EB%8B%B9/" rel="alternate" type="text/html" title="[운영체제] # 18 파일 할당(Allocation of Files)" /><published>2019-05-05T19:10:00+09:00</published><updated>2019-05-05T19:10:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-18%EC%9E%A5-%ED%8C%8C%EC%9D%BC%20%ED%95%A0%EB%8B%B9</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-18%EC%9E%A5-%ED%8C%8C%EC%9D%BC-%ED%95%A0%EB%8B%B9/">&lt;p&gt;컴퓨터 시스템 자원 중 가장 중요한 것은 CPU이다. CPU 자원 관리에 대해서는 맨 처음 부분에서 다루었으며 CPU 스케줄링, 프로세스 동기화 등에 대해서 배웠다. CPU 다음으로 중요한 자원은 메인 메모리와 같은 주기억장치이다. 메인 메모리 관리에 대한 주요 이슈는 페이징, 가상 메모리(요구 페이징) 등이 있었다.&lt;/p&gt;

&lt;p&gt;CPU, 주기억장치 다음 중요한 컴퓨터 시스템 자원은 하드디스크와 같은 보조기억장치이다. 하드디스크가 데이터를 관리하는 방식은 &lt;strong&gt;파일 시스템&lt;/strong&gt; 이다. 파일은 컴퓨터에서 운영체제를 사용해본 사용자라면 매우 익숙한 단어일 것이다. 대표적인 windows 운영체제를 보면 폴더(디렉토리) 내부에 또 다른 폴더 또는 어떠한 파일이 존재한다. 이러한 폴더 및 파일은 트리 구조를 이루어 관리할 수 있다.&lt;/p&gt;

&lt;p&gt;이번 장에서는 보조기억장치 중 컴퓨터에서 주로 사용하는 하드디스크의 파일이 할당되는 방법에 대해서 살펴볼 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57186865-72139280-6f21-11e9-8d3a-ba7554aff1ac.png&quot; alt=&quot;OS18-1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 하드디스크의 구조이다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;platter&lt;/strong&gt;: 실제 데이터를 기록하는 자성을 가진 원판이다. platter는 그림과 같이 여러 개가 존재하고 앞뒤로 사용할 수 있다. 한 platter는 여러 개의 track으로 이루어져 있다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;track&lt;/strong&gt;: platter의 동심원을 이루는 하나의 영역이다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;sector&lt;/strong&gt;: 하나의 track을 여러 개로 나눈 영역을 sector라 한다. sector size는 일반적으로 512 bytes이며 주로 여러 개를 묶어서 사용한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;cylinder&lt;/strong&gt;: 한 cylinder는 모든 platter에서 같은 track 위치의 집합을 말한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;앞서 sector는 여러 개로 묶어서 사용한다고 했는데, 이를 &lt;strong&gt;블록(block)&lt;/strong&gt; 이라 한다. 하드디스크는 &lt;strong&gt;블록 단위로 읽고 쓰기&lt;/strong&gt; 때문에 block device 라고 불리기도 한다.&lt;/p&gt;

&lt;p&gt;하드디스크가 블록 단위로 읽고 쓰는 것을 확인할 수 있는 간단한 방법은 메모장 프로그램에서 알파벳 a만을 적고 저장해보자. a는 character로 1byte 크기를 갖는데, 실제 저장된 텍스트 파일의 속성을 확인하면 디스크에 &lt;strong&gt;4KB(하나의 block size)&lt;/strong&gt; 가 할당되는 것을 확인할 수 있다.(실제 디스크 할당 크기는 운영체제마다 다르다.)&lt;/p&gt;

&lt;p&gt;따라서 디스크는 비어있는 블록들의 집합이라고 볼 수 있다.(pool of free blocks) 그렇다면 운영체제는 각각의 파일에 대해 &lt;strong&gt;free block&lt;/strong&gt; 을 어떻게 할당할까?&lt;/p&gt;

&lt;h1 id=&quot;파일-할당&quot;&gt;파일 할당&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57186866-72139280-6f21-11e9-898a-d2deeb334286.png&quot; alt=&quot;OS18-2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 pool of free blocks를 논리적인 그림으로 나타낸 모습이고 블록마다 인덱스 번호를 설정하였다. 블록들이 위와 같이 있을 때 파일을 할당하는 방법은 크게 연속 할당, 연결 할당, 색인 할당 세 가지가 존재한다.&lt;/p&gt;

&lt;h2 id=&quot;연속-할당-contiguous-allocation&quot;&gt;연속 할당 (Contiguous Allocation)&lt;/h2&gt;
&lt;p&gt;연속 할당은 말그대로 &lt;strong&gt;연속된 블록에 파일을 할당&lt;/strong&gt; 하는 것이다. 예를 들어, 블록 크기가 1KB이고, 할당할 파일은 f1, f2, f3 3개가 있고 각각의 크기는 5KB, 3KB, 4KB이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57186867-72ac2900-6f21-11e9-9542-e68d1eef7e27.png&quot; alt=&quot;OS18-3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;앞선 예제로 연속 할당을 수행하면 위의 그림과 같은 모습이 나온다.&lt;/p&gt;

&lt;p&gt;연속 할당의 장점은 &lt;strong&gt;디스크 헤더의 이동을 최소화&lt;/strong&gt; 할 수 있어 I/O 성능을 높일 수 있다. 이 방식은 예전의 IBM에서 사용하던 방법이며 주로 동영상, 음악, VOD 등에 적합하다.&lt;/p&gt;

&lt;p&gt;또한, 연속 할당에는 두 가지 특징이 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;순차 접근(Sequential Access)&lt;/strong&gt; 이 가능하다.
이는 말그대로 순서대로 파일을 읽을 수 있다는 의미이다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;직접 접근(Direct Access)&lt;/strong&gt; 이 가능하다.
운영체제는 파일의 정보를 &lt;strong&gt;디렉토리(directory)&lt;/strong&gt; 라는 테이블에 저장한다. 디렉토리에서 사용자가 접근가능한 정보는 파일의 이름, 크기, 날짜 등이 있고, 운영체제 내부에서 접근하는 정보는 해당 &lt;strong&gt;파일의 시작 블록 번호&lt;/strong&gt; 와 같은 것이 있다. 예를 들어, 위 예제의 f1 파일의 디렉토리 정보는 아래와 같다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;file name: f1
file size: 5 bytes
...
-----------------
block number: 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;연속 할당은 순차적으로 저장되어 있으므로 운영체제는 디렉토리에서 얻은 시작 블록 번호로 원하는 블록에 바로 접근할 수 있다. 예를 들어, 위 예제에서 f1 파일의 3번째 블록에 접근하고 싶다고 가정하자. 운영체제는 f1의 시작 블록 번호가 0번인 것을 알고 있기 때문에 2번 블록에 접근하면 f1의 3번째 블록이라는 것을 알 수 있다.&lt;/p&gt;

&lt;p&gt;연속 할당은 현재에는 거의 사용하지 않는 방식인데, 이 방법에는 큰 단점이 존재하기 때문이다. 파일을 할당하고 지우고를 반복하다보면 중간 중간에 빈 공간(hole)이 생기는데 연속 할당은 연속된 공간을 찾아야 하기 때문에 이전 메인 메모리 할당에서 살펴본 것과 같이 &lt;strong&gt;외부 단편화&lt;/strong&gt; 문제가 발생한다.&lt;/p&gt;

&lt;p&gt;외부 단편화로 인해 디스크 공간의 낭비가 매우 심해진다. 이전 메모리 할당에서 외부 단편화로 인해 메모리의 약 1/3을 낭비한다고 하였는데, 디스크의 연속 할당도 같은 낭비가 발생한다.&lt;/p&gt;

&lt;p&gt;또 다른 문제는 파일을 저장할 때 &lt;strong&gt;실제 크기를 알 수 없다.&lt;/strong&gt; 특히, 계속해서 사용하는 파일의 경우 &lt;strong&gt;크기가 계속 증가&lt;/strong&gt; 할 수 있기 때문에 이를 지속해서 연속적으로 할당하기에는 매우 부적절하다.&lt;/p&gt;

&lt;h2 id=&quot;연결-할당-linked-allocation&quot;&gt;연결 할당 (Linked Allocation)&lt;/h2&gt;
&lt;p&gt;연결 할당은 연속 할당의 문제점을 해결하기 위해 나온 방법으로, 연속적으로 할당하는 것이 아니라 &lt;strong&gt;링크드 리스트(linked list)&lt;/strong&gt; 와 같은 방식으로 파일을 할당한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57186868-72ac2900-6f21-11e9-94a6-40054c58852b.png&quot; alt=&quot;OS18-4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 block 크기가 1 byte, 파일 f1의 크기가 5 bytes 일 때 연결 할당을 수행한 모습이다. 각 블록의 마지막에 &lt;strong&gt;주소를 저장하는 포인터 공간(4bytes)&lt;/strong&gt; 이 존재하며, 여기서 다음 블록을 가리키고 있다. 마지막 블록의 포인터 공간에는 끝임을 나타내는 값이 저장되어 있다.&lt;/p&gt;

&lt;p&gt;이러한 파일을 &lt;strong&gt;linked list of data blocks&lt;/strong&gt; 라고 하며, f1의 파일 디렉토리 정보는 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;file name: f1
file size: 5 bytes
...
-----------------
block number: 6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;연결 할당을 사용해서 새로운 파일을 할당할 때는 비어있는 임의의 블록을 첫 블록으로 선택하며, 만약 파일이 커지는 경우 다른 블록을 할당해서 기존의 블록과 연결만 해주면 된다. 연결 할당은 위치와 상관없이 할당이 가능하므로 &lt;strong&gt;외부 단편화 문제가 없다.&lt;/strong&gt; (= 디스크 낭비가 없다.)&lt;/p&gt;

&lt;p&gt;하지만, 연결 할당 역시 여러 문제점을 가지고 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;순차 접근은 가능하지만 &lt;strong&gt;직접 접근은 불가능하다.&lt;/strong&gt; : 파일의 블록들은 모두 흩어져 있으므로 시작 블록 번호를 가지고는 원하는 위치의 블록에 바로 접근할 수는 없다.&lt;/li&gt;
  &lt;li&gt;포인터를 저장하는 4 bytes 이상의 손해가 발생한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;낮은 신뢰성&lt;/strong&gt; : 중간 블록의 포인터가 끊어지면 그 이후의 모든 블록에 접근하지 못한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;느린 속도&lt;/strong&gt; : 블록이 모두 흩어져 있으므로 디스크 헤더의 움직임이 그 만큼 많이 발생한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 문제점을 개선하기 위해 나온 것이 같은 연결 할당 방식인 &lt;strong&gt;FAT(File Allocation Table) 시스템&lt;/strong&gt; 이다. FAT 시스템은 &lt;strong&gt;다음 블록으르 가리키는 포인터들만 모아서 하나의 테이블(FAT)&lt;/strong&gt; 을 만들어 한 블록에 저장한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57186869-72ac2900-6f21-11e9-98db-e780d2db15ea.png&quot; alt=&quot;OS18-5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 앞선 예제의 f1 파일을 FAT 파일 시스템 방식으로 저장한 모습이다. 0번 블록에 저장된 FAT를 보면 테이블의 인덱스는 전체 디스크의 블록 번호이며, &lt;strong&gt;각 인덱스마다 다음 블록 번호를 저장&lt;/strong&gt; 하고 있다.&lt;/p&gt;

&lt;p&gt;FAT 시스템을 사용하면 기존의 연결 할당의 문제점 대부분을 해결할 수 있다. FAT를 한 번만 읽으면 &lt;strong&gt;직접 접근이 가능&lt;/strong&gt; 하고, FAT만 문제가 없다면 중간 블록에 문제가 생겨도 FAT를 통해 그 다음 블록은 여전히 읽을 수 있다. 그리고 FAT는 일반적으로 메모리 캐싱을 사용하여 블록 위치를 찾는데는 빠르지만 실제 디스크 헤더가 움직는 것은 블록이 흩어져 있으므로 여전히 느리다고 볼 수 있다. 마지막으로 FAT는 매우 중요한 정보이므로 &lt;strong&gt;손실 시 복구를 위해 이중 저장&lt;/strong&gt; 을 한다.&lt;/p&gt;

&lt;p&gt;FAT의 각 인덱스 크기는 전체 블록의 개수를 저장할 만큼의 크기를 가지고 있어야 하는데, 현재는 일반적으로 32bit 크기를 사용한다. 이를 FAT32라고 부른다.(이전에는 FAT16, FAT12 등이 있었다.)&lt;/p&gt;

&lt;h2 id=&quot;색인-할당-indexed-allocation&quot;&gt;색인 할당 (Indexed Allocation)&lt;/h2&gt;
&lt;p&gt;색인 할당 역시 연결 할당과 같이 데이터를 랜덤한 블록 번호에 할당하지만 할당된 블록 번호(포인터)를 하나의 블록에 따로 저장한다. 이러한 블록을 &lt;strong&gt;인덱스 블록&lt;/strong&gt; 이라고 부르며, 파일 당 하나의 인덱스 블록이 존재한다. 색인 할당은 디렉토리 정보가 다른 할당과 다른데, 시작 블록 번호를 저장하는 것이 아니라 &lt;strong&gt;인덱스 블록 번호를 저장한다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;예제
block size = 1 byte, f1 = 5 bytes, f2 = 2 bytes&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57186870-72ac2900-6f21-11e9-8b3b-531b44ea89ce.png&quot; alt=&quot;OS18-6&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;file name: f1
file size: 5 bytes
...
-----------------
index block number: 11
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;file name: f2
file size: 2 bytes
...
-----------------
index block number: 27
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;색인 할당은 인덱스 블록에 할당된 블록을 순서대로 저장하기 때문에 직접 접근이 가능하다. 그리고 연속적으로 할당할 필요가 없으므로 외부 단편화 문제 또한 발생하지 않는다. 색인 할당은 Unix/Linux에서 주로 사용한다.&lt;/p&gt;

&lt;p&gt;색인 할당의 단점은 작은 크기의 파일인 경우에도 하나의 블록을 인덱스 블록으로 사용하기 때문에 저장 공간이 손실된다. 그리고 &lt;strong&gt;하나의 인덱스 블록을 가지고는 크기가 큰 파일을 저장할 수 없다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;예를 들어, 하나의 블록 크기가 512 bytes인 블록은 최대 저장할 수 있는 블록 인덱스 개수는 512 / 4 bytes(포인터 크기) = 128개이다. 즉 파일의 최대 크기는 128 * 512bytes = 64KB로 아주 작은 크기이다. 블록 크기가 1KB이라 하더라도 최대 인덱스 개수는 256개(1000/4)이고 최대 파일의 크기는 256KB(256*1KB)이다.&lt;/p&gt;

&lt;p&gt;이를 해결하기 위한 여러 가지 방법이 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Linked: 이 방식은 인덱스 블록을 여러 개 만들어 연결 할당을 하는 것과 같다. 즉, 각 인덱스 블록의 마지막은 다음 인덱스 블록을 가리키는 포인터가 저장되어 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57186871-7344bf80-6f21-11e9-93a2-ded535b8b74b.png&quot; alt=&quot;OS18-7&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Multilevel index: 이 방식은 계층을 두는 방법으로 하나의 인덱스 블록의 &lt;strong&gt;모든 포인터&lt;/strong&gt; 가 다른 인덱스 블록을 가리킨다. 만약 이것으로 부족하면 계층을 더 만들어 간다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57186872-7344bf80-6f21-11e9-84ac-4fe150977f63.png&quot; alt=&quot;OS18-8&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Combined: 이 방식은 Linked와 Multilevel index를 합친 방법으로 한 인덱스 블록의 포인터들은 데이터 블록과 또 다른 인덱스 블록 둘 다 가리킬 수 있다.(리눅스는 combined 방식을 사용한다.)&lt;/li&gt;
&lt;/ul&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="Study_OperatingSystem" /><summary type="html">최신 업데이트 날짜: 2019-05-05</summary></entry><entry><title type="html">[운영체제] # 17 프레임 할당(Allocation of Frames)</title><link href="https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-17%EC%9E%A5-%ED%94%84%EB%A0%88%EC%9E%84-%ED%95%A0%EB%8B%B9/" rel="alternate" type="text/html" title="[운영체제] # 17 프레임 할당(Allocation of Frames)" /><published>2019-05-04T07:30:00+09:00</published><updated>2019-05-04T07:30:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-17%EC%9E%A5-%ED%94%84%EB%A0%88%EC%9E%84%20%ED%95%A0%EB%8B%B9</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-17%EC%9E%A5-%ED%94%84%EB%A0%88%EC%9E%84-%ED%95%A0%EB%8B%B9/">&lt;h1 id=&quot;global-vs-local-replacement&quot;&gt;Global VS Local Replacement&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Global Replacement: 메모리 상의 모든 프로세스 페이지에 대한 교체 작업을 수행한다.&lt;/li&gt;
  &lt;li&gt;Local Replacement: 메모리 상의 자기 자신의 프로세스 페이지에 대해서만 교체 작업을 수행한다.
메모리 사용 효율은 일반적으로 Global Replacement이 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;프레임-할당allocation-of-frames&quot;&gt;프레임 할당(Allocation of Frames)&lt;/h1&gt;
&lt;h2 id=&quot;쓰레싱thrashing&quot;&gt;쓰레싱(Thrashing)&lt;/h2&gt;
&lt;p&gt;일반적으로 메모리에 올라가는 프로세스 개수가 증가할수록 CPU의 이용률은 올라갈 것이라 예상한다. 왜냐하면 프로세스가 많을 수록 CPU의 할 일 역시 증가하기때문이다. 이는 일정 범위까지는 맞는 예상이지만, 그 &lt;strong&gt;범위를 넘어서면 오히려 CPU 이용률이 감소하는 현상&lt;/strong&gt; 이 나타난다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57186861-717afc00-6f21-11e9-8002-7b4130f361c2.png&quot; alt=&quot;OS17-1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 이러한 현상을 그래프로 나타낸 것이다. 이와 같은 현상이 발생하는 이유는 프로세스가 증가할수록 메인 메모리의 비어있는 프레임 개수는 줄어들게 되고 결국 모든 프레임이 가득 차게 된다. 그 후에도 계속 프로세스가 증가한다면 &lt;strong&gt;메모리와 backing store 사이에 page in/out 작업&lt;/strong&gt; 이 발생하는데, 프로세스가 많아질수록 이 작업 역시 증가한다. page in/out은 디스크 I/O 작업으로 CPU를 사용하지 않는 작업이다. 그러므로 이 작업이 많아질수록 CPU는 그동안 아무것도 하지 않게 된다.&lt;/p&gt;

&lt;p&gt;위 그래프에서도 나와있듯이, I/O 작업이 증가하여 CPU 이용률이 떨어지는 현상을 &lt;strong&gt;Thrashing&lt;/strong&gt; 이라 한다.&lt;/p&gt;

&lt;p&gt;쓰레싱을 해결하는 방법은 크게 두 가지가 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Global Replacement보다 Local Replacement를 사용하는 것이다. 하지만 이 경우에는 메모리 사용 효율이 떨어지는 단점이 있다.&lt;/li&gt;
  &lt;li&gt;프로세스당 &lt;strong&gt;충분한/적절한 수의 프레임(메모리)을 할당&lt;/strong&gt; 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그렇다면, 적절한 프레임의 수는 어떻게 정하는 것일까?&lt;/p&gt;

&lt;p&gt;프레임 할당은 크게 정적 할당과 동적 할당으로 나뉜다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;정적 할당(Static Allocation)
    &lt;ul&gt;
      &lt;li&gt;동일 할당(Equal Allocation): 모든 프로세스에게 똑같은 수의 프레임을 할당한다. 이 방식은 프로세스의 크기에 따라 매우 비효율적이다.&lt;/li&gt;
      &lt;li&gt;비례 할당(Proportional Allocation): 프로세스의 크기에 따라 프레임을 할당한다. 이 방식 역시 단점이 있다. 프로세스 크기가 크더라도 모든 기능을 사용하지 않기 때문에 이 방식 또한 비효율적이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이처럼 정적 할당은 한계가 뚜렷하다. 이를 해결하기 위한 방법은 &lt;strong&gt;실행 중에 프레임을 할당하는 동적 할당&lt;/strong&gt; 이다.&lt;/p&gt;

&lt;h2 id=&quot;동적-할당dynamic-allocation&quot;&gt;동적 할당(Dynamic Allocation)&lt;/h2&gt;
&lt;h3 id=&quot;working-set-model&quot;&gt;Working Set Model&lt;/h3&gt;
&lt;p&gt;프로세스가 실행 중일 때 어느 페이지를 사용하는지 실험한 결과에서 &lt;strong&gt;Locality&lt;/strong&gt; 성질이 성립한다는 것을 발견할 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57186862-717afc00-6f21-11e9-8bbb-794e7ac36f1e.png&quot; alt=&quot;OS17-2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그래프는 프로세스가 실행 중에 어떤 프로세스를 사용하는지 표시한 것으로, 특정 시간에는 일정 범위의 페이지를 주로 참조하는 것을 알 수 있다. 이러한 성질은 캐시에서도 볼 수 있다. 이를 통해 특정 시간에 따라 사용하는 페이지의 개수만큼 프레임을 할당해줄 수 있다.&lt;/p&gt;

&lt;p&gt;이 방법 역시 치명적인 단점이 있다. 바로 프로세스를 미리 수행해봐야 할 수 있다는 것이다. 그리고 프로세스를 수행할 때마다 사용하는 기능이 달라질 수 있으므로, Locality를 이용하는 방법은 비현실적이다.&lt;/p&gt;

&lt;p&gt;이를 해결하기 위해 나온 것이 &lt;strong&gt;working set&lt;/strong&gt; 이다. working set은 위의 locality의 방식과 유사한데, 미래가 아닌 과거를 보는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57186863-717afc00-6f21-11e9-8f9c-d580494fa04c.png&quot; alt=&quot;OS17-3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 working set을 사용하는 모습이다. working set은 &lt;strong&gt;현재 시간에서 일정 시간(△) 이전동안 사용되었던 페이지의 집합&lt;/strong&gt; 이다. △(델타)는 운영체제 내부에서 정하는 기준에 따라 다르며, 이를 &lt;strong&gt;working set window&lt;/strong&gt; 라 한다. 마지막으로 working set의 개수만큼 프레임을 할당한다.&lt;/p&gt;

&lt;p&gt;만약 현재 시간이 t1이라면 working set = {1, 2, 5, 6, 7}이다. 이 때 working set의 개수는 총 5개이므로 프레임 역시 5개를 할당해주면 된다.&lt;/p&gt;

&lt;h2 id=&quot;page-fault-frequencypff&quot;&gt;Page-Fault Frequency(PFF)&lt;/h2&gt;
&lt;p&gt;페이지 부재의 비율은 프로세스에 할당된 프레임의 수에 반비례한다. 즉, 할당된 프레임의 수가 적을수록 페이지 부재 비율은 늘어난다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57186864-717afc00-6f21-11e9-9c69-5f6e1a1e0f20.png&quot; alt=&quot;OS17-4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 이와 같은 현상을 그래프로 나타낸 것이다. 세로축은 페이지 부재 비율이고, 가로축은 할당된 프레임의 수이다. 여기서 운영체제 내부에서 해당 프로세스의 페이지 부재 횟수를 계속 검사한다. 그러면 위와 같은 그래프처럼 나오는데, 여기서 &lt;strong&gt;상한선(upper bound)과 하한선(lower bound)를 설정&lt;/strong&gt; 한다.&lt;/p&gt;

&lt;p&gt;만약 상한선보다 많은 페이지 부재가 발생하면 프레임을 더 많이 할당해주고, 하한선보다 적게 페이지 부재가 발생하면 할당된 프레임 개수를 줄여준다.&lt;/p&gt;

&lt;h1 id=&quot;페이지-크기&quot;&gt;페이지 크기&lt;/h1&gt;
&lt;p&gt;현재 페이지의 일반적인 크기는 &lt;strong&gt;4KB ~ 4MB&lt;/strong&gt; 이다. 이는 과거에서부터 점점 커져왔고, 현재에도 메모리 크기가 증가하면서 커지고 있다.&lt;/p&gt;

&lt;p&gt;페이지 크기에 따라 성능에는 어떤 영향을 미치는지 알아보자.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;내부단편화&lt;/strong&gt;: 내부단편화를 줄이려면 페이지 크기는 작은 것이 좋다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Page-in, page-out 시간&lt;/strong&gt;: 페이지의 in/out 시간을 결정하는 가장 큰 요인은 하드디스크 기준으로 하드디스크의 헤더가 움직이는 시간이다.(&lt;strong&gt;seek time&lt;/strong&gt;) 페이지 크기가 크면 클수록 한 번의 seek time마다 큰 페이지를 읽을 수 있으므로, 페이지 부재 빈도가 줄어든다.(데이터를 읽는 시간은 크기에 따라 차이가 매우 적다.)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;페이지 테이블 크기&lt;/strong&gt;: 페이지 크기가 클수록 페이지 개수가 줄어들기 때문에 그만큼 페이지 테이블 크기도 줄일 수 있다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Memory resolution(해상도)&lt;/strong&gt;: Memory resolution은 해당 메모리에 필요한 데이터가 있는 확률이다. 이는 페이지 크기가 작을수록 resolution을 높일 수 있다. 만약 페이지 크기가 크면 다른 필요없는 부분이 있을 확률이 크기 때문이다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Page fault 발생 확률&lt;/strong&gt;: Page fault 발생 확률을 줄이려면 페이지 크기가 큰 것이 좋다. 이는 locality 성질과도 관련이 있는데, 대부분 프로세스는 필요한 부분이 일정 범위 이내인 경우가 많으므로 페이지 크기가 클수록 필요한 부분이 있을 확률이 크다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;페이지-테이블&quot;&gt;페이지 테이블&lt;/h2&gt;
&lt;p&gt;반도체 기술의 발달로 TLB 역시 CPU의 내장 칩 형태로 만들어져있다.&lt;/p&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="Study_OperatingSystem" /><summary type="html">최신 업데이트 날짜: 2019-05-03</summary></entry><entry><title type="html">[운영체제] # 16 페이지 교체 알고리즘(Page Replacement Algorithm)</title><link href="https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-16%EC%9E%A5-%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/" rel="alternate" type="text/html" title="[운영체제] # 16 페이지 교체 알고리즘(Page Replacement Algorithm)" /><published>2019-05-04T05:30:00+09:00</published><updated>2019-05-04T05:30:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-16%EC%9E%A5-%ED%8E%98%EC%9D%B4%EC%A7%80%20%EA%B5%90%EC%B2%B4%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-16%EC%9E%A5-%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">&lt;p&gt;페이지 교체 알고리즘을 살펴보기 전에 &lt;strong&gt;Page reference string&lt;/strong&gt; 이라는 용어를 알아야 한다. CPU가 내는 주소는 이진수 단위이지만, 페이지 교체 알고리즘을 계산하기 위해서는 이진수 주소 단위가 아닌 페이지 단위로 계산해야한다.&lt;/p&gt;

&lt;p&gt;예를 들어, CPU가 내는 주소를 간단히 십진수로 표현하여 {100, 101, 102, 432, 612, 103, 104, 611, 612} 라고 하자. 만약 페이지 크기가 100bytes라면, 위 주소를 페이지 번호로 나타내면 {1, 1, 1, 4, 6, 1, 1, 6, 6} 이다. 주소 100번지는 1번 페이지에서 offset이 0인 위치이고, 101은 1번 페이지의 offset 1인 위치라고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;마지막으로 페이지 번호로 나타낸 것을 page reference string으로 나타내면 {1, 4, 6, 1, 6}이다. 이는 간단히 말하면 &lt;strong&gt;연속된 페이지는 생략하고 하나의 페이지 번호만&lt;/strong&gt; 나타낸 것으로 볼 수 있다. 이 이유는 연속된 페이지를 참조할 때는 한 번 page fault가 발생하면 같은 페이지를 사용하는 동안에는 절대 page fault가 발생할 수 없기 때문이다.&lt;/p&gt;

&lt;p&gt;정리하면, page size = 100bytes 일때&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CPU 주소              = {100, 101, 102, 432, 612, 103, 104, 611, 612}
Page 번호             = {1, 1, 1, 4, 6, 1, 1, 6, 6}
Page reference string = {1, 4, 6, 1, 6}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;first-in-first-outfifo&quot;&gt;First-In First-Out(FIFO)&lt;/h1&gt;
&lt;p&gt;FIFO은 가장 간단한 알고리즘이다. 가장 먼저 page-in 한 페이지를 먼저 page-out 시킨다. 이를 사용한 이유는 초기화 코드가 더 이상 사용되지 않을 것이라는 아이디어에서 시작되었다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;예제
페이지 참조열(page reference string): {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 7, 0, 1}
프레임 개수(number of frame): 3
조건은 위와 같고 최초의 메모리는 비어있는 상태이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;4&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;5&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;6&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;7&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;8&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;9&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;10&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;11&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;12&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;13&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;14&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;15&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;16&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;17&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;18&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;19&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;프레임 상태: {}&lt;/li&gt;
  &lt;li&gt;Page-in: 7 =&amp;gt; 프레임 상태: {7}        Page fault 수: 1                First Page: 7&lt;/li&gt;
  &lt;li&gt;Page-in: 0 =&amp;gt; 프레임 상태: {7, 0}     Page fault 수: 2                First Page: 7&lt;/li&gt;
  &lt;li&gt;Page-in: 1 =&amp;gt; 프레임 상태: {7, 0, 1}  Page fault 수: 3                First Page: 7&lt;/li&gt;
  &lt;li&gt;Page-in: 2 =&amp;gt; 프레임 상태: {2, 0, 1}  Page fault 수: 4   Page-out: 7  First Page: 0&lt;/li&gt;
  &lt;li&gt;Page-in: 0 =&amp;gt; 프레임 상태: {2, 0, 1}  Page fault 수: 4                First Page: 0&lt;/li&gt;
  &lt;li&gt;Page-in: 3 =&amp;gt; 프레임 상태: {2, 3, 1}  Page fault 수: 5   Page-out: 0  First Page: 1&lt;/li&gt;
  &lt;li&gt;Page-in: 0 =&amp;gt; 프레임 상태: {2, 3, 0}  Page fault 수: 6   Page-out: 1  First Page: 2&lt;/li&gt;
  &lt;li&gt;Page-in: 4 =&amp;gt; 프레임 상태: {4, 3, 0}  Page fault 수: 7   Page-out: 2  First Page: 3&lt;/li&gt;
  &lt;li&gt;Page-in: 2 =&amp;gt; 프레임 상태: {4, 2, 1}  Page fault 수: 8   Page-out: 3  First Page: 1&lt;/li&gt;
  &lt;li&gt;Page-in: 3 =&amp;gt; 프레임 상태: {4, 2, 3}  Page fault 수: 9   Page-out: 1  First Page: 4&lt;/li&gt;
  &lt;li&gt;Page-in: 0 =&amp;gt; 프레임 상태: {0, 2, 3}  Page fault 수: 10  Page-out: 4  First Page: 2&lt;/li&gt;
  &lt;li&gt;Page-in: 3 =&amp;gt; 프레임 상태: {0, 2, 3}  Page fault 수: 10               First Page: 2&lt;/li&gt;
  &lt;li&gt;Page-in: 2 =&amp;gt; 프레임 상태: {0, 2, 3}  Page fault 수: 10               First Page: 2&lt;/li&gt;
  &lt;li&gt;Page-in: 1 =&amp;gt; 프레임 상태: {0, 1, 3}  Page fault 수: 11  Page-out: 2  First Page: 3&lt;/li&gt;
  &lt;li&gt;Page-in: 2 =&amp;gt; 프레임 상태: {0, 1, 2}  Page fault 수: 12  Page-out: 3  First Page: 0&lt;/li&gt;
  &lt;li&gt;Page-in: 0 =&amp;gt; 프레임 상태: {0, 1, 2}  Page fault 수: 12               First Page: 0&lt;/li&gt;
  &lt;li&gt;Page-in: 7 =&amp;gt; 프레임 상태: {7, 1, 2}  Page fault 수: 13  Page-out: 0  First Page: 1&lt;/li&gt;
  &lt;li&gt;Page-in: 0 =&amp;gt; 프레임 상태: {7, 0, 2}  Page fault 수: 14  Page-out: 1  First Page: 2&lt;/li&gt;
  &lt;li&gt;Page-in: 1 =&amp;gt; 프레임 상태: {7, 0, 1}  Page fault 수: 15  Page-out: 2  First Page: 7&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;결과는 최종 page fault 수는 15이다. 예제를 수행하면서, 이전에 page-out한 페이지를 그 다음 바로 page-in을 하려한다면 다시 page fault가 발생하기 때문에 비효율적인 모습을 볼 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;beladys-anomaly&quot;&gt;Belady’s Anomaly&lt;/h2&gt;
&lt;p&gt;프레임 수가 증가하면(= 메모리 용량이 증가하면) page fault 수가 줄어드는 것이 정상적이지만, 특정한 페이지 참조열에 대해서는 프레임 수가 증가해도 page fault 수가 오히려 증가하는 이상 현상이 발생한다. 이를 Belady’s Anomaly라 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57186860-70e26580-6f21-11e9-8633-6012ad59eb3d.png&quot; alt=&quot;OS16-1&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;optimalopt&quot;&gt;Optimal(OPT)&lt;/h1&gt;
&lt;p&gt;OPT는 말그대로 가장 효율적인 페이지 교체 알고리즘이다. 이 알고리즘은 &lt;strong&gt;가장 오랫동안 사용되지 않을&lt;/strong&gt; 페이지를 희생양 페이지로 선택한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;예제
페이지 참조열(page reference string): {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 7, 0, 1}
프레임 개수(number of frame): 3
여기서 가장 오랫동안 사용되지 않을 페이지를 계산하기 위해 &lt;strong&gt;현재 시점 에서 그 이후에 최초로 나타나는 시점의 거리&lt;/strong&gt; 를 dist로 둔다. 이 값이 가장 큰 페이지가 가장 오랫동안 사용되지 않은 페이지로 정한다.(해당 페이지가 이후에 나오지 않는 경우는 INF로 가장 큰 값으로 한다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;4&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;5&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;6&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;7&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;8&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;9&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;10&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;11&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;12&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;13&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;14&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;15&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;16&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;17&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;18&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;19&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;프레임 상태: {}&lt;/li&gt;
  &lt;li&gt;Page-in: 7 =&amp;gt; 프레임 상태: {7}        Page fault 수: 1                dist: {15}&lt;/li&gt;
  &lt;li&gt;Page-in: 0 =&amp;gt; 프레임 상태: {7, 0}     Page fault 수: 2                dist: {14, 3}&lt;/li&gt;
  &lt;li&gt;Page-in: 1 =&amp;gt; 프레임 상태: {7, 0, 1}  Page fault 수: 3                dist: {13, 2, 11}&lt;/li&gt;
  &lt;li&gt;Page-in: 2 =&amp;gt; 프레임 상태: {2, 0, 1}  Page fault 수: 4   Page-out: 7  dist: {5, 1, 10}&lt;/li&gt;
  &lt;li&gt;Page-in: 0 =&amp;gt; 프레임 상태: {2, 0, 1}  Page fault 수: 4                dist: {4, 2, 9}&lt;/li&gt;
  &lt;li&gt;Page-in: 3 =&amp;gt; 프레임 상태: {2, 0, 3}  Page fault 수: 5   Page-out: 1  dist: {3, 1, 4}&lt;/li&gt;
  &lt;li&gt;Page-in: 0 =&amp;gt; 프레임 상태: {2, 0, 3}  Page fault 수: 5                dist: {2, 4, 3}&lt;/li&gt;
  &lt;li&gt;Page-in: 4 =&amp;gt; 프레임 상태: {2, 4, 3}  Page fault 수: 6   Page-out: 0  dist: {1, INF, 2}&lt;/li&gt;
  &lt;li&gt;Page-in: 2 =&amp;gt; 프레임 상태: {2, 4, 3}  Page fault 수: 6                dist: {4, INF, 1}&lt;/li&gt;
  &lt;li&gt;Page-in: 3 =&amp;gt; 프레임 상태: {2, 4, 3}  Page fault 수: 6                dist: {3, INF, 2}&lt;/li&gt;
  &lt;li&gt;Page-in: 0 =&amp;gt; 프레임 상태: {2, 0, 3}  Page fault 수: 7   Page-out: 4  dist: {2, 5, 1}&lt;/li&gt;
  &lt;li&gt;Page-in: 3 =&amp;gt; 프레임 상태: {2, 0, 3}  Page fault 수: 7                dist: {1, 4, INF}&lt;/li&gt;
  &lt;li&gt;Page-in: 2 =&amp;gt; 프레임 상태: {2, 0, 3}  Page fault 수: 7                dist: {2, 3, INF}&lt;/li&gt;
  &lt;li&gt;Page-in: 1 =&amp;gt; 프레임 상태: {2, 0, 1}  Page fault 수: 8   Page-out: 3  dist: {1, 2, 5}&lt;/li&gt;
  &lt;li&gt;Page-in: 2 =&amp;gt; 프레임 상태: {2, 0, 1}  Page fault 수: 8                dist: {INF, 1, 4}&lt;/li&gt;
  &lt;li&gt;Page-in: 0 =&amp;gt; 프레임 상태: {2, 0, 1}  Page fault 수: 8                dist: {INF, 2, 3}&lt;/li&gt;
  &lt;li&gt;Page-in: 7 =&amp;gt; 프레임 상태: {7, 0, 1}  Page fault 수: 9   Page-out: 2  dist: {INF, 1, 2}&lt;/li&gt;
  &lt;li&gt;Page-in: 0 =&amp;gt; 프레임 상태: {7, 0, 1}  Page fault 수: 9                dist: {INF, INF, 1}&lt;/li&gt;
  &lt;li&gt;Page-in: 1 =&amp;gt; 프레임 상태: {7, 0, 1}  Page fault 수: 9                dist: {INF, INF, INF}&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;OPT의 결과는 총 9번의 page fault가 발생했다. 이는 FIFO의 15번보다 크게 줄어든 모습을 볼 수 있다. 하지만 OPT의 방법은 &lt;strong&gt;현실적으로 불가능하다.&lt;/strong&gt; 실제 컴퓨터에서는 미래에 어떤 프로세스가 사용되는지 알 수 없다. 그러므로 어느 프로세스가 가장 오래 사용안되는 지를 계산할 수 없다.&lt;/p&gt;

&lt;h1 id=&quot;least-recently-usedlru&quot;&gt;Least-Recently-Used(LRU)&lt;/h1&gt;
&lt;p&gt;OPT는 최적해를 구할 수 있지만 미래를 알 수 없으므로 현실적으로 불가능한 방법이었는데, 최적의 해는 아니더라도 근사의 해를 구하기 위해서 LRU가 나왔다. LRU는 &lt;strong&gt;최근에 사용되지 않으면 나중에도 사용되지 않을 것&lt;/strong&gt; 이라는 개념으로 과거의 페이지 기록을 통해 희생양 페이지를 선태한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;예제&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;LRU는 근사 해를 구하므로 OPT보다는 page fault가 많이 발생하지만, FIFO보다는 일반적으로 적게 일어난다. 그러므로 현재 대부분 환경에서는 LRU를 사용하고 있다.&lt;/p&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="Study_OperatingSystem" /><summary type="html">최신 업데이트 날짜: 2019-05-03</summary></entry><entry><title type="html">[운영체제] # 15 가상메모리(Virtual Memory)</title><link href="https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-15%EC%9E%A5-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC/" rel="alternate" type="text/html" title="[운영체제] # 15 가상메모리(Virtual Memory)" /><published>2019-05-04T00:30:00+09:00</published><updated>2019-05-04T00:30:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-15%EC%9E%A5-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-15%EC%9E%A5-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC/">&lt;p&gt;가상 메모리는 물리 메모리 크기의 한계를 극복하기 위해 나온 기술이다. 즉, 물리 메모리보다 큰 프로세스를 수행하기 위해 가상 메모리를 사용한다. 예를 들어, 100MB 메모리 크기에서 200MB 크기의 프로세스를 수행할 수 있도록 하는 것이다.&lt;/p&gt;

&lt;p&gt;이러한 방식이 어떻게 가능할까? 앞서 메모리 낭비 방지의 동적 할당에서도 봤듯이, &lt;strong&gt;필요한 부분만&lt;/strong&gt; 메모리에 적재하는 것이다. 프로세스를 실행할 때, 실행에 필요한 부분만 메모리에 올리는 것이다. 이러한 프로세스의 일부분은 페이지 단위일 수도 있고, 세그먼트 단위일 수도 있지만 현재 대부분은 페이지 단위를 사용한다. 이처럼 현재 필요한(요구되어지는) 페이지만 메모리에 올리는 것을 &lt;strong&gt;Demanding Paging(요구 페이징)&lt;/strong&gt; 이라고 한다.&lt;/p&gt;

&lt;h1 id=&quot;demanding-paging&quot;&gt;Demanding Paging&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57119450-47043400-6da5-11e9-8810-c6a981a1d689.png&quot; alt=&quot;OS15-1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 요구 페이징의 모습이다. 두 프로세스 P1, P2는 각각 필요한 페이지만 메모리에 할당하였다. 여기서 위 그림의 테이블은 P1이 수행 중일 때의 페이지 테이블이다. 기존의 페이지 테이블과 다른 점은 &lt;strong&gt;valid bit&lt;/strong&gt; 가 추가된 모습이다. 이는 현재 메모리에 페이지가 있는지 없는지를 나타내는 비트이다. 현재 페이지가 메모리에 있다면 1, 없다면 0값을 갖는다.&lt;/p&gt;

&lt;p&gt;만약, CPU에서 P1의 3번째 페이지에 접근하는데, valid bit값이 0이다. 그러면 &lt;strong&gt;CPU에 인터럽트 신호를 발생하여 운영체제 내부의 ISR로 점프&lt;/strong&gt; 한다. 여기서 디스크 내부의 프로세스 P1에 있는 2번째 페이지를 메모리에 할당하는 작업을 처리한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57119451-47043400-6da5-11e9-9ca3-d0b250683bf0.png&quot; alt=&quot;OS15-2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 P1의 3번째 페이지를 메모리에 올린 후 모습이다.&lt;/p&gt;

&lt;p&gt;가상 메모리를 만드는 방법은 대표적으로 두 가지가 존재하지만, 대부분 &lt;strong&gt;요구 페이징을 사용&lt;/strong&gt; 하므로 가상 메모리와 요구 페이징을 같은 용어로 사용하는 경우가 많다.&lt;/p&gt;

&lt;h2 id=&quot;page-fault페이지-부재&quot;&gt;Page Fault(페이지 부재)&lt;/h2&gt;
&lt;p&gt;페이지 부재는 위에서 살펴본 &lt;strong&gt;CPU가 접근하려는 페이지가 메모리에 없는 경우&lt;/strong&gt; 이다. 즉, 페이지 테이블의 valid bit값이 0인 경우이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57119452-479cca80-6da5-11e9-9c9e-50c3a3e74f53.png&quot; alt=&quot;OS15-3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 page fault가 발생했을 때 처리하는 과정을 나타낸 것이다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;해당 페이지가 메모리에 있는지 valid bit를 확인한다.&lt;/li&gt;
  &lt;li&gt;valid bit가 0이라면 CPU에 인터럽트 신호를 보내어 운영체제 내부 해당 ISR로 점프한다.&lt;/li&gt;
  &lt;li&gt;해당 ISR에서 backing store(디스크)를 탐색하여 해당 프로세스의 페이지를 찾는다.&lt;/li&gt;
  &lt;li&gt;해당 페이지를 비어있는 프레임에 할당한다.&lt;/li&gt;
  &lt;li&gt;페이지 테이블을 갱신한다.(프레임 번호 설정, valid bit 1로 변경)&lt;/li&gt;
  &lt;li&gt;다시 명령어로 돌아가서 실행한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;pure-demanding-paging&quot;&gt;Pure Demanding Paging&lt;/h3&gt;
&lt;p&gt;Pure Demanding Paging은 &lt;strong&gt;프로세스가 최초로 실행될 때는 어떤 페이지가 필요한지 알 수 없으므로, 아무 페이지도 올리지 않는다.&lt;/strong&gt; 그러므로 프로그램을 실행하자마자 page fault가 발생한다. 즉, 순수하게 필요한 페이지만 올리는 것을 말한다. Pure Demanding Paging의 장점은 메모리를 최대한 효율적으로 사용할 수 있다. 하지만 시작부터 page fault가 발생하므로 속도면에서 느리다.&lt;/p&gt;

&lt;h3 id=&quot;prepaging&quot;&gt;Prepaging&lt;/h3&gt;
&lt;p&gt;Prepaging은 pure demanding paging과 반대대는 개념이다. 프로그램을 실행할 때 &lt;strong&gt;필요할 것이라 판단되는 페이지를 미리 올리는 것&lt;/strong&gt; 이다. 이것의 장점은 page fault가 발생할 확률이 적으므로 속도면에서 빠르지만, 단점으로 미리 올라간 페이지를 사용하지 않는다면 메모리가 낭비된다.&lt;/p&gt;

&lt;h3 id=&quot;swapping-vs-demanding-paging&quot;&gt;Swapping VS Demanding Paging&lt;/h3&gt;
&lt;p&gt;Swapping와 Demanding Paging의 공통점은 둘 다 메모리와 backing store 사이를 서로 오고 가는 기능을 수행하지만, &lt;strong&gt;Swapping은 프로세스 단위&lt;/strong&gt; 로 이동하고 &lt;strong&gt;Demanding Paging은 페이지 단위&lt;/strong&gt; 로 이동하는 차이점이 있다.&lt;/p&gt;

&lt;h3 id=&quot;유효-접근-시간effective-access-time&quot;&gt;유효 접근 시간(Effective Access Time)&lt;/h3&gt;
&lt;p&gt;Demending Paing은 페이지 테이블에 해당 페이지가 없으면 backing store에서 메모리로 가져오는 과정이 있으므로, 페이지 테이블에 해당 페이지가 있을 때와 없을 때 시간 차이가 발생한다. 이러한 시간 차이를 고려하여 평균적으로 어느정도 소요되는지 계산하는 것을 유효 접근 시간이라 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;p: 페이지 부재 확률(probability of a page fault = page fault rate)&lt;/li&gt;
  &lt;li&gt;Tm: 메모리를 읽는 시간&lt;/li&gt;
  &lt;li&gt;Tp: Page fault가 발생했을 때 소요되는 시간(대부분 backing store(하드디스크)를 읽는 시간이 차지한다.)&lt;/li&gt;
  &lt;li&gt;T = (1-p)Tm + pTp&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예제를 살펴보자.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Tm = 200nsec (DRAM)&lt;/li&gt;
  &lt;li&gt;Tp = 8msec (seek time + rotational delay + transfer time)&lt;/li&gt;
  &lt;li&gt;T = (1-p) * 200 + p * 8,000,000 = 200 + 7,999,800 * p&lt;/li&gt;
  &lt;li&gt;p = 1/1,000 =&amp;gt; T = 8.2usec (40배 정도 느림)&lt;/li&gt;
  &lt;li&gt;p = 1/399,990 =&amp;gt; T = 220nsec (10% 정도 느림)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 예제를 보았을 때, page fault는 매우 적은 확률로 발생해야 효율적이다. 그러면 현실적으로 페이지 부재는 어느정도로 발생할까? 이는 &lt;strong&gt;지역성의 원리(Locality of reference)&lt;/strong&gt; 로 인해 페이지 부재 확률은 매우 낮다. 지역성의 원리는 &lt;strong&gt;메모리 접근은 시간적 지역성과 공간적 지역성을 가진다&lt;/strong&gt; 는 의미이다.&lt;/p&gt;

&lt;p&gt;시간적 지역성은 CPU는 어느 메모리 공간을 읽은 후, 시간이 지나도 그 공간을 다시 읽을 확률이 매우 높다는 것을 말한다. 공간적 지역성은 CPU가 메모리 공간을 읽을 때는 인접한 범위 내에서 읽는다는 의미이다. 시간적 지역성의 대표적인 예는 반복문이다. 반복문은 하나의 코드 공간을 여러 번 읽는다. 공간적 지역성은 프로그램은 대부분 절차적으로 구현되어 있으므로 순서대로 읽는 경우가 빈번한다.&lt;/p&gt;

&lt;p&gt;이와 같이 페이지 부재가 현실적으로 발생할 확률은 매우 낮으므로 예제와 같이 40배로 느려지는 일을 거의 없다. 여기서 더 효율적으로 사용하기 위해서는 페이지 부재일 때 소요되는 시간을 줄일 수 있는데, backing store로 HDD를 사용하기 보다는 더욱 빠르게 동작하는 SSD나 저가 DRAM과 같은 것을 사용하는 방법이 있다.&lt;/p&gt;

&lt;h2 id=&quot;페이지-교체page-replacement&quot;&gt;페이지 교체(Page Replacement)&lt;/h2&gt;
&lt;p&gt;Demanding Paging은 요구되어지는 페이지만 backing store에서 가져온다. 하지만 프로그램들이 계속 실행함에 따라 요구 페이지도 계속 늘어나고, 언젠가는 메모리가 가득 차게 될 것이다.(memory full) 여기서 다른 프로그램이 새로 실행되거나 실행중인 프로세스가 다른 페이지를 요구한다면 &lt;strong&gt;이미 메모리에 있는 페이지 중 하나를 다시 backing store에 보내고(page-out), 새로운 페이지를 메모리에 올려야한다.(page-in)&lt;/strong&gt; 이를 페이지 교체라고 한다. 여기서 backing store로 page-out이 된 페이지를 &lt;strong&gt;victim page&lt;/strong&gt; 라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;victim-page희생양-페이지&quot;&gt;Victim Page(희생양 페이지)&lt;/h3&gt;
&lt;p&gt;희생양 페이지는 어떤 페이지로 하는 것이 좋을까? 먼저 생각할 수 있는 것은 메모리에 올라가 있는 페이지 중 &lt;strong&gt;CPU에 수정(modify)되지 않는 페이지&lt;/strong&gt; 를 고르는 것이 효율적으로 보인다. 수정되지 않은 페이지는 page-out이 될 때 backing store에 쓰기(write) 연산을 할 필요가 없기 때문이다. backing store는 읽는 시간도 느리지만, 거기에 더해 쓰기 작업까지 한다면 더욱 비효율적일 것이다.&lt;/p&gt;

&lt;p&gt;그러면 해당 페이지가 수정되었는지 안되었는지를 판단할 수 있어야 하는데, 이를 위해 페이지 테이블에 &lt;strong&gt;modified bit(=dirty bit)&lt;/strong&gt; 를 추가하여 이를 검사한다. 해당 페이지가 수정되었다면 이 비트를 1로 두고, 수정되지 않으면 0으로 둔다. 이를 이용해서 victim page는 최대한 수정되지 않은 페이지를 선택한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57119453-479cca80-6da5-11e9-83e7-cd46f595422d.png&quot; alt=&quot;OS15-4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 modified bit를 추가한 페이지 테이블의 모습이다. 여기서 수정되지 않은 페이지는 0, 2, 3번 3개의 페이지가 존재하는데 이 중에서는 어떤 페이지를 선택해야 할까?&lt;/p&gt;

&lt;p&gt;제일 간단한 방법은 랜덤하게 선택하는 것이지만, 이는 성능을 보장할 수 없다. 그 다음은 가장 먼저 메모리에 올라온 페이지를 희생양 페이지로 선택하는 것이다. 이는 아주 유명한 FIFO(First-In First-Out) 방식이다. 이 외에도 여러가지 방법이 존재한다.&lt;/p&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="Study_OperatingSystem" /><summary type="html">최신 업데이트 날짜: 2019-05-03</summary></entry><entry><title type="html">[운영체제] # 14 세그먼테이션(Segmentation)</title><link href="https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-14%EC%9E%A5-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98/" rel="alternate" type="text/html" title="[운영체제] # 14 세그먼테이션(Segmentation)" /><published>2019-05-03T21:30:00+09:00</published><updated>2019-05-03T21:30:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-14%EC%9E%A5-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-14%EC%9E%A5-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98/">&lt;p&gt;지금까지 살펴본 페이징은 프로세스를 물리적으로 일정한 크기로 나눠서 메모리에 할당하였다. 반면에 세그먼테이션은 프로세스를 &lt;strong&gt;논리적 내용을 기반&lt;/strong&gt; 으로 나눠서 메모리에 배치하는 것을 말한다.&lt;/p&gt;

&lt;p&gt;세그먼테이션은 프로세스를 세그먼트(segment)의 집합으로 만들고, 각 세그먼트의 크기는 일반적으로 같지 않다. 프로세스를 code + data + stack 으로 나누는 것 역시 세그먼테이션의 모습이다. 물론 code, data, stack 각각 내부에서 더 작은 세그먼트로 나눌 수도 있다.&lt;/p&gt;

&lt;p&gt;세그먼트를 메모리에 할당할 때는 페이지를 할당하는 것과 동일하다. 하지만 테이블은 조금 다른데, 세그먼테이션을 위한 테이블은 &lt;strong&gt;세그먼트 테이블&lt;/strong&gt; 이라고한다. 그리고 세그먼트 테이블은 세그먼트 번호와 시작 주소(base), 세그먼트 크기(limit)를 엔트리로 갖는다.&lt;/p&gt;

&lt;p&gt;세그먼트에서 주소변환 역시, 페이징과 유사하다. 한 가지 주의할 점은 세그먼트의 크기는 일정하지 않기 때문에, 테이블에 &lt;strong&gt;limit&lt;/strong&gt; 정보가 주어진다. 그리고 CPU에서 해당 세그먼트의 크기를 넘어서는 주소가 들어오면 인터럽트가 발생해서 해당 프로세스를 강제로 종료시킨다. 그러면 세그먼트 주소변환 예제를 하나 살펴보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57119448-47043400-6da5-11e9-95da-91cb808de992.png&quot; alt=&quot;OS14-1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 세그먼트 테이블과 프로세스가 할당된 메모리의 모습이다. 페이징 주소변환과 동일하게 d는 논리주소와 물리주소가 동일하다. 물리주소 a는 &lt;strong&gt;base[s] + d&lt;/strong&gt; 로 계산된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;논리주소 (2, 100) =&amp;gt; 물리주소 4400번지&lt;/li&gt;
  &lt;li&gt;논리주소 (1, 500) =&amp;gt; 인터럽트로 인해 프로세스 강제 종료(범위를 벗어남)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;세그먼테이션에서-보호와-공유&quot;&gt;세그먼테이션에서 보호와 공유&lt;/h1&gt;
&lt;p&gt;먼저, 결론부터 말하면 페이징보다 세그먼테이션에서의 보호와 공유는 더 효율적이다.&lt;/p&gt;

&lt;p&gt;보호에서는 세그먼테이션 역시 r, w, x 비트를 테이블에 추가하는데, 세그먼테이션은 논리적으로 나누기 때문에 해당 비트를 설정하기 매우 간단하고 안전하다. 페이징은 code + data + stack 영역이 있을 때 이를 일정한 크기로 나누므로 두 가지 영역이 섞일 수가 있다. 그러면 비트를 설정하기가 매우 까다롭다.&lt;/p&gt;

&lt;p&gt;공유에서도 마찬가지다. 페이징에서는 code 영역을 나눈다해도 다른 영역이 포함될 확률이 매우 높다. 하지만 세그먼테이션은 정확히 code 영역만 나누기 때문에 더 효율적으로 공유를 수행할 수 있다.&lt;/p&gt;

&lt;h1 id=&quot;세그먼테이션과-페이징&quot;&gt;세그먼테이션과 페이징&lt;/h1&gt;
&lt;p&gt;세그먼테이션은 페이징과 유사하고 보호와 공유에서는 더 나은 성능을 보여주었지만, 현재 &lt;strong&gt;대부분은 페이징 기법을 사용한다.&lt;/strong&gt; 그 이유는 세그먼테이션에는 치명적인 단점이 있기 때문이다.&lt;/p&gt;

&lt;p&gt;메모리 할당을 처음 시작할 때 다중 프로그래밍에서의 문제는 크기가 서로 다른 프로세스로 인해 여러 크기의 hole이 발생한다. 이로 인해 어느 hole에 프로세스를 할당하는 것에 대한 최적화 알고리즘이 존재하지 않고, 외부 단편화로 인해 메모리 낭비가 크다고 했었다.&lt;/p&gt;

&lt;p&gt;세그먼테이션도 똑같은 문제점이 발생한다. 왜냐하면 세그먼테이션은 논리적인 단위로 나누기 때문에 세그먼트의 &lt;strong&gt;크기가 다양하다.&lt;/strong&gt; 이로 인해 다양한 크기의 hole이 발생하므로 같은 문제가 발생한다.&lt;/p&gt;

&lt;p&gt;결론적으로 세그먼테이션은 보호와 공유에서 효율적이고, 페이징은 외부 단편화 문제를 해결할 수 있다. 그러므로 두 가지를 합쳐서 사용하는 방법이 나왔다. 두 장점을 합치기 위해서는 &lt;strong&gt;세그먼트를 페이징 기법으로 나누는 것이다.(Paged segmentation)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;하지만 이 역시 단점이 존재한다. 세그먼트와 페이지가 동시에 존재하기 때문에 주소 변환도 두 번해야한다. 즉 CPU에서 세그먼트 테이블에서 주소 변환을 하고, 그 다음 페이지 테이블에서 또 주소 변환을 해야한다.&lt;/p&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="Study_OperatingSystem" /><summary type="html">최신 업데이트 날짜: 2019-05-03</summary></entry><entry><title type="html">다익스트라(Dijkstra) 알고리즘</title><link href="https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/" rel="alternate" type="text/html" title="다익스트라(Dijkstra) 알고리즘" /><published>2019-05-03T21:06:00+09:00</published><updated>2019-05-03T21:06:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">&lt;p&gt;다익스트라 알고리즘은 &lt;strong&gt;단일 시작점 최단 경로 알고리즘&lt;/strong&gt; 으로, 시작 정점 s에서부터 다른 정점들까지의 최단 거리를 계산한다. 하지만 이 알고리즘은 음수 간선이 있는 그래프(특히, 음수 사이클)에 대해서는 최단거리를 계산하지 못한다. 만약 음수 간선이 사이클을 이루지 않는다면, 계산을 할 수 있는 경우가 있지만 시간복잡도는 지수적으로 증가한다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;이에 대한 부분은 https://www.acmicpc.net/board/view/19865 이 링크에서 자세하게 토론을 하고 있다. 한 번 읽어보면 좋을 듯 하다.&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;기본적인-다익스트라-알고리즘&quot;&gt;기본적인 다익스트라 알고리즘&lt;/h2&gt;
&lt;p&gt;다익스트라 알고리즘은 너비 우선 탐색(BFS)처럼 시작점에서 가까운 순서대로 정점을 방문한다. BFS와 다른 점은 가중치가 있는 그래프에 적용하며, BFS로는 아래와 같은 그래프에서 최단 거리를 찾을 수 없다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57118124-297e9c80-6d9c-11e9-90c4-21ebb461c96d.JPG&quot; alt=&quot;dijkstra1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그래프에서 최단 경로는 &lt;strong&gt;s-a-b-c&lt;/strong&gt; 이다. 하지만 BFS를 사용하면 시작점과 인접한 정점을 방문하므로 b정점을 통한 최단 경로를 계산할 수 없다. 이러한 경우 다익스트라 알고리즘을 사용할 수 있다. 그러면 기본적으로 다익스트라 알고리즘이 어떻게 동작하는지 예제를 통해 살펴보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/57118125-2a173300-6d9c-11e9-9fd2-dccf0a61fdd3.JPG&quot; alt=&quot;dijkstra2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그래프에서 시작점은 1번 정점으로 하여 모든 정점에 대해서 최단 거리를 구해보자. 다익스트라 알고리즘은 위에서 말했듯이 BFS와 같이 인접한 정점에서 가장 가까운 정점을 선택한다. 그리고 그 정점 중 최단 거리를 갱신해나아간다. 그러기 위해 시작점을 제외한 아직 방문하지 않은 정점은 &lt;strong&gt;가장 큰 수(INF)&lt;/strong&gt; 로 초기화 한다. 따라서 초기 모습은 다음과 같다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;횟수/정점&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;4&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;5&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;6&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;표에서 확정된 정점의 최단 거리는 &lt;strong&gt;진한 검정색&lt;/strong&gt; 으로 표시한다. 그리고 인접한 정점까지의 거리와 현재 표의 거리 중 &lt;strong&gt;더 짧은 거리로 갱신한다.&lt;/strong&gt; 그 다음 확정되지 않은 정점 중 가장 짧은 정점으로 이동한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1번 정점과 인접한 정점 (정점, 거리)
    &lt;ul&gt;
      &lt;li&gt;(2, 0 + 7),   &lt;code class=&quot;highlighter-rouge&quot;&gt;min(INF, 7) = 7&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;(3, 0 + 9),   &lt;code class=&quot;highlighter-rouge&quot;&gt;min(INF, 9) = 9&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;(6, 0 + 14),  &lt;code class=&quot;highlighter-rouge&quot;&gt;min(INF, 14) = 14&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1번 정점과 인접한 정점까지 거리를 계산하여 표와 비교한 후 더 짧은 거리로 갱신한다. 그 다음 &lt;strong&gt;확정되지 않은 정점 중 가장 짧은 거리를 가진 정점으로 이동한다.&lt;/strong&gt; 선택된 정점은 시작점과 최단 거리임을 확정하고 그 정점에서 위와 같이 인접한 정점과 거리 계산 과정을 반복한다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;횟수/정점&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;4&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;5&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;6&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;14&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;2번 정점과 인접한 정점
    &lt;ul&gt;
      &lt;li&gt;(3, 7 + 10),   &lt;code class=&quot;highlighter-rouge&quot;&gt;min(9, 17) = 9&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;(4, 7 + 15),   &lt;code class=&quot;highlighter-rouge&quot;&gt;min(INF, 22) = 22&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;횟수/정점&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;4&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;5&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;6&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;14&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;9&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;22&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;14&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그 결과, 최단 거리로 확정되지 않은 정점 중 3번 정점이 가장 짧으므로 이를 확정시키고 3번 정점과 인접한 정점을 계산한다. 이와 같은 계산 과정을 모든 정점이 최단 거리로 확정될 때까지 반복한다. 모든 결과를 표로 나타내면 다음과 같다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;횟수/정점&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;4&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;5&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;6&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;14&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;9&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;22&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;14&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;9&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;20&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;INF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;11&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;9&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;20&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;20&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;11&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;9&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;20&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;20&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;11&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;하지만 이 방법은 확정되지 않은 정점 중 가장 짧은 거리의 정점을 찾기 위해 시간복잡도 O(N)으로 순차적으로 탐색한다. 이를 최적화하기 위해 &lt;strong&gt;우선 순위 큐&lt;/strong&gt; 를 사용하여 가장 짧은 거리의 정점을 시간복잡도 O(logN) 으로 찾을 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;우선-순위-큐를-이용한-다익스트라-알고리즘&quot;&gt;우선 순위 큐를 이용한 다익스트라 알고리즘&lt;/h2&gt;
&lt;p&gt;우선 순위 큐를 사용하더라도 알고리즘 로직은 바뀌지 않는다. 다만, 확정할 정점을 찾는데 소요되는 시간을 O(N)에서 O(logN)으로 줄인 것이다. 그러면 이를 구현한 코드를 살펴보자.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//정점의 개수
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//그래프의 인접 리스트 (연결된 정점 번호, 간선 가중치) 쌍을 담는다.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pair&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX_V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//다익스트라, 최단 거리 배열을 반환한다.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dijkstra&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//INF: 매우 큰 값
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;dist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//(해당 정점까지 최단 거리, 해당 정점)쌍
&lt;/span&gt;  	&lt;span class=&quot;c1&quot;&gt;//STL내부에서 pair의 첫번째 원소부터 크기 비교를 하기 때문에, 거리값을 첫 원소로 해야 한다.
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;priority_queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pair&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;pq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;make_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;here&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cost&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;pq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;//만약 지금 꺼낸 것보다 더 짧은 경로를 알고 있다면 지금 꺼낸 것을 무시한다.
&lt;/span&gt;		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;here&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cost&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;//인접한 정점들을 모두 검사한다.
&lt;/span&gt;		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;here&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;there&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;here&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextDist&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cost&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;here&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;//더 짧은 경로를 발견하면, dist[]를 갱신하고 우선순위 큐에 넣는다.
&lt;/span&gt;			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;there&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextDist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;dist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;there&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextDist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;pq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;make_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextDist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;there&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;코드를 살펴보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;dist[]&lt;/code&gt;은 매개변수로 전달받은 시작점 &lt;code class=&quot;highlighter-rouge&quot;&gt;src&lt;/code&gt; 정점에서 모든 정점까지 최단 거리를 저장한 배열이다. 그리고 구현의 편의성을 위해 몇가지 사용한 방법이 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;C++ STL pair는 첫 번째 원소를 비교하므로 (거리, 정점) 쌍으로 저장한다.&lt;/li&gt;
  &lt;li&gt;C++ STL 우선순위 큐는 기본적으로 내림차순이므로 거리의 부호를 바꾸는 것으로 간단하게 사용할 수 있다.&lt;/li&gt;
  &lt;li&gt;중복된 정점의 계산을 피하기 위해 현재 거리보다 긴 경우는 모두 무시한다.(따라서, 저장할 때 정점 중복 검사는 하지 않아도 된다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;시간복잡도&quot;&gt;시간복잡도&lt;/h3&gt;
&lt;p&gt;간선의 개수를 E라고 할 때, 각 정점마다 인접한 간선들을 모두 검사하는 작업은 O(E) 이고, 우선 순위 큐에 추가 및 삭제하는 연산은 O(logE)이다. 따라서 전체 시간복잡도는 &lt;strong&gt;O(ElogE)&lt;/strong&gt; 이다. 여기서 대부분의 그래프에서 &lt;strong&gt;간선의 개수는 정점의 개수(V) 제곱보다 작으므로&lt;/strong&gt; 최대 원소의 개수가 전체 간선의 수가 아닌 전체 정점의 수로 볼 수 있다. 따라서, 시간복잡도를 &lt;strong&gt;O(ElogV)&lt;/strong&gt; 로 계산할 수도 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;O(VlogV) 다익스트라 알고리즘&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;중복 원소를 우선순위 큐에 넣지 않도록 수정하면 시간복잡도는 O(VlogV)로 만들 수 있다. 이를 위해 피보나치 힙이나 이진 검색 트리를 사용해서 우선 순위 큐를 구현하면 중복 원소를 제거할 수 있지만, 구현이 복잡하고 실제로 시간이 더 오래 걸리는 경우가 많다.&lt;/p&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="Algorithm_Algorithm" /><summary type="html">최신 업데이트 날짜: 2019-05-03</summary></entry><entry><title type="html">LIS(Longest Increasing Subsequence) 알고리즘</title><link href="https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-LIS%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/" rel="alternate" type="text/html" title="LIS(Longest Increasing Subsequence) 알고리즘" /><published>2019-05-01T00:45:00+09:00</published><updated>2019-05-01T00:45:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-LIS%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-LIS%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">&lt;p&gt;LIS 알고리즘은 &lt;strong&gt;가장 긴 증가하는(최장증가) 부분 수열&lt;/strong&gt; 이다. 아래의 그림 처럼 부분 수열이므로 연속적이지 않아도 된다. (2번 째 배열의 노란색 박스가 LIS이다.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/46916274-410a5980-cff3-11e8-948a-31488df44de1.JPG&quot; alt=&quot;lis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;LIS 알고리즘을 해결하는 방법은 시간복잡도가 O(N^2)과 O(NlogN) 두 가지 방법이 대표적이다.&lt;/p&gt;

&lt;h2 id=&quot;해결-방법1-동적-계획법&quot;&gt;해결 방법1: 동적 계획법&lt;/h2&gt;
&lt;p&gt;동적 계획법을 이용한 해결 방법은 시간복잡도 O(N^2)에 속한다. 동적 계획법에서도 Bottom-up 방식과 Top-down 방식 두 가지 모두 알아보자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DP[i] = i 번째 위치일 때, 최장 증가 부분 수열의 개수 (cache 배열도 동일)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;bottom-up&quot;&gt;Bottom-up&lt;/h3&gt;
&lt;p&gt;Bottom-up은 반복문을 사용하는 동적 계획법이다. 현재 위치 이전의 값들을 차례대로 순회하면서 현재 위치에서 최장증가 부분 수열의 개수를 갱신한다. 이는 말보다 코드로 이해하는 것이 쉽다.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// num[]: 숫자 배열
// n: num 배열의 크기
// lis: 가장 긴 증가하는 부분 수열의 개수 (0으로 초기화)
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 0 ~ i - 1 위치까지 반복
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 1) 현재 위치의 값보다 작고,
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 2) 최장증가부분 수열 개수가 1개 증가했을 때, 현재 가지고 있는 수열 개수보다 크다면
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;lis&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lis&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;top-down&quot;&gt;Top-down&lt;/h3&gt;
&lt;p&gt;Top-down은 재귀를 사용한 메모이제이션 방식이다. 이 방식은 대부분 완전탐색에서 최적화한 모습이므로 완전탬색 코드와 유사한 로직을 가진다. 여기서는 전체 배열을 탐색하는 구현을 간단히 하기 위해 &lt;strong&gt;-1&lt;/strong&gt; 부터 시작한다.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// cache[]: -1으로 초기화
// 가장 긴 증가하는 부분 수열의 개수 반환(start 초기값은 -1)
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Memoization&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;candidate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Memoization&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;candidate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;candidate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;해결-방법2-이분-탐색&quot;&gt;해결 방법2: 이분 탐색&lt;/h2&gt;
&lt;p&gt;LIS는 이분 탐색을 사용하여 시간복잡도 O(NlogN)으로 해결할 수 있다. 이는 &lt;strong&gt;lower_bound&lt;/strong&gt; 를 사용하는 것으로, lower_bound는 찾으려는 값과 같으면 그 위치를 반환하고 없다면 이 값보다 큰 수 중 가장 작은 값의 위치를 반환한다. 이는 이분 탐색으로 찾기 때문에 O(logN)의 시간복잡도는 가지고 있다. 그러면 예제를 살펴보자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;10, 20, 10, 30, 20, 50
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 예제에서 처음 위치부터 끝까지 순회하면서 해당 숫자의 위치를 vector에 저장한다. 이를 계산한 표를 살펴보자.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;i/num[]&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;10&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;20&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;10&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;30&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;20&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;50&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;20&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;20&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;20&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;30&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;20&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;30&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;20&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;30&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;50&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;i = 0: 처음 위치는 바로 vector에 삽입한다.&lt;/li&gt;
  &lt;li&gt;i = 1: 숫자 20은 vector안에 존재하는 10보다 크므로 그 뒤에 삽입한다.&lt;/li&gt;
  &lt;li&gt;i = 2: 숫자 10은 vector안에 이미 존재하므로 이를 대체한다.(무시하는 것과 같다.)&lt;/li&gt;
  &lt;li&gt;i = 3: 숫자 30은 vector안에 존재하는 마지막 숫자 20보다 크므로 그 뒤에 삽입한다.&lt;/li&gt;
  &lt;li&gt;i = 4: 숫자 20은 vector안에 이미 존재하므로 이를 대체한다.&lt;/li&gt;
  &lt;li&gt;i = 5: 숫자 50은 vector안에 존재하는 마지막 숫자 30보다 크므로 그 뒤에 삽입한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위처럼 배열 크기만큼 순회하면서 그 때마다 해당 숫자의 위치를 lower_bound로 탐색하므로 시간복잡도 O(NlogN)을 보장한다.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;lis&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lower_bound&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lis&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lis&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lis&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;lis&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="Algorithm_Algorithm" /><summary type="html">최신 업데이트 날짜: 2019-04-30</summary></entry></feed>