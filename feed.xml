<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="https://codemcd.github.io/pages/CODEMCD/feed.xml" rel="self" type="application/atom+xml" /><link href="https://codemcd.github.io/pages/CODEMCD/" rel="alternate" type="text/html" /><updated>2018-10-15T23:42:30+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/</id><title type="html">CODEMCD’s Tech Blog</title><subtitle>My Tech Blog</subtitle><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><entry><title type="html">[Kotlin]6. 흐름 제어(control flow)</title><link href="https://codemcd.github.io/pages/CODEMCD/kotlin/Kotlin-6.%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4/" rel="alternate" type="text/html" title="[Kotlin]6. 흐름 제어(control flow)" /><published>2018-10-14T00:00:00+09:00</published><updated>2018-10-14T00:00:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/kotlin/Kotlin-6.%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/kotlin/Kotlin-6.%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4/">&lt;h1 id=&quot;흐름-제어control-flow&quot;&gt;흐름 제어(control flow)&lt;/h1&gt;

&lt;h2 id=&quot;자바와-동일한-구문&quot;&gt;자바와 동일한 구문&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;if-else문&lt;/li&gt;
  &lt;li&gt;while문, for문&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코틀린-구문&quot;&gt;코틀린 구문&lt;/h2&gt;
&lt;h3 id=&quot;1-when문&quot;&gt;1. when문&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;when문은 자바의 switch문을 대체하며, 훨씬 더 많은 기능이 추가되었다.&lt;/li&gt;
  &lt;li&gt;when문은 각각의 branch의 조건문이 만족할 때까지 위에서 부터 순차적으로 인자를 비교한다.&lt;/li&gt;
  &lt;li&gt;when문 안의 else문은 다른 모든 branch가 조건에 성립하지 않을 때 수행된다.
    &lt;ul&gt;
      &lt;li&gt;else문은 필수로 있어야 하며, 없으면 컴파일 에러가 난다.&lt;/li&gt;
      &lt;li&gt;when문이 식으로 사용된 경우 else문이 없어도 된다는 것을 컴파일러가 입증할 수 있는 경우 생략 가능하다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var res = when (x) {
  true -&amp;gt; &quot;맞다&quot;
  false -&amp;gt; &quot;틀리다&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;사용 예제
    &lt;ul&gt;
      &lt;li&gt;기본 예제&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;when (x) {
  1 -&amp;gt; print(&quot;x == 1&quot;)
  2 -&amp;gt; print(&quot;x == 2&quot;)
  else -&amp;gt; { // Note the block
    print(&quot;x is neither 1 nor 2&quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;여러 개의 조건이 사용된 경우&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;when (x) {
  0, 1 -&amp;gt; print(&quot;x == 0 or x == 1&quot;)
  else -&amp;gt; print(&quot;otherwise&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;조건에 함수나 식이 사용된 경우&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;when (x) {
  parseInt(x) -&amp;gt; print(&quot;s encodes x&quot;)
  1 + 3 -&amp;gt; print(&quot;4&quot;)
  else -&amp;gt; print(&quot;s does not encode x&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;범위 연산자 ‘..’, collection에 ‘in’연산자로 범위를 검사하는 경우&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val validNumbers = listOf(3, 6, 9)
when (x) {
  in validNumbers -&amp;gt; print(&quot;x is valid&quot;)
  in 1..10 -&amp;gt; print(&quot;x is in the range&quot;)
  !in 10..20 -&amp;gt; print(&quot;x is outside the range&quot;)
  else -&amp;gt; print(&quot;none of the above&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;is 연산자를 이용하여 타입 검사를 하는 경우&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//스마트 캐스트가 적용된다.
fun hasPrefix(x: Any) = when(x) {
  is String -&amp;gt; x.startsWith(&quot;prefix&quot;)
  else -&amp;gt; false
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;when문에 인자를 입력하지 않으면 논리 연산을 검사한다. (if-else문 대체 가능)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;when {
  x.isOdd() -&amp;gt; print(&quot;x is odd&quot;)
  x.isEven() -&amp;gt; print(&quot;x is even&quot;)
  else -&amp;gt; print(&quot;x is funny&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-범위-연산자&quot;&gt;2. 범위 연산자&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;..연산자&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//0부터 10까지, 시작과 끝을 포함하는 범위를 정의한다.
val myRange: IntRange = 0..10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;until 함수&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val items: List&amp;lt;String&amp;gt; = ... //항목이 담긴 리스트라고 가정

val myRange: IntRage = 0..3
//마지막 값을 포함하지 않는 범위, 즉 0, 1, 2, 3 의 인덱스를 나타낸다.
val myRange: IntRage = 0 until 4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;dounTo() 함수, step() 함수&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//2씩 감소하는 for문
for (i in 5 downTo 1 step 2) {
  System.out.print(i)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="개념 정리" /><summary type="html">Kotlin 개념</summary></entry><entry><title type="html">[Kotlin]5. 코틀린만의 클래스</title><link href="https://codemcd.github.io/pages/CODEMCD/kotlin/Kotlin-5.%EC%BD%94%ED%8B%80%EB%A6%B0%EB%A7%8C%EC%9D%98%ED%81%B4%EB%9E%98%EC%8A%A4/" rel="alternate" type="text/html" title="[Kotlin]5. 코틀린만의 클래스" /><published>2018-10-14T00:00:00+09:00</published><updated>2018-10-14T00:00:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/kotlin/Kotlin-5.%EC%BD%94%ED%8B%80%EB%A6%B0%EB%A7%8C%EC%9D%98%ED%81%B4%EB%9E%98%EC%8A%A4</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/kotlin/Kotlin-5.%EC%BD%94%ED%8B%80%EB%A6%B0%EB%A7%8C%EC%9D%98%ED%81%B4%EB%9E%98%EC%8A%A4/">&lt;h1 id=&quot;코틀린만의-클래스&quot;&gt;코틀린만의 클래스&lt;/h1&gt;

&lt;h2 id=&quot;데이터-클래스data-class&quot;&gt;데이터 클래스(data class)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;데이터 클래스는 자료만을 저장하기 위해 사용하는 클래스이다.(메서드 없음)&lt;/li&gt;
  &lt;li&gt;사용 예제&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;data class Person(val name: String, val address: String)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;기본 생성자에서 선언된 속성을 통해, 컴파일러에서 자동으로 아래의 기능들을 만들어준다.
    &lt;ul&gt;
      &lt;li&gt;equals()&lt;/li&gt;
      &lt;li&gt;hashCode()&lt;/li&gt;
      &lt;li&gt;copy()&lt;/li&gt;
      &lt;li&gt;toString()&lt;/li&gt;
      &lt;li&gt;componentN() functions&lt;/li&gt;
      &lt;li&gt;만약 명시적으로 클래스 내에 선언해주는 경우, 해당 메서드는 컴파일러가 자동으로 생성해주지 않는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;의미 있는 데이터 클래스 조건
    &lt;ul&gt;
      &lt;li&gt;기본 생성자에 1개 이상의 파라미터가 존재한다.&lt;/li&gt;
      &lt;li&gt;기본 생성자의 파라미터가 val, var로 선언되어 있다.&lt;/li&gt;
      &lt;li&gt;abstract, open, inner 키워드는 사용할 수 없다.&lt;/li&gt;
      &lt;li&gt;interface 구현과 한정 클래스(sealed class) 상속은 가능하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;데이터 클래스는 componentN 함수를 사용하여, Destructuring Declarations가 가능하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val person = User(&quot;Jane&quot;, 35)
val (name, age) = person
println(&quot;$name, $age years of age&quot;)
// prints: &quot;Jane, 35 years of age&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;한정-클래스sealed-class&quot;&gt;한정 클래스(sealed class)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;한정 클래스는 enum 클래스를 확장한 개념이다.
    &lt;ul&gt;
      &lt;li&gt;각 종류별로 하나의 인스턴스만 생성되어 있는 enum 클래스와 달리 잉ㄴ스턴스를 여러 개 생성 가능하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용 예제&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// MoblieApp 한정 클래스와 이를 상속하는 Android, IOS 클래스
sealed class MobileApp(val os: String) {
  class Android(os: String, val packageName: String) : MobileApp(os)
  calss IOS(os: String, val bundleId: String) : MobileApp(os)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;한정 클래스를 상속하는 클래스는 일반적으로 한정 클래스 내에 중첩하여 선언한다.
    &lt;ul&gt;
      &lt;li&gt;같은 파일 내에 정의한다면 클래스 외부에 선언 할수도 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;한정 클래스를 상속하는 클래스는 한정 클래스의 한 종류로 취급된다.&lt;/li&gt;
  &lt;li&gt;한정 클래스의 장점
    &lt;ul&gt;
      &lt;li&gt;한정 클래스로 취급된 여러 종류의 클래스마다 다른 작업을 처리해야할 때 유용하다.&lt;/li&gt;
      &lt;li&gt;임의의 클래스가 한정 클래스로 추가되었을 때 처리하는 작업이 간단하다.&lt;/li&gt;
      &lt;li&gt;대표적인 예제로 한정 클래스들로 when문을 처리할 때 이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;프로퍼티의-사용자-지정-gettersetter&quot;&gt;프로퍼티의 사용자 지정 Getter/Setter&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;코틀린은 프로퍼티를 선언하면 자동으로 Getter/Setter를 내부에서 제공한다.&lt;/li&gt;
  &lt;li&gt;Getter/Setter 함수를 사용자가 필요에 맞게 수정하여 사용할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;프로퍼티 선언과 함께 &lt;code class=&quot;highlighter-rouge&quot;&gt;get(), set(value)&lt;/code&gt;로 같이 선언하면 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;선언 형식&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var &amp;lt;propertyName&amp;gt;[: &amp;lt;PropertyType&amp;gt;] [=property_initializer&amp;gt;]
  [&amp;lt;getter&amp;gt;]
  [&amp;lt;setter&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="개념 정리" /><summary type="html">Kotlin 개념</summary></entry><entry><title type="html">[Kotlin]4. 클래스 및 인터페이스</title><link href="https://codemcd.github.io/pages/CODEMCD/kotlin/Kotlin-4.%ED%81%B4%EB%9E%98%EC%8A%A4%EB%B0%8F%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/" rel="alternate" type="text/html" title="[Kotlin]4. 클래스 및 인터페이스" /><published>2018-10-14T00:00:00+09:00</published><updated>2018-10-14T00:00:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/kotlin/Kotlin-4.%ED%81%B4%EB%9E%98%EC%8A%A4%EB%B0%8F%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/kotlin/Kotlin-4.%ED%81%B4%EB%9E%98%EC%8A%A4%EB%B0%8F%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/">&lt;h1 id=&quot;클래스-및-인터페이스&quot;&gt;클래스 및 인터페이스&lt;/h1&gt;

&lt;h2 id=&quot;클래스와-인터페이스의-선언-및-인스턴스-생성&quot;&gt;클래스와 인터페이스의 선언 및 인스턴스 생성&lt;/h2&gt;
&lt;h3 id=&quot;1-클래스&quot;&gt;1. 클래스&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;클래스를 선언하는 방법은 자바와 거의 동일하다.&lt;/li&gt;
  &lt;li&gt;예제&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;예제 코드&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;패키지&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;에&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;포함된&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;클래스&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Baz&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;선언&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Baz&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;---&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;클래스&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;본체&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;없이&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;클래스를&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;선언할&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;수&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;있다&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;코틀린에서 접근 제한자를 지정하지 않는 경우 public으로 간주한다.&lt;/li&gt;
  &lt;li&gt;코틀린에서는 키워드 ‘new’없이 인스턴스 생성이 가능하다.&lt;/li&gt;
  &lt;li&gt;예제&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;예제 코드&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val foo: Foo = Foo()
//인자 하나를 받는 생성자로 인스턴스 생성
val bar: Bar = Bar(1);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2-인터페이스&quot;&gt;2. 인터페이스&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;인터페이스의 생성은 자바와 비슷하지만, 인터페이스의 인스턴스 생성은 조금 다르다.&lt;/li&gt;
  &lt;li&gt;예제&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;예제 코드&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//인터페이스 선언
interface Bar {
  fun baz()
}
//인터페이스의 인스턴스 생성
//object: [인터페이스 이름] 형태
val bar = object: Bar {
  override fun baz() {
    //함수 구현
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;추상-클래스abstract-class&quot;&gt;추상 클래스(abstract class)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;추상 클래스의 선언 방법은 자바와 동일하지만, 인스턴스 생성은 다르며, 코틀린의 인터페이스의 인스턴스 생성과 유사하다.&lt;/li&gt;
  &lt;li&gt;추상 클래스에서는 인스턴스 생성 시 생성자를 사용하지만, 생성자가 없는 인스턴스는 인스턴스 이름만 사용한다.&lt;/li&gt;
  &lt;li&gt;예제&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;예제 코드&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//추상 클래스 선언
abstract class Foo {
  abstract fun bar()
}
//추상 클래스의 인스턴스 생성
//object: [생성자] 형태
val foo = object: Foo() {
  override fun bar() {
    //함수 구현
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;프로퍼티property&quot;&gt;프로퍼티(property)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;프로퍼티는 자료를 저장할 수 있는 필드(field)와 이에 상응하는 Getter/Setter 메서드를 함께 제공하며, 자바의 필드와 유사한 형태로 선안한다.
    &lt;ul&gt;
      &lt;li&gt;자바는 클래스내의 멤버함수에 접근하기 위해 Getter/Setter 메서드를 직접 추가해주어야 하기 때문에 코드의 양이 불필요하게 늘어난다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로퍼티 역시 ‘val’와 ‘var’ 중 하나로 선언해야 한다.
    &lt;ul&gt;
      &lt;li&gt;val: Getter 메서드만 존재한다.&lt;/li&gt;
      &lt;li&gt;var: Getter/Setter 메서드 모두 존재한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로퍼티는 초기값을 명시적으로 지정해야 하며, 그렇지 않은 경우 컴파일 에러가 발생한다.&lt;/li&gt;
  &lt;li&gt;프로퍼티 선언 시점이나 생성자 호출 시점에 값을 할당하지 않을 경우 ‘lateinit’ 키워드를 사용하여 초기 할당없이 사용할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;키워드 ‘lateinit’은 프로퍼티 값을 나중에 할당할 것이라고는 것을 명시하는 것으로서, ‘var’ 프로퍼티에만 사용가능하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로퍼티 역시 타입 추론이 가능하기 때문에 타입 선언을 생략할 수 있다.&lt;/li&gt;
  &lt;li&gt;예제&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;예제 코드&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Person {
  //기본 예제
  val name: String? = null
  var address: String? = null

  //lateinit
  lateinit var adderss: String?

  //타입 추론
  var name = &quot;No Name&quot;
  var address: String? = null  //null만으로는 타입을 추론할 수 없기 때문에 타입 선언이 필요하다.
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;접근-제한자&quot;&gt;접근 제한자&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;접근 제한자는 자바와 거의 동일하다.
    &lt;ul&gt;
      &lt;li&gt;제한자가 없으면 자동으로 public으로 간주한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;자바와 다르게 ‘internal’ 접근 제한자가 존재한다.
    &lt;ul&gt;
      &lt;li&gt;자바에서 public의 접근 범위는 동일한 패키지 안이다. 하지만 외부 모듈이라도 패키지 이름이 같다면 접근이 가능하다.&lt;/li&gt;
      &lt;li&gt;위를 보완하기 위해 코틀린에서는 internal 접근 제한자를 제공한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;‘internal’ 접근 제한자의 범위는 동일한 모듈 내이다.
    &lt;ul&gt;
      &lt;li&gt;IntelliJ IDEA 모듈&lt;/li&gt;
      &lt;li&gt;Maven/Gradle 프로젝트&lt;/li&gt;
      &lt;li&gt;하나의 Ant 태스크 내에서 함께 컴파일되는 파일들&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;생성자&quot;&gt;생성자&lt;/h2&gt;
&lt;h3 id=&quot;1-기본-생성자&quot;&gt;1. 기본 생성자&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;코틀린의 기본 생성자는 자바보다 더욱 직관적으로 정의한다.
    &lt;ul&gt;
      &lt;li&gt;init {} 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;예제&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;_ 예제 코드&lt;/strong&gt;_&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Foo {
  init {
    //생성자에서 수행할 작업들...
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2-주-생성자primary-constructor&quot;&gt;2. 주 생성자(primary constructor)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;생성자에 인자가 필요한 경우 주 생성자를 활용한다.&lt;/li&gt;
  &lt;li&gt;주 생성자로 클래스 내부의 프로퍼티를 대신해서 사용할 수 있으므로, 프로퍼티를 생략할 수 있다.&lt;/li&gt;
  &lt;li&gt;예제&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;예제 코드&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//기본 생성자에서 주 생성자의 인자를 사용할 수 있다.
class Foo(a: Int) {
  init {
    Log.d(&quot;Foo&quot;, &quot;Number: $a&quot;)
  }
}

//프로퍼티 대신 주 생성자를 사용할 수 있다.
class Foo(val a: Int, var b: Char)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3-추가-생성자&quot;&gt;3. 추가 생성자&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;주 생성자 외에 다른 형태의 생성자가 필요한 경우 ‘constructor’ 키워드를 사용하여 추가 생성자를 선언할 수 있다.&lt;/li&gt;
  &lt;li&gt;추가 생성자를 정의하는 경우 주 생성자를 반드시 호출해야 한다.&lt;/li&gt;
  &lt;li&gt;추가 생성자에서는 인자와 프로퍼티를 함께 선언할 수 없다.
    &lt;ul&gt;
      &lt;li&gt;프로퍼티 선언이 필요한 인자인 경우 반드시 주 생성자에서 이를 처리해야 한다.&lt;/li&gt;
      &lt;li&gt;예제&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;strong&gt;&lt;em&gt;예제 코드&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Foo(val a: Int, var b: Char) {
  //a값만 인자로 받는 추가 생성자
  constructor(a: Int) : this(a, 0)

  //두 인자의 값을 모두 0으로 지정하는 생성자
  constructor() : this(0, 0)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-생상자의-접근-제한자&quot;&gt;4. 생상자의 접근 제한자&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;생성자의 가시성을 변경하려면 constructor 키워드 앞에 접근 제한자를 추가하면 된다.&lt;/li&gt;
  &lt;li&gt;주 생성자는 생략하였던 constructor 키워드를 추가하고 그 앞에 접근 제한자를 추가해야 한다.&lt;/li&gt;
  &lt;li&gt;예제&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;예제 코드&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Foo internal constructor(val a: Int, var b: Char) {
  private constructor(a: Int) this(a, 0)

  // 접근 제한자를 지정하지 않았으므로 public
  constructor(): this(0, 0)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;함수function&quot;&gt;함수(function)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;코틀린은 자바의 클래스 내 메서드를 함수로 표현한다.&lt;/li&gt;
  &lt;li&gt;함수에서 특별한 값을 반환하지 않는다면 ‘함수 자체’를 의미하는 Unit 타입을 반환하며, 이는 생략 할 수 있다.&lt;/li&gt;
  &lt;li&gt;예제&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;예제 코드&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Foo {
  //아무 값도 반환하지 않는 함수, 생략 가능
  fun foo(): Unit { }

  //정수 값을 반환하는 함수
  private fun bar(): Int {
    return 0
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;상속-및-인터페이스-구현&quot;&gt;상속 및 인터페이스 구현&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;코틀린에서 상속 및 인터페이스는 키워드로 구분하는 자바와 달리 콜론(:) 뒤에 상속한 클래스나 구현한 인터페이스를 표기한다.&lt;/li&gt;
  &lt;li&gt;클래스를 상속하는 경우 반드시 부모 클래스의 생성자를 호출해야 한다.
    &lt;ul&gt;
      &lt;li&gt;부모 클래스의 생성자가 여러 개일 경우, 클래스의 선언부가 아닌 내부에서 호출할 수도 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;코틀린에서 부모 클래스의 메서드 재정의, 인터페이스 구현한 메서드는 앞에 ‘override’ 키워드를 반드시 붙여야 한다.
    &lt;ul&gt;
      &lt;li&gt;자바에서 이를 ‘@Override’ 어노테이션으로 구분하는데, 이는 선택 사항이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;코틀린에서는 ‘open’ 키워드를 붙인 클래스나 함수만이 상속이나 재정의를 할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;자바에서는 ‘final’ 키워드로 더 이상 상속이나 재정의를 할 수 없도록 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;예제&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;예제 코드&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// AppCompatActivity 상속: AppCompatActivity()로 기본 생성자를 바로 호출한다.
// View.OnClickListener 구현
class MyActivity: AppCompatActivity(), View.OnClickListener {
  // AppCompatActivity의 onCreate() 메서드 상속
  override fun onCreate(savedInstanceState: Bundle?) {
    super.oncreate(savedInstanceState)
  }

  // View.OnClickListener 인터페이스 구현
  override fun onClick(v: View) { }
}

// 'open' 키워드 사용 예제
open class OpenClass {
  open val openProperty = &quot;foo&quot;
  val finalProperty = &quot;bar&quot;
  open fun openFunc() { }
  fun finalFunc() { }
}

// 성공: OpenClass 앞에 'open' 키워드가 있으므로 상속 가능한 클래스이다.
class FinalClass : OpenClass() {
  // 성공: '부모 클래스의 openProperty 변수 앞에 'open' 키워드가 있으므로 재정의가 가능한 프로퍼티이다.
  override val openProperty = &quot;FOO&quot;
  // 실패: 해당 프로퍼티에 'open' 키워드가 없다.
  override val finalProperty = &quot;BAR&quot;
  // 성공: '부모 클래스의 openFunc 함수 앞에 'open' 키워드가 있으므로 재정의가 가능한 함수이다.
  override open fun openFunc() { }
  // 실패: 해당 함수에 'open' 키워드가 없다.
  override fun finalFunc() { }
}

// 실패: 해당 클래스에 'open' 키워드가 없다.
class Foo : FinalClass()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;this&quot;&gt;this&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;코틀린의 this 키워드는 자바와 거의 동일하다.&lt;/li&gt;
  &lt;li&gt;자바에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;{클래스 이름}.this&lt;/code&gt;를 코틀린에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;this@{클래스 이름}&lt;/code&gt; 형태로 사용된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;정적-필드-및-메서드&quot;&gt;정적 필드 및 메서드&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;코틀린에서는 자바와 달리 정적 필드와 메서드를 사용하여, 클래스 내에 상수를 정의하거나 static 메서드(인스턴스 생성 없이 사용할 수 있는 메서드)를 정의할 수 없다.&lt;/li&gt;
  &lt;li&gt;일반적인 경우 클래스 내에 선언했던 정적 필드나 메서드는 패키지 단위(package-level)로 선언할 수 있다.&lt;/li&gt;
  &lt;li&gt;패키지 단위로 선언한 값이나 함수는 패키지에 종속되므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;import {패키지 이름}.{값 혹은 함수 이름}&lt;/code&gt;으로 사용해야 한다.&lt;/li&gt;
  &lt;li&gt;예제&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;자바 코드&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;정적&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;필드&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;상수&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;선언&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FOO&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;정적&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;static&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;메서드&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;선언&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;인스턴스&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;메서드&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;인스턴스를&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;생성해야&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;사용할&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;수&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;있는&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;메서드&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import foo.bar.Foo;
public class Bar {
  public void bar() {
    //Foo클래스 내의 정적 필드 FOO의 값을 참조한다.
    int foo = foo.Foo;
    //Foo 클래스 내의 정적 메서드 foo를 호출한다.
    Foo.foo();
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;코틀린 코드&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kt&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;값&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FOO&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;를&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;패키지&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;에&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;선언한다&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FOO&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;123&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;함수&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;를&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;패키지&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;에&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;선언한다&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;함수&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;는&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;의&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;인스턴스를&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;생성해야&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;사용할&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;수&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;있다&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import foo.bar.Foo
import foo.bar.foo

clas Bar {
  //foo.bar 패키지 내의 FOO 값을 참조한다.
  val foo = Foo

  //foo.bar 패키지 내의 함수 foo를 호출한다.
  foo()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;클래스 내 private로 선언된 멤버에 접근해야 하는 팩토리 메서드(factory method)는 패키지 단위 함수로 구현할 수 없다.
    &lt;ul&gt;
      &lt;li&gt;동반 객체(companion object)를 사용하면 클래스 내 모든 멤버에 접근할 수 있고, 인스턴스 생성 없이 호출가능한 함수를 작성할 수 있다.&lt;/li&gt;
      &lt;li&gt;동반 객체: 클래스별로 하나씩 클래스의 인스턴스 생성 없이 사용할 수 있는 오브젝트(object)를 정의할 수 있는데, 이를 동반 객체라 한다.&lt;/li&gt;
      &lt;li&gt;예제&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class User private constructor(val name: String, val registerTime: Long) {
  companion object {
    //동반 객체는 클래스 내부에 존재하므로, private로 선언된 생성자에 접근할 수 있다.
    fun create(name: String) : User {
      return User(name, System.currentTimeMillis())
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;싱글톤singleton&quot;&gt;싱글톤(singleton)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;싱글톤은 단 하나의 인스턴스만 생성되도록 제약을 둔 디자인 패턴이다.&lt;/li&gt;
  &lt;li&gt;코틀린에서는 이를 단 한줄로 간편하게 선언할 수 있다.&lt;/li&gt;
  &lt;li&gt;예제&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;object singleton
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;enum-클래스&quot;&gt;enum 클래스&lt;/h2&gt;
&lt;h2 id=&quot;어노테이션-클래스annotation-class&quot;&gt;어노테이션 클래스(annotation class)&lt;/h2&gt;
&lt;h2 id=&quot;중첩-클래스nested-class&quot;&gt;중첩 클래스(nested class)&lt;/h2&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="개념 정리" /><summary type="html">Kotlin 개념</summary></entry><entry><title type="html">[Kotlin]3. 컬렉션(collection)</title><link href="https://codemcd.github.io/pages/CODEMCD/kotlin/Kotlin-3.%EC%BB%AC%EB%A0%89%EC%85%98/" rel="alternate" type="text/html" title="[Kotlin]3. 컬렉션(collection)" /><published>2018-10-14T00:00:00+09:00</published><updated>2018-10-14T00:00:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/kotlin/Kotlin-3.%EC%BB%AC%EB%A0%89%EC%85%98</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/kotlin/Kotlin-3.%EC%BB%AC%EB%A0%89%EC%85%98/">&lt;h1 id=&quot;컬렉션collection&quot;&gt;컬렉션(collection)&lt;/h1&gt;

&lt;h2 id=&quot;개요&quot;&gt;개요&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;코틀린에서 컬렉션은 자바에서 제공하는 클래스들을 그대로 사용합니다.&lt;/li&gt;
  &lt;li&gt;코틀린의 컬렉션은 타입 별칭(type alias)을 사용하여 컬럭션 내 다른 클래스와의 일관성을 유지한다.&lt;/li&gt;
  &lt;li&gt;컬렉션 내 자료의 수정 가능 여부에 따라 컬렉션의 종류를 구분한다.
    &lt;ul&gt;
      &lt;li&gt;이는 새로운 타입을 선언하는 것이 아닌, 인터페이스를 통해 사용 가능한 함수를 제한하는 방식으로 구현된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;자바의 List 인터페이스 상속 관계도&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/43832903-e441e45e-9b43-11e8-98b2-9cd79a150851.JPG&quot; alt=&quot;jcollection&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;코틀린의 List 인터페이스 상속 관계도
    &lt;ul&gt;
      &lt;li&gt;컬렉션 내 자료를 수정 할 수 있는 가변 타입(mutable)과 수정이 불가능한 불변 타입(immutable)로 구분된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/43832902-e4164d58-9b43-11e8-966b-5426e0332271.JPG&quot; alt=&quot;collection&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;코틀린은 가변/불변 타입의 컬렉션이 있지만, 자바에서는 모두 가변 타입의 컬렉션이다. 그러므로 혼용 시에 이를 주의 해야 한다.
    &lt;ul&gt;
      &lt;li&gt;코틀린의 불변 타입 컬렉션을 자바로 변경 시 가변 타입의 컬렉션이 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;컬렉션은 배열과 마찬가지로 표준 라이브러리에서 쉽게 생성하는 함수를 제공한다.
    &lt;ul&gt;
      &lt;li&gt;일부 타입은 타입 별칭을 사용하므로 실제 반환되는 타입이 따로 존재한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;함수명&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;자료 수정가능 여부&lt;/th&gt;
      &lt;th&gt;반환 타입(실제 타입)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;listOf()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td&gt;kotlin.collections.List&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;arrayListOf()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td&gt;kltlin.collections.ArrayList(java.util.ArraryLsit)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;setOf()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td&gt;kltlin.collections.Set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;hashSetOf()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td&gt;kltlin.collections.HashSet(java.util.HashSet)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;linkedSetOf()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td&gt;kltlin.collections.LinkedHashSet(java.util.LinkedHashSet)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;sortedSetOf()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td&gt;kltlin.collections.TreeSet(java.util.TreeSet)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;mapOf()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td&gt;kltlin.collections.Map&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;hashMapOf()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td&gt;kltlin.collections.HashMap(java.util.HashMap)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;linkedMapOf()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td&gt;kltlin.collections.LinkedHashMar(java.util.LinkedHashMap)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;sortedMapOf()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td&gt;kltlin.collections.SortedMap(java.util.SortedMap)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;예제&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;예제 코드&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//자료를 수정할 수 없는 리스트 생성
val immutableList: List&amp;lt;String&amp;gt; = listOf(&quot;Lorem&quot;, &quot;ipsum&quot;, &quot;dolor&quot;, &quot;sit&quot;)

//컴파일 에러: 자료 수정을 위한 함수를 지원하지 않음
immutableList.add(&quot;amet&quot;)

//자료를 수정할 수 있는 리스트 생성
val mutableList: MutableList&amp;lt;String&amp;gt; = arrayListOf(&quot;Lorem&quot;, &quot;ipsum&quot;, &quot;dolor&quot;, &quot;sit&quot;)

//자료 수정 가능
mutableList.add(&quot;amet&quot;)

//자료를 수정하지 않는 자료형으로 재할당
val immutableList2: List&amp;lt;String&amp;gt; = mutatbleList

//컴파일 에러: 자료 수정을 위한 함수를 지원하지 않음
immutableList2.add(&quot;amet&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="개념 정리" /><summary type="html">Kotlin 개념</summary></entry><entry><title type="html">[Kotlin]2. 기본 자료형</title><link href="https://codemcd.github.io/pages/CODEMCD/kotlin/Kotlin-2.%EA%B8%B0%EB%B3%B8%EC%9E%90%EB%A3%8C%ED%98%95/" rel="alternate" type="text/html" title="[Kotlin]2. 기본 자료형" /><published>2018-10-14T00:00:00+09:00</published><updated>2018-10-14T00:00:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/kotlin/Kotlin-2.%EA%B8%B0%EB%B3%B8%EC%9E%90%EB%A3%8C%ED%98%95</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/kotlin/Kotlin-2.%EA%B8%B0%EB%B3%B8%EC%9E%90%EB%A3%8C%ED%98%95/">&lt;h1 id=&quot;기본-자료형&quot;&gt;기본 자료형&lt;/h1&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;자바의 자료형은 원시 타입과 참조 타입 두 가지로 나뉜다.
    &lt;ul&gt;
      &lt;li&gt;원시 타입(primitive type; int, double 등): 값 자체를 저장함.&lt;/li&gt;
      &lt;li&gt;참조 타입(reference type; String 등): 객체의 참조 값을 저장함.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;코틀린은 모든 타입을 객체로 표현한다.
    &lt;ul&gt;
      &lt;li&gt;원시 타입과 래퍼(wrapper; Integer, Double 등)클래스를 구분하지 않는다.
        &lt;ul&gt;
          &lt;li&gt;wrapper class: 기본 자료형을 객체로 사용하기 위해 기본 자료형 값을 객체로 포장해주는 클래스&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;자바의 원시 타입 및 래퍼 클래스를 코틀린에서 사용하는 자료형으로 처리한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;코틀린 코드를 작성하는 시점에서는 원시 타입과 래퍼를 구분하지 않지만, 컴파일 단계를 거치면서 가장 효율적인 타입으로 변환된다.
    &lt;ul&gt;
      &lt;li&gt;값이나 변수 타입으로 사용되는 경우: 원시 타입으로 변환&lt;/li&gt;
      &lt;li&gt;컬렉션의 타입 인자로 사용되는 경우: 래퍼로 변환&lt;/li&gt;
      &lt;li&gt;컴파일 단계는 intelliJ 플랫폼에서 디컴파일 하는 기능으로 컴파일 단계의 자바코드를 확인할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Java(원시 타입)&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Java(래퍼)&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Kotlin&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;byte&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;java.lang.Byte&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;kotlin.Byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;short&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;java.lang.Short&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;kotlin.Short&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;int&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;java.lang.Integer&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;kotlin.Int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;long&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;java.lang.Long&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;kotlin.Long&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;char&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;java.lang.Character&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;kotlin.Char&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;float&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;java.lang.Float&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;kotlin.Float&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;double&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;java.lang.Double&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;kotlin.Double&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;boolean&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;java.lang.Boolean&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;kotlin.Boolean&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;숫자&quot;&gt;숫자&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;숫자를 표현하는 모든 자료형은 Number 클래스를 상속합니다.&lt;/li&gt;
  &lt;li&gt;자료형 변환
    &lt;ul&gt;
      &lt;li&gt;코틀린은 작은 타입이 큰 타입으로 대입될 때, 자동으로 형변환을 해주지 않는다.(무조건 명시적 변환을 해주어야 함)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;java.lang.Number&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;kotlin.Number&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;byte byteValue()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;fun toByte(): Byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;없음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;fun toChar(): Char&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;double doubleValue()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;fun toDouble(): Double&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;float floatValue()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;fun toFloat(): Float&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;int intValue()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;fun toInt(): Int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;long longValue()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;fun toLong(): Long&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;short shortValue()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;fun toShort(): Short&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;리터럴(Literal) 표기법
    &lt;ul&gt;
      &lt;li&gt;Long 타입은 대문자 ‘L’을 사용하는 것 외에는 자바와 모두 동일하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val dec: Int = 100
val hex: Int = 0x100
val binary: Int = 0b100
val longValue: Long = 100L
val doubleValue: Double = 100.1 //(= 1.001e2)
val flaotValue: Float = 100.0f
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;숫자 연산에 사용하는 사칙연산(+, -, *, /)은 자바와 동일하지만, 비트 연산자의 이름은 좀더 직관적으로 바뀌었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Java&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Kotlin&lt;/th&gt;
      &lt;th&gt;의미&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&amp;amp;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;and&lt;/td&gt;
      &lt;td&gt;비트 연산 AND&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td&gt;or&lt;/td&gt;
      &lt;td&gt;비트 연산 OR&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;^&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;xor&lt;/td&gt;
      &lt;td&gt;비트 연산 XOR&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;~&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;inv&lt;/td&gt;
      &lt;td&gt;비트 연산 NOT&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;«&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;shl&lt;/td&gt;
      &lt;td&gt;왼쪽으로 시프트(부호 비트 유지)&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;»&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;shr&lt;/td&gt;
      &lt;td&gt;오른쪽으로 시프트(부호 비트 유지)&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;»&amp;gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ushr&lt;/td&gt;
      &lt;td&gt;오른쪽으로 시프트(부호 비트 무시)&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;문자&quot;&gt;문자&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;코틀리은 자바와 달리 문자 자료형에 숫자의 형태로 대입할 경우 컴파일 에러가 발생한다.
    &lt;ul&gt;
      &lt;li&gt;해당 문자의 아스키 코드 값을 알고 싶을 때, &lt;code class=&quot;highlighter-rouge&quot;&gt;toChar()&lt;/code&gt;를 사용하여 위 문제를 해결할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;논리&quot;&gt;논리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;논리 연산자는 자바와 동일하다. (Boolean 사용)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;문자열&quot;&gt;문자열&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;String 클래스로 표현하며, 자바와 거의 동일하다.&lt;/li&gt;
  &lt;li&gt;get() 메서드 혹은 대괄호([])와 인덱스를 통해 특정 문자에 접근 가능하다.&lt;/li&gt;
  &lt;li&gt;문자열 리터럴
    &lt;ul&gt;
      &lt;li&gt;escaped string(“ “): 전통 적인 방식으로 자바와 거의 동일하다.&lt;/li&gt;
      &lt;li&gt;raw string(“”” “””): 개행이나 어떠한 문자열도 사용가능하다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val espstr = &quot;Hello, kotlin!&quot;
val rawstr = &quot;&quot;&quot;
&quot;Hello, kotlin.
I'm John.&quot;
&quot;&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;배열&quot;&gt;배열&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;자바에서는 배열 타입이 별도로 존재하지만, 코틀린에서의 배열은 타입 인자를 갖는 Array클래스로 표현한다.&lt;/li&gt;
  &lt;li&gt;get(), set(), [], size 등 다양한 기능을 제공한다.&lt;/li&gt;
  &lt;li&gt;예제&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val words: Array&amp;lt;String&amp;gt; = arrayOf(&quot;Lorem&quot;, &quot;ipsum&quot;, &quot;dolor&quot;, &quot;sit&quot;)
val intArr: IntArray = intArrayOf(1, 2, 3, 4, 5)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Java&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Kotlin&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;byte[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;kotlin.ByteArray&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;double[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;kotlin.DoubleArray&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;float[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;kotlin.FloatArray&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;int[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;kotlin.IntArray&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;long[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;kotlin.LongArray&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;short[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;kotlin.ShortArray&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="개념 정리" /><summary type="html">Kotlin 개념</summary></entry><entry><title type="html">[Kotlin]1. 코틀린이란?</title><link href="https://codemcd.github.io/pages/CODEMCD/kotlin/Kotlin-1.%EC%BD%94%ED%8B%80%EB%A6%B0%EC%9D%B4%EB%9E%80_/" rel="alternate" type="text/html" title="[Kotlin]1. 코틀린이란?" /><published>2018-10-14T00:00:00+09:00</published><updated>2018-10-14T00:00:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/kotlin/Kotlin-1.%EC%BD%94%ED%8B%80%EB%A6%B0%EC%9D%B4%EB%9E%80_</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/kotlin/Kotlin-1.%EC%BD%94%ED%8B%80%EB%A6%B0%EC%9D%B4%EB%9E%80_/">&lt;h1 id=&quot;코틀린kotlin이란&quot;&gt;코틀린(Kotlin)이란?&lt;/h1&gt;

&lt;h2 id=&quot;코틀린-소개&quot;&gt;코틀린 소개&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;코틀린은 인텔리제이(IntelliJ IDEA)라는 제품으로 유명한 JetBrains에서 만든 언어로, 2011년 최초로 공개된 후 오랜 시간 개발을 거쳐 2016년 2월
1.0 정식 버전이 출시되었다.&lt;/li&gt;
  &lt;li&gt;코틀린의 목표는 간결한 문법, 풍부한 기능, 높은 안정성을 토대로 높은 생산성을 보장하는 것이다.&lt;/li&gt;
  &lt;li&gt;코틀린은 자바와 100% 호환되기 때문에, 한 프로젝트에 혼합해서 사용할 수 있다.&lt;/li&gt;
  &lt;li&gt;구글 I/O 2017에서 안드로이드 공식 지원 언어로 채택되었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코틀린-특징&quot;&gt;코틀린 특징&lt;/h2&gt;
&lt;h3 id=&quot;1-간결한-문법&quot;&gt;1. 간결한 문법&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;코틀린 문법은 자바에 비해 더 간결한 형태를 추구한다.&lt;/li&gt;
  &lt;li&gt;자바와 주요 차이점
    &lt;ul&gt;
      &lt;li&gt;문장 끝에 세미콜론(;)을 넣지 않아도 된다.&lt;/li&gt;
      &lt;li&gt;new 키워드를 쓰지 않고 객체를 생성한다.&lt;/li&gt;
      &lt;li&gt;타입 추론을 지원하므로 일반적인 경우 타입을 적지 않아도 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;예제&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;자바 코드&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String name = &quot;John Smith&quot;
Person person = new Person(name);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;코틀린 코드&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val nmae = &quot;John Smith&quot;
val person = Person(name)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2-널-안정성&quot;&gt;2. 널 안정성&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;객체 타입의 변수에서 널(null) 값의 허용 여부를 구분하지 않던 자바와 달리, 코틀린은 이를 명확히 구분한다.&lt;/li&gt;
  &lt;li&gt;널 값의 허용 여부를 컴파일 단계에서 검사하므로 런타임에서 발생하는 오류를 대폭 줄일 수 있다.&lt;/li&gt;
  &lt;li&gt;예제&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 널 값을 허용하는 문자열 타입(String?)
val foo: String? = null

// 널 값을 허용하지 않는 문자열 타입(String)
val bar: String  = &quot;bar&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3-가변불변-구분&quot;&gt;3. 가변/불변 구분&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;코틀린에서는 변수 및 변수 내 할당된 값의 불변 여부를 구분한다.
    &lt;ul&gt;
      &lt;li&gt;불변 여부: 최초 생성 시 할당된 값을 이후에도 변경할 수 있는지 여부&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;키워드 ‘val’: 값을 한번 할당하고 나면 그후에 변경할 수 없다.
    &lt;ul&gt;
      &lt;li&gt;자바의 키워드 ‘final’과 유사하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;키워드 ‘var’: 할당된 값을 자유자재로 변경할 수 있다.&lt;/li&gt;
  &lt;li&gt;변수와 마찬가지로 컬렉션 자료형에 대해서도 불변 여부를 구분한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-람다-표현식-지원&quot;&gt;4. 람다 표현식 지원&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;코틀린에서는 람다 표현식을 기본으로 지원한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;5-스트림-api-지원&quot;&gt;5. 스트림 API 지원&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;코틀린에서는 컬렉션 내 자료를 다루는데 유용한 스트림(stream) API를 표준 라이브러리에서 제공한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;6-완벽한-자바-호환성&quot;&gt;6. 완벽한 자바 호환성&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;코틀린에서 자바를 사용하는 것과 자바에서 코틀린을 사용하는 것이 모두 가능하다.&lt;/li&gt;
  &lt;li&gt;자바 라이브러리와도 모두 호환된다.&lt;/li&gt;
  &lt;li&gt;혼용 시 유의해야 하거나 사용 방법이 약간 다른 부분이 있으니 주의해야한다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="개념 정리" /><summary type="html">Kotlin 개념</summary></entry><entry><title type="html">[Java]예외처리(exception handing)</title><link href="https://codemcd.github.io/pages/CODEMCD/java/Java-%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC/" rel="alternate" type="text/html" title="[Java]예외처리(exception handing)" /><published>2018-10-14T00:00:00+09:00</published><updated>2018-10-14T00:00:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/java/Java-%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/java/Java-%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC/">&lt;h1 id=&quot;예외처리exception-handing&quot;&gt;예외처리(exception handing)&lt;/h1&gt;

&lt;h2 id=&quot;프로그램-오류&quot;&gt;프로그램 오류&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;컴파일 에러(compile-time error): 컴파일 시에 발생하는 에러&lt;/li&gt;
  &lt;li&gt;런타임 에러(runtime error): 실행 시에 발생하는 에러&lt;/li&gt;
  &lt;li&gt;논리적 에러(logical error): 실행은 되지만, 의도와는 다르게 동작하는 것&lt;/li&gt;
  &lt;li&gt;자바에서는 실행 시(runtime)에 발생할 수 있는 프로그램 오류를 두 가지로 구분한다.
    &lt;ul&gt;
      &lt;li&gt;에러(error): 프로그램 코드에 의해서 수습될 수 없는 심각한 오류를 말한다.
        &lt;ul&gt;
          &lt;li&gt;예를들어, 메모리 부족(OutOfMemoryError)나 스택오버플로우(StackOverflowError)가 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;예외(exception): 프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류를 말한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;예외-클래스의-계층구조&quot;&gt;예외 클래스의 계층구조&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Exception과 Error클래스 역시 Object클래스의 자손들이다.&lt;/li&gt;
  &lt;li&gt;밑의 그림은 예외클래스 계층도를 주요 클래스들만을 나열한 모습이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/44071623-3ff72644-9fc5-11e8-808d-0d1b5c6b9c07.jpg&quot; alt=&quot;exceptionclasshierarchy&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Exception클래스는 두 개의 그룹으로 구분할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;RuntimeException클래스와 그 자손클래스들
        &lt;ul&gt;
          &lt;li&gt;자손클래스는 ArithmeticException, ClassCastException, NullPointerException, …, IndexOutOfBoundException 클래스 등이 있다.&lt;/li&gt;
          &lt;li&gt;해당 클래스들은 주로 프로그래머의 실수에 의해 발생될 수 있는 예외들로 자바의 프로그래밍 요소들과 관계가 깊다.&lt;/li&gt;
          &lt;li&gt;IndexOutOfBoundException: 배열의 범위를 벗어난 경우&lt;/li&gt;
          &lt;li&gt;NullPointerException: null인 참조변수의 멤버를 호출한 경우&lt;/li&gt;
          &lt;li&gt;ClassCastException: 클래스의 형변환이 잘못된 경우&lt;/li&gt;
          &lt;li&gt;ArithmeticException: 정수를 0으로 나누려고하는 경우&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Exception클래스와 그 자손클래스들(RuntimeException과 자손들 제외)
        &lt;ul&gt;
          &lt;li&gt;자손클래스는 IOException, ClassNotFoundException 클래스 등이 있다.&lt;/li&gt;
          &lt;li&gt;프로그램의 사용자의 실수와 같은 외적인 요인에 의해 발생하는 예외이다.&lt;/li&gt;
          &lt;li&gt;FileNotFoundException: 존재하지 않은 파일의 이름을 입력한 경우&lt;/li&gt;
          &lt;li&gt;ClassNotFoundException: 실수로 클래스의 이름을 잘못된 경우&lt;/li&gt;
          &lt;li&gt;DataFormatException: 입력한 데이터 형식이 잘못된 경우&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;예외처리하기&quot;&gt;예외처리하기&lt;/h2&gt;
&lt;h3 id=&quot;1-try-catch문&quot;&gt;1. try-catch문&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;예외처리: 프로그램 실행 시 발생할 수 있는 예기치 못한 예외의 발생에 대비한 코드를 작성하는 것이다.&lt;/li&gt;
  &lt;li&gt;예외처리의 목적은 예외의 발생으로 인한 프로그램의 비정상적인 종료를 막고, 정상적인 실행상태를 유지하는 것이다.&lt;/li&gt;
  &lt;li&gt;예외를 처리하지 못하면, 프로그램은 비정상적으로 종료되며, JVM의 예외처리기(UncaughtExceptionHandler)에서 처리하지 못한 예외(uncaught exception)를 받아서 그 원인을 출력한다.&lt;/li&gt;
  &lt;li&gt;try-catch문의 구조&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//예외가 발생할 가능성이 있는 문장들을 넣는다.&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//Exception1이 발생했을 경우, 이를 처리하기 위한 문장을 적는다.&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//Exception2이 발생했을 경우, 이를 처리하기 위한 문장을 적는다.&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eN&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//ExceptionN이 발생했을 경우, 이를 처리하기 위한 문장을 적는다.&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;여러 개의 catch블럭이 올 수 있지만, 이 중 발생한 예외의 종류와 일치하는 단 하나의 catch블럭만 실행된다.&lt;/li&gt;
  &lt;li&gt;if문과 같은 문법과 달리, 괄호({ })를 절대 생략할 수 없다.&lt;/li&gt;
  &lt;li&gt;try-catch문은 여러개 반복해서 사용할 수 있고, try-catch문 안에 또 다른 try-catch문의 선언도 가능하다.
    &lt;ul&gt;
      &lt;li&gt;중첩된 try-catch문을 사용할 때 같은 이름의 참조변수를 사용해서는 안된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-try-catch문-흐름&quot;&gt;2. try-catch문 흐름&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;try블럭 내에서 예외가 발생한 경우
    &lt;ul&gt;
      &lt;li&gt;발생한 예외와 일치하는 catch블럭이 있는지 확인한다.&lt;/li&gt;
      &lt;li&gt;일치하는 catch블럭을 찾으면, 그 catch블럭 내의 문장들을 수행하고 전체 try-catch문을 빠져나가서 그 다음 문장을 계속해서 수행한다.
(try블럭 내의 예외 발생 시점 밑의 코드들은 수행하지 않는다.)&lt;/li&gt;
      &lt;li&gt;일치하는 catch블럭을 찾지 못하면, 예외는 처리되지 못한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;tyr블럭 내에서 예외가 발생하지 않은 경우
    &lt;ul&gt;
      &lt;li&gt;catch블럭을 거치지 않고 전체 try-catch문을 빠져나가서 계속해서 수행한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-catch블럭&quot;&gt;3. catch블럭&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;예외가 발생했을 때, 생성되는 예외 클래스의 인스턴스에는 발생한 예외에 대한 정보가 담겨져 있으며, getMessage()와 printStackTrace()를 통해서 이 정보에 접근가능하다.&lt;/li&gt;
  &lt;li&gt;printStackTrace(): 예외발생 당시의 호출스택(Call Stack)에 있었던 메서드의 정보와 예외 메시지를 화면에 출력한다.
    &lt;ul&gt;
      &lt;li&gt;printStackTrace(PrintStream s)나 printStackTrace(PrintWriter s)를 통해 예외에 대한 정보를 파일에 저장할 수도 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;getMessage(): 발생한 예외클래스의 인스턴스에 저장된 메시지를 얻을 수 있다.&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;멀티 catch블럭: JDK1.7부터 여러 catch블럭을 ‘&lt;/td&gt;
          &lt;td&gt;‘기호를 이용해서 하나의 catch블럭으로 합칠 수 있다.&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
    &lt;ul&gt;
      &lt;li&gt;조상과 자손 관계를 연결 시킬수는 없다.&lt;/li&gt;
      &lt;li&gt;예외 클래스들의 공통 분모인 조상 예외 클래스에 선언된 멤버만을 사용할 수 있고, 참조변수는 ‘e’로 고정된다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;strong&gt;&lt;em&gt;기존 catch 블럭 코드&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ExceptionA&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printStackTrace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ExceptionB&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;e2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printStackTrace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;strong&gt;&lt;em&gt;멀티 catch 블럭 코드&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ExceptionA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExceptionB&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printStackTrace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;예외-발생시키기&quot;&gt;예외 발생시키기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;키워드 ‘throw’를 사용해서 프로그래머가 고의로 예외를 발생시킬 수 있다.&lt;/li&gt;
  &lt;li&gt;사용 방법
    &lt;ul&gt;
      &lt;li&gt;연산자 new를 이용해서 발생시키려는 예외 클래스의 객체를 만든다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Exception e = new Exception(&quot;고의로 발생시킴&quot;);&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;키워드 throw를 이용해서 예외를 발생시킨다. &lt;code class=&quot;highlighter-rouge&quot;&gt;throw e;&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;예외를 고의로 발생시켰다면, 반드시 그 예외에 대한 처리를 해주어야 한다.(try-catch문)
    &lt;ul&gt;
      &lt;li&gt;Exception 클래스(checked 예외)의 경우, 처리를 해주지 않으면 컴파일 단계에서 오류가 발생한다.&lt;/li&gt;
      &lt;li&gt;RuntimeException 클래스(unchecked 예외)의 경우, 컴파일에는 성공하지만 비정상적으로 종료된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;메서드에-예외-선언하기&quot;&gt;메서드에 예외 선언하기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;try-catch문 외에, 메서드의 선언부에 키워드 ‘throws’를 사용해서 메서드 내에서 발생할 수 있는 예외를 선언해주면 된다.
    &lt;ul&gt;
      &lt;li&gt;예외가 여러개일 경우, 쉼표(,)로 구분하고, 키워드 ‘throw’와 구분해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Exception1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Exception2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExceptionN&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//메서드 내용&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;메서드의 선언부에 예외를 선언함으로써, 메서드를 사용하려는 사람이 해당 메서드를 사용하기 위해 어떠한 예외들을 처리해야 하는지 알려 줄 수 있다.
    &lt;ul&gt;
      &lt;li&gt;예외 발생 가능성을 예측해야 하는 프로그래머들의 수고를 덜어주고, 보다 견고한 프로그램 코드를 작성할 수 있다.&lt;/li&gt;
      &lt;li&gt;특히, JAVA API 작성된 메서드를 사용할때 보다 정확히 사용할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;대부분 RuntimeException클래스는 적어 주지 않고, 반드시 처리해주어야 하는 예외들만 선언한다.&lt;/li&gt;
  &lt;li&gt;예외가 발생한 메서드에서 예외처리를 해주지 않으면, 그 메서드를 호출한 메서드에게 예외를 넘겨준다.
    &lt;ul&gt;
      &lt;li&gt;예외가 발생하면, 해당 메서드나 호출한 메서드 둘 중 한 곳에서는 예외 처리를 해주어야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;finally-블럭&quot;&gt;finally 블럭&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;finally블럭은 try-catch문과 함께 예외의 발생여부에 상관없이 실행되어야할 코드를 포함 시킬 목적으로 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//예외가 발생할 가능성이 있는 문장들&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//예외처리를 위한 문장&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//예외의 발생여부에 관계없이 항상 수행되어야하는 문장들&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;finally블럭은 try-catch문의 맨 마지막에 위치해야 한다.&lt;/li&gt;
  &lt;li&gt;실행 순서는 다음과 같다.
    &lt;ul&gt;
      &lt;li&gt;예외 발생: try -&amp;gt; catch -&amp;gt; finally&lt;/li&gt;
      &lt;li&gt;그 외: try -&amp;gt; finally&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;try블럭에 return문이 있은 경우에도, finally블럭을 실행한 후에 return문이 실행된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;자동-자원-반환---try-with-resourced문&quot;&gt;자동 자원 반환 - try-with-resourced문&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;JDK1.7부터 try-with-resourced문이라는 try-catch문 번형이 새로 추가되었다.&lt;/li&gt;
  &lt;li&gt;주로 입출력(I/O)과 관련된 클래스를 사용할 때 주로 사용된다.
    &lt;ul&gt;
      &lt;li&gt;입출력이 끝난 자원을 반환할 때, finally문을 사용한다고 해도 여기서 오류가 발생하면 처리해줄 수 없기 때문에 try-with-resourced문을 사용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;예제&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fis&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileInputStream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;score.dat&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dis&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DataInputStream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;score&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;readInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;score&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;score&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EOFException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;점수의 총합은 &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;입니다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ie&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ie&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printStackTrace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;try-with-resourced문dml 괄호()안에 객체를 생성하는 문장을 넣으면, 이 객체는 따로 close()를 호출하지 않아도 try블럭을 벗어나는 순간 자동으로 close()가 호출된다.
    &lt;ul&gt;
      &lt;li&gt;그 다음에 catch블럭 또는 finally블럭이 수행된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;괄호()안에 두 문장 이상을 넣을 경우 세미콜론(;)으로 구분해주고, 변수 선언도 가능하다.
    &lt;ul&gt;
      &lt;li&gt;선언된 변수는 try블럭안에서만 사용가능하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;사용자-정의-예외&quot;&gt;사용자 정의 예외&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;프로그래머가 직접 Exception클래스로부터 상속을 받아 클래스를 만들거나, 필요에 따라 새로운 예외 클래스를 만들 수 있다.
    &lt;ul&gt;
      &lt;li&gt;기존 예외 클래스를 상속받아 만드는 것을 추천한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;예제&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyException&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;privatee&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ERR_CODE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;//생성자&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;MyException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;//조상인 Excepton클래스의 생성자를 호출한다.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ERR_CODE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;//생성자&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;MyException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;//ERR_CODE를 100을 기본값으로 초기화한다.&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;//에러 코드를 얻을 수 있는 메서드&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getErrCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ERR_CODE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;예외-되던지기exception-re-throwin&quot;&gt;예외 되던지기(exception re-throwin)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;하나의 예외에 대해서 예외가 발생한 메서드와 호출한 메서드 양쪽에서 처리하고자 할때, 예외 되던지기 방법을 사용한다.&lt;/li&gt;
  &lt;li&gt;예외 되던지기는 예외를 처리한 후에 인위적으로 다시 발생시키는 것을 말한다.&lt;/li&gt;
  &lt;li&gt;예외가 발생한 메서드에서는 try-catch문으로 예외를 처리해줌과 동시에 메서드의 선언부에 발생할 예외를 throws에 지정해줘야 한다.&lt;/li&gt;
  &lt;li&gt;예제&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExceptionEX&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;method1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;main메서드에서 예외가 처리되었습니다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;method1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;method1메서드에서 예외가 처리되었습니다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//다시 예외를 발생시킨다.&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;결과 화면&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;method1메서드에서 예외가 처리되었습니다.
main메서드에서 예외가 처리되었습니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;연결된-예외chained-exception&quot;&gt;연결된 예외(chained exception)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;한 예외가 다른 예외를 발생시킬 수 있다.
    &lt;ul&gt;
      &lt;li&gt;예를 들어, A가 예외 B를 발생시켰다면, A를 B의 ‘원인 예외(cause exception)’라고 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;initCause&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cause&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//지정한 예외를 원인 예외로 등록&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getCause&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;                   &lt;span class=&quot;c1&quot;&gt;//원인 예외를 반환&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;연결된 예외를 사용하는 이유
    &lt;ul&gt;
      &lt;li&gt;여러가지 예외를 하나의 큰 분류의 예외로 묶어서 다루기 위함이다.&lt;/li&gt;
      &lt;li&gt;checked예외를 unchecked예외로 바꾸기 위함이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="개념 정리" /><summary type="html">Java 개념</summary></entry><entry><title type="html">[Java]JAVA 변수와 자료형</title><link href="https://codemcd.github.io/pages/CODEMCD/java/Java-%EB%B3%80%EC%88%98%EC%99%80%EC%9E%90%EB%A3%8C%ED%98%95/" rel="alternate" type="text/html" title="[Java]JAVA 변수와 자료형" /><published>2018-10-14T00:00:00+09:00</published><updated>2018-10-14T00:00:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/java/Java-%EB%B3%80%EC%88%98%EC%99%80%EC%9E%90%EB%A3%8C%ED%98%95</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/java/Java-%EB%B3%80%EC%88%98%EC%99%80%EC%9E%90%EB%A3%8C%ED%98%95/">&lt;h1 id=&quot;java-변수와-자료형&quot;&gt;JAVA 변수와 자료형&lt;/h1&gt;

&lt;h2 id=&quot;변수와-자료형-정의&quot;&gt;변수와 자료형 정의&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;변수: 단 하나의 값(data)을 저장할 수 있는 메모리 공간&lt;/li&gt;
  &lt;li&gt;자료형: 변수에 저장할 값의 유형&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;변수의-명명규칙&quot;&gt;변수의 명명규칙&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;대소문자가 구분되며 길이에 제한이 없다.
    &lt;ul&gt;
      &lt;li&gt;True와 true는 서로 다른 것으로 간주된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;예약어를 사용해서는 안 된다.
    &lt;ul&gt;
      &lt;li&gt;true는 예약어라서 사용할 수 없지만, True는 가능하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;숫자로 시작해서는 안 된다.
    &lt;ul&gt;
      &lt;li&gt;top10은 허용되지만, 7up은 혀용되지 않는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;특수문자는 ‘_’ 와 ‘$’ 만을 허용한다.&lt;/li&gt;
  &lt;li&gt;그 외 프로그래머들간의 규칙
    &lt;ul&gt;
      &lt;li&gt;이는 필수는 아니지만 코드의 가독성을 위해 프로그래머들간의 약속이다.&lt;/li&gt;
      &lt;li&gt;클래스 이름의 첫 글자는 항상 대문자로 한다.
        &lt;ul&gt;
          &lt;li&gt;클래스 이름은 ASCII코드로 하는 것이 좋다.(일부 운영체제에서 유니코드를 인식하지 못한다.)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;변수와 메서드의 이름의 첫 글자는 항상 소문자로 한다.&lt;/li&gt;
      &lt;li&gt;여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 한다.&lt;/li&gt;
      &lt;li&gt;상수의 이름은 모두 대문자로 한다.&lt;/li&gt;
      &lt;li&gt;여러 단어로 이루어진 경우 ‘_‘로 구분한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;상수와-리터럴constant--literal&quot;&gt;상수와 리터럴(constant &amp;amp; literal)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;상수: 선언과 동시에 초기화하며, 이 초기화된 값은 변경할 수 없다.(변수 앞에 final 기호를 붙임)&lt;/li&gt;
  &lt;li&gt;리터럴: 그 자체로 값을 의미하는 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;year&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2014&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MAX_VALUE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//변수: year&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//상수: MAX_VALUE&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//리터럴: 2014, 100&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;기본형primitive-type&quot;&gt;기본형(Primitive type)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;기본형에는 모두 8개의 자료형이 있으며, 크게 논리형, 문자형, 정수형, 실수형으로 구분된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;논리형&quot;&gt;논리형&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;true와 false 중 하나를 값으로 갖으며, 조건식과 논리적 계산에 사용된다.&lt;/li&gt;
  &lt;li&gt;기본값(default)은 false이다.&lt;/li&gt;
  &lt;li&gt;두 가지 값만을 사용하므로 1bit만으로 충분하지만 자바의 최소단위가 1byte이기 때문에 논리형의 크기는 1byte이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;자료형&lt;/th&gt;
      &lt;th&gt;저장 가능한 값의 범위&lt;/th&gt;
      &lt;th&gt;bit&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;byte&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;boolean&lt;/td&gt;
      &lt;td&gt;false, true&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;문자형&quot;&gt;문자형&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;문자를 저장하기 위한 변수를 선언할 때 사용한다.&lt;/li&gt;
  &lt;li&gt;자료형은 char 하나이며, 크기는 2byte 이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;자료형&lt;/th&gt;
      &lt;th&gt;저장 가능한 값의 범위&lt;/th&gt;
      &lt;th&gt;bit&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;byte&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;char&lt;/td&gt;
      &lt;td&gt;0 ~ 2^16 -1,(0 ~ 65535)&lt;/td&gt;
      &lt;td&gt;16&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;특수 문자&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;특수 문자&lt;/th&gt;
      &lt;th&gt;문자 리터럴&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;tab&lt;/td&gt;
      &lt;td&gt;\t&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;backspace&lt;/td&gt;
      &lt;td&gt;\b&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;form feed&lt;/td&gt;
      &lt;td&gt;\f&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;new line&lt;/td&gt;
      &lt;td&gt;\n&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;carriage return&lt;/td&gt;
      &lt;td&gt;\r&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;역슬래쉬()&lt;/td&gt;
      &lt;td&gt;\&lt;/td&gt;
      &lt;td&gt;ㅅ&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;작은따옴표&lt;/td&gt;
      &lt;td&gt;'&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;큰따옴표&lt;/td&gt;
      &lt;td&gt;&quot;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;유니코드(16진수)문자&lt;/td&gt;
      &lt;td&gt;\u유니코드(ex, char a = ‘\u0041’)&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;정수형&quot;&gt;정수형&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;정수값을 저장하는데 사용된다.&lt;/li&gt;
  &lt;li&gt;자료형은 byte 크기순으로 byte(1), short(2), int(4), long(8) 이 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;자료형&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;저장 가능한 값의 범위&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;bit&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;byte&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;byte&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-2^7 ~ 2^7-1 (-128 ~ 127)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;성능보다 저장공간을 절약하는 것이 중요할 때 사용된다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;short&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-2^15 ~ 2^15-1 (-32,768 ~ 32,767)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;16&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;byte타입과 같은 이유로 사용된다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;int&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-2^31 ~ 2^31-1 (약 +/-20억)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;32&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;JVM의 피연산자 스택은 4byte단위로 저장하기 때문에 같은 크기를 사용하는 int 타입이 가장 효율적이다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;long&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-2^63 ~ 2^63-1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;64&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;int타입의 범위를 넘어사는 수를 저장할 때 사용된다.(리터럴에 접미사 ‘L’을 붙임)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;오버플로우: 연산과정에서 타입이 표현할 수 있는 값의 범위를 넘어서는 것을 말하며, 에러가 발생하지는 않지만 예상할 수 없는 값을 얻게 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;실수형&quot;&gt;실수형&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;실수값을 저장하는데 사용된다.&lt;/li&gt;
  &lt;li&gt;실수형의 타입은 float와 double 이 있으며, 다른 자료형과 달리 소수점을 표현하기 때문에 정밀도가 존재한다.&lt;/li&gt;
  &lt;li&gt;해당 리터럴에 접미사 ‘f’, ‘d’ 를 붙여야 한다.&lt;/li&gt;
  &lt;li&gt;실수형은 큰 값을 표현하는 것과 얼마나 ‘0’에 가깝게 표현할 수 있는가도 중요하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;자료형&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;저장 가능한 값의 범위(양수)&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;정밀도&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;bit&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;byte&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;float&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1.4 * 10^-45 ~ 3.4 * 10^38&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7자리&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;32&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;double&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4.9 * 10^-324 ~ 1.8 * 10^308&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;15자리&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;64&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;오버플로우: 실수형에서 오버플로우가 발생하면 해당 변수의 값은 무한대가 된다.&lt;/li&gt;
  &lt;li&gt;언더플로우: 실수형으로 표현할 수 없는 아주 작은 값의 경우 해당 변수의 값은 ‘0’이 된다.&lt;/li&gt;
  &lt;li&gt;실수형의 저장형식
    &lt;ol&gt;
      &lt;li&gt;flaot: 1 + 8 + 23 = 32(4byte)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;| S(1) |      E(8)     |         M(23)         |
|:—-:|:————-:|:———————:|&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;double: 1 + 11 + 52 = 64(8byte)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;| S(1) |        E(11)       |              M(52)              |
|:—-:|:——————:|:——————————-:|&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;기호&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;의미&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;S&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;부호(Sign bit)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;크기: 1 bit, 0이면 양수, 1이면 음수&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;E&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;지수(Exponent)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;부호있는 정수, 지수의 범위는 float: -127 ~ 128, double: -1023 ~ 1024&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;M&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;가수(Mantissa)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;실제 값을 저장하는 부분, float: 10진수로 7자리, double: 15자리 정밀도로 저장가능&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;출력---printf&quot;&gt;출력 - printf()&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;기본 출력&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;지시자&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;자료형&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;%b&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;boolean&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;%d&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;int&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10진수&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;%o&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;int&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8진수&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;%x, %X&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;int&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;16진수&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;%f&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;float&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10진수&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;%e, %E&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;지수형태표현&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;%c&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;char&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;문자&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;%s&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;string&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;문자열&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;특수 출력&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[%s]%n&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;//문자열의 길이만큼 출력공간을 확보한다.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[%20s]%n&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//최소 20글자 출력공간 확보(우측정렬)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[%-20s]%n&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//최소 20글자 출력공간 확보(좌측정렬)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[%.8s]%n&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//왼쪽에서 8글자만 출력&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;finger&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;finger = [%5d]%n&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;finger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//finger = [   10]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;finger = [%-5d]%n&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;finger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//finger = [10   ]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;finger = [%05d]%n&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;finger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//finger = [00010]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="개념 정리" /><summary type="html">Java 개념</summary></entry><entry><title type="html">[Java]9. 상속(Inhertance)</title><link href="https://codemcd.github.io/pages/CODEMCD/java/Java-9.-%EC%83%81%EC%86%8D/" rel="alternate" type="text/html" title="[Java]9. 상속(Inhertance)" /><published>2018-10-14T00:00:00+09:00</published><updated>2018-10-14T00:00:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/java/Java-9.%20%EC%83%81%EC%86%8D</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/java/Java-9.-%EC%83%81%EC%86%8D/">&lt;h1 id=&quot;9-상속inhertance&quot;&gt;9. 상속(Inhertance)&lt;/h1&gt;

&lt;h2 id=&quot;상속의-정의와-장점&quot;&gt;상속의 정의와 장점&lt;/h2&gt;
&lt;h3 id=&quot;1-정의&quot;&gt;1. 정의&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;상속: 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-장점&quot;&gt;2. 장점&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;코드의 재사용성
    &lt;ul&gt;
      &lt;li&gt;보다 적은 양의 코드로 새로운 클래스를 작성할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로그램의 생상성 향상과 유지보수가 간단함
    &lt;ul&gt;
      &lt;li&gt;코드를 공통적으로 관리할 수 있기 때문에 코드의 추가 및 변경이 매우 용이하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-특징&quot;&gt;3. 특징&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;상속의 구현 방법
    &lt;ul&gt;
      &lt;li&gt;클래스의 이름 뒤에 상속받고자 하는 클래스의 이름을 키워드 ‘&lt;strong&gt;extends&lt;/strong&gt;‘와 함께 작성하면 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Child&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;용어
    &lt;ul&gt;
      &lt;li&gt;조상 클래스: 부모(parent)클래스, 상위(super)클래스, 기반(base)클래스&lt;/li&gt;
      &lt;li&gt;자손 클래스: 자식(child)클래스, 하위(sub)클래스, 파생된(derived)클래스&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;상속계층도(class hierarchy)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Parent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Child&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/46916597-c1cb5480-cff7-11e8-81b2-b8fba36ec62d.JPG&quot; alt=&quot;class hierarchy&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자손 클래스는 조상 클래스의 모든 멤버를 상속 받으므로 항상 조상 클래스보다 같거나 많은 멤버를 갖는다.
    &lt;ul&gt;
      &lt;li&gt;접근 제어자가 private 또는 default인 멤버들은 상속은 받지만 자손 클래스로부터의 접근이 제한된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;생성자와 초기화 블럭은 상속되지 않는다.&lt;/li&gt;
  &lt;li&gt;클래스간 관계에서는 형제 관계는 존재하지 않고 오직 상속 관계만 존재한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-예제&quot;&gt;4. 예제&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;예제 코드&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Tv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;power&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//전원상태(on/off)&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//채널&lt;/span&gt;

	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;power&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;power&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;power&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;channelUp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;channelDown&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CaptionTv&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;caption&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//캡션상태(on/ofF)&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;displayCaption&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;caption&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//캡션상태가 true면 해당 text를 출력한다.&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CaptionTvTest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;CaptionTv&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CaptionTv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;ctv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;channel&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;                    &lt;span class=&quot;c1&quot;&gt;//조상 클래스로부터 상속받은 멤버&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;ctv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;channelUp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;                     &lt;span class=&quot;c1&quot;&gt;//조상 클래스로부터 상속받은 멤버&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;ctv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;displayCaption&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;ctv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;caption&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;ctv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;displayCaption&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;실행 결과&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;11
Hello World
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;상속계층도&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/46916595-c132be00-cff7-11e8-92a9-ae870e7bfdcb.JPG&quot; alt=&quot;class hierarchy ex&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;벤다이어그램&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/34755287/46916598-c1cb5480-cff7-11e8-832e-0d9ef73f8912.JPG&quot; alt=&quot;diagram ex&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;클래스간의-관계---포함composite관계&quot;&gt;클래스간의 관계 - 포함(Composite)관계&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;상속이외에 클래스를 재사용하는 방법으로서, 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// x좌표&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// y좌표&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Circle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 원점 (x, y) 좌표, 포함관계&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// 반지름&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;클래스간의-관계-결정하기&quot;&gt;클래스간의 관계 결정하기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;상속 관계: ‘~은 ~이다. (is-a)’&lt;/li&gt;
  &lt;li&gt;포함 관계: ‘~은 ~을 가지고 있다. (has-a)’&lt;/li&gt;
  &lt;li&gt;예제
    &lt;ul&gt;
      &lt;li&gt;원(Circle)은 점(Point)를 가지고 있다. =&amp;gt; 포함 관계 (‘원은 점이다’는 어색하다.)&lt;/li&gt;
      &lt;li&gt;스포츠카(SportsCar)는 차(Car)이다. =&amp;gt; 상속 관계&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;단일-상속single-inheritance&quot;&gt;단일 상속(Single inheritance)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;JAVA에서는 단일 상속만을 허용한다.
    &lt;ul&gt;
      &lt;li&gt;C++에서는 다중 상속을 허용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단일 상속 특징
    &lt;ul&gt;
      &lt;li&gt;클래스 간의 관계가 명확하다.&lt;/li&gt;
      &lt;li&gt;코드의 신뢰성을 높인다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다중 상속 특징
    &lt;ul&gt;
      &lt;li&gt;여러 클래스로부터 상속을 받을 수 있기 때문에 복합적인 기능을 가지는 클래스를 쉽게 작성할 수 있다.&lt;/li&gt;
      &lt;li&gt;서로 다른 클래스로부터 상속받은 멤버간의 이름이 같은 경우 구별할 수 있는 방법이 없다. (큰 단점)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;object-클래스---모든-클래스의-조상&quot;&gt;Object 클래스 - 모든 클래스의 조상&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;모든 클래스의 상속계층도의 최상위에는 Object 클래스가 있다.&lt;/li&gt;
  &lt;li&gt;상속을 명시하지 않는 클래스는 컴파일러가 자동으로 ‘extends Object’를 추가한다.
    &lt;ul&gt;
      &lt;li&gt;상속이 명시되어 있다면 추가하지 않는다. (다중 상속이 안되기 때문)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="개념 정리" /><summary type="html">Java 객체지향프로그래밍</summary></entry><entry><title type="html">[Java]8. 변수의 초기화</title><link href="https://codemcd.github.io/pages/CODEMCD/java/Java-8.-%EB%B3%80%EC%88%98%EC%9D%98-%EC%B4%88%EA%B8%B0%ED%99%94/" rel="alternate" type="text/html" title="[Java]8. 변수의 초기화" /><published>2018-10-14T00:00:00+09:00</published><updated>2018-10-14T00:00:00+09:00</updated><id>https://codemcd.github.io/pages/CODEMCD/java/Java-8.%20%EB%B3%80%EC%88%98%EC%9D%98%20%EC%B4%88%EA%B8%B0%ED%99%94</id><content type="html" xml:base="https://codemcd.github.io/pages/CODEMCD/java/Java-8.-%EB%B3%80%EC%88%98%EC%9D%98-%EC%B4%88%EA%B8%B0%ED%99%94/">&lt;h1 id=&quot;8-변수의-초기화&quot;&gt;8. 변수의 초기화&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;멤버변수(클래스 변수와 인스턴스 변수)는 초기화하지 않아도 자동적으로 자료형에 맞는 기본값으로 초기화한다.&lt;/li&gt;
  &lt;li&gt;지역변수는 사용하기 전에 반드시 초기화해야 한다.&lt;/li&gt;
  &lt;li&gt;각 타입의 기본값(default value)&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;자료형&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;기본값&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;boolean&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;false&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;char&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;‘\u000’&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;byte, short, int&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;long&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0L&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;float&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0.0f&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;double&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0.0d or 0.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;참조형 변수&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;null&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;멤버변수-초기화-방법&quot;&gt;멤버변수 초기화 방법&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;명시적 초기화(explicit initialization)&lt;/li&gt;
  &lt;li&gt;생성자(constructor)&lt;/li&gt;
  &lt;li&gt;초기화 블럭(initialization block)&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;명시적 초기화
    &lt;ul&gt;
      &lt;li&gt;변수를 선언과 동시에 초기화하는 것을 말한다.&lt;/li&gt;
      &lt;li&gt;가장 우선시되는 초기화 방법&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;classs&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Car&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;door&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;              &lt;span class=&quot;c1&quot;&gt;//기본형 변수의 초기화&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Engine&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Engine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//참조형 변수의 초기화&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;초기화 블럭
    &lt;ul&gt;
      &lt;li&gt;클래스 초기화 블럭: 클래스변수의 복잡한 초기화에 사용된다.
        &lt;ul&gt;
          &lt;li&gt;클래스내에 블럭 &lt;code class=&quot;highlighter-rouge&quot;&gt;static { }&lt;/code&gt;만들고 그 안에 코드를 작성한다.&lt;/li&gt;
          &lt;li&gt;클래스가 메모리에 처음 로딩될 때 한 번 수행된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;인스턴스 초기화 블럭: 인스턴스변수의 복잡한 초기화에 사용된다.
        &lt;ul&gt;
          &lt;li&gt;클래스 내에 블럭 &lt;code class=&quot;highlighter-rouge&quot;&gt;{ }&lt;/code&gt; 만들고 그 안에 코드를 작성한다.&lt;/li&gt;
          &lt;li&gt;생성자와 같이 인스턴스를 생성할 때 마다 수행된다. &lt;strong&gt;(생성자보다 인스턴스 초기화 블럭이 먼저 수행된다.)&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;생성자는 주로 인스턴스 변수의 초기화에 사용되고, 초기화 블럭은 모든 생성자에 공통적으로 수행되어야할 코드를 삽입한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;초기화 블럭 내에서 조건문, 반복문, 예외처리구문 등을 사용할 수 있다.&amp;lt;/&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;예제 코드&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BlockTest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//클래스 초기화 블럭&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;static { }, 클래스 초기화 블럭&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//인스턴스 초기화 블럭&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{ }, 인스턴스 초기화 블럭&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//생성자&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;BlockTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;생성자&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bt1 인스턴스 생성 전&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;BlockTest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bt1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BlockTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bt1 인스턴스 생성 후&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bt2 인스턴스 생성 전&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;BlockTest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bt2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BlockTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bt2 인스턴스 생성 후&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;실행 결과&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static { }, 클래스 초기화 블럭
bt1 인스턴스 생성 전
{ } 인스턴스 초기화 블럭
생성자
bt1 인스턴스 생성 후
bt2 인스턴스 생성 전
{ } 인스턴스 초기화 블럭
생성자
bt2 인스턴스 생성 후
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;멤버변수 초기화 시기와 순서
    &lt;ul&gt;
      &lt;li&gt;클래스변수의 초기화 시점: 클래스가 처음 로딩될 때 단 한 번 초기화 된다.&lt;/li&gt;
      &lt;li&gt;클래스변수의 초기화 순서: 기본값 -&amp;gt; 명시적 초기화 -&amp;gt; 클래스 초기화 블럭&lt;/li&gt;
      &lt;li&gt;인스턴스변수의 초기화 시점: 인스턴스가 생성될 때마다 각 인스턴스별로 초기화가 이루어진다.&lt;/li&gt;
      &lt;li&gt;인스턴스변수의 초기화 순서: 기본값 -&amp;gt; 명시적 초기화 -&amp;gt; 인스턴스 초기화 블럭 -&amp;gt; 생성자&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>CODEMCD</name><email>psbum1609@gmail.com</email></author><category term="개념 정리" /><summary type="html">Java 객체지향프로그래밍</summary></entry></feed>