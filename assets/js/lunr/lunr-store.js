var store = [{
        "title": "[ALGOSPOT]DRAGON",
        "excerpt":"Dragon 문제 링크   https://algospot.com/judge/problem/read/DRAGON코드 분석 k번째 답을 계산하는 동적 계획법   더 간단한 문제 풀기          드래곤 커브 문자열의 일부를 계산하는 문제 대신 문자열 중 주어진 위치의 한 글자만을 계산하는 문제로 바꾼다.      이 문제를 빠르게 풀 수 있다면 l번 반복만 한다면 문제를 해결할 수 있다.      결과적으로, n세대 드래곤 커브의 p번째 글자를 찾는 것으로 변경한다.        p번째 글자를 찾는 함수          먼저 전체 드래곤 커브 문자열을 생성하는 알고리즘을 재귀적인 방법으로 구현한다.      curve(seed, generations) = 초기 문자열 seed를 generations세대 진화시킨 결과를 출력한다.      위 함수에서 p번째 글자만을 출력하기 위해 skip 전역변수(건너뛰어야 하는 글자 수)를 두어, 문자열 혹은 문자를 출력할 때마다 skip과 출력할 부분의 길이를 비교한다.        계산 결과 미리 계산하기(동적 계획법)          p번째 글자를 출력하는 재귀 호출 코드를 최적화하려면, 재귀 호출 때마다 몇 글자를 출력할지를 미리 알고 skip과 이 값을 비교할 수 있어야 한다.      genrations 세대 값의 크기에 상관 없이, 이전 세대의 드래곤 커브를 계속 유지하며 확장하기 때문에 skip 값의 길이 만큼의 generations 세대까지만 가면 된다.      curve(seed, generations)함수에서 seed는 ‘X+TF’ 혹은 ‘FX-Y’로 확장하기 때문에 간단히 동적 계획법 알고리즘을 만들 수 있다.                  xLength(n) = 문자열 “X”를 n세대  진화시킨 결과의 길이 반환          yLength(n) = 문자열 “Y”를 n세대  진화시킨 결과의 길이 반환          xLength(n) = xLength(n - 1) + yLength(n - 1) + 2          yLength(n) = xLength(n - 1) + yLength(n - 1) + 2          최적화: length(n) = length(n - 1) * 2 + 2                      시간 복잡도          재귀 호출 함수가 최대 n번 호출되고, 출력 길이 l의 최대 값이 50이므로, O(n * 50)이다.      결과적으로, O(n)이다.      결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cassert&gt;using namespace std;#define min(a,b) ((a) &lt; (b) ? (a) : (b))#define N 51//오버 플로 방지const int MAX = 1000000000 + 51;//length[i] = X나 Y를 i번 치환 후의 길이int length[N];//계산 결과를 미리 계산하는 동적 계획법 알고리즘void precalc() {\tlength[0] = 1;\tfor (int i = 1; i &lt; N; ++i)\t\tlength[i] = min(MAX, length[i - 1] * 2 + 2);}const string EXPAND_X = \"X+YF\";const string EXPAND_Y = \"FX-Y\";//dragonCurve를 generations 진화시킨 결과에서 skip번째 문자를 반환한다.char expand(const string &amp;dragonCurve, int generations, int skip) {\t//기저 사례\tif (generations == 0) {\t\t//assert(skip &lt; (int)dragonCurve.size());\t\treturn dragonCurve[skip];\t}\tfor (int i = 0; i &lt; (int)dragonCurve.size(); ++i) {\t\t//문자열이 확장되는 경우\t\tif (dragonCurve[i] == 'X' || dragonCurve[i] == 'Y') {\t\t\tif (skip &gt;= length[generations])\t\t\t\tskip -= length[generations];\t\t\telse if (dragonCurve[i] == 'X')\t\t\t\treturn expand(EXPAND_X, generations - 1, skip);\t\t\telse\t\t\t\treturn expand(EXPAND_Y, generations - 1, skip);\t\t}\t\t//확장되진 않지만 건너뛰어야 할 경우\t\telse if (skip &gt; 0)\t\t\t--skip;\t\t//답을 찾은 경우\t\telse\t\t\treturn dragonCurve[i];\t}\treturn '#';  //이 줄은 수행되지 않음}int main(){\tint tc; scanf(\"%d\", &amp;tc);\tprecalc();\twhile (tc--) {\t\tint n, p, l; scanf(\"%d %d %d\", &amp;n, &amp;p, &amp;l);\t\tstring seed = \"FX\";\t\tfor (int skip = p - 1; skip &lt; p + l - 1; ++skip)\t\t\tprintf(\"%c\", expand(seed, n, skip));\t\tprintf(\"\\n\");\t}\treturn 0;}","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-DRAGON/",
        "teaser":null},{
        "title": "[ALGOSPOT]ARCTIC",
        "excerpt":"남극 기지 문제 링크   https://algospot.com/judge/problem/read/ARCTIC코드 분석 1. 최적화 문제 결정 문제로 바꿔 풀기   최적화 문제: optimize(P)          P에 주어진 기지들을 모두 연결하는 연락망을 구축할 때 가능한 최소 무전기 반경은 얼마인가?      기지들을 모두 연결하는 연락망의 경우의 수는 매우 많으며, 이 중 무전기의 반경 d가 최소화되는 답을 찾고 있으므로 이 문제는 최적화 문제이다.        결정 문제: decision(P, d)          모든 기지를 하나로 연결하되, 가장 먼 두 가지 간의 거리가 d 이하인 연락망이 있는가?      이 질문은 “x 또는 그보다 좋은 답이 있는가?”의 형태를 유지하고 있다.      이 질문의 구현은 서로 거리가 d 이하인 기지들이 하나로 연결될 수 있는지를 확인한다.                  너비 우선 탐색 알고리즘          두 기지 사이의 거리를 이용하는 암시적 그래프를 탐색한다.                      시간 복잡도          너비 우선 탐색의 시간 복잡도: O(V + E)      거리 계산: O(n^2)      결과적으로, O(n^2)이다.      2. 다른 해법   크루스칼의 최소 스패닝 알고리즘  플로이드의 모든 쌍 최단 거리 알고리즘결과 코드   최적화 문제 결정문제로 바꿔 풀기#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;#define abs(a) ((a) &gt; 0 ? (a) : (-1 * a))#define N 101vector&lt;pair&lt;double, double&gt;&gt; bsv;double dist[N][N];int n;//두 기지 사이 거리 계산double calcDist(int b1, int b2) {\tdouble dy = (bsv[b1].first - bsv[b2].first) *\t\t(bsv[b1].first - bsv[b2].first);\tdouble dx = (bsv[b1].second - bsv[b2].second) *\t\t(bsv[b1].second - bsv[b2].second);\treturn sqrt(dy + dx);}//거리 d인하인 기지들만을 연결했을 때 모든 기지가 연결되는지 여부를 반환한다.bool decision(double d) {\tvector&lt;bool&gt; visited(n, false);\tvisited[0] = true;\tqueue&lt;int&gt; q;\tq.push(0);\tint seen = 0;\twhile (!q.empty()) {\t\tint here = q.front();\t\tq.pop();\t\t++seen;\t\tfor(int there = 0; there &lt; n; ++there)\t\t\tif (!visited[there] &amp;&amp; dist[here][there] &lt;= d) {\t\t\t\tvisited[there] = true;\t\t\t\tq.push(there);\t\t\t}\t}\treturn seen == n;}//모든 기지를 연결할 수 있는 최소 d를 반환한다.double optimize() {\tdouble lo = 0, hi = 1416.00;\tfor (int it = 0; it &lt; 100; ++it) {\t\tdouble mid = (lo + hi) / 2;\t\t//mid가 가능하다면, 더 좋은(작은) 답을 찾는다.\t\tif (decision(mid))\t\t\thi = mid;\t\t//mid가 불가능하다면, 더 나쁜(큰) 답을 찾는다.\t\telse\t\t\tlo = mid;\t}\treturn hi;}int main(){\tint tc; scanf(\"%d\", &amp;tc);\twhile(tc--) {\t\tbsv.clear();\t\tmemset(dist, 0, sizeof(dist));\t\tscanf(\"%d\", &amp;n);\t\tfor (int i = 0; i &lt; n; i++) {\t\t\tdouble y, x; scanf(\"%lf %lf\", &amp;y, &amp;x);\t\t\tbsv.push_back({ y, x });\t\t}\t\tfor (int i = 0; i &lt; n; i++)\t\t\tfor (int j = 0; j &lt; n; j++)\t\t\t\tdist[i][j] = calcDist(i, j);\t\tprintf(\"%.2lf\\n\", optimize());\t}\treturn 0;}","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-ARCTIC/",
        "teaser":null},{
        "title": "[ALGOSPOT]ASYMTILING",
        "excerpt":"비대칭 타일링 문제 링크   https://algospot.com/judge/problem/read/ASYMTILING](https://algospot.com/judge/problem/read/ASYMTILING)코드 분석 전체 타일링 경우의 수 - 대칭 타일링 경우의 수   전체 타일링 경우의 수는 쉽게 구할 수 있다.  비대칭 타일링 경우의 수를 찾는 것 보다 대칭 타일링 경우의 수를 찾는 것이 더욱 간단하다.   n이 홀수인 경우, 위 그림의 (a)에 해당한다.  n이 짝수인 경우, 위 그림의 (b)와 (c)에 해당한다.  회색부분은 양쪽이 대칭이기 때문에 한 부분의 경우의 수만 빼주면 된다.  두 값을 빼줄 때, mod계산에 주의하자!  시간복잡도: 전체 타일링의 경우의 수 O(n) + 대칭 타일링 경우의 수 O(n) = 총 O(n) 이다.비대칭 타일링 경우의 수   총 4가지 패턴의 비대칭 방법이 있다.   (a), (b): 가운데 남은 회색 부분을 덮은 방법을 재귀 호출로 찾는다. 물론 이 방법은 대칭이 아니어야 한다.  (c), (d): 가운데 남은 회색 부분을 덮는 방법을 찾으며, 이는 대칭이어도 상관없다.  시간복잡도: O(n)  답이 제대로 나오지 않음 - 보류…결과 코드   전체 타일링 경우의 수 - 대칭 타일링 경우의 수#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define N 101#define M 1000000007int tile[N];int asymmetric(int width){\tif (width % 2 == 1)  //(a)\t\treturn (tile[width] - tile[width / 2] + M) % M;\tint ret = tile[width];\tret = (ret - tile[width / 2 - 1] + M) % M;  //(b)\tret = (ret - tile[width / 2] + M) % M;      //(c)\treturn ret;}int main(void){\t//전체 타일링 경우의 수 구하기\ttile[1] = 1; tile[2] = 2;\tfor (int i = 3; i &lt; N; i++)\t\ttile[i] = (tile[i - 1] % M + tile[i - 2] % M) % M;\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tint n;\t\tscanf(\"%d\", &amp;n);\t\tif (n == 1 || n == 2)\t\t\tprintf(\"0\\n\");\t\telse\t\t\tprintf(\"%d\\n\", asymmetric(n));\t}\treturn 0;}","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-ASYMTILNG/",
        "teaser":null},{
        "title": "[ALGOSPOT]BOARDCOVER",
        "excerpt":"BOARDCOVER 문제 링크   https://algospot.com/judge/problem/read/BOARDCOVER내 코드 분석 논리 분석   한 칸에 8개의 L자 모양을 만들 수 있다.  재귀 함수를 이용하여, 전체 경우의 수를 계산한다.  하지만, 아직 재귀 함수가 익숙하지 않아 완성하지 못하였다.  재귀 함수 공부를 위해 다른 방법은 생각하지 않았다.해답 논리 분석   재귀 호출의 각 단계마다 아직 흰 칸중에서 가장 윗 줄, 가장 왼쪽 칸부터 덮도록 규칙을 정한다.  위 규칙을 적용하면, 위에서 정한 칸 이전은 모두 채워졌다는 것을 알 수 있으므로 내가 생각했던 8가지 모양이 아니라 4가지 모양이 나온다. (아래 그림 참고) 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;//주어진 칸을 덮을 수 있는 네 가지 방법//블록을 구성하는 세 칸의 상대적 위치 (dy, dx)의 목록(위 그림 참고)const int coverType[4][3][2] = {\t{ { 0, 0 },{ 1, 0 },{ 0, 1 } },\t{ { 0, 0 },{ 0, 1 },{ 1, 1 } },\t{ { 0, 0 },{ 1, 0 },{ 1, 1 } },\t{ { 0, 0 },{ 1, 0 },{ 1, -1 } }};//board의 (y, x)를 type번 방법으로 덮거나, 덮었던 블록을 없앤다.//delta = 1이면 덮고, -1이면 덮었던 블록을 없앤다.//만약 블록이 제대로 덮이지 않은 경우(게임판 밖으로 나가거나, 겹쳐지거나, 검은 칸일 때) false를 반환한다.bool set(vector&lt;vector&lt;int&gt;&gt;&amp;board, int y, int x, int type, int delta){\tbool ok = true;\tfor (int i = 0; i &lt; 3; i++) {\t\tconst int ny = y + coverType[type][i][0];\t\tconst int nx = x + coverType[type][i][1];\t\tif (ny &lt; 0 || ny &gt;= (int)board.size() || nx &lt; 0 || nx &gt;= (int)board[0].size())\t\t\tok = false;\t\telse if ((board[ny][nx] += delta) &gt; 1)\t\t\tok = false;\t}\treturn ok;}//board의 모든 빈 칸을 덮을 수 있는 방법의 수를 반환한다.//board[i][j] = 1 이미 덮인 칸 혹은 검은 칸//board[i][j] = 0 아직 덮이지 않은 칸int cover(vector&lt;vector&lt;int&gt;&gt;&amp;board){\t//아직 채우지 못한 칸 중 가장 윗줄 왼쪽에 있는 칸을 찾는다.\tint y = -1, x = -1;  //flag 기능을 추가하기 위해 -1로 초기화\tfor (int i = 0; i &lt; (int)board.size(); i++) {\t\tfor (int j = 0; j &lt; (int)board[i].size(); j++) {\t\t\tif (board[i][j] == 0) {\t\t\t\ty = i;\t\t\t\tx = j;\t\t\t\tbreak;\t\t\t}\t\t}\t\tif (y != -1) break;\t}\t//기저 사례: 모든 칸을 채웠으면 1을 반환한다.\tif (y == -1) return 1;\tint ret = 0;\tfor (int type = 0; type &lt; 4; type++) {\t\t//만약 board[y][x]를 type 형태로 덮을 수 있으면 재귀 호출한다.\t\tif (set(board, y, x, type, 1))\t\t\tret += cover(board);\t\t//덮었던 블록을 치운다.\t\tset(board, y, x, type, -1);\t}\treturn ret;}int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tvector&lt;vector&lt;int&gt;&gt; board;\t\tvector&lt;int&gt; v;\t\tchar row[21];\t\tint h, w;\t\tscanf(\"%d %d\", &amp;h, &amp;w);\t\tfor (int i = 0; i &lt; h; i++) {\t\t\tscanf(\"%s\", row);\t\t\tfor (int j = 0; j &lt; w; j++) {\t\t\t\tif (row[j] == '#')\t\t\t\t\tv.push_back(1);\t\t\t\telse\t\t\t\t\tv.push_back(0);\t\t\t}\t\t\tboard.push_back(v);\t\t\tv.clear();\t\t}\t\t/*for (int i = 0; i &lt; (int)board.size(); i++) {\t\t\tfor (int j = 0; j &lt; (int)board[i].size(); j++) {\t\t\t\tprintf(\"%d \", board[i][j]);\t\t\t}\t\t\tprintf(\"\\n\");\t\t}*/\t\tprintf(\"%d\\n\", cover(board));\t}\treturn 0;}결과 및 코드 분석   수행 시간: 0ms  최대 시간 복잡도: 블록을 하나 놓을 때마다 4가지 선택지가 있다. 최대 16개의 블록을 놓기 때문에 가능한 최대 연산 수는 4^16(2^32)으로시간내에 불가능하게 느껴진다. 하지만 6칸이 있다고 가정하면, 4^2으로 16가지 방법이 있어야 하는데 실제로 계산하면 2가지 방법밖에 없다.이렇게 프로그램을 작성하고 직접 여러 예제를 넣어 이론과 다른 실제 시간복잡도를 계산할 수 있어야 한다.알아둘 점 1) 재귀를 구현하는 논리 흐름2) 이중 Vector 함수   사용법 (위 main함수 참고)vector&lt;vector&lt;int&gt;&gt; board;vector&lt;int&gt; v;char row[21];int h, w;scanf(\"%d %d\", &amp;h, &amp;w);for (int i = 0; i &lt; h; i++) {\t\tscanf(\"%s\", row);\t\tfor (int j = 0; j &lt; w; j++) {\t\t\tif (row[j] == '#')\t\t\t\tv.push_back(1);\t\t\telse\t\t\t\tv.push_back(0);\t\t}\t\tboard.push_back(v);\t\tv.clear();}  장점          크기를 지정하지 않고 입력을 줄 수 있다.      STL이기 때문에 효율성을 보장받을 수 있다.      ","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-BOARDCOVER/",
        "teaser":null},{
        "title": "[ALGOSPOT]BOGGLE",
        "excerpt":"BOGGLE 문제 링크   https://algospot.com/judge/problem/read/BOGGLE내 코드 분석 논리 분석   char 형인 알파벳을 아스키 코드값을 이용하여 int형으로 사용한다.  check 배열을 선언하여 5 x 5 배열입력에서 사용된 알파벳을 저장하여 문자 입력 시 5 x 5 배열에 없는 알파벳이 있을 경우 바로 ‘NO’를 출력한다.(시간복잡도를 줄이기 위함)  BFS를 활용하여 문자가 5 x 5배열에서 만들어질 수 있는지 판단한다.  check_cnt 배열은 BFS 수행과정에서 해당 문자의 다음 알파벳을 비교하기 위해 수행과정에서의 문자 길이를 갱신한다.구현 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;#define N 26bool check[N];  // 5 x 5 맵에 입력된 알파벳 종류 확인int check_cnt[5][5];  // BFS에서 다음 문자 알파벳을 판단하기 위한 2차원 배열int map[5][5];  // 5 x 5 알파벳을 입력할 2차원 배열int word[11];  // 문자를 저장할 배열int mx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };int my[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };void init(void){\tfor (int i = 0; i &lt; 5; ++i)\t\tfor (int j = 0; j &lt; 5; ++j)\t\t\tmap[i][j] = 0;\tfor (int i = 0; i &lt; N; ++i)\t\tcheck[i] = false;\tfor (int i = 0; i &lt; 11; ++i)\t\tword[i] = -1;\tfor (int i = 0; i &lt; 5; ++i)\t\tfor (int j = 0; j &lt; 5; ++j)\t\t\tcheck_cnt[i][j] = 0;}void init_cnt(void){\tfor (int i = 0; i &lt; 5; ++i)\t\tfor (int j = 0; j &lt; 5; ++j)\t\t\tcheck_cnt[i][j] = 0;}int main(void){\tint tc;\tcin &gt;&gt; tc;\t//scanf(\"%d\", &amp;tc);\t//while (getchar() != '\\n');  //입력 버퍼에서 엔터 지우기\twhile (tc--) {\t\tinit();  //다음 테스트 케이스를 위한 초기화\t\tfor (int i = 0; i &lt; 5; ++i) {  // 5 x 5 알파벳 배열 입력\t\t\tfor (int j = 0; j &lt; 5; ++j) {\t\t\t\tchar alph;\t\t\t\t//scanf(\"%c\", &amp;alph);\t\t\t\tcin &gt;&gt; alph;\t\t\t\tmap[i][j] = alph - 'A';  //char -&gt; int 로 사용하기 위함\t\t\t\tif (!check[alph - 'A'])  \t\t\t\t\tcheck[alph - 'A'] = true;\t\t\t}\t\t\t//while (getchar() != '\\n');\t\t}\t\tint n;\t\tcin &gt;&gt; n;\t\t//scanf(\"%d\", &amp;n);\t\t//while (getchar() != '\\n');\t\tint str_len;  //단어 길이\t\tbool flag = false;  // 단어를 맵에서 찾을 수 있으면 TRUE, 못 찾으면 FALSE\t\tpair&lt;int, int&gt; p;  //큐에 2차원 배열 인덱스를 저장하기 위한 pair\t\tqueue&lt;pair&lt;int, int&gt;&gt; q;  //BFS를 위한 큐\t\tfor (int i = 0; i &lt; n; ++i) {\t\t\tfor (int ii = 0; ii &lt; 11; ++ii)  //단어 입력 초기화\t\t\t\tword[ii] = -1;\t\t\tflag = false;\t\t\tchar inputW[11];\t\t\tcin &gt;&gt; inputW;\t\t\t//scanf(\"%s\", inputW);\t\t\t//while (getchar() != '\\n');\t\t\tstr_len = strlen(inputW);\t\t\tfor (int j = 0; j &lt; str_len; ++j)\t\t\t\tword[j] = inputW[j] - 'A';\t\t\tfor (int j = 0; j &lt; str_len; ++j) {  //map에 알파벳이 없을 때 바로 NO출력하고 다음 단어\t\t\t\tif (!check[word[j]]) {\t\t\t\t\tfor (int l = 0; l &lt; str_len; ++l)\t\t\t\t\t\tprintf(\"%c\", word[l] + 'A');\t\t\t\t\tprintf(\" NO\\n\");\t\t\t\t\tflag = true;\t\t\t\t}\t\t\t\tif (flag) break;\t\t\t}\t\t\tif (str_len == 1 &amp;&amp; check[word[0]]) {  //문자 길이가 1일 때 처리\t\t\t\tfor (int ll = 0; ll &lt; str_len; ++ll)\t\t\t\t\tprintf(\"%c\", word[ll] + 'A');\t\t\t\tprintf(\" YES\\n\");\t\t\t\tflag = true;\t\t\t}\t\t\tif (flag) continue;  //문자 판단이 끝났으므로 다음으로 넘어감\t\t\tflag = false;\t\t\tfor (int j = 0; j &lt; 5; ++j) {\t\t\t\tfor (int k = 0; k &lt; 5; ++k) {\t\t\t\t\tif (map[j][k] == word[check_cnt[j][k]]) {  // 5 x 5 배열중 문자의 첫 알파벳 위치\t\t\t\t\t\tp = make_pair(j, k);\t\t\t\t\t\tq.push(p);  //큐에 삽입\t\t\t\t\t\twhile (!q.empty()) {\t\t\t\t\t\t\tint nowx = q.front().second;\t\t\t\t\t\t\tint nowy = q.front().first;\t\t\t\t\t\t\tq.pop();\t\t\t\t\t\t\tfor (int l = 0; l &lt; 8; ++l) {  // 8방향으로 모두 체크\t\t\t\t\t\t\t\tint nextx = nowx + mx[l];\t\t\t\t\t\t\t\tint nexty = nowy + my[l];\t\t\t\t\t\t\t\tif (!flag &amp;&amp; nextx &gt;= 0 &amp;&amp; nextx &lt; 5 &amp;&amp; nexty &gt;= 0 &amp;&amp; nexty &lt; 5) {  // 5 x 5 배열 밖으로 나갔는지 체크\t\t\t\t\t\t\t\t\tif (word[check_cnt[nowy][nowx] + 1] != -1 &amp;&amp; map[nexty][nextx] == word[check_cnt[nowy][nowx] + 1]) {  // 다음 알파벳과 일치하면\t\t\t\t\t\t\t\t\t\tcheck_cnt[nexty][nextx] = check_cnt[nowy][nowx] + 1;  // 현재 문자열 길이 갱신\t\t\t\t\t\t\t\t\t\tif ((check_cnt[nexty][nextx] + 1) == str_len) {  // 현재 체크중인 문자열 길이와 최종 문자열 길이가 일치하면 YES출력\t\t\t\t\t\t\t\t\t\t\tflag = true;\t\t\t\t\t\t\t\t\t\t\tfor (int ll = 0; ll &lt; str_len; ++ll)\t\t\t\t\t\t\t\t\t\t\t\tprintf(\"%c\", word[ll] + 'A');\t\t\t\t\t\t\t\t\t\t\tprintf(\" YES\\n\");\t\t\t\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\tp = make_pair(nexty, nextx);\t\t\t\t\t\t\t\t\t\tq.push(p);\t\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t}\t\t\t\t\t\t\tif (flag) break;\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t\tinit_cnt();\t\t\t\t\twhile (!q.empty()) q.pop();  //정답을 제출하고 바로 반복문을 빠져나갔기 때문에 큐에 남은 인덱스가 있을 수 있기 때문\t\t\t\t\tif (flag) break;\t\t\t\t}\t\t\t\tif (flag) break;\t\t\t}\t\t\tif (!flag) {  //못찾으면 NO 출력\t\t\t\tfor (int l = 0; l &lt; str_len; ++l)\t\t\t\t\tprintf(\"%c\", word[l] + 'A');\t\t\t\tprintf(\" NO\\n\");\t\t\t}\t\t}\t}\treturn 0;}결과   수행 시간 : 4ms  오답  디버깅과 직접 그리면서 코드를 분석하였지만 틀린 부분을 찾을 수 없었다.  위의 참고 예제를 통과하면 왠만한 예제는 통과하였다고 생각한다.  다른 의견          재귀를 활용하여 구현하면 시간 초과가 난다고 한다.      다이나믹 프로그래밍으로 구현하는 것이 가장 효율적이라고 생각한다.      알아둘 점 1) 입력 버퍼 지우기 while (getchar() != '\\n');  문자열을 입력할 때 입력버퍼에 엔터키(\\n)가 남아있는 현상으로 다음 문자열을 입력할 때 제대로된 입력을 받을 수 없었다.  입력함수 바로 밑에 위의 코드를 추가하여 해결하였다.  cin 을 사용하여 해결할 수도 있다.2) BFS에서 경로 순서 확인하기   BFS는 큐를 활용하기 때문에 경로를 찾아가는 것이 순차적으로 하기 않는다.  위의 이유로 똑같은 크기의 2차원 배열을 선언하여 이전의 값에 +1을 하며 해당 배열에 저장한다.  위의 코드에서는 check_cnt 배열이 그 역할을 한다.해답 코드   출처 : http://b.mystika.me/26#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;char map[5][5];char word[11];int dp[5][5][10];int mx[8] = { 0,1,1,1,0,-1,-1,-1 };int my[8] = { -1,-1,0,1,1,1,0,-1 };int solve(int y, int x, int idx){\tint &amp;ret = dp[y][x][idx];\t//초기화 오류 처리\tif (ret != -1) return ret;\tfor (int i = 0; i &lt; 8; i++) {\t\tint nexty = y + my[i];\t\tint nextx = x + mx[i];\t\tif (nexty &gt;= 0 &amp;&amp; nexty &lt; 5 &amp;&amp; nextx &gt;= 0 &amp;&amp; nextx &lt; 5) {\t\t\t//단어와 일치되는 알파벳을 찾았을 때,\t\t\tif (map[nexty][nextx] == word[idx]) {\t\t\t\t//단어의 다음 문자가 NULL이면, 모두 찾았기 때문에 TRUE를 반환\t\t\t\tif (word[idx + 1] == '\\0') return ret = 1;\t\t\t\t//아직 단어를 찾을 것이 남아있다면 다시 재귀함수 호출\t\t\t\tret = solve(nexty, nextx, idx + 1);  \t\t\t\t//문자열을 찾았다면 남은 재귀함수에서 모두 1(TRUE)값을 반환하여 마지막 결과에 1을 반환하도록 한다.\t\t\t\tif (ret) return ret;\t\t\t}\t\t}\t}\t//문자를 모두 매칭할 수 없으므로 FALSE를 반환\treturn false;}int find(){\tfor (int i = 0; i &lt; 5; i++) {\t\tfor (int j = 0; j &lt; 5; j++) {\t\t\tint &amp;ret = dp[i][j][0];\t\t\t//초기화가 안됬다면 바로 리턴(오류 처리)\t\t\tif (ret != -1) return ret;\t\t\t//첫 단어를 map에서 찾았다면\t\t\tif (map[i][j] == word[0]) {\t\t\t\tret = solve(i, j, 1);\t\t\t\tif (ret) return ret;\t\t\t}\t\t}\t}\treturn false;}int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tfor (int i = 0; i &lt; 5; i++)\t\t\tscanf(\"%s\", map[i]);\t\tint n;\t\tscanf(\"%d\", &amp;n);\t\tfor (int i = 0; i &lt; n; i++) {\t\t\tmemset(dp, -1, sizeof(dp));\t\t\tscanf(\"%s\", word);\t\t\tprintf(\"%s %s\\n\", word, find() ? \"YES\" : \"NO\");\t\t}\t}\treturn 0;}  출처를 참고하여 다시 구현해 본 코드이다.  DP를 사용하였으며, dp[y][x][idx]는 해당 맵의 좌표(map[y][x])에서 현재 단어(word[idx]) 이후를 찾을 수 있는지를 판단한다.알아둘 점 1) 재귀함수를 이용하여 DP를 구현하는 방식 2) 삼항 연산자를 이용하여 간단히 출력하는 방식   특히, 삼항 연산자를 사용하기 위해 함수를 사용한 부분을 참고하자.","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-BOGGLE/",
        "teaser":null},{
        "title": "[ALGOSPOT]DARPA",
        "excerpt":"DARPA Grand Challenge 문제 링크   https://algospot.com/judge/problem/read/DARPA코드 분석 최적화 문제 결정 문제로 바꿔 풀기   최적화 문제          optimize(locations, cameras) = 카메라를 설치할 수 있는 위치 locations와 카메라의 수 cameras가 주어질 때, 카메라 간 최소 간격의 최대치를반환한다.        결정 문제          decision(locations, cameras, gap) = 카메라를 설치할 수 있는 위치 locations와 카메라의 수 cameras가 주어질 때, 이들을 적절히 배치해모든 카메라의 간격이 gap이상이 되도록 하는 방법이 있는가?      “카메라 간의 최소 간격이 gap인 방법이 있는가?”가 아니라 “카메라들의 간의 최소 간격이 gap이상인 방법이 있는가?” 임을 유의하자.                  이와 같이 질문해야 최적화 문제를 풀 수 있다.          “이상”이라 함은 그 범위의 값들을 모두 포함할 수 있기 때문에 답의 후보 범위를 계속 반으로 줄여서 최적화를 할 수 있다.(이분법)                    카메라들이 항상 xkm 이상 떨어져 있다고 할때, 0km위치에 카메라를 항상 설치할 수 있다.                  만약, 0km에 설치하지 않는다고 하면 이를 0km로 옮겨도 똑같은 답이 된다.          결과적으로, 탐욕법으로 이 문제를 해결할 수 있다는 사실을 떠올릴 수 있어야 한다.                      구현 함수          optimize(): 이분법을 구현하는 함수이다.      decision(): 첫 번째로 만나는 위치에 무조건 카메라를 설치한 뒤, 각 위치를 순회하며 카메라를 설치할 수 있을때마다 카메라를 설치한다. 그 후설치한 카메라의 수가 문제에서 요구한 설치 개수 이상이 되면 참을 반환한다      결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;//결정 문제: 정렬되어 있는 locations 중 cameras를 선택해 모든 카메라 간의 간격이//gap 이상이 되는 방법이 있는지를 반환한다.bool decision(const vector&lt;double&gt; &amp;location, int cameras, double gap) {\t//카메라를 설치할 수 있을 때마다 설치하는 탐욕적 알고리즘\tdouble limit = -1;\tint installed = 0;\tfor (int i = 0; i &lt; (int)location.size(); i++) {\t\tif (limit &lt;= location[i]) {\t\t\t++installed;\t\t\t//location[i] + gap 이후는 되어야 카메라를 설치할 수 있다.\t\t\tlimit = location[i] + gap;\t\t}\t}\t//결과적으로 cameras대 이상을 설치할 수 있으면 참 반환\treturn installed &gt;= cameras;}//최적화 문제: 정렬되어 있는 locations 중 cameras를 선택해 최소 간격을 최대화 한다.double optimize(const vector&lt;double&gt; &amp;location, int cameras) {\tdouble lo = 0., hi = 241.;\t//반복문 불변식: decision(lo) &amp;&amp; !decision(hi)\tfor (int it = 0; it &lt; 100; it++) {\t\tdouble mid = (lo + hi) / 2.0;\t\t//간격이 mid 이상이 되도록 할 수 있으면 답은 [mid, hi]에 있다.\t\tif (decision(location, cameras, mid))\t\t\tlo = mid;\t\t//간격이 mid 이상이 되도록 할 수 없으면 답은 [lo, mid]에 있다.\t\telse\t\t\thi = mid;\t}\treturn lo;}int main(){\tint tc; scanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tint n, m; scanf(\"%d %d\", &amp;n, &amp;m);\t\tvector&lt;double&gt; lv;\t\tfor (int i = 0; i &lt; m; i++) {\t\t\tdouble in; scanf(\"%lf\", &amp;in);\t\t\tlv.push_back(in);\t\t}\t\tprintf(\"%.2lf\\n\", optimize(lv, n));\t}\treturn 0;}","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-DARPA/",
        "teaser":null},{
        "title": "[ALGOSPOT]DICTIONARY",
        "excerpt":"고대어 사전 문제 링크   https://algospot.com/judge/problem/read/DICTIONARY코드 분석 위상 정렬 문제 1. 그래프 모델링   각 알파벳을 정점으로 표현하고, 한 알파벳이 다른 알파벳 앞에 와야 할 때 두 정점을 방향 간선으로 연결한다.          문제가 원하는 알파벳들의 순서는 위 그래프의 위상 정렬 결과가 된다.      makeGraph()함수가 이를 구현하는 모습을 볼 수 있다.        2. 인접한 단어들만 검사하기               만약 세 단어 A, B, C가 순서대로 등장한다면, (A,C)는 검사하지 않고 (A,B), (B,C)만 검사해도 답을 해결할 수 있다.          예를 들어, A = impr, C = impo 라고 할때, B는 다음과 같이 3가지의 경우가 있다.                  B의 네 번째 글자가 ‘r’인 경우: (B,C)를 검사할 때 ‘r’이 ‘o’보다 앞에 온다는 사실을 알 수 있다.          B의 네 번째 글자가 ‘o’인 경우: (A,B)를 검사할 때 ‘r’이 ‘o’보다 앞에 온다는 사실을 알 수 있다.          B의 네 번째 글자가 ‘r’, ‘o’ 둘다 아닌 경우: (A,B)를 검사할 때 ‘r’이 이 글자보다 앞에 온다는 사실을 알 수 있고, (B,C)를 검사할 때 이 글자가 ‘o’보다 앞에 온다는 사실을 알 수 있다. 결과적으로 ‘r’은 ‘o’보다 앞에 온다.            3. 위상 정렬 적용                                 위의 규칙을 적용하여 그래프를 생성한 뒤, 해당 그래프가 사이클이 없다면 문제의 사전은 논리에 맞는 것으로 알파벳 순서를 정상적으로 만들 수 있다.구현 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;#define min(a,b) ((a) &lt; (b) ? (a) : (b))//알파벳의 각 글자에 대한 인접 행렬 표현//간선 (i, j)는 알파벳 i가 j보다 앞에 와야 함을 나타낸다.vector&lt;vector&lt;int&gt;&gt; adj;//주어진 단어들로부터 알파벳 간의 선후관계 그래프를 생성한다.void makeGraph(const vector&lt;string&gt; &amp;words) {\tadj = vector&lt;vector&lt;int&gt;&gt;(26, vector&lt;int&gt;(26, 0));\tfor (int j = 1; j &lt; words.size(); ++j) {\t\tint i = j - 1, len = min(words[i].size(), words[j].size());\t\t//word[i]가 word[j]앞에 오는 이유를 찾는다.\t\tfor (int k = 0; k &lt; len; ++k)\t\t\tif (words[i][k] != words[j][k]) {\t\t\t\tint a = words[i][k] - 'a';\t\t\t\tint b = words[j][k] - 'a';\t\t\t\tadj[a][b] = 1;\t\t\t\tbreak;\t\t\t}\t}}vector&lt;int&gt; seen, order;void dfs(int here) {\tseen[here] = 1;\tfor (int there = 0; there &lt; adj.size(); ++there)\t\tif (adj[here][there] &amp;&amp; !seen[there])\t\t\tdfs(there);\torder.push_back(here);}//adj에 주어진 그래프를 위상정렬한 결과를 반환한다.//그래프가 DAG가 아니라면 빈 벡터를 반환한다.vector&lt;int&gt; topologicalSort() {\tint n = adj.size();\tseen = vector&lt;int&gt;(n, 0);\torder.clear();\tfor (int i = 0; i &lt; n; ++i)\t\tif (!seen[i])\t\t\tdfs(i);\treverse(order.begin(), order.end());\t//만약 그래프가 DAG가 아니라면 정렬 결과에 역방향 간선이 있다.\tfor (int i = 0; i &lt; n; ++i)\t\tfor (int j = i + 1; j &lt; n; ++j)\t\t\tif (adj[order[j]][order[i]])\t\t\t\treturn vector&lt;int&gt;();\t//없는 경우라면 깊이 우선 탐색에서 얻은 순서를 반환한다.\treturn order;}int main(){\tint tc; scanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tint n; scanf(\"%d\", &amp;n);\t\tvector&lt;string&gt; sv;\t\tfor (int i = 0; i &lt; n; i++) {\t\t\tstring str; cin &gt;&gt; str;\t\t\tsv.push_back(str);\t\t}\t\tmakeGraph(sv);\t\tvector&lt;int&gt; ans;\t\tans = topologicalSort();\t\tif (!ans.size())\t\t\tprintf(\"INVALID HYPOTHESIS\");\t\telse {\t\t\tfor (int i = 0; i &lt; ans.size(); ++i)\t\t\t\tprintf(\"%c\", ans[i] + 'a');\t\t}\t\tprintf(\"\\n\");\t}\treturn 0;}","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-DICTIONARY/",
        "teaser":null},{
        "title": "[ALGOSPOT]DRUNKEN",
        "excerpt":"음주 운전 단속 문제 링크   https://algospot.com/judge/problem/read/DRUNKEN코드 분석 플로이드 최단 거리 알고리즘   플로이드 알고리즘은 아무 정점도 경유하지 않은 최단 거리에서 시작해 경유할 수 있는 정점으르 하나씩 추가해 가며 최단 거리를 갱신한다.          이 과정에서 0번부터 V-1번까지 정점들을 순서대로 추가하지만, 이 순서는 단지 편의를 위함이지 순서가 바뀐다고 해도 알고리즘의 정당성에는 어떠한 영향도 미치지 않는다.        위 속성을 이용하여, 각 정점을 단속에 걸리는 시간 별로 오름차순으로 정렬한 뒤, 순서대로 플로이드 알고리즘을 수행하면 해당 문제의 답을 찾을 수 있다.          단속 시간이 짧은 정점부터 알고리즘을 수행하면, 순서대로 한 경유점의 가중치를 포함한 최단 거리를 계산하면서 가장 가중치가 큰 경유점에서의 최단 거리 경로를 찾을 수 있다. (오름차순으로 가중치가 가장 큰 경유점이 마지막에 있기 때문)      이는 플로이드 알고리즘은 반복문을 사용하기 때문에 경유점의 가중치가 입력된 순서가 결과값에 영향을 미치기 때문이다.        C_k(u, v) = k 혹은 그보다 단속 시간이 적게 걸리는 정점들만을 경유해서 u에서 v로 가는 최단 거리  W[][]: 최소 예상 시간  E[w]: 정점 w에서 소요되는 단속 시간    W[u][v] = min(C_w(u, w) + C_w(w, v) + E[w])      구현 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define N 501const int INF = 987654321;int map[N][N];//각 정점까지 음주단속 시간을 포함한 가장 짧은 시간을 저장int W[N][N];//각 정점에서 음주 운전 단속을 할 때 걸리는 시간int delay[N];int v, e;void solve() {\t//모든 정점들을 예상 시간 별로 정렬한다.\tvector&lt;pair&lt;int, int&gt;&gt; order;\tfor (int i = 0; i &lt; v; ++i)\t\torder.push_back(make_pair(delay[i], i));\tsort(order.begin(), order.end());\t//정점을 하나도 거치지 않고 얻을 수 있는 최단 경로\tfor (int i = 0; i &lt; v; ++i)\t\tfor (int j = 0; j &lt; v; ++j)\t\t\tif (i == j)\t\t\t\tW[i][j] = 0;\t\t\telse\t\t\t\tW[i][j] = map[i][j];\tfor (int k = 0; k &lt; v; ++k) {\t\t//k번째로 예상 시간이 적게 걸리는 정점 w까지를 지나서 얻을 수 있는 최단 거리\t\tint w = order[k].second;\t\tfor(int i=0; i&lt;v; ++i)\t\t\tfor (int j = 0; j &lt; v; ++j) {\t\t\t\tmap[i][j] = min(map[i][j], map[i][w] + map[w][j]);\t\t\t\tW[i][j] = min(W[i][j], map[i][w] + delay[w] + map[w][j]);\t\t\t}\t}}int main(){\tscanf(\"%d %d\", &amp;v, &amp;e);\tfor (int i = 0; i &lt; v; ++i)\t\tscanf(\"%d\", &amp;delay[i]);\tfor (int i = 0; i &lt; e; ++i) {\t\tint a, b, c;\t\tscanf(\"%d %d %d\", &amp;a, &amp;b, &amp;c);\t\tmap[a - 1][b - 1] = c;\t\tmap[b - 1][a - 1] = c;\t}\tfor (int i = 0; i &lt; v; ++i)\t\tfor (int j = 0; j &lt; v; ++j)\t\t\tif (!map[i][j])\t\t\t\tmap[i][j] = INF;\tsolve();\tint tc; scanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tint start, end;\t\tscanf(\"%d %d\", &amp;start, &amp;end);\t\tprintf(\"%d\\n\", W[start - 1][end - 1]);\t}\treturn 0;}","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-DRUNKEN/",
        "teaser":null},{
        "title": "[ALGOSPOT]FENCE",
        "excerpt":"FENCE 문제 링크   https://algospot.com/judge/problem/read/FENCE코드 분석   출처: 알고리즘 문제해결전략, 분할정복  n개의 판자를 절반으로 나눠 분할한다.          부분문제 1: 가장 큰 직사각형을 왼쪽 부분 문제에서만 잘라낼 수 있다.      부분문제 2: 가장 큰 직사각형을 오른쪽 부분 문제에서만 잘라낼 수 있다.      부분문제 3: 가장 큰 직사각형은 왼쪽 부분 문제와 오른쪽 부분 문제에 결쳐 있다.      중요 조건: 가장 큰 직사각형은 반드시 부분 문제 경계에 있는 두 판자를 포함한다.      결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;#define max(a, b) ((a) &gt; (b) ? (a) : (b))#define min(a, b) ((a) &lt; (b) ? (a) : (b))//각 판자의 높이를 저장하는 배열vector&lt;int&gt; h;//h[left,...,right]구간에서 찾아낼 수 있는 가장 큰 사각형의 넓이를 반환int solve(int left, int right){\t//기저 사례: 판자가 하나밖에 없는 경우\tif (left == right) return h[left];\t//[left, mid],[mid+1, right]의 두 구간으로 문제를 분할\tint mid = (left + right) / 2;\t//분할한 문제를 각개격파(부분문제1, 부분문제2)\tint ret = max(solve(left, mid), solve(mid + 1, right));\t//부분문제3: 두 부분에 모두 걸치는 사각형 중 가장 큰 것을 찾는다.\tint lo = mid;\tint hi = mid + 1;\tint height = min(h[lo], h[hi]);\t//[mid, mid+1]만 포합하는 너비 2인 사각형을 고려한다.\tret = max(ret, height * 2);\t//사각형이 입력 전체를 덮을 때까지 확장해 나간다.\twhile (left &lt; lo || hi &lt; right) {\t\t//left ~ right 범위안에 있을 경우\t\tif (hi &lt; right &amp;&amp; (lo == left || h[lo - 1] &lt; h[hi + 1])) {\t\t\thi++;\t\t\theight = min(height, h[hi]);\t\t}\t\telse {\t\t\tlo--;\t\t\theight = min(height, h[lo]);\t\t}\t\t//확장한 후 사각형의 넓이\t\tret = max(ret, height * (hi - lo + 1));\t}\treturn ret;}int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tint n;\t\tscanf(\"%d\", &amp;n);\t\tfor (int i = 0; i &lt; n; i++) {\t\t\tint height;\t\t\tscanf(\"%d\", &amp;height);\t\t\th.push_back(height);\t\t}\t\tprintf(\"%d\\n\", solve(0, n - 1));\t\th.clear();\t}\treturn 0;}","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-FENCE/",
        "teaser":null},{
        "title": "[ALGOSPOT]FIRETRUCKS",
        "excerpt":"소방차 문제 링크   https://algospot.com/judge/problem/read/FIRETRUCKS코드 분석 다익스트라 알고리즘 응용   이 문제에서 최대 정점 개수는 1000개, 최대 간선 개수는 50만개이므로, 아래와 같은 단순한 알고리즘으로는 풀 수 없다.          각 불난 위치에서 다익스트라 알고리즘을 실행하여 가장 가까운 소방서를 찾는다. (O(nElogV))      각 소방서마다 다익스트라 알고리즘을 실행하여 가장 가까운 불난 위치를 찾는다. (O(mElogV))      플로이드 알고리즘 (O(V^3))        이 문제는 어느 소방서에서 소방차가 오느냐는 중요하지 않고, 무조건 소방서로부터 거리만 최소로 하면 된다.  따라서, 모든 소방서를 임의의 한 정점으로 연결한 후, 거리를 0으로 두면 단 한번의 다익스트라 알고리즘으로 문제를 해결할 수 있다.   위 그래프는 임의의 정점을 추가한 모습이다.  시간 복잡도는 다익스트라 알고리즘과 같다.구현 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;deque&gt;#include &lt;map&gt;using namespace std;#define MAX_V 1001const int INF = 987654321;int v, e, n, m;vector&lt;pair&lt;int, int&gt;&gt; adj[MAX_V];//minDist: 한 소방서에서 각 불난 위치의 정점까지 최소 거리//fireStation: 소방서 정점//fire: 불난 위치 정점int minDist[MAX_V], fireStation[MAX_V], fire[MAX_V];void dijkstra(int src) {   vector&lt;int&gt; dist(v + 1, INF);   dist[src] = 0;   priority_queue&lt;pair&lt;int, int&gt;&gt; pq;   pq.push(make_pair(0, src));   while (!pq.empty()) {      int here = pq.top().second;      int cost = -pq.top().first;      pq.pop();      if (dist[here] &lt; cost) continue;      for (int i = 0; i &lt; adj[here].size(); ++i) {         int there = adj[here][i].first;         int nextDist = cost + adj[here][i].second;         if (dist[there] &gt; nextDist) {            dist[there] = nextDist;            pq.push(make_pair(-nextDist, there));         }         //해당 정점이 불난 위치이며, 현재까지의 거리보다 짧다면 갱신한다.         for (int j = 0; j &lt; n; ++j)            if (there == fire[j] &amp;&amp; minDist[fire[j]] &gt; nextDist)               minDist[fire[j]] = nextDist;      }   }}int main(){   int tc; scanf(\"%d\", &amp;tc);   while (tc--) {      for (int i = 0; i &lt; MAX_V; ++i) {         adj[i].clear();         minDist[i] = INF;         fireStation[i] = 0;         fire[i] = 0;      }      scanf(\"%d %d %d %d\", &amp;v, &amp;e, &amp;n, &amp;m);      for (int i = 0; i &lt; e; ++i) {         int a, b, t;         scanf(\"%d %d %d\", &amp;a, &amp;b, &amp;t);         adj[a].push_back(make_pair(b, t));         adj[b].push_back(make_pair(a, t));      }      for (int i = 0; i &lt; n; ++i)         scanf(\"%d\", &amp;fire[i]);      //소방서의 정점을 입력 받은 후, 임의의 정점 0을 연결한다.(거리 0)      for (int i = 0; i &lt; m; ++i) {         scanf(\"%d\", &amp;fireStation[i]);         adj[0].push_back(make_pair(fireStation[i], 0));      }      //임의의 정점 0을 시작으로 다익스트라 알고리즘을 한번 실행한다.      dijkstra(0);      int ans = 0;      for (int i = 0; i &lt; n; ++i)         ans += minDist[fire[i]];      printf(\"%d\\n\", ans);   }   return 0;}","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-FIRETRUCKS/",
        "teaser":null},{
        "title": "[ALGOSPOT]GALLERY",
        "excerpt":"감시 카메라 설치 문제 링크   https://algospot.com/judge/problem/read/GALLERY코드 분석 루트 없는 트리의 지배 집합 찾기   지배 집합(domination set): 각 정점이 자기 자신과 모든 인접한 정점들을 지배한다고 할때, 그래프의 모든 정점을 지배하는 정점들의 부분집합을 그래프의 지배 집합이라고 한다.          그래프에서 지배 집합을 찾는 문제는 NP-완전 문제 중 하나로, 정점 개수의 지수 함수에 비례한다.      1. 루트 없는 트리(unrooted tree)   이 문제가 그래프가 아닌 루트 없는 트리라는 것을 알 수 있는 점은 문제 속에 있다.          문제 설명의 마지막에 미술관에서 한 번 지나간 갤러리를 다시 지나기 위해서는 전에 지난 복도를 반드시 지나야 한다.      사이클이 없다. = 트리로 표현할 수 있다.        위와 같이 그래프가 트리의 형태를 하는 것을 루트 없는 트리라고 부른다.  어떤 그래프가 루트 없는 트리인지를 알기 위해서는 아래와 같은 특징 중 한 가지가 성립해야 한다.(서로 동치 관계에 있음)          정확히 V - 1개의 간선이 있다.      사이클이 존재하지 않는다.      두 정점 사이를 연결하는 단순 경로가 정확히 하나만 존재한다.      2. 루트 없는 트리 문제 풀기   루트 없는 트리를 다루는 가장 간단한 방법은 임의의 시작점에서 깊이 우선 탐색을 수행하는 것이다.  이 결과로 얻은 깊이 탐색 스패닝 트리는 원래 그래프의 구조를 그대로 가지면서, 부모 자식 관계르르 갖는 일반적인 트리 형태가 된다.  문제 설명에서 모든 갤러리가 서로 연결되어 있을 필요가 없다고 명시되어 있기 때문에, 그래프의 각 컴포넌트는 트리 형태인 것을 알 수 있다.3. 트리의 지배 집합 찾기   트리의 최소 지배 집합을 찾는 가장 간단한 방법은 트리의 맨 아래에서부터 시작해서 위로 올라오는 것이다.          잎 노드는 부모 노드와 자기 자신밖에 지배하지 못하므로, 최소 지배 집합을 만들 수 없기 때문에 절대 선택해선 안된다.        알고리즘 과정          잎 노드는 선택하지 않는다.      이 외의 노드에 대해, 트리의 맨 밑에서부터 올라오면서 다음과 같이 선택 여부를 결정 한다.                  자기 자손 중 아직 지배당하지 않은 노드가 하나라도 있다면 현재 노드를 선택한다.          이 외의 경우는 현재 노드를 선택하지 않는다.                      첫 번째 예제 데이터 그래프 형태 구현   dfs(here)는 here를 루트로 하는 서브트리를 방문하고, 반환하면서 해당 노드가 지배 집합의 일부인지, 다른 노드에 지배당하고 있는지, 지배당하지 않고 있는지 3가지 중 하나를 반환한다.  시간 복잡도: O(g + h)구현 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;#define MAX_V 1001int V;vector&lt;int&gt; adj[MAX_V];vector&lt;bool&gt; visited;const int UNWATCHED = 0;const int WATCHED = 1;const int INSTALLED = 2;//지금까지 설치한 카메라의 총 수int installed;//here로부터 깊이 우선 탐색을 하고, here의 정보를 반환한다.int dfs(int here) {\tvisited[here] = true;\tint children[3] = { 0,0,0 }; //UNWATCHED, WATCHED, INSTALLED 정보\tfor (int i = 0; i &lt; adj[here].size(); ++i) {\t\tint there = adj[here][i];\t\tif (!visited[there])\t\t\t++children[dfs(there)];\t}\t//자손 노드 중 감시되지 않는 노드가 있을 경우 카메라를 설치한다.\tif (children[UNWATCHED]) {\t\t++installed;\t\treturn INSTALLED;\t}\t//자손 노드 중 카메라가 설치된 노드가 있을 경우 설치할 필요가 없다.\tif (children[INSTALLED])\t\treturn WATCHED;\treturn UNWATCHED;}//그래프를 감시하는데 필요한 카메라의 최소 수를 반환한다.int installCamera() {\tinstalled = 0;\tvisited = vector&lt;bool&gt;(V, false);\tfor (int u = 0; u &lt; V; ++u)\t\tif (!visited[u] &amp;&amp; dfs(u) == UNWATCHED)\t\t\t++installed;\treturn installed;}int main(){\tint tc; scanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tfor (int i = 0; i &lt; MAX_V; ++i)\t\t\tadj[i].clear();\t\tint h; scanf(\"%d %d\", &amp;V, &amp;h);\t\tfor (int i = 0; i &lt; h; ++i) {\t\t\tint s, e; scanf(\"%d %d\", &amp;s, &amp;e);\t\t\tadj[s].push_back(e);\t\t\tadj[e].push_back(s);\t\t}\t\tprintf(\"%d\\n\", installCamera());\t}\treturn 0;}","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-GALLERY/",
        "teaser":null},{
        "title": "[ALGOSPOT]LIS",
        "excerpt":"LIS(Longest Increasing Sequence) 문제 링크   https://algospot.com/judge/problem/read/LIS코드 분석 Bottom-up   DP[N]: 현재 인덱스에서 가장 긴 증가 부분 수열의 길이를 저장한다.  Input[N]: 입력 값을 저장한다.  현재 인덱스가 i일 때, j: (1 ~ i - 1)중 만약 input[i] &lt; input[j]이라면 DP[i] = DP[j] + 1로 갱신한다.  갱신된 값 중 가장 큰 값을 해당 인덱스의 최적해로 판단한다.  시간 복잡도: 1 + 2 + 3 + ... + n이므로, O(n^2)이다.Top-down   chache[N]: 현재 인덱스에서 가장 긴 증가 부분 수열의 길이를 저장한다.(메모이제이션)  S[N]: 입력 배열  lis(start) = S[start]에서 시작하는 부분 증가 수열 중 최대의 길이를 반환한다.  별도의 기저 사례 없이, for문의 조건문을 이용한다.  시간 복잡도: 총 n개의 부분 문제를 갖고, 하나를 해결할 때마다 n번 연산하므로 O(n^2)이다.결과 코드   Bottom-up#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define N 501int dp[N];int input[N];int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tmemset(dp, 0, sizeof(dp));\t\tmemset(input, 0, sizeof(input));\t\tint n;\t\tscanf(\"%d\", &amp;n);\t\tfor (int i = 0; i &lt; n; i++)\t\t\tscanf(\"%d\", &amp;input[i]);\t\t//dp배열을 모두 1로 초기화(숫자가 한개 이면 길이가 1이기 때문)\t\tfor (int i = 0; i &lt; n; i++)\t\t\tdp[i] = 1;\t\t//i: 현재 인덱스, j: 이전 인덱스\t\t//dp배열에서 이전의 인덱스들의 값들은 최적해이다.\t\t//입력 배열에서 현재 인덱스의 값이 이전의 인덱스의 값보다 크다면\t\t//해당 dp배열의 값에서 1을 더하여 갱신하며, 갱신 값중의 최대값을 최적해라고 판단한다.\t\tfor (int i = 1; i &lt; n; i++) {\t\t\tfor (int j = 0; j &lt; i; j++) {\t\t\t\tif (input[j] &lt; input[i]) {\t\t\t\t\tif (dp[i] &lt; (dp[j] + 1))\t\t\t\t\t\tdp[i] = dp[j] + 1;\t\t\t\t}\t\t\t}\t\t}\t\tint max = 0;\t\tfor (int i = 0; i &lt; n; i++)\t\t\tif (max &lt; dp[i])\t\t\t\tmax = dp[i];\t\tprintf(\"%d\\n\", max);\t}\treturn 0;}  Top-down```cpp#define _CRT_SECURE_NO_WARNINGS#include #include #include using namespace std;#define max(a, b) ((a)&gt;(b)?(a):(b))#define N 501int n;int cache[N], S[N]; int lis(int start){\tint &amp;ret = cache[start];\tif (ret != -1) return ret;\tret = 1;\tfor (int next = start + 1; next &lt; n; ++next)\t\tif (S[start] &lt; S[next])\t\t\tret = max(ret, lis(next) + 1);\treturn ret;} int main(void){\tint tc;\tscanf(“%d”, &amp;tc);\twhile (tc–) {\t\tmemset(cache, -1, sizeof(cache));\t\tmemset(S, 0, sizeof(S)); \tscanf(\"%d\", &amp;n);\tfor (int i = 0; i &lt; n; i++)\t\tscanf(\"%d\", &amp;S[i]);\tint max = 0;\tfor (int i = 0; i &lt; n; i++) {\t\tint res = lis(i);\t\tif (max &lt; res)\t\t\tmax = res;\t}\tprintf(\"%d\\n\", max);}return 0; } ```","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-LIS/",
        "teaser":null},{
        "title": "[ALGOSPOT]MORSE",
        "excerpt":"모스 부호 사전 문제 링크   K번째 답 계산하기  https://algospot.com/judge/problem/read/MORSE코드 분석 1. 완전 탐색   장점인 신호가 단점인 신호보다 사전순으로 항상 앞으로 오는 모든 신호 만들기//s: 지금까지 만든 신호//n: 더 필요한 '-'의 개수//m: 더 필요한 'o'의 개수void generate(int n, int m, string s) {\t//기저 사례: n = m = 0\tif (n == 0 &amp;&amp; m == 0) {\t\tif (skip == 0) cout &lt;&lt; s &lt;&lt; endl;\t\t--skip;\t\treturn;\t}\tif (bino[n + m][n] &lt;= skip) {\t\tskip -= bino[n + m][n];\t\treturn;\t}\tif (n &gt; 0) generate(n - 1, m, s + \"-\");\tif (m &gt; 0) generate(n, m - 1, s + \"o\");}  k - 1개 건너뛰기//skip개를 건너뛰고 출력한다.void generate(int n, int m, string s) {\t//기저 사례: skip &lt; 0 (skip=-1이란 것은 이미 k번째 신호가 출력됨)\tif (skip &lt; 0) return;\t//기저 사례: n = m = 0\tif (n == 0 &amp;&amp; m == 0) {\t\t//더 건너뛸 신호가 없는 경우\t\tif (skip == 0) cout &lt;&lt; s &lt;&lt; endl;\t\t--skip;\t\treturn;\t}\tif (bino[n + m][n] &lt;= skip) {\t\tskip -= bino[n + m][n];\t\treturn;\t}\tif (n &gt; 0) generate(n - 1, m, s + \"-\");\tif (m &gt; 0) generate(n, m - 1, s + \"o\");}  전역 변수 skip은 k - 1로 초기화해야 한다.  시간 복잡도          n, m의 최대 크기는 각각 100이다.      모든 경우의 수는 이항 계수 C(n + m, n)이므로 C(200, 100)이다. 이는 시간내에 절대 계산할 수 없다.      2. 동적 계획법   모든 신호를 만드는 경우의 수는 C(n + m. n)이다.  skip이 C(n + m. n)와 같거나 크다면 generate(n, m, s)가 종료될 때, skip은 C(n + m. n)만큼 줄어 있고 답은 못찾은 상태이다.  그렇다면, 함수를 실행할 필요 없이 skip만 줄여 버리고 종료해도 똑같은 결과가 나온다.  skip 변수의 오버플로를 막기 위해 문제에서 k가 항상 10억 이하라는 점을 이용한다.          이항계수 계산을 C(n, r)대신 min( C(n, r), 10^9 )으로 한다.        시간 복잡도          generate() 함수는 k번째 신호 외에는 어떤 신호도 만들지 않는다. =&gt; O(n + m)      calcBino() 함수는 이항 계수를 미리 모두 계산하는 함수이다. =&gt; O(nm)      결과적으로, 총 시간 복잡도는 O(nm)이다.      결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;#define min(a,b) ((a) &lt; (b) ? (a) : (b))#define N 201//k의 최대값  + 100, 오버플로를 막기 위해 이보다 큰 값은 구하지 않는다.const int M = 1000000000 + 100;int bino[N][N];int skip;//필요한 모든 이항계수를 미리 계산해 둔다.void calcBino() {\tmemset(bino, 0, sizeof(bino));\tfor (int i = 0; i &lt; N; i++) {\t\tbino[i][0] = bino[i][i] = 1;\t\tfor (int j = 1; j &lt; i; j++)\t\t\tbino[i][j] = min(M, bino[i - 1][j - 1] + bino[i - 1][j]);\t}}//s: 지금까지 만든 신호//n: 더 필요한 '-'의 개수//m: 더 필요한 'o'의 개수//skip개를 건너뛰고 출력한다.void generate(int n, int m, string s) {\t//기저 사례: skip &lt; 0 (skip=-1이란 것은 이미 k번째 신호가 출력됨)\tif (skip &lt; 0) return;\t//기저 사례: n = m = 0\tif (n == 0 &amp;&amp; m == 0) {\t\t//더 건너뛸 신호가 없는 경우\t\tif (skip == 0) cout &lt;&lt; s &lt;&lt; endl;\t\t--skip;\t\treturn;\t}\tif (bino[n + m][n] &lt;= skip) {\t\tskip -= bino[n + m][n];\t\treturn;\t}\tif (n &gt; 0) generate(n - 1, m, s + \"-\");\tif (m &gt; 0) generate(n, m - 1, s + \"o\");}int main(){\tint tc; scanf(\"%d\", &amp;tc);\tcalcBino();\twhile (tc--) {\t\tint n, m, k; scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;k);\t\tstring s;\t\t//skip 초기화\t\tskip = k - 1;\t\tgenerate(n, m, s);\t}\treturn 0;}","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-MORSE/",
        "teaser":null},{
        "title": "[ALGOSPOT]PACKING",
        "excerpt":"여행 짐 싸기 문제 링크   https://algospot.com/judge/problem/read/PACKING코드 분석 1. 완전 탐색   시간 복잡도: 각 물건에 대해 가져가거나 말거나 두 가지의 선택이 있다.          O(2^N)        pack(items) = 지금까지 고른 문건들의 목록이 items에 주어질 때, 남은 용량을 채워 얻을 수 있는 최대 절박도의 합2. 동적 계획법   완전 탐색에서 메모이제이션을 적용해보자.          items를 넣고 남은 용량에 담을 수 있는 물건들의 절박도 합만을 반환하도록 pack()을 바꾼다.      그 결과, 지금까지 고른 물건들의 목록은 상관이 없어진다.      중요한 것은 마지막으로 고른 물건의 번호(같은 물건을 두 번 고르면 안되므로)와 캐리어에 남아있는 용량이다.        capacity: 남은 용량, item: 물건의 번호, volume[item]: 해당 물건의 부피, need[item]: 해당 물건의 절박도  pack(capacity, item) = 캐리어에 용량이 capacity만큼 남았을 때, item 이후의 물건들을 싸서 얻을 수 있는 최대 절박도          해당 물건을 가져가는 경우: pack(capacity - volume[item], item + 1) + need[item]      해당 물건을 가져가지 않는 경우: pack(capacity, item + 1)        시간 복잡도: 용량 w, 물건의 개수 n 일때, 부분 문제의 수는 nw개이고 각 부분 문제를 해결하는데 걸리는 시간은 상수 시간이다.          O(nw)      3. 답 추적하기   각 부분 문제에서 선택지가 두 가지밖에 없으므로 따로 선택으르 저장하지 않고도 답을 역추적할 수 있다.  pack(capacity, item) 부분 문제에서 item을 선택했는지를 알고 싶으면 pack(capacity, item + 1)과 pack(capacity, item)이 같은지 비교하면 된다.          만약 두 값이 같다면, item을 선택하지 않고도 최대 절박도를 얻을 수 있다는 말이므로 item을 무시한다.      다르면, 목록에 item을 추가한다.      결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;#define max(a,b) ((a) &gt; (b) ? (a) : (b))#define N 101int n, w;int cache[1001][N];//물건의 정보를 저장할 구조체typedef struct _product{\tstring name;\tint volume;\tint need;}product;vector&lt;product&gt; pv;//캐리어에 남은 용량이 capacity일때, item 이후의 물건들을//담아 얻을 수 있는 최대 절박도의 합을 반환한다.int pack(int capacity, int item) {\t//기저 사례: 더 담을 물건이 없을 때\tif (item == n) return 0;\tint &amp;ret = cache[capacity][item];\tif (ret != -1) return ret;\t//이 물건을 담지 않을 경우\tret = pack(capacity, item + 1);\t//이 물건을 담을 경우\tif (capacity &gt;= pv[item].volume)\t\tret = max(ret, pack(capacity - pv[item].volume, item + 1) +\t\t\tpv[item].need);\treturn ret;}//pack(capacity, item)이 선택한 물건들의 목록을 packed에 저장한다.void reconstruct(int capacity, int item, vector&lt;string&gt; &amp;packed) {\t//기저 사례: 모든 물건을 다 고려했을 때\tif (item == n) return;\tif (pack(capacity, item) == pack(capacity, item + 1))\t\treconstruct(capacity, item + 1, packed);\telse {\t\tpacked.push_back(pv[item].name);\t\treconstruct(capacity - pv[item].volume, item + 1, packed);\t}}//초기화void init() {\tmemset(cache, -1, sizeof(cache));\tpv.clear();}int main(){\tint tc; scanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tinit();\t\tscanf(\"%d %d\", &amp;n, &amp;w);\t\tfor (int i = 0; i &lt; n; i++) {\t\t\tproduct in;\t\t\tcin &gt;&gt; in.name;\t\t\tscanf(\"%d %d\", &amp;in.volume, &amp;in.need);\t\t\tpv.push_back(in);\t\t}\t\tvector&lt;string&gt; packed;\t\treconstruct(w, 0, packed);\t\tint psize = packed.size();\t\tprintf(\"%d %d\\n\", pack(w, 0), psize);\t\tfor (int i = 0; i &lt; psize; i++)\t\t\tcout &lt;&lt; packed[i] &lt;&lt; endl;\t}\treturn 0;}","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-PACKING/",
        "teaser":null},{
        "title": "[ALGOSPOT]PI",
        "excerpt":"PI 문제 링크   https://algospot.com/judge/problem/read/PI코드 분석 동적 계획법(메모이제이션)   첫 조각의 길이는 3, 4, 5 중의 하나이므로 각 경우마다 하나씩의 부분 문제를 해결한다, 이때 세 개의 부분 문제의 최적화(최소값)을 각각 구하면 전체 문제의 최적해가 된다.          길이 3인 조각의 난이도 +3글자 빼고 나머지 수열에 대한 최적해            길이 4인 조각의 난이도 +4글자 빼고 나머지 수열에 대한 최적해     길이 5인 조각의 난이도 +5글자 빼고 나머지 수열에 대한 최적해          begin: 부분 수열의 시작 위치, memorize(): 최소 난이도를 반환하는 함수, returnLevel(): 해당 수열의 난이도를 반환하는 함수      memorize(begin) = min(memorize(begin + L) + returnLevel(N[begin…begin + L])), L: 3 ~ 5        returnLevel() 함수             checkLevel() 함수            수열의 길이 3, 4, 5에 대해서만 적용할 수 있는 함수이다.     시간복잡도면에서 효율적이다. (소요시간: 24ms)          classify() 함수            모든 수열의 길이에 대해 적용 가능하다.     시간이 오래 걸린다. (소요시간: 250ms)결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;limits.h&gt;using namespace std;#define N 10001#define min(a, b) ((a) &lt; (b) ? (a) : (b))string arr;const int INF = 987654321;int cache[N];//1) arr[s]부터 size만큼 크기의 난이도를 반환int checkLevel(int s, int size){\tif (size == 3) {\t\tint s1, s2, s3;\t\ts1 = arr[s]; s2 = arr[s + 1]; s3 = arr[s + 2];\t\tif (s1 == s2 &amp;&amp; s2 == s3)\t\t\treturn 1;\t\tint d1, d2;\t\td1 = s2 - s1; d2 = s3 - s2;\t\tif (d1 == d2) {\t\t\tif (d1 == 1 || d1 == -1)\t\t\t\treturn 2;\t\t\telse\t\t\t\treturn 5;\t\t}\t\tif (s1 == s3)\t\t\treturn 4;\t}\telse if (size == 4) {\t\tint s1, s2, s3, s4;\t\ts1 = arr[s]; s2 = arr[s + 1]; s3 = arr[s + 2]; s4 = arr[s + 3];\t\tif (s1 == s2 &amp;&amp; s2 == s3 &amp;&amp; s3 == s4)\t\t\treturn 1;\t\tint d1, d2, d3;\t\td1 = s2 - s1; d2 = s3 - s2; d3 = s4 - s3;\t\tif (d1 == d2 &amp;&amp; d2 == d3) {\t\t\tif (d1 == 1 || d1 == -1)\t\t\t\treturn 2;\t\t\telse\t\t\t\treturn 5;\t\t}\t\tif (s1 == s3 &amp;&amp; s2 == s4)\t\t\treturn 4;\t}\telse if (size == 5) {\t\tint s1, s2, s3, s4, s5;\t\ts1 = arr[s]; s2 = arr[s + 1]; s3 = arr[s + 2];\t\ts4 = arr[s + 3]; s5 = arr[s + 4];\t\tif (s1 == s2 &amp;&amp; s2 == s3 &amp;&amp; s3 == s4 &amp;&amp; s4 == s5)\t\t\treturn 1;\t\tint d1, d2, d3, d4;\t\td1 = s2 - s1; d2 = s3 - s2; d3 = s4 - s3; d4 = s5 - s4;\t\tif (d1 == d2 &amp;&amp; d2 == d3 &amp;&amp; d3 == d4) {\t\t\tif (d1 == 1 || d1 == -1)\t\t\t\treturn 2;\t\t\telse\t\t\t\treturn 5;\t\t}\t\tif ((s1 == s3 &amp;&amp; s3 == s5) &amp;&amp; s2 == s4)\t\t\treturn 4;\t}\treturn 10;}//2) arr[a,b]구간의 난이도를 반환한다.int classify(int a, int b){\t//숫자 조각을 가져온다.\tstring M = arr.substr(a, b - a + 1);\t//첫 글자만으로 이루어진 문자열과 같은으면 난이도 1\tif (M == string(M.size(), M[0])) return 1;\t//등차수열인지 검사한다.\tbool progressive = true;\tfor (int i = 0; i &lt; (int)M.size() - 1; i++)\t\tif (M[i + 1] - M[i] != M[1] - M[0])\t\t\tprogressive = false;\t//등차수열이고 공차가 1 or -1 이면 난이도 2\tif (progressive &amp;&amp; abs(M[1] - M[0]) == 1)\t\treturn 2;\t//두 수가 번갈아 등장하는지 확인한다.\tbool alternating = true;\tfor (int i = 0; i &lt; (int)M.size(); i++)\t\tif (M[i] != M[i % 2])\t\t\talternating = false;\tif (alternating) return 4;  //두 수가 번갈아 등장하면 난이도 4\tif (progressive) return 5;  //공차가 1 아닌 등차수열이면 난이도 5\treturn 10;                  //이 외는 모두 난이도 10}//수열 arr[begin...]를 외우는 방법 중 난이도의 최소 합을 출력한다.int memorize(int begin){\t//기저 사례: 수열의 끝에 도달했을 경우\tif (begin == arr.size()) return 0;\t//메모이제이션\tint &amp;ret = cache[begin];\tif (ret != -1) return ret;\tret = INF;\tfor (int L = 3; L &lt;= 5; ++L) {\t\tif (begin + L &lt;= (int)arr.size())\t\t\tret = min(ret, memorize(begin + L) + checkLevel(begin, L));              //방법 1)\t\t\t//ret = min(ret, memorize(begin + L) + classify(begin, begin + L - 1));  //방법 2)\t}\treturn ret;}int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tmemset(cache, -1, sizeof(cache));\t\tarr.clear();\t\tcin &gt;&gt; arr;\t\tprintf(\"%d\\n\", memorize(0));\t}\treturn 0;}","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-PI/",
        "teaser":null},{
        "title": "[ALGOSPOT]PICNIC",
        "excerpt":"PICNIC 문제 링크   https://algospot.com/judge/problem/read/PICNIC코드 분석 논리 분석   입력받은 친구가 가능한 쌍을 2차원 배열에 중복없이 저장한다. ((1,0), (0,1)도 중복으로 처리한다.)  경우의 수를 체크하기 위해 가능한 쌍의 최대 크기(45)만큼 가로, 세로 크기를 갖는 2차원 배열을 선언한다.  모든 친구들이 쌍을 이루었는지 체크하는 1차원 배열을 선언한다.  최대 시간복잡도는 O(m^2)로 예상한다. (최대 반복 수는 45 * (45 + 45) 로 예사됨)구현 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;#define N 11  //최대 친구 수#define M 46  //최대 친구 쌍의 수bool checkF[N];  //모든 친구들이 짝이 만들어졌는지 체크bool checkP[M][M];  //짝지을 수 있는 방법을 저장할 배열(중복되지 않음)int _pair[M][2];   //가능한 친구 쌍을 저장할 배열bool tmp[M];  //짝지을 방법를 임시로 저장할 배열void init_checkF_tmp(void){\tfor (int i = 0; i &lt; N; i++)\t\tcheckF[i] = false;\tfor (int i = 0; i &lt; M; i++)\t\ttmp[i] = false;}void init_pair(void){\tfor (int i = 0; i &lt; M; i++) {\t\t_pair[i][0] = 0;\t\t_pair[i][1] = 0;\t\tfor (int j = 0; j &lt; M; j++)\t\t\tcheckP[i][j] = false;\t}}bool full_checkF(int n){\tfor (int i = 0; i &lt; n; i++) {\t\tif (!checkF[i])\t\t\treturn false;\t}\treturn true;}//n은 현재 방법의 수bool check_pair(int n, int m){\tbool flag = false;\tfor (int i = 0; i &lt; n; i++) {\t\tfor (int j = 0; j &lt; m; j++) {\t\t\t//하나라도 다른 부분이 있다면 다음 방법으로 넘어가서 검사한다.\t\t\tif (tmp[j] == checkP[i][j])\t\t\t\tflag = true;\t\t\telse {\t\t\t\tflag = false;\t\t\t\tbreak;\t\t\t}\t\t}\t\t//완전히 같으면 FALSE 반환\t\tif (flag) return false;\t}\treturn true;}int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tinit_pair();\t\tint n, m;\t\tscanf(\"%d %d\", &amp;n, &amp;m);\t\tbool repet_flag = false;\t\tint repet_cnt = 0;\t\tfor (int i = 0; i &lt; m; i++) {\t\t\tint f, s;\t\t\tscanf(\"%d %d\", &amp;f, &amp;s);\t\t\t//(0, 1), (1, 0)과 같은 중복을 방지하기 위해 서로 같은 쌍은 입력하지 않는다.\t\t\trepet_flag = false;\t\t\tfor (int j = 0; j &lt; i; j++) {\t\t\t\tif (_pair[j][0] == f &amp;&amp; _pair[j][1] == s) repet_flag = true;\t\t\t\tif (_pair[j][0] == s &amp;&amp; _pair[j][1] == f) repet_flag = true;\t\t\t}\t\t\tif (repet_flag)\t\t\t\trepet_cnt++;\t\t\telse {\t\t\t\t_pair[i - repet_cnt][0] = f;\t\t\t\t_pair[i - repet_cnt][1] = s;\t\t\t}\t\t}\t\tm -= repet_cnt;\t\tint ans = 0;\t\tfor (int i = 0; i &lt; m; i++) {\t\t\tinit_checkF_tmp();\t\t\tcheckF[_pair[i][0]] = true;\t\t\tcheckF[_pair[i][1]] = true;\t\t\ttmp[i] = true;\t\t\tfor (int j = 0; j &lt; m; j++) {\t\t\t\t//중복을 피해기 위함\t\t\t\tif (i == j)\t\t\t\t\tcontinue;\t\t\t\t//친구쌍의 두 친구가 모두 check배열에 false면 해당 쌍을 사용한다.(중복검사)\t\t\t\tif (!checkF[_pair[j][0]] &amp;&amp; !checkF[_pair[j][1]]) {\t\t\t\t\tcheckF[_pair[j][0]] = true;\t\t\t\t\tcheckF[_pair[j][1]] = true;\t\t\t\t\ttmp[j] = true;\t\t\t\t}\t\t\t}\t\t\t//모든 친구들이 짝을 이루었고, 이전에 방법과 다르다면 새로운 방법이다.\t\t\tif (full_checkF(n) &amp;&amp; check_pair(ans, m)) {\t\t\t\tfor (int j = 0; j &lt; m; j++)\t\t\t\t\tcheckP[ans][j] = tmp[j];\t\t\t\tans++;\t\t\t}\t\t}\t\tprintf(\"%d\\n\", ans);\t}\treturn 0;}결과   수행시간 : 0ms  오답  디버깅과 다른 예제를 만들어서 테스트한 결과 틀린 부분을 찾을 수 없었다.알아둘 점   재귀에 관한 이해가 더욱 필요하다.  위의 문제도 책의 해답에서는 재귀를 사용하였다.해답 코드   출처 : 알고리즘 문제해결전략 책#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;#define N 10int n;bool areFriends[N][N];//taken[i] = i번째 학생이 짝을 이미 찾았으면 true, 아니면 falseint countPairings(bool taken[N]){\t//남은 학생들 중 가장 번호가 빠른 학생을 찾는다.\tint firstFree = -1;\tfor (int i = 0; i &lt; n; i++) {\t\tif (!taken[i]) {\t\t\tfirstFree = i;\t\t\tbreak;\t\t}\t}\t//기저 사례 : 모든 학생이 짝을 찾았으면 한 가지 방법을 찾았으니 종료한다.\tif (firstFree == -1) return 1;\tint ret = 0;\t//이 학생과 짝지을 학생을 결정한다.\tfor (int pairWith = firstFree + 1; pairWith &lt; n; pairWith++) {\t\tif (!taken[pairWith] &amp;&amp; areFriends[firstFree][pairWith]) {\t\t\ttaken[firstFree] = taken[pairWith] = true;\t\t\tret += countPairings(taken);\t\t\t//모든 경우의 수를 구해야하기 때문에 초기화해야함\t\t\ttaken[firstFree] = taken[pairWith] = false;\t\t}\t}\treturn ret;}int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tfor (int i = 0; i &lt; N; i++)\t\t\tfor (int j = 0; j &lt; N; j++)\t\t\t\tareFriends[i][j] = false;\t\tint m;\t\tscanf(\"%d %d\", &amp;n, &amp;m);\t\tfor (int i = 0; i &lt; m; i++) {\t\t\tint f, s;\t\t\tscanf(\"%d %d\", &amp;f, &amp;s);\t\t\tareFriends[f][s] = areFriends[s][f] = true;\t\t}\t\tbool taken[10] = { false, };\t\tint ans = countPairings(taken);\t\tprintf(\"%d\\n\", ans);\t}\treturn 0;}결과 및 코드 분석   수행 시간 : 0ms  최대 시간 복잡도 : 열 명의 학생이 모두 친구인 경우(9 * 7 * 5 * 3 * 1 = 945)  재귀 함수 사용  공간 복잡도면에서, 2차원 배열 1개와 1차원 배열 1개를 사용하여 내가 구현한 코드보다 더 효율적이다.  친구 쌍이 가능한지를 저장하는 2차원 배열에서 그 반대의 경우도 모두 저장해주어야 정확한 답이 나온다.알아둘 점 1) 재귀 함수 구현 능력&lt;/br&gt;2) 재귀 함수를 사용하기 위한 입력 형식을 만드는 방법 ","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-PICNIC/",
        "teaser":null},{
        "title": "[ALGOSPOT]QUADTREE",
        "excerpt":"QUADTREE 문제 링크   https://algospot.com/judge/problem/read/QUADTREE코드 분석   출처: 알고리즘 문제해결전략, 분할정복  재귀 호출을 이용해 네 부분을 각각 상하로 뒤집은 결과를 얻은 뒤, 이들을 병합한다.  STL의 string 함수 사용  STL의 문자열에서 지원하는 반복자(iterator) 활용  시간복잡도 분석: O(n)          주어진 문자열 길이: n      재귀 함수를 호출할 때 마다 주어진 문자열의 한 글자씩을 사용한다.      결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;string reserve(string::iterator &amp;it){\tchar head = *it;\t++it;\tif (head == 'b' || head == 'w')\t\treturn string(1, head);\tstring upperLeft = reserve(it);\tstring upperRight = reserve(it);\tstring lowerLeft = reserve(it);\tstring lowerRight = reserve(it);\t//각각 위와 아래 조각들의 위치를 바꾼다.\treturn string(\"x\") + lowerLeft + lowerRight +\t\tupperLeft + upperRight;}int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tstring map;\t\tcin &gt;&gt; map;\t\tstring::iterator it = map.begin();\t\tcout &lt;&lt; reserve(it) &lt;&lt; endl;\t}\treturn 0;}결과 분석   수행시간: 4ms","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-QUADTREE/",
        "teaser":null},{
        "title": "[ALGOSPOT]QUANTIZE",
        "excerpt":"QUANTIZE 문제 링크   https://algospot.com/judge/problem/read/QUANTIZE코드 분석 완전 탐색   시간복잡도: O(1000C10^n)이고, 최대 연산수 1000C10^100이므로 시간안에 풀 수 없다.    동적 계획법(메모이제이션)     주어진 수열을 오름차순 or 내림차순으로 정렬하면, 같은 숫자로 양자화되는 숫자들은 항상 인접해 있다!          예를들어, a &lt; b에 대해 a에 대응되는 숫자가 b에 대응되는 숫자보다 커서는 안된다.      이는 몇 개의 작은 입력들을 풀어보면 알 수 있는 조건이며, 시간내에 풀기 위해 알아야하는 중요한 조건이다.        기본 테스트 케이스의 한 예를 사용하면, {1, 4, 6, 744, 755, 777, 890, 897, 902} =&gt; {1, 4, 6}: 4, {744, 755, 777}: 759, {890, 897, 902}: 896 로 대응된다.  이를 형식화하면, from번째 이후의 숫자들을 parts개의 묶음으로 묶을 때, 최소 오류 제곱 합을 반환하는 함수 quantize(from, parts)가 있다.  quantize(from, parts) = min[minError(from, from + size - 1) + quantize(from + size, parts - 1)], size: 1 ~ n-from  minError(a,b): a번째 숫자부터 b번째 숫자까지 하나의 수로 표현했을 때의 최소 오류를 반환하는 함수          주어진 구간을 어떤 수로 표현해야 할지 결정하기        결정한 수 m으로 해당 구간을 표현했을 때 오차를 계산하기  위의 역할을 완전 탐색으로 구현하여도 시간안에 해결할 수 있지만, 밑의 구현 코드는 좀 더 복잡하며 효율적인 방법을 사용한다.  이는 오차 제곱의 합을 미분하여 값을 도출하며, 이를 부분 합 계산 방식으로 시간복잡도 O(1)의 방법으로 푸는 방법이며, 이 설명은 추후 추가할 예정이다.시간복잡도: 부분 문제의 수 ns개를 각각 n번 계산해야 하기 때문에 총 O(sn^2)이다.결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define N 10001#define min(a,b) ((a)&lt;(b)?(a):(b))const int INF = 987654321;//A[]: 양자화해야 할 수열, 정렬한 상태//pSum[]: A[]의 부분합을 저장한다. pSum[i]는 A[0]...A[i]의 합//qSuSum[]: A[]제곱의 부분합을 저장한다. pSqSum[i]는 A[0]^2...A[i]^2의 합int n;int A[N], pSum[N], pSqSum[N];//A를 정렬하고 가가 부분합을 계산한다.void precalc(){\tsort(A, A + n);\tpSum[0] = A[0];\tpSqSum[0] = A[0] * A[0];\tfor (int i = 1; i &lt; n; i++) {\t\tpSum[i] = pSum[i - 1] + A[i];\t\tpSqSum[i] = pSqSum[i - 1] + A[i] * A[i];\t}}//A[lo]...A[hi] 구간을 하나의 숫자로 표현할 때 최소 오차 합을 반환한다.int minError(int lo, int hi){\t//부분합을 이용해 A[lo] ~ A[hi]까지의 합을 구한다.\tint sum = pSum[hi] - (lo == 0 ? 0 : pSum[lo - 1]);\tint sqSum = pSqSum[hi] - (lo == 0 ? 0 : pSqSum[lo - 1]);\t//평균을 반올림한 값으로 이 수 들을 표현한다.\tint m = int(0.5 + (double)sum / (hi - lo + 1));\t//sum(A[i] - m)^2를 전개한 결과를 부분 합으로 표현\tint ret = sqSum - 2 * m *sum + m *m *(hi - lo + 1);\treturn ret;}int cache[N][11];int quantize(int from, int parts){\t//기저 사례: 모든 숫자들 양자화했을 떄\tif (from == n) return 0;\t//기저 사례: 숫자는 아직 남았는데 더 묶을 수 없을 때 아주 큰 값으르 반환한다.\tif (parts == 0) return INF;\tint &amp;ret = cache[from][parts];\tif (ret != -1) return ret;\tret = INF;\t//조각의 길이를 변화시켜 가며 최소값을 찾는다.\tfor (int partSize = 1; from + partSize &lt;= n; partSize++)\t\tret = min(ret, minError(from, from + partSize - 1)\t\t\t+ quantize(from + partSize, parts - 1));\treturn ret;}int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tmemset(cache, -1, sizeof(cache));\t\tmemset(A, 0, sizeof(A));\t\tmemset(pSum, 0, sizeof(pSum));\t\tmemset(pSqSum, 0, sizeof(pSqSum));\t\tint s;\t\tscanf(\"%d %d\", &amp;n, &amp;s);\t\tfor (int i = 0; i &lt; n; i++)\t\t\tscanf(\"%d\", &amp;A[i]);\t\tprecalc();\t\tprintf(\"%d\\n\", quantize(0, s));\t}\treturn 0;}","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-QUANTIZE/",
        "teaser":null},{
        "title": "[ALGOSPOT]SNAIL",
        "excerpt":"장마가 찾아왔다 문제 링크   https://algospot.com/judge/problem/read/SNAIL코드 분석 동적 계획법을 활용한 확률 계산   예제 문제: 우물의 깊이 n미터, 장마 기간 m일, 비가올 확률 50%, 달팽이는 비가 안올 때 1m 올라가고 비가 올 때 2m를 올라간다. 이때, 올라갈 수 있는확률을 구하라.int cache[N][2 * N + 1];int n, m;//달팽이가 days일 동안 climbed미터를 기어올라 왔다고 할 때,//m일 전까지 n미터를 기어올라갈 수 있는 경우의 수int climb(int days, int climbed){\t//기저 사례: m일이 모두 지난 경우\tif (days == m) return climbed &gt;= n ? 1 : 0;\t//메모이제이션\tint &amp;ret = cache[days][climbed];\tif (ret != -1) return ret;\treturn ret = climb(days + 1, climbed + 2) + climb(days + 1, climbed + 1);}  완전 탐색 알고리즘에서 동적 계획법으로 순서          완전 탐색      climb(C): 지금까지 만든 날씨 조합C를 완성해서 원소의 합이 n이상이 되도록 하는 방법의 수      점화식: climb(C) = climb(C + [1]) + climb(C + [2])                  C + [x]는 배열 C의 맨 뒤에 x를 덧붙인 결과이다.          이 점화식은 C의 종류가 너무 많기 때문에 메모이제이션을 활용할 수 없다!          날씨 조합C =&gt; C의 길이와 C의 원소의 합만을 활용한다.                    동적 계획법      climbed(days, climbed): 지금까지 만든 날씨 조합C의 크기가 days, 그 원소들의 합이 climbed일 때, C를 완성해서 원소의 합이 n이상이 되게 하는방법의 수                  최대 부분 문제의 수: n * m          얻은 결과의 경우의 수를 2^m으로 나누면 최종 확률을 얻을 수 있다.                    SNAIL 문제   위와 문제의 구조는 동일하지만, 비가 올 확률이 50%에서 75%으로 증가하였다.  점화식: climb(days, climbed) = 0.25 * climb(days + 1, climbed + 1) + 0.75 * climb(days + 1, climbed + 2)          위의 예제와 달리 날씨의 조합마다 출현할 확률이 달라지므로, 재귀함수 결과를 경우의 수가 아닌 직접 확률을 계산해야 한다.      결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;#define N 1001double cache[N][2 * N + 1];int n, m;double climb(int days, int climbed){\t//기저 사례\tif (days == m) return climbed &gt;= n ? 1. : 0.;\t//메모이제이션\tdouble &amp;ret = cache[days][climbed];\tif (ret != -1.) return ret;\treturn ret = 0.75 * climb(days + 1, climbed + 2) + 0.25 * climb(days + 1, climbed + 1);}int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tfor (int i = 0; i &lt; N; i++)\t\t\tfor (int j = 0; j &lt; 2 * N + 1; j++)\t\t\t\tcache[i][j] = -1.;\t\tscanf(\"%d %d\", &amp;n, &amp;m);\t\tprintf(\"%.10lf\\n\", climb(0, 0));\t}\treturn 0;}","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-SNAIL/",
        "teaser":null},{
        "title": "[ALGOSPOT]SORTGAME",
        "excerpt":"Sorting Game 문제 링크   https://algospot.com/judge/problem/read/SORTGAME코드 분석 그래프화한 뒤 넓이 우선 탐색(BFS) 사용하기 1. 그래프로 바꾸기   각 배열을 정점으로 표현하고, 부분 구간을 뒤집어 한 배열에서 다른 배열을 만들 수 있을 때 두 정점을 간선으로 연결한다.  n원소가 있을 때 이들을 배열하는 방법은 n!이며, 최대 정점의 개수도 이와 같다.   위 그래프를 넓이 우선 탐색하면서 정렬된 상태를 나타내는 정점까지의 거리를 계산한다.  구현          그래프를 생성하는 과정은 생략하고, 입력 배열의 부분 구간을 뒤집으면서 그때 그때 그래프의 간선을 만들어 넓이 우선 탐색을 실행한다.      정점 큐의 각 원소를 정수 배열로 하며, 거리를 계산할 distance[]는 정수 배열을 키(key)로 갖는 map을 사용한다.      //perm을 정렬하기 위해 필요한 최소 뒤집기 연산의 수를 계산 후 반환한다.int bfs(const vector&lt;int&gt; &amp;perm) {\tint n = perm.size();\t//목표 정점을 미리 계산한다.(오름차순된 배열)\tvector&lt;int&gt; sorted = perm;\tsort(sorted.begin(), sorted.end());\t//방문 목록(큐)\tqueue&lt;vector&lt;int&gt;&gt; q;\t//시작점으로부터 각 정점까지의 거리(map)\tmap&lt;vector&lt;int&gt;, int&gt; distance;\t//시작점의 거리는 0\tdistance[perm] = 0;\t//시작점을 큐에 넣는다.\tq.push(perm);\twhile (!q.empty()) {\t\tvector&lt;int&gt; here = q.front();\t\tq.pop();\t\t//목표 정점을 발견했으면 곧장 종료한다.\t\tif (here == sorted) return distance[here];\t\tint cost = distance[here];\t\t//가능한 모든 부분 구간을 뒤집어 본다.\t\tfor (int i = 0; i &lt; n; ++i) {\t\t\t//reverse함수의 배열 범위에 주의한다.\t\t\tfor (int j = i + 1; j &lt;= n; ++j) {\t\t\t\treverse(here.begin() + i, here.begin() + j);\t\t\t\tif (distance.count(here) == 0) {\t\t\t\t\tdistance[here] = cost + 1;\t\t\t\t\tq.push(here);\t\t\t\t}\t\t\t\treverse(here.begin() + i, here.begin() + j);\t\t\t}\t\t}\t}\t//실행되지 않음\treturn -1;}2. 더 빠른 해결방법   위 방법은 최악의 경우 8! = 40320개의 정점을 탐색하며, map에 접근해야한다. 그리고 최대 1000개의 테스트 케이스가 있기 때문에 시간안에 해결하기 힘들다.  위 알고리즘을 최적화하기 위해 2가지를 알고 있어야 한다.          숫자들이 다르더라도 상대적인 크기가 같은 배열들에 대한 답은 같다.                  예를들어, 두 배열 {30, 40, 10, 20}과 {3, 4, 1, 2}는 모두 최소 연산수가 2이다.                    이 문제의 그래프는 양방향 그래프이기 때문에, 시작 정점에서 목표 정점으로 가는 최단 거리는 그 반대인 목표 정점에서 시작 정점으로 가는 최단 거리와 같다.                  한 배열을 정렬하는데 드는 연산의 수는 정렬된 배열을 원래 배열로 바꾸는데 드는 연산의 수와 같다.                      위 2가지 속성을 이용하면, 모든 n(최대 크기 8)에 대해 정렬된 배열 [0, 1, 2, …, n-1]에서 모든 상태를 미리 계산한다.  입력 배열을 [0, n-1] 범위의 값으로 상대적인 크기를 유지한 상태로 바꾸면 위에서 미리 계산된 연산의 수로 답을 바로 알 수 있다.3. 구현 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;map&lt;vector&lt;int&gt;, int&gt; toSort;//[0, ..., n-1]의 모든 순열에 대해 toSort[]를 계산해 저장한다.void precalc(int n) {\tvector&lt;int&gt; perm(n);\tfor (int i = 0; i &lt; n; ++i) perm[i] = i;\tqueue&lt;vector&lt;int&gt;&gt; q;\tq.push(perm);\ttoSort[perm] = 0;\twhile (!q.empty()) {\t\tvector&lt;int&gt; here = q.front();\t\tq.pop();\t\tint cost = toSort[here];\t\tfor (int i = 0; i &lt; n; ++i) {\t\t\tfor (int j = i + 1; j &lt;= n; ++j) {\t\t\t\treverse(here.begin() + i, here.begin() + j);\t\t\t\tif (toSort.count(here) == 0) {\t\t\t\t\ttoSort[here] = cost + 1;\t\t\t\t\tq.push(here);\t\t\t\t}\t\t\t\treverse(here.begin() + i, here.begin() + j);\t\t\t}\t\t}\t}}int solve(const vector&lt;int&gt; &amp;perm) {  //perm을 [0, ..., n-1]의 순열로 변환한다.\tint n = perm.size();\tvector&lt;int&gt; fixed(n);\tfor (int i = 0; i &lt; n; ++i) {\t\tint smaller = 0;\t\tfor (int j = 0; j &lt; n; ++j) {\t\t\tif (perm[j] &lt; perm[i])\t\t\t\tsmaller++;\t\t}\t\tfixed[i] = smaller;\t}\treturn toSort[fixed];}int main(){\tfor (int i = 1; i &lt;= 8; ++i)\t\tprecalc(i);\tint tc; scanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tint n; scanf(\"%d\", &amp;n);\t\tvector&lt;int&gt; in(n);\t\tfor (int i = 0; i &lt; n; ++i)\t\t\tscanf(\"%d\", &amp;in[i]);\t\tprintf(\"%d\\n\", solve(in));\t}\treturn 0;}","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-SORTGAME/",
        "teaser":null},{
        "title": "[ALGOSPOT]STRJOIN",
        "excerpt":"문자열 합치기 문제 링크   https://algospot.com/judge/problem/read/STRJOIN코드 분석   그리디 알고리즘  문자열 길이가 가장 짧은 2개를 계속 더해나간다.          더한 값 역시 문자열 길이가 저장되어 있는 배열에 갱신해야 한다.        vector로 구현          vector의 멤버함수인 push_back과 pop_back을 사용하기 위해 내림차순으로 정렬하여 구현하였다.      시간 복잡도: 내림차순 정렬O(NlogN) + 문자열 길이 2개 더하고 vector 갱신하기O(N) = O(N^2 * logN)        우선순위 큐로 구현          시간복잡도: 우선순위 큐O(logN) + 문자열 길이 2개 더하고 큐 갱신O(N) = O(NlogN)      허프만 압축 알고리즘을 응용한다.      결과 코드   vector로 구현한 코드#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; len;//내림차순bool compare(const int a, const int b){ return a &gt; b; }int main(){\tint tc; scanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tint n; scanf(\"%d\", &amp;n);\t\tfor (int i = 0; i &lt; n; i++) {\t\t\tint num; scanf(\"%d\", &amp;num);\t\t\tlen.push_back(num);\t\t}\t\tint vlen = len.size();\t\t//내림차순 정렬\t\tsort(len.begin(), len.end(), compare);\t\t/*for (int i = 0; i &lt; vlen; i++)\t\t\tprintf(\"%d \", len[i]);*/\t\tint ans = 0, num1, num2, sum;\t\t//문자열 길이가 2개 이상이면 계속 더해나간다.\t\twhile (vlen &gt; 1) {\t\t\t//문자열 길이가 가장 짧은 2개를 뽑아서 더한다.\t\t\tnum1 = len[vlen - 1];\t\t\tnum2 = len[vlen - 2];\t\t\tlen.pop_back();\t\t\tlen.pop_back();\t\t\tsum = num1 + num2;\t\t\tans += sum;\t\t\t//더한 값 역시 vector에 추가한다.\t\t\tlen.push_back(sum);\t\t\t//vector 길이를 갱신한다.\t\t\tvlen = len.size();\t\t\t//다시 내림차순 정렬을 한다.\t\t\tsort(len.begin(), len.end(), compare);\t\t}\t\tprintf(\"%d\\n\", ans);\t\tlen.clear();\t}\treturn 0;}","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-STRJOIN/",
        "teaser":null},{
        "title": "[ALGOSPOT]TRIANGLEPATH",
        "excerpt":"TRIANGLEPATH 문제 링크   https://algospot.com/judge/problem/read/TRIANGLEPATH코드 분석 Bottom-up   DP[y][x] = (y,x)일 때, 최대합  DP[0][0] = triangle[0][0]  DP[y][x] = triangle[y][x] + max(DP[y-1][x], DP[y-1][x-1])  시간복잡도: O(n^2), 부분 문제 수 n^2 * 부분 문제 계산 2Top-down + 메모이제이션   y, x는 재귀 호출이 풀어야 할 부분 문제를 지정한다. 즉, 이들은 앞으로 풀어야 할 조각들에 대한 정볼르 주는 입력들이다.  path(y,x)는 (y,x)에서 시작해서 맨 아래줄까지 내려가는 부분 경로의 최대합을 반환한다.  점화식: path(y,x) = trinangle[y][x] + max(path(y+1,x), path(y+1, x+1))  시간복잡도: O(n^2), 부분 문제수 n^2 * 부분 문제 계산 시간 M(상수)최적 부분 구조   동적 계획법의 중요한 요소로서, 어떤 문제와 분할 방식에 성립하는 조건이다.  각 부분 문제의 최적해만 있으면 전체 문제의 최적해를 쉽게 얻어낼 수 있는 경우이다.  대두분의 최적 부분 구조는 직관적으로 이해할 수 있지만, 그렇지 않은 경우는 대게 귀류법이나 대우를 이용해 증명할 수 있다.결과 코드   Bottom-up#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define N 101int dp[N][N];int tri[N][N];int mj[2] = { -1, 0 };int mi[2] = { -1, -1 };int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tmemset(dp, 0, sizeof(dp));\t\tmemset(tri, 0, sizeof(dp));\t\tint n;\t\tscanf(\"%d\", &amp;n);\t\tfor (int i = 0; i &lt; n; i++) {\t\t\tfor (int j = 0; j &lt; n; j++) {\t\t\t\tif (j &gt; i)\t\t\t\t\tbreak;\t\t\t\tscanf(\"%d\", &amp;tri[i][j]);\t\t\t}\t\t}\t\t//윗 줄부터 차례대로 내려가면서 최대합을 계산한다.\t\tdp[0][0] = tri[0][0];\t\tfor (int i = 1; i &lt; n; i++) {\t\t\tfor (int j = 0; j &lt; n; j++) {\t\t\t\tif (j &gt; i)\t\t\t\t\tbreak;\t\t\t\tfor (int f = 0; f &lt; 2; f++) {\t\t\t\t\tint fi = i + mi[f];\t\t\t\t\tint fj = j + mj[f];\t\t\t\t\tif (fj &gt;= 0 &amp;&amp; fj &lt; i)\t\t\t\t\t\tif (dp[i][j] &lt; (tri[i][j] + dp[fi][fj]))\t\t\t\t\t\t\tdp[i][j] = tri[i][j] + dp[fi][fj];\t\t\t\t}\t\t\t}\t\t}\t\t/*for (int i = 0; i &lt; n; i++) {\t\tfor (int j = 0; j &lt; n; j++)\t\tprintf(\"%d \", dp[i][j]);\t\tprintf(\"\\n\");\t\t}*/\t\tint max = 0;\t\tfor (int i = 0; i &lt; n; i++) {\t\t\tif (max &lt; dp[n - 1][i])\t\t\t\tmax = dp[n - 1][i];\t\t}\t\tprintf(\"%d\\n\", max);\t}\treturn 0;}  Top-down + 메모이제이션#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define N 100#define max(a,b) ((a)&gt;(b)?(a):(b))int n, triangle[N][N];int cache[N][N];//(y, x) 위치부터 맨 아래줄까지 내려가면서 얻을 수 있는 최대 경로의 합을 반환한다.int path(int y, int x){\t//기저 사례: 맨 아래 줄까지 도달했을 경우\tif (y == n - 1) return triangle[y][x];\t//메모이제이션\tint &amp; ret = cache[y][x];\tif (ret != -1) return ret;\treturn ret = max(path(y + 1, x), path(y + 1, x + 1))\t\t+ triangle[y][x];}int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tmemset(triangle, 0, sizeof(triangle));\t\tmemset(cache, -1, sizeof(cache));\t\tscanf(\"%d\", &amp;n);\t\tfor (int i = 0; i &lt; n; i++) {\t\t\tfor (int j = 0; j &lt; n; j++) {\t\t\t\tif (j &gt; i) break;\t\t\t\tscanf(\"%d\", &amp;triangle[i][j]);\t\t\t}\t\t}\t\tprintf(\"%d\\n\", path(0, 0));\t}\treturn 0;}결과 분석   Bottom-up          시간: 12ms        Top-down + 메모이제이션          시간: 8ms      ","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-TRIANCLEPATH/",
        "teaser":null},{
        "title": "[ALGOSPOT]WILDCARD",
        "excerpt":"WILDCARD 문제 링크   https://algospot.com/judge/problem/read/WILDCARD코드 분석 완전 탐색: 4가지 경우   s[pos]와 w[pos]가 대응되지 않는다.: 대응 실패  w 끝에 도달했다.: 패턴에 *가 하나도 없는 경우, 패턴과 문자열의 길이가 정확히 같아야 대응 할 수 있다.  s 끝에 도달했다.: 패턴은 남아있지만 문자열은 끝난 경우, 남은 패턴이 모두 *면 대응 가능하지만 아니면 대응 실패이다.  w[pos]가 *인 경우: *가 몇 글자에 대응될지 모르기 때문에, 0 글자부터 남은 문자열의 길이까지를 순회하며 모든 가능성을 검사해야한다.이때 w는 pos+1이후를 패턴 w’으로 하고, s의 pos + skip(현재 인덱스(pos) 이후 문자열 끝까지) 이후를 문자열 s’로 하여 match(w’, s’)로 재귀 호출했을 때 답이 하나라도 참이면 대응 가능하다.DP   w와 s는 각각 최대 101개이다.  match()가 101 * 101 = 10201번 이상 호출되었다면 비둘기집의 원리에 따라 어떤 부분 문제가 반드시 여러 번 계산되고 있다는 뜻이다.  중복되는 계산은 메모이제이션을 사용하여 해결 가능하다.  w는 항상 전체 패턴 W의 접미사이기 때문에 w의 길이가 결정되면 w 또한 결정된다. 이를 이용하여 101 X 101 크기의 배열에 모든 부분 문제를 저장할 수 있다.결과 코드   완전 탐색#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;#define N 1001vector&lt;string&gt; res;//와일드카드 패턴 w가 문자열 s에 대응되는지 여부를 반환한다.bool match(const string &amp;w, const string &amp;s){\t//w[pos]와 s[pos]를 맞춰나간다.\tint pos = 0;\twhile (pos &lt; (int)s.size() &amp;&amp; pos &lt; (int)w.size() &amp;&amp;\t\t(w[pos] == '?' || w[pos] == s[pos]))\t\t++pos;\t//더이상 대응할 수 없으면 왜 while문이 끝났는지 확인한다.\t//2. 패턴 끝에 도달해서 끝난 경우: 문자열도 끝났어야 대응됨\tif (pos == w.size())\t\treturn pos == s.size();\t//4. *를 만나서 끝난 경우: *에 몇 글자를 대응해야 할지 재귀 호출하면서 확인한다.\tif (w[pos] == '*')\t\tfor (int skip = 0; pos + skip &lt;= (int)s.size(); ++skip)\t\t\t//하나라도 대응되는 것이 있으면 TRUE 반환\t\t\tif (match(w.substr(pos + 1), s.substr(pos + skip)))\t\t\t\treturn true;\t//이 외의 경우에는 모두 대응되지 않는다.\treturn false;}int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tstring wild;\t\tcin &gt;&gt; wild;\t\tint n;\t\tscanf(\"%d\", &amp;n);\t\twhile (n--) {\t\t\tstring file;\t\t\tcin &gt;&gt; file;\t\t\tif (match(wild, file))\t\t\t\tres.push_back(file);\t\t}\t\tsort(res.begin(), res.end());\t\tfor (int i = 0; i &lt; (int)res.size(); i++)\t\t\tcout &lt;&lt; res[i] &lt;&lt; endl;\t\tres.clear();\t}\treturn 0;}  DP#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;#define N 101vector&lt;string&gt; res;//-1: 아직 답이 계산되지 않음//1: 해당 입력들이 서로 대응됨//0: 해당 입력들이 서로 대응되지 않음int cache[N][N];//패턴과 문자열string W, S;//와일드카드 패턴 W[w...]가 문자열 S[s...]에 대응되는지 여부를 반환int matchMemoized(int w, int s){\t//메모이제이션\tint &amp;ret = cache[w][s];\tif(ret != -1) return ret;\t//W[w]와 S[s]를 맞춰나간다.\twhile (s &lt; (int)S.size() &amp;&amp; w &lt; (int)W.size() &amp;&amp;\t\t(W[w] == '?' || W[w] == S[s])) {\t\t++w;\t\t++s;\t}\t//더이상 대응할 수 없으면 왜 while문이 끝났는지 확인한다.\t//2. 패턴 끝에 도달해서 끝난 경우: 문자열도 끝났어야 참이다.\tif (w == W.size()) return ret = (s == (int)S.size());\t//4. *를 만나서 끝난 경우: *에 몇 글자를 대응해야 할지 재귀 호출하면서 확인한다.\tif (W[w] == '*')\t\tfor (int skip = 0; skip + s &lt;= (int)S.size(); ++skip)\t\t\tif (matchMemoized(w + 1, s + skip))\t\t\t\treturn ret = 1;\t//3. 이 외의 경우에는 모두 대응되지 않는다.\treturn ret = 0;}int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tcin &gt;&gt; W;\t\tint n;\t\tscanf(\"%d\", &amp;n);\t\twhile (n--) {\t\t\tmemset(cache, -1, sizeof(cache));\t\t\tcin &gt;&gt; S;\t\t\tif (matchMemoized(0, 0))\t\t\t\tres.push_back(S);\t\t\tS.clear();\t\t}\t\tsort(res.begin(), res.end());\t\tfor (int i = 0; i &lt; (int)res.size(); i++)\t\t\tcout &lt;&lt; res[i] &lt;&lt; endl;\t\tres.clear();\t\tW.clear();\t}\treturn 0;}결과 분석   완전 탐색          소요 시간: 44ms        DP          소요 시간: 4ms      ","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-WILDCARD/",
        "teaser":null},{
        "title": "[ALGOSPOT]WORDCHAIN",
        "excerpt":"단어 제한 끝말잇기 문제 링크   https://algospot.com/judge/problem/read/WORDCHAIN코드 분석 1. 해밀토니안 경로(Hamiltonian path)   그래프의 모든 정점을 정확히 한 번씩 지나는 경로  해밀토니안 경로를 찾는 유일한 방법은 조합 탐색으로, 모든 정점의 배열을 하나하나 시도하며 이들이 경로가 되는지 확인하는 것이다.          시간 복잡도: 최악의 경우 O(N!)이다.      이 문제 최대 크기인 100인 경우 100!이므로, 시간안에 절대 해결할 수 없다.        예제 그림   구현 코드#define N 101bool check[N];int adj[N][N];vector&lt;string&gt; sv, ans;int n;//행의 마지막 글자가 열의 첫 번째 글자와 일치하면 1값을 넣어,//각각 단어를 이을 수 있는 지를 그래프로 표현한다.(인접 행렬)void makeAdj() {\tfor (int i = 0; i &lt; n; ++i)\t\tfor (int j = 0; j &lt; n; ++j)\t\t\tif (i != j) {\t\t\t\tchar iBackCh = sv[i][(int)sv[i].size() - 1];\t\t\t\tchar jFrontCh = sv[j][0];\t\t\t\tif (iBackCh == jFrontCh)\t\t\t\t\tadj[i][j] = 1;\t\t\t}}//단어 정점을 하나씩 방문하며 경로가 되는지 검사한다.(DFS)bool dfs(int here) {\tcheck[here] = true;\tans.push_back(sv[here]);\tbool flag = true;\tfor (int j = 0; j &lt; n; ++j)\t\tif (!check[j]) {\t\t\tflag = false;\t\t\tbreak;\t\t}\tif (flag) return true;\tfor (int there = 0; there &lt; n; ++there) {\t\tif (!check[there] &amp;&amp; adj[here][there]) {\t\t\tif (dfs(there)) return true;\t\t\tcheck[there] = false;\t\t}\t}\treturn false;}//모든 정점에서 경로를 만들 수 있는지 검사한다.bool dfsAll() {\tmakeAdj();\tfor (int i = 0; i &lt; n; ++i) {\t\tmemset(check, false, sizeof(check));\t\tans.clear();\t\tif (dfs(i))\t\t\treturn true;\t}\treturn false;}2. 오일러 트레일 혹은 서킷   입력으로 주어진 각 단어를 정점이 아닌 간선으로 갖는 방향 그래프를 만든다.  각 정점은 알파벳으로 이루어져 있고, 각 단어의 첫글자에서 마지막 글자로 가는 간선을 만든다.   위 그림에서와 같은 그래프에서 오일러 트레일 혹은 서킷을 활용하면, 답이 될 수 있는 것을 알 수 있다.  오일러 서킷 및 트레일의 자세한 내용은 링크: (추가 예정)  방향 그래프에서의 오일러 서킷          무향 그래프에서는 각 정점에서ㅓ 인접하나 간선이 짝수 개여야 하지만, 방향 그래프에서는 둘 중 한 방향만 쓸 수 있기 때문에 각 정점에 들어오는 간선의 수와 나가는 간선의 수가 같아야 한다.      방향 그래프에서 오일러 서킷을 통해 오일러 트레일(a에서 시작, b에 도착)을 찾는 방법                  간선 (b, a)를 추가 한다.          정점 a에서는 나가는 간선이 들어오는 간선보다 하나 많고, 정점 b는 들어오는 간선이 나가는 간선보다 하나 많아야 한다.          위 두 정점을 제외한 나머지 정점은 나가는 간선과 들어오는 간선의 수가 같아야 한다.                      구현 코드#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;/* 끝말잊기 문제의 입력을 그래프로 만들기*///그래프의 인점 행렬 표현, adj[i][j] = i와 j사이의 간선의 수vector&lt;vector&lt;int&gt;&gt; adj;//graph[i][j] = i로 시작해서 j로 끝나는 단어의 수vector&lt;string&gt; graph[26][26];//indegree[i] = i로 시작하는 단어의 수//outdegree[i] = i로 끝나는 단어의 수vector&lt;int&gt; indegree, outdegree;void makeGraph(const vector&lt;string&gt; &amp;words) {\t//전역 변수 초기화\tfor (int i = 0; i &lt; 26; ++i)\t\tfor (int j = 0; j &lt; 26; ++j)\t\t\tgraph[i][j].clear();\tadj = vector&lt;vector&lt;int&gt;&gt;(26, vector&lt;int&gt;(26, 0));\tindegree = outdegree = vector&lt;int&gt;(26, 0);\t//각 단어를 그래프에 추가한다.\tfor (int i = 0; i &lt; words.size(); ++i) {\t\tint a = words[i][0] - 'a';\t\tint b = words[i][words[i].size() - 1] - 'a';\t\tgraph[a][b].push_back(words[i]);\t\tadj[a][b]++;\t\toutdegree[a]++;\t\tindegree[b]++;\t}}/* 방향 그래프에서 오일러 서킷 혹은 트레일 찾아내기 *///유향 그래프의 인접 행렬 adj가 주어질 때 오일러 서킷 혹은 트레일을 계산한다.void getEulerCircuit(int here, vector&lt;int&gt; &amp;circuit) {\tfor (int there = 0; there &lt; adj.size(); ++there)\t\twhile (adj[here][there] &gt; 0) {\t\t\tadj[here][there]--;  //간선을 지운다\t\t\tgetEulerCircuit(there, circuit);\t\t}\tcircuit.push_back(here);}//현재 그래프의 오일러 트레일이나 서킷을 반환한다.vector&lt;int&gt; getEulerTrailOrCircuit() {\tvector&lt;int&gt; circuit;\t//우선 트레일을 찾아본다: 시작점이 존재하는 경우\tfor(int i = 0; i &lt; 26; ++i)\t\tif (outdegree[i] == indegree[i] + 1) {\t\t\tgetEulerCircuit(i, circuit);\t\t\treturn circuit;\t\t}\t//아니면 서킷이니, 간선에 인접한 아무 정점에서나 시간한다.\tfor(int i = 0; i &lt; 26; ++i)\t\tif (outdegree[i]) {\t\t\tgetEulerCircuit(i, circuit);\t\t\treturn circuit;\t\t}\t//모두 실패한 경우 빈 배열을 반환한다.\treturn circuit;}/* 끝말잇기 문제를 오일러 트레일 문제로 바꿔 해결하는 알고리즘 */string solve(const vector&lt;string&gt; &amp;words) {\tmakeGraph(words);\t//오일러 서킷이나 트레일으르 찾아낸다.\tvector&lt;int&gt; circuit = getEulerTrailOrCircuit();\t//모든 간선을 방문하지 못했으면 실패\tif (circuit.size() != words.size() + 1) return \"IMPOSSIBLE\";\t//아닌 경우 방문 순서를 뒤집은 뒤 간선들을 모아 문자열로 만들어 반환한다.\treverse(circuit.begin(), circuit.end());\tstring ret;\tfor (int i = 1; i &lt; circuit.size(); ++i) {\t\tint a = circuit[i - 1], b = circuit[i];\t\tif (ret.size()) ret += \" \";\t\tret += graph[a][b].back();\t\tgraph[a][b].pop_back();\t}\treturn ret;}int main(){\tint tc; scanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tvector&lt;string&gt; sv;\t\tint n;  scanf(\"%d\", &amp;n);\t\tfor (int i = 0; i &lt; n; ++i) {\t\t\tstring str;\t\t\tcin &gt;&gt; str;\t\t\tsv.push_back(str);\t\t}\t\tcout &lt;&lt; solve(sv) &lt;&lt; endl;\t}\treturn 0;}예외 사항   위 오일러 서킷 및 트레일 코드에 예외 사항이 발생한다.          결과는 정답으로 나온다.        getEulerCircuit()함수에서 갈 수 없는 경로를 가는 경우가 발생하여 vector에 추가하지 못하는데, solve()함수에서 정답을 출력하려 하기 때문에 존재하지 않는 vector 인덱스에 접근하여 오류로 강제 종료된다.  예외 테스트 케이스15goddoggunnewnurse  나중에 수정 및 해결 해볼것…","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-WORDCHAIN/",
        "teaser":null},{
        "title": "[SW Expert Academy] 2117.홈 방범 서비스",
        "excerpt":"홈 방범 서비스 문제 링크   https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5V61LqAf8DFAWu해결 방법 완전 탐색   서비스 영역의 면적이 최대 크기 20 x 20을 모두 포함하려면 대략 k 값을 25로 정한다.  k 값 1 ~ 25 까지 포함되는 모든 좌표를 벡터에 저장한다.          원점 기준으로 하며, 이는 도시 정보의 한 칸 한 칸마다 서비스 영역을 적용하기 위해서이다.        도시 정보가 주어진 2차원 배열의 모든 좌표에서 위에서 저장한 서비스 영역을 적용하여 손해보지 않는 최대 집의 수를 구한다.시간 복잡도 서비스 영역 구하기   다음 서비스 영역을 구하는 방법으로 현재 서비스 영역에서 동서남북 방향으로 한 칸씩 늘리는 방법을 사용하였다.(중복 제외)  서비스 영역의 개수는 1, 5, 13, 25, 41, 61, ... 1201로 증가한다.  이를 바탕으로 최대 시간 복잡도는 대략25 * 4(동서남북) * 1200 * 1200 = 144,000,000으로 약 1초정도 걸릴 것으로 예상된다.최대 집의 개수 구하기   최대 시간 복잡도는 25(서비스 영역 크기) * 20(가로) * 20(세로) * 1200(최대 서비스 영역 좌표 개수) = 12,000,000이다.결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int my[4] = { -1, 0, 1, 0 };int mx[4] = { 0, 1, 0, -1 };//도시 입력int cmap[21][21];//kv[i] = k의 크기가 i일때 방범 서비스를 제공할 수 있는 모든 좌표의 집합vector&lt;pair&lt;int, int&gt;&gt; kv[25];//가로세로 최대 크기 20인 배열을 모두 방범 서비스를 제공할 k의 최대 크기는 대략 23 ~ 25이다.//미리 k의 크기에 따른 방범 서비스를 할 수 있는 좌표 집합을 만든다.void makeKSet() {\t//k = 1일때\tkv[0].push_back({ 0, 0 });\t//k = 2일때 부터 계산을 한다.\tfor (int i = 1; i &lt; 25; ++i) {\t\tint pre_ksize = kv[i - 1].size();\t\tkv[i] = kv[i - 1];\t\tfor (int j = 0; j &lt; pre_ksize; ++j) {\t\t\tfor (int k = 0; k &lt; 4; ++k) {\t\t\t\tint nexty = kv[i - 1][j].first + my[k];\t\t\t\tint nextx = kv[i - 1][j].second + mx[k];\t\t\t\tbool flag = false;\t\t\t\t//중복되는 좌표가 있는지 검사한다.\t\t\t\tfor(int l = 0; l &lt; kv[i].size(); ++l)\t\t\t\t\tif (kv[i][l].first == nexty &amp;&amp; kv[i][l].second == nextx) {\t\t\t\t\t\tflag = true;\t\t\t\t\t\tbreak;\t\t\t\t\t}\t\t\t\t//중복이 없으면 추가한다.\t\t\t\tif (!flag)\t\t\t\t\tkv[i].push_back({ nexty, nextx });\t\t\t}\t\t}\t}}//k에 따른 운영 비용을 반환한다.int calOperationFin(int k) {\treturn (k * k) + ((k - 1) * (k - 1));}int main(void){\tmakeKSet();\tint tc; scanf(\"%d\", &amp;tc);\tfor (int t = 1; t &lt;= tc; ++t) {\t\tmemset(cmap, 0, sizeof(cmap));\t\tint n, m; scanf(\"%d %d\", &amp;n, &amp;m);\t\tfor(int i=0; i&lt;n; ++i)\t\t\tfor(int j=0; j&lt;n; ++j)\t\t\t\tscanf(\"%d\", &amp;cmap[i][j]);\t\tint ans = 0;\t\t//k에 따라 방범 서비스를 받을 수 있는 최대 집의 개수를 계산한다.\t\tfor(int i = 0; i &lt; 25; ++i) {\t\t\t//현재 k에서 운영 비용\t\t\tint curOF = calOperationFin(i + 1);\t\t\t//현재 k에서 모든 좌표를 순회한다.\t\t\tfor (int y = 0; y &lt; n; ++y) {\t\t\t\tfor (int x = 0; x &lt; n; ++x) {\t\t\t\t\tint serviced = 0, curProfit;\t\t\t\t\t//현재 좌표에서 방범 서비스를 받을 수 있는 집의 개수 계산\t\t\t\t\tfor (int j = 0; j &lt; kv[i].size(); ++j) {\t\t\t\t\t\tint nexty = y + kv[i][j].first;\t\t\t\t\t\tint nextx = x + kv[i][j].second;\t\t\t\t\t\tif (nexty &gt;= 0 &amp;&amp; nexty &lt; n &amp;&amp; nextx &gt;= 0 &amp;&amp; nextx &lt; n)\t\t\t\t\t\t\tif (cmap[nexty][nextx])\t\t\t\t\t\t\t\tserviced++;\t\t\t\t\t}\t\t\t\t\tcurProfit = (serviced * m) - curOF;\t\t\t\t\t//비용 손해를 보지 않는다면 최대 집 개수를 갱신한다.\t\t\t\t\tif (curProfit &gt;= 0)\t\t\t\t\t\tans = ans &gt; serviced ? ans : serviced;\t\t\t\t\t\t}\t\t\t}\t\t}\t\tprintf(\"#%d %d\\n\", t, ans);\t}\treturn 0;}","categories": ["PS"],
        "tags": ["SW Expert Academy"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/SW-Expert-Academy-2117.%ED%99%88-%EB%B0%A9%EB%B2%94-%EC%84%9C%EB%B9%84%EC%8A%A4/",
        "teaser":null},{
        "title": "[SW Expert Academy] 2382.미생물 격리",
        "excerpt":"미생물 격리 문제 링크   https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV597vbqAH0DFAVl해결 방법 시뮬레이션   문제에서 제시된 시간에 따라 미생물의 움직임에 대한 경우의 수를 조건에 맞게 구현한다.  주의할 점은 임시로 사용할 배열을 반복문안에 선언하여 사용하면 시간이 훨씬 많이 걸린다.          전역으로 선언하여 초기화해주면서 사용하는 것이 효율적이다.      시간 복잡도   최대 시간 복잡도는 1000(시간) * 1000(군집 개수) * 4(겹쳐질 수 있는 군집의 개수) = 4,000,000이다.결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//상,하,좌,우int my[4] = { -1, 1, 0, 0 };int mx[4] = { 0, 0, -1, 1 };//미생물 군집 정보 클래스class state {public:\tint y, x;\tint microNum;\tint dir;};//방향 반전int reverseDir(int cur) {\t//상하 반전\tif (cur == 0)\t\treturn 1;\telse if (cur == 1)\t\treturn 0;\t//좌우 반전\telse if (cur == 2)\t\treturn 3;\telse if (cur == 3)\t\treturn 2;\treturn -1;}//모든 미생물 군집 정보를 저장할 벡터vector&lt;state&gt; mov;//미생물 군집이 존재하는 좌표에 군집 인덱스를 저장할 2차원 벡터vector&lt;int&gt; map[101][101];int main(void){\tint tc; scanf(\"%d\", &amp;tc);\tfor (int t = 1; t &lt;= tc; ++t) {\t\tmov.clear();\t\tint n, m, k; scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;k);\t\tfor (int i = 0; i &lt; k; ++i) {\t\t\tint y, x, mn, d;\t\t\tscanf(\"%d %d %d %d\", &amp;y, &amp;x, &amp;mn, &amp;d);\t\t\tmov.push_back({ y, x, mn, d - 1 });\t\t}\t\tint msize = mov.size();\t\t//시간 경과\t\tfor (int i = 0; i &lt; m; ++i) {\t\t\t//미생물 군집들이 이동한 결과를 갱신할 벡터\t\t\tvector&lt;state&gt; tmp;\t\t\t/*\t\t\t크기가 큰 저장공간을 계속해서 만들고 사용하는 것은 시간이 매우 오래걸린다.\t\t\t전역으로 선언 후 초기화하면서 사용하는 것이 시간 단축에 큰 도움이 된다.\t\t\t특히 이 문제에서는 map[y][x]을 한번 사용하면 바로 지워주기 때문에\t\t\t따로 초기화해줄 필요가 없어 전역으로 선언해서 사용하면 더욱 효율적이다.\t\t\t(map[y][x]를 중복해서 사용하는 것을 방지하기위해 사용하면 바로 지워준다.)\t\t\t*/\t\t\t//vector&lt;int&gt; map[101][101];\t\t\t//군집 이동\t\t\tfor (int j = 0; j &lt; msize; ++j) {\t\t\t\tint nexty = mov[j].y + my[mov[j].dir];\t\t\t\tint nextx = mov[j].x + mx[mov[j].dir];\t\t\t\tmov[j].y = nexty;\t\t\t\tmov[j].x = nextx;\t\t\t\t//이동한 좌표에 군집 인덱스 저장\t\t\t\tmap[nexty][nextx].push_back(j);\t\t\t}\t\t\t//군집 갱신\t\t\tfor (int j = 0; j &lt; msize; ++j) {\t\t\t\t//해당 좌표의 군집 개수가 1개인 경우\t\t\t\tif (map[mov[j].y][mov[j].x].size() == 1) {\t\t\t\t\t//약품이 칠해진 셀에 도착한 경우\t\t\t\t\tif (mov[j].y == 0 || mov[j].y == n - 1\t\t\t\t\t\t|| mov[j].x == 0 || mov[j].x == n - 1) {\t\t\t\t\t\tstate half;\t\t\t\t\t\thalf.dir = reverseDir(mov[j].dir);\t\t\t\t\t\thalf.y = mov[j].y;\t\t\t\t\t\thalf.x = mov[j].x;\t\t\t\t\t\thalf.microNum = mov[j].microNum / 2;\t\t\t\t\t\t//미생물 군집 크기가 0보다 큰 경우에만 갱신한다.\t\t\t\t\t\tif (half.microNum &gt; 0)\t\t\t\t\t\t\ttmp.push_back(half);\t\t\t\t\t\t//해당 좌표의 인덱스를 지운다.\t\t\t\t\t\tmap[mov[j].y][mov[j].x].clear();\t\t\t\t\t}\t\t\t\t\t//일반 셀인 경우\t\t\t\t\telse {\t\t\t\t\t\ttmp.push_back(mov[j]);\t\t\t\t\t\tmap[mov[j].y][mov[j].x].clear();\t\t\t\t\t}\t\t\t\t}\t\t\t\t//해당 좌표의 군집 개수가 1보다 많은 경우\t\t\t\telse if (map[mov[j].y][mov[j].x].size() &gt; 1) {\t\t\t\t\tint bigMicro = 0, bigIdx = 0, totalMicro = 0;\t\t\t\t\t//방향을 정할 가장 큰 군집 인덱스와 미생물의 총합을 구한다.\t\t\t\t\tfor (int k = 0; k &lt; map[mov[j].y][mov[j].x].size(); ++k) {\t\t\t\t\t\tif (bigMicro &lt; mov[map[mov[j].y][mov[j].x][k]].microNum) {\t\t\t\t\t\t\tbigMicro = mov[map[mov[j].y][mov[j].x][k]].microNum;\t\t\t\t\t\t\tbigIdx = map[mov[j].y][mov[j].x][k];\t\t\t\t\t\t}\t\t\t\t\t\ttotalMicro += mov[map[mov[j].y][mov[j].x][k]].microNum;\t\t\t\t\t}\t\t\t\t\tstate summ;\t\t\t\t\tsumm.dir = mov[bigIdx].dir;\t\t\t\t\tsumm.y = mov[bigIdx].y;\t\t\t\t\tsumm.x = mov[bigIdx].x;\t\t\t\t\tsumm.microNum = totalMicro;\t\t\t\t\ttmp.push_back(summ);\t\t\t\t\t//해당 좌표에는 여러 군집이 저장되어 있으므로 지우지 않으면 중복이 발생한다.(궁극적인 이유)\t\t\t\t\tmap[mov[j].y][mov[j].x].clear();\t\t\t\t}\t\t\t}\t\t\t//갱신한 임시 벡터를 원래 벡터에 저장해주고 크기를 다시 계산한다.\t\t\tmov = tmp;\t\t\tmsize = mov.size();\t\t}\t\t//남은 미생물 군집을 모두 더한다.\t\tint ans = 0;\t\tfor (int i = 0; i &lt; msize; ++i)\t\t\tans += mov[i].microNum;\t\tprintf(\"#%d %d\\n\", t, ans);\t}\treturn 0;}","categories": ["PS"],
        "tags": ["SW Expert Academy"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/SW-Expert-Academy-2382.%EB%AF%B8%EC%83%9D%EB%AC%BC-%EA%B2%A9%EB%A6%AC/",
        "teaser":null},{
        "title": "[SW Expert Academy] 2383.점심 식사시간",
        "excerpt":"점심 식사시간 문제 링크   https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5-BEE6AK0DFAVl해결 방법 조합 + 시뮬레이션   각 사람들이 2개의 계단을 이용하는 모든 경우의 수는 조합으로 풀 수 있다.  각 경우의 수마다 모든 사람이 계단을 내려가는 시뮬레이션을 통해 시간을 구하며, 그 중 최소값을 선택한다.시간 복잡도   최대 10명의 사람이 2개의 계단을 이용하는 모든 경우의 수: 10C2 = 45  시뮬레이션 최대 시간: 10(세로) * 10(가로) * 10(계단을 내려가는 최대 시간) * 10(사람수) = 10,000  45 * 10(사람수, 정보 저장) * 10,000 = 4,500,000Notice   SW Expert Academy는 GCC컴파일러는 사용하는데 이때 sort SLT함수의 3번째 인자 함수 오버로딩이 동작하지 않아 연산자 오버로딩으로 대체 하였다.//에러sort(arriveState.begin(), arriveState.end(), [](state &amp;a, state &amp;b) {  return a.arriveTime &lt; b.arriveTime;});결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;queue&gt;using namespace std;const int INF = 987654321;//계단에 도착한 사람의 상태 클래스class state {public:\tint arriveTime;  //도착 시간\tint stairNum;    //계단 번호\tint personNum;   //사람 번호};//거리 계산int calDist(int py, int px, int sy, int sx) {\treturn abs(py - sy) + abs(px - sx);}//sort함수를 위한 연산자 오버로딩bool operator &lt;(const state &amp;a, const state &amp;b) {\treturn a.arriveTime &lt; b.arriveTime;}int main(void){\tint tc; scanf(\"%d\", &amp;tc);\tfor (int t = 1; t &lt;= tc; ++t) {\t\tint n; scanf(\"%d\", &amp;n);\t\t//사람의 위치를 저장하는 벡터\t\tvector&lt;pair&lt;int, int&gt;&gt; person;\t\t//계단의 위치를 저장하는 벡터\t\tvector&lt;pair&lt;int, int&gt;&gt; stair;\t\t//계단의 길이를 저장할 배열\t\tint sLen[2], cnt = 0;\t\tfor (int i = 0; i &lt; n; ++i)\t\t\tfor (int j = 0; j &lt; n; ++j) {\t\t\t\tint loc; scanf(\"%d\", &amp;loc);\t\t\t\tif (loc == 1)\t\t\t\t\tperson.push_back(make_pair(i, j));\t\t\t\telse if (loc &gt; 1) {\t\t\t\t\tstair.push_back(make_pair(i, j));\t\t\t\t\tsLen[cnt++] = loc;\t\t\t\t}\t\t\t}\t\tint ans = INF;\t\tint psize = person.size();\t\t//계단 2개를 이용하는 모든 경우의 수를 탐색 (조합 사용)\t\tfor (int i = 0; i &lt;= psize; ++i) {\t\t\tvector&lt;int&gt; flag;\t\t\tfor (int j = 0; j &lt; psize - i; ++j)\t\t\t\tflag.push_back(0);\t\t\tfor (int j = 0; j &lt; i; ++j)\t\t\t\tflag.push_back(1);\t\t\t//조합 계산\t\t\tdo {\t\t\t\t//각 사람에게 주어진 계단에 도착할 때의 정보를 저장하는 벡터        //{ 계단까지 거리, 계단 번호, 사람 번호 }\t\t\t\tvector&lt;state&gt; arriveState;\t\t\t\tfor (int j = 0; j &lt; psize; ++j) {\t\t\t\t\tif (!flag[j]) {\t\t\t\t\t\tarriveState.push_back({ calDist(person[j].first, person[j].second,\t\t\t\t\t\t\tstair[0].first, stair[0].second), 0, j });\t\t\t\t\t}\t\t\t\t\telse {\t\t\t\t\t\tarriveState.push_back({ calDist(person[j].first, person[j].second,\t\t\t\t\t\t\tstair[1].first, stair[1].second), 1, j });\t\t\t\t\t}\t\t\t\t}\t\t\t\t//계단에 도착하는 시간을 오름차순으로 정렬\t\t\t\tsort(arriveState.begin(), arriveState.end());\t\t\t\t//time: 시간, serviced: 계단을 모두 내려간 사람 수\t\t\t\tint time = 0, serviced = 0;        //계단의 상황을 통제하는 벡터 {계단 번호, 계단을 내려가는데 걸리는 시간 }\t\t\t\t//계단을 내려가는데 걸리는 시간이\t\t\t\t//-1: 계단을 모두 내려온 후로 계산에서 제외함\t\t\t\t//0: 현재 시간에 계단을 모두 내려옴\t\t\t\t//0보다 큰수: 계단을 내려거야할 시간\t\t\t\tvector&lt;pair&lt;int, int&gt;&gt; s1, s2;\t\t\t\t//시뮬레이션\t\t\t\twhile (true) {\t\t\t\t\t//기저 사례: 계단을 모두 내려간 사람 수와 전체 사람수가 같으면 종료\t\t\t\t\tif (serviced == psize) break;\t\t\t\t\tint vcnt = 0;\t\t\t\t\t//계단 1\t\t\t\t\tfor (int j = 0; j &lt; s1.size(); ++j) {\t\t\t\t\t\t//계단을 사용할 수 있는 최대 사람 수인 3명을 넘으면 빠져나간다.\t\t\t\t\t\tif (vcnt == 3) break;\t\t\t\t\t\tif (s1[j].second &gt; 0) {\t\t\t\t\t\t\ts1[j].second--;\t\t\t\t\t\t\tvcnt++;\t\t\t\t\t\t}\t\t\t\t\t\t//계단을 모두 내려갔다면 서비스완료 사람수를 늘리고 시간에 -1값을 넣는다.\t\t\t\t\t\telse if (s1[j].second == 0) {\t\t\t\t\t\t\tserviced++;\t\t\t\t\t\t\ts1[j].second = -1;\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t\tvcnt = 0;\t\t\t\t\t//계단 2\t\t\t\t\tfor (int j = 0; j &lt; s2.size(); ++j) {\t\t\t\t\t\tif (vcnt == 3) break;\t\t\t\t\t\tif (s2[j].second &gt; 0) {\t\t\t\t\t\t\ts2[j].second--;\t\t\t\t\t\t\tvcnt++;\t\t\t\t\t\t}\t\t\t\t\t\telse if (s2[j].second == 0) {\t\t\t\t\t\t\tserviced++;\t\t\t\t\t\t\ts2[j].second = -1;\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t\t//현재 시간에 계단에 도착하는 사람이 있는지 탐색한다.\t\t\t\t\tfor (int j = 0; j &lt; psize; ++j) {\t\t\t\t\t\tif (arriveState[j].arriveTime == time) {\t\t\t\t\t\t\tif (arriveState[j].stairNum == 0)\t\t\t\t\t\t\t\ts1.push_back({ arriveState[j].personNum, sLen[0] });\t\t\t\t\t\t\telse if(arriveState[j].stairNum == 1)\t\t\t\t\t\t\t\ts2.push_back({ arriveState[j].personNum, sLen[1] });\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t\t//시간 증가\t\t\t\t\ttime++;\t\t\t\t}\t\t\t\t//시간을 1증가하고 시뮬레이션이 종료되므로 시간을 1빼준다.\t\t\t\tans = ans &lt; (time - 1) ? ans : (time - 1);\t\t\t} while (next_permutation(flag.begin(), flag.end()));\t\t}\t\tprintf(\"#%d %d\\n\", t, ans);\t}\treturn 0;}","categories": ["PS"],
        "tags": ["SW Expert Academy"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/SW-Expert-Academy-2383.%EC%A0%90%EC%8B%AC-%EC%8B%9D%EC%82%AC%EC%8B%9C%EA%B0%84/",
        "teaser":null},{
        "title": "[SW Expert Academy] 2477.차량 정비소",
        "excerpt":"차량 정비소 문제 링크   https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV6c6bgaIuoDFAXy&amp;categoryId=AV6c6bgaIuoDFAXy&amp;categoryType=CODE해결 방법 시뮬레이션   문제가 제시하는 고객이 서비스 받는 순서를 그대로 시뮬레이션으로 구현한다.시간 복잡도   최대 시간: 1,000  최대 고객 수: 1,000  최대 창구 개수: 9 + 9 = 18  1,000 * 1,000(?) * 18 = 18,000,000  시뮬레이션 안의 고객 수는 현재 시간에 도착한 고객 수이기 때문에 0 ~ 1000로 시간마다 변한다.결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;queue&gt;using namespace std;//창구 정보를 저장하는 클래스class desk {public:\t\tbool use;          //현재 사용여부\t\tint usingPerson;   //현재 사용하고 있는 사람 번호\t\tint usingTime;     //현재까지 사용한 시간\t\t//클래스 초기화\t\tdesk() {\t\t\tuse = false;\t\t\tusingPerson = 0;\t\t\tusingTime = 0;\t\t}};int main(void){\tint tc; scanf(\"%d\", &amp;tc);\tfor (int t = 1; t &lt;= tc; ++t) {\t\tint n, m, k, a, b;\t\tscanf(\"%d %d %d %d %d\", &amp;n, &amp;m, &amp;k, &amp;a, &amp;b);\t\t//1번 인덱스부터 저장\t\tint at[10], bt[10];\t\tfor (int i = 0; i &lt; n; ++i)\t\t\tscanf(\"%d\", &amp;at[i + 1]);\t\tfor (int i = 0; i &lt; m; ++i)\t\t\tscanf(\"%d\", &amp;bt[i + 1]);\t\tint kt[1001];\t\tfor (int i = 0; i &lt; k; ++i)\t\t\tscanf(\"%d\", &amp;kt[i + 1]);\t\t//현재 시간\t\tint cur_time = 0;\t\t//서비스를 모두 받은 사람 수\t\tint servicedPerson = 0;\t\t//각 창구 정보를 저장하는 벡터(0번 인덱스부터 시작)\t\tvector&lt;desk&gt; aDesk(n);\t\tvector&lt;desk&gt; bDesk(m);\t\t//aq: 접수 창구를 기다리고 있는 대기열\t\t//bq: 정비 창구를 기다리고 있는 대기열\t\tqueue&lt;int&gt; aq, bq;\t\t//각각의 사람이 몇번 접수 창구(0) 몇번 정비 창구(1)를 사용했는지 저장하는 배열\t\tint usedDesk[2][1001];\t\t//시뮬레이션 시작\t\twhile (true) {\t\t\t//기저 사례: 모든 사람이 서비스를 받았다면 반복문을 종료한다.\t\t\tif (servicedPerson == k) break;\t\t\t//현재 시간에서 정비소에 온 사람을 접수 창구 대기열에 추가한다.\t\t\tfor (int i = 0; i &lt; k; ++i)\t\t\t\tif (kt[i + 1] == cur_time)\t\t\t\t\taq.push(i + 1);\t\t\t//접수 창구\t\t\tfor (int i = 0; i &lt; n; ++i) {\t\t\t\t//현재 접수 창구를 사용하지 않고 있으며, 대기열에 사람이 있는 경우\t\t\t\tif (!aDesk[i].use &amp;&amp; !aq.empty()) {\t\t\t\t\taDesk[i].use = true;\t\t\t\t\tint nextPerson = aq.front();\t\t\t\t\taq.pop();\t\t\t\t\tusedDesk[0][nextPerson] = i + 1;\t\t\t\t\taDesk[i].usingPerson = nextPerson;\t\t\t\t}\t\t\t\t//현재 접수 창구를 사용하고 있고, 서비스 시간이 끝난 경우\t\t\t\telse if (aDesk[i].use &amp;&amp; aDesk[i].usingTime == at[i + 1]) {\t\t\t\t\t//정비 창구 대기열에 추가해준다.\t\t\t\t\tbq.push(aDesk[i].usingPerson);\t\t\t\t\t//접수 창구 대기열에 사람이 있다면 추가한다.\t\t\t\t\tif (!aq.empty()) {\t\t\t\t\t\tint nextPerson = aq.front();\t\t\t\t\t\taq.pop();\t\t\t\t\t\tusedDesk[0][nextPerson] = i + 1;\t\t\t\t\t\taDesk[i].usingTime = 0;\t\t\t\t\t\taDesk[i].usingPerson = nextPerson;\t\t\t\t\t}\t\t\t\t\t//대기열이 없다면 초기화한다.\t\t\t\t\telse {\t\t\t\t\t\taDesk[i].use = false;\t\t\t\t\t\taDesk[i].usingPerson = 0;\t\t\t\t\t\taDesk[i].usingTime = 0;\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\t//정비 창구\t\t\tfor (int i = 0; i &lt; m; ++i) {\t\t\t\t//현재 정비 창구를 사용하지 않고 있으며, 대기열에 사람이 있는 경우\t\t\t\tif (!bDesk[i].use &amp;&amp; !bq.empty()) {\t\t\t\t\tbDesk[i].use = true;\t\t\t\t\tint nextPerson = bq.front();\t\t\t\t\tbq.pop();\t\t\t\t\tusedDesk[1][nextPerson] = i + 1;\t\t\t\t\tbDesk[i].usingPerson = nextPerson;\t\t\t\t\t//정비 창구까지 왔다면 모든 서비스를 받은 것으로 간주한다.\t\t\t\t\tservicedPerson++;\t\t\t\t}\t\t\t\t//현재 정비 창구를 사용하고 있고, 서비스 시간이 끝난 경우\t\t\t\telse if (bDesk[i].use &amp;&amp; bDesk[i].usingTime == bt[i + 1]) {\t\t\t\t\t//정비 창구 대기열에 사람이 있다면 추가한다.\t\t\t\t\tif (!bq.empty()) {\t\t\t\t\t\tint nextPerson = bq.front();\t\t\t\t\t\tbq.pop();\t\t\t\t\t\tusedDesk[1][nextPerson] = i + 1;\t\t\t\t\t\tbDesk[i].usingTime = 0;\t\t\t\t\t\tbDesk[i].usingPerson = nextPerson;\t\t\t\t\t\t//정비 창구까지 왔다면 모든 서비스를 받은 것으로 간주한다.\t\t\t\t\t\tservicedPerson++;\t\t\t\t\t}\t\t\t\t\t//대기열이 없다면 초기화한다.\t\t\t\t\telse {\t\t\t\t\t\tbDesk[i].use = false;\t\t\t\t\t\tbDesk[i].usingPerson = 0;\t\t\t\t\t\tbDesk[i].usingTime = 0;\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\t//현재 시간 및 창구에 서비스를 받고 있는 시간을 증가시킨다.\t\t\tcur_time++;\t\t\tfor (int i = 0; i &lt; n; ++i)\t\t\t\tif (aDesk[i].use)\t\t\t\t\taDesk[i].usingTime++;\t\t\tfor (int i = 0; i &lt; m; ++i)\t\t\t\tif (bDesk[i].use)\t\t\t\t\tbDesk[i].usingTime++;\t\t}\t\tint ans = 0;\t\tfor (int i = 0; i &lt; k; ++i) {\t\t\tif (usedDesk[0][i + 1] == a &amp;&amp; usedDesk[1][i + 1] == b)\t\t\t\tans += (i + 1);\t\t}\t\tprintf(\"#%d %d\\n\", t, ans == 0 ? -1 : ans);\t}\treturn 0;}","categories": ["PS"],
        "tags": ["SW Expert Academy"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/SW-Expert-Academy-2477.%EC%B0%A8%EB%9F%89-%EC%A0%95%EB%B9%84%EC%86%8C/",
        "teaser":null},{
        "title": "[SW Expert Academy] 4008.숫자 만들기",
        "excerpt":"숫자 만들기 문제 링크   https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWIeRZV6kBUDFAVH&amp;categoryId=AWIeRZV6kBUDFAVH&amp;categoryType=CODE해결 방법 순열 + 완전탐색   주어진 연산자들이 정해진 숫자 사이의 공간에 위치하는 모든 경우의 수를 순열로 계산하여 해결한다.          연산자의 종류는 4개이므로 4개보다 많은 연산자를 사용하면 반드시 중복이 생긴다.      중복이 m개 있는 수열 n에서 r개를 뽑는 순열은 nPr / m!이다.      시간 복잡도   최대 연산자 개수(n): 11  최대 주어진 공간(r): 11  11P11(= 11!) / m!Notice   음수가 나올 수 있으므로, 가장 작은 값을 설정할 때 0이 아닌 최대 음수값으로 설정해야 한다.결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;const int INF = 987654321;const int RINF = -987654321;int main(void){\tint tc; scanf(\"%d\", &amp;tc);\tfor (int t = 1; t &lt;= tc; ++t) {\t\tint n; scanf(\"%d\", &amp;n);\t\t// 0: +, 1: -, 2: *, 3: /\t\tint oper[4] = { 0, };\t\tvector&lt;int&gt; opv;\t\tfor (int i = 0; i &lt; 4; ++i) {\t\t\tscanf(\"%d\", &amp;oper[i]);\t\t\t//연산자별로 저장하기(조합 탐색을 위해)\t\t\tfor (int j = 0; j &lt; oper[i]; ++j)\t\t\t\topv.push_back(i);\t\t}\t\tint num[13] = { 0, };\t\tfor (int i = 0; i &lt; n; ++i)\t\t\tscanf(\"%d\", &amp;num[i]);\t\t//최대값은 음수를 포함한 범위안에서 가장 작은수\t\t//최소값은 가장 큰수로 초기화한다.\t\tint ans_max = RINF, ans_min = INF;\t\tdo {\t\t\tint cal_res = num[0];\t\t\tint cnt = 0;\t\t\tfor (int i = 1; i &lt; n; ++i) {\t\t\t\tswitch (opv[cnt++]) {\t\t\t\tcase 0: cal_res += num[i]; break;\t\t\t\tcase 1: cal_res -= num[i]; break;\t\t\t\tcase 2: cal_res *= num[i]; break;\t\t\t\tcase 3: cal_res /= num[i]; break;\t\t\t\tdefault: break;\t\t\t\t}\t\t\t}\t\t\tans_max = ans_max &gt; cal_res ? ans_max : cal_res;\t\t\tans_min = ans_min &lt; cal_res ? ans_min : cal_res;\t\t\t/* //연산자의 모든 경우의 수 출력해보기\t\t\tfor (int i = 1; i &lt; n; ++i) {\t\t\t\tswitch (opv[cnt++]) {\t\t\t\tcase 0: printf(\"+ \"); break;\t\t\t\tcase 1: printf(\"- \"); break;\t\t\t\tcase 2: printf(\"* \"); break;\t\t\t\tcase 3: printf(\"/ \"); break;\t\t\t\tdefault: break;\t\t\t\t}\t\t\t}\t\t\tprintf(\"\\n\");*/\t\t} while (next_permutation(opv.begin(), opv.end()));\t\tprintf(\"#%d %d\\n\", t, ans_max - ans_min);\t}\treturn 0;}","categories": ["PS"],
        "tags": ["SW Expert Academy"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/SW-Expert-Academy-4008.%EC%88%AB%EC%9E%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
        "teaser":null},{
        "title": "[SW Expert Academy] 4012.요리사",
        "excerpt":"요리사 문제 링크   https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWIeUtVakTMDFAVH&amp;categoryId=AWIeUtVakTMDFAVH&amp;categoryType=CODE해결 방법 조합 + 완전탐색   재료를 2가지로 나누므로 모든 재료를 2가지로 나누는 모든 경우의 수를 조합으로 계산한다.  재료의 시너지는 각각 2개의 재료의 시너지를 모두 더한 값이다.시간 복잡도   최대 식재료 개수: n = 16  재료 시너지의 총합: (n/2) * (n/2) = 8 * 8 = 64  16C2 * 64 = 7,680결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;const int INF = 987654321;int mat[17][17];int main(void){\tint tc; scanf(\"%d\", &amp;tc);\tfor (int t = 1; t &lt;= tc; ++t) {\t\tmemset(mat, 0, sizeof(mat));\t\tint n; scanf(\"%d\", &amp;n);\t\tfor (int i = 0; i &lt; n; ++i)\t\t\tfor (int j = 0; j &lt; n; ++j)\t\t\t\tscanf(\"%d\", &amp;mat[i][j]);\t\tint ans = INF;\t\t//전체 재료의 반을 선택하는 모든 경우의 수 계산(조합 사용)\t\tvector&lt;int&gt; flag;\t\tfor (int i = 0; i &lt; n - (n / 2); ++i)\t\t\tflag.push_back(0);\t\tfor (int i = 0; i &lt; n / 2; ++i)\t\t\tflag.push_back(1);\t\tdo {\t\t\tint matA[17], matB[17];\t\t\tint cntA = 0, cntB = 0;\t\t\t//1: A재료, 0: B재료 로 사용\t\t\tfor (int i = 0; i &lt; n; ++i)\t\t\t\tif (flag[i])\t\t\t\t\tmatA[cntA++] = i;\t\t\t\telse\t\t\t\t\tmatB[cntB++] = i;\t\t\t//두가지 재료마다 시너지를 모두 더한다.\t\t\tint foodA = 0, foodB = 0;\t\t\tfor (int i = 0; i &lt; n / 2; ++i)\t\t\t\tfor (int j =  i + 1; j &lt; n / 2; ++j) {\t\t\t\t\tfoodA += (mat[matA[i]][matA[j]] + mat[matA[j]][matA[i]]);\t\t\t\t\tfoodB += (mat[matB[i]][matB[j]] + mat[matB[j]][matB[i]]);\t\t\t\t}\t\t\t//맛 차이 구하기\t\t\tint sub = foodA - foodB;\t\t\tsub = sub &gt;= 0 ? sub : -sub;\t\t\tans = ans &lt; sub ? ans : sub;\t\t\t/*for (int i = 0; i &lt; n; ++i)\t\t\t\tif (flag[i])\t\t\t\t\tprintf(\"%d \", i);\t\t\tprintf(\"\\n\");*/\t\t} while (next_permutation(flag.begin(), flag.end()));\t\tprintf(\"#%d %d\\n\", t, ans);\t}\treturn 0;}","categories": ["PS"],
        "tags": ["SW Expert Academy"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/SW-Expert-Academy-4012.%EC%9A%94%EB%A6%AC%EC%82%AC/",
        "teaser":null},{
        "title": "[SW Expert Academy] 4013.특이한 자석",
        "excerpt":"특이한 자석 문제 링크   https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWIeV9sKkcoDFAVH&amp;categoryId=AWIeV9sKkcoDFAVH&amp;categoryType=CODE해결 방법 구현   문제에서 제시한 톱니바퀴가 도는 조건을 바탕으로, 특정 톱니바퀴를 한 번 회전 시킬 때 같이 회전해야할 톱니바퀴들을 계산하여 그에 맞게 회전 시켜 준다.결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;//자석을 회전하는 함수//dir = 1: 시계 방향//dir = -1: 반시계 방향void rotate(int *gear, int dir) {\tif (dir == 1) {\t\tint tmp = gear[7];\t\tfor (int i = 6; i &gt;= 0; --i)\t\t\tgear[i + 1] = gear[i];\t\tgear[0] = tmp;\t}\telse if (dir == -1) {\t\tint tmp = gear[0];\t\tfor (int i = 0; i &lt; 7; ++i)\t\t\tgear[i] = gear[i + 1];\t\tgear[7] = tmp;\t}}int main(void){\tint tc; scanf(\"%d\", &amp;tc);\tfor (int t = 1; t &lt;= tc; ++t) {\t\t//4개 자석\t\tint gear[4][8];\t\tint k; scanf(\"%d\", &amp;k);\t\tfor (int i = 0; i &lt; 4; ++i)\t\t\tfor (int j = 0; j &lt; 8; ++j)\t\t\t\tscanf(\"%d\", &amp;gear[i][j]);\t\t//회전\t\tfor (int i = 0; i &lt; k; ++i) {\t\t\tint n, d; scanf(\"%d %d\", &amp;n, &amp;d);\t\t\t//하나의 톱니바퀴가 회전할 때, 각 자석에 적용해야할 회전 방향\t\t\tint rotRes[4];\t\t\t//1번 자석이 회전하는 경우\t\t\tif (n == 1) {\t\t\t\trotRes[0] = d;\t\t\t\tif (gear[0][2] == gear[1][6]) {\t\t\t\t\trotRes[1] = 0;\t\t\t\t\trotRes[2] = 0;\t\t\t\t\trotRes[3] = 0;\t\t\t\t}\t\t\t\telse {\t\t\t\t\trotRes[1] = -d;\t\t\t\t\tif (gear[1][2] == gear[2][6]) {\t\t\t\t\t\trotRes[2] = 0;\t\t\t\t\t\trotRes[3] = 0;\t\t\t\t\t}\t\t\t\t\telse {\t\t\t\t\t\trotRes[2] = d;\t\t\t\t\t\tif (gear[2][2] == gear[3][6])\t\t\t\t\t\t\trotRes[3] = 0;\t\t\t\t\t\telse\t\t\t\t\t\t\trotRes[3] = -d;\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\t//2번 자석이 회전하는 경우\t\t\telse if (n == 2) {\t\t\t\trotRes[1] = d;\t\t\t\tif (gear[1][2] == gear[2][6]) {\t\t\t\t\trotRes[2] = 0;\t\t\t\t\trotRes[3] = 0;\t\t\t\t}\t\t\t\telse {\t\t\t\t\trotRes[2] = -d;\t\t\t\t\tif (gear[2][2] == gear[3][6])\t\t\t\t\t\trotRes[3] = 0;\t\t\t\t\telse\t\t\t\t\t\trotRes[3] = d;\t\t\t\t}\t\t\t\tif (gear[0][2] == gear[1][6])\t\t\t\t\trotRes[0] = 0;\t\t\t\telse\t\t\t\t\trotRes[0] = -d;\t\t\t}\t\t\t//3번 자석이 회전하는 경우\t\t\telse if (n == 3) {\t\t\t\trotRes[2] = d;\t\t\t\tif (gear[2][2] == gear[3][6])\t\t\t\t\trotRes[3] = 0;\t\t\t\telse\t\t\t\t\trotRes[3] = -d;\t\t\t\tif (gear[1][2] == gear[2][6]) {\t\t\t\t\trotRes[1] = 0;\t\t\t\t\trotRes[0] = 0;\t\t\t\t}\t\t\t\telse {\t\t\t\t\trotRes[1] = -d;\t\t\t\t\tif (gear[0][2] == gear[1][6])\t\t\t\t\t\trotRes[0] = 0;\t\t\t\t\telse\t\t\t\t\t\trotRes[0] = d;\t\t\t\t}\t\t\t}\t\t\t//4번 자석이 회전하는 경우\t\t\telse if (n == 4) {\t\t\t\trotRes[3] = d;\t\t\t\tif (gear[2][2] == gear[3][6]) {\t\t\t\t\trotRes[2] = 0;\t\t\t\t\trotRes[1] = 0;\t\t\t\t\trotRes[0] = 0;\t\t\t\t}\t\t\t\telse {\t\t\t\t\trotRes[2] = -d;\t\t\t\t\tif (gear[1][2] == gear[2][6]) {\t\t\t\t\t\trotRes[1] = 0;\t\t\t\t\t\trotRes[0] = 0;\t\t\t\t\t}\t\t\t\t\telse {\t\t\t\t\t\trotRes[1] = d;\t\t\t\t\t\tif (gear[0][2] == gear[1][6])\t\t\t\t\t\t\trotRes[0] = 0;\t\t\t\t\t\telse\t\t\t\t\t\t\trotRes[0] = -d;\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\t//회전 적용 (0이면 회전하지 않음)\t\t\tfor (int j = 0; j &lt; 4; ++j)\t\t\t\tif (rotRes[j] != 0)\t\t\t\t\trotate(gear[j], rotRes[j]);\t\t}\t\t//점수 계산\t\tprintf(\"#%d %d\\n\", t, gear[0][0] * 1 + gear[1][0] * 2 +\t\t\tgear[2][0] * 4 + gear[3][0] * 8);\t}\treturn 0;}","categories": ["PS"],
        "tags": ["SW Expert Academy"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/SW-Expert-Academy-4013.%ED%8A%B9%EC%9D%B4%ED%95%9C-%EC%9E%90%EC%84%9D/",
        "teaser":null},{
        "title": "[SW Expert Academy] 4014.활주로 건설",
        "excerpt":"활주로 건설 문제 링크   https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWIeW7FakkUDFAVH&amp;categoryId=AWIeW7FakkUDFAVH&amp;categoryType=CODE해결 방법 구현   활주로를 만드는 경우의 수를 총 4가지로 구분하였다.          경사가 모두 같은 경우      경사 차이가 1보다 큰 경우(활주로를 지을 수 없음)      오르막 설치      내리막 설치                  구현 능력에 따라 코드 길이를 대폭 줄일 수 있는 것 같다. 나는 실력이 부족해서 안되는 경우가 있으면 다시 추가 추가하면서 구현하였다.                     결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;#define N 21//입력 배열int map[N][N];int main(void){\tint tc; scanf(\"%d\", &amp;tc);\tfor (int t = 1; t &lt;= tc; ++t) {\t\tmemset(map, 0, sizeof(map));\t\tint n, x; scanf(\"%d %d\", &amp;n, &amp;x);\t\tfor (int i = 0; i &lt; n; ++i)\t\t\tfor (int j = 0; j &lt; n; ++j)\t\t\t\tscanf(\"%d\", &amp;map[i][j]);\t\t//활주로 개수\t\tint ans = 0;\t\t//활주로를 건설할 수 있는지 검사\t\tbool buildPos = false;\t\t//가로 방향\t\tfor (int i = 0; i &lt; n; ++i) {\t\t\t//한 활주로에서 경사로를 지을수 있는지 없는지 검사하는 배열\t\t\tbool check[N] = { false, };\t\t\tbuildPos = false;\t\t\t//높이가 같은 인덱스를 한 그룹으로 묶는다.\t\t\t//preIdx: 이전 그룹의 가장 마지막 인덱스(0으로 초기화)\t\t\t//curIdx: 현재 그룹의 가장 마지막 인덱스\t\t\tint preIdx = 0;\t\t\tfor (int j = 0; j &lt; n; ++j) {\t\t\t\t//높이 같은 인덱스 개수\t\t\t\tint sameCnt = 1;\t\t\t\tint curIdx;\t\t\t\t//높이가 같은 인덱스 개수 계산\t\t\t\tfor (curIdx = j + 1; curIdx &lt; n; ++curIdx) {\t\t\t\t\tif (map[i][j] == map[i][curIdx])\t\t\t\t\t\tsameCnt++;\t\t\t\t\telse\t\t\t\t\t\tbreak;\t\t\t\t}\t\t\t\t//현재 인덱스를 현재 그룹 가장 마지막 인덱스에 맞춘다.\t\t\t\tcurIdx -= 1;\t\t\t\t//주어진 x길이보다 크거나 같다면 해당 그룹을 모두 true값을 넣어준다.\t\t\t\tif (sameCnt &gt;= x) {\t\t\t\t\t//preIdx를 0으로 초기화 하였기 때문에 처음 그룹이 인덱스 0을 포함한다면 0도 true값을 넣어준다.\t\t\t\t\tif (!preIdx) check[0] = true;\t\t\t\t\tfor (int k = preIdx + 1; k &lt;= curIdx; ++k)\t\t\t\t\t\tcheck[k] = true;\t\t\t\t}\t\t\t\t// 1) preIdx가 0이고, preIdx와 curIdx의 높이가 같다면 이 그룹은 같은 그룹이며 모두 높이가 같다.\t\t\t\tif (preIdx == 0 &amp;&amp; map[i][preIdx] - map[i][curIdx] == 0)\t\t\t\t\tbuildPos = true;\t\t\t\t// 2) 이전 그룹보다 현재 그룹의 높이가 1 작은 경우,\t\t\t\t// 현재 그룹의 처음부터 x개의 경사로를 만들 수 있어야 한다.\t\t\t\telse if (map[i][preIdx] - map[i][curIdx] == 1 &amp;&amp; (preIdx + x) &lt; n\t\t\t\t\t&amp;&amp; check[preIdx + x]) {\t\t\t\t\tbuildPos = true;\t\t\t\t\t//x개의 경사로를 만들었으므로, 해당 인덱스에서 중복으로 경사로를 지을 수 없다.\t\t\t\t\tfor (int k = preIdx + 1; k &lt;= preIdx + x; ++k)\t\t\t\t\t\tcheck[k] = false;\t\t\t\t}\t\t\t\t// 3) 이전 그룹보다 현재 그룹의 높이가 1 큰 경우,\t\t\t\t// 이전 그룹의 마지막부터 x개의 경사로를 만들 수 있어야 한다.\t\t\t\telse if (map[i][preIdx] - map[i][curIdx] == -1 &amp;&amp; (preIdx - x + 1) &gt;= 0\t\t\t\t\t&amp;&amp; check[preIdx - x + 1]) {\t\t\t\t\tbuildPos = true;\t\t\t\t\tfor (int k = preIdx - x + 1; k &lt;= preIdx; ++k)\t\t\t\t\t\tcheck[k] = false;\t\t\t\t}\t\t\t\t// 4) 높이차이가 1보다 크거나, 경사로를 지을 수 없는 경우\t\t\t\telse {\t\t\t\t\tbuildPos = false;\t\t\t\t\tbreak;\t\t\t\t}\t\t\t\t//현재 인덱스를 이전 인덱스에 삽입한다.\t\t\t\tpreIdx = curIdx;\t\t\t\tj = curIdx;\t\t\t}\t\t\t//활주로를 지을 수 있다면 개수를 증가한다.\t\t\tif (buildPos) ans++;\t\t}\t\t//세로 방향\t\t//가로 방향 알고리즘에서 map배열의 인덱스를 서로 바꿔준다.\t\tfor (int i = 0; i &lt; n; ++i) {\t\t\tbool check[N] = { false, };\t\t\tbuildPos = false;\t\t\tint preIdx = 0;\t\t\tfor (int j = 0; j &lt; n; ++j) {\t\t\t\tint sameCnt = 1;\t\t\t\tint curIdx;\t\t\t\tfor (curIdx = j + 1; curIdx &lt; n; ++curIdx) {\t\t\t\t\tif (map[j][i] == map[curIdx][i])\t\t\t\t\t\tsameCnt++;\t\t\t\t\telse\t\t\t\t\t\tbreak;\t\t\t\t}\t\t\t\tcurIdx -= 1;\t\t\t\tif (sameCnt &gt;= x) {\t\t\t\t\tif (!preIdx) check[0] = true;\t\t\t\t\tfor (int k = preIdx + 1; k &lt;= curIdx; ++k)\t\t\t\t\t\tcheck[k] = true;\t\t\t\t}\t\t\t\tif (preIdx == 0 &amp;&amp; map[preIdx][i] - map[curIdx][i] == 0)\t\t\t\t\tbuildPos = true;\t\t\t\telse if (map[preIdx][i] - map[curIdx][i] == 1 &amp;&amp; (preIdx + x) &lt; n\t\t\t\t\t&amp;&amp; check[preIdx + x]) {\t\t\t\t\tbuildPos = true;\t\t\t\t\tfor (int k = preIdx + 1; k &lt;= preIdx + x; ++k)\t\t\t\t\t\tcheck[k] = false;\t\t\t\t}\t\t\t\telse if (map[preIdx][i] - map[curIdx][i] == -1 &amp;&amp; (preIdx - x + 1) &gt;= 0\t\t\t\t\t&amp;&amp; check[preIdx - x + 1]) {\t\t\t\t\tbuildPos = true;\t\t\t\t\tfor (int k = preIdx - x + 1; k &lt;= preIdx; ++k)\t\t\t\t\t\tcheck[k] = false;\t\t\t\t}\t\t\t\telse {\t\t\t\t\tbuildPos = false;\t\t\t\t\tbreak;\t\t\t\t}\t\t\t\tpreIdx = curIdx;\t\t\t\tj = curIdx;\t\t\t}\t\t\tif (buildPos) ans++;\t\t}\t\tprintf(\"#%d %d\\n\", t, ans);\t}\treturn 0;}","categories": ["PS"],
        "tags": ["SW Expert Academy"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/SW-Expert-Academy-4014.%ED%99%9C%EC%A3%BC%EB%A1%9C-%EA%B1%B4%EC%84%A4/",
        "teaser":null},{
        "title": "[SW Expert Academy] 5644.무선 충전",
        "excerpt":"무선 충전 문제 링크   https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRDL1aeugDFAUo&amp;categoryId=AWXRDL1aeugDFAUo&amp;categoryType=CODE&amp;&amp;&amp;해결 방법 시뮬레이션   2차원 배열에 주어진 배터리 범위들을 저장한다.  두 사용자의 시작점부터 한 칸씩 이동할 때마다 배터리 범위에 포함되어 있는지 검사한다.  두 사용자가 배터리 범위에 있을 경우의 수는 총 3가지가 있다.          A사용자가 배터리 범위에 있고 B사용자는 배터리 범위에 있지 않을 경우                  A사용자가 속한 배터리 범위 중 가장 큰 충전량을 선택한다.                    A사용자가 배터리 범위에 없고 B사용자는 배터리 범위에 있는 경우                  B사용자가 속한 배터리 범위 중 가장 큰 충전량을 선택한다.                    A사용자, B사용자 둘 다 배터리 범위에 있는 경우                  A, B사용자가 같은 배터리 범위에 있을 때의 충전량과 다른 배터리 범위에 있을 때 충전량 중 큰 값을 선택한다.                    결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//이동하지 않음, 상, 우, 하, 좌int my[5] = { 0, -1, 0, 1, 0 };int mx[5] = { 0, 0, 1, 0, -1 };//배터리 정보class APInfo {public:\tint y, x;  //배터리 좌표\tint c;     //범위\tint p;     //충전량};//범위 크기에 따라 계산할 좌표 벡터(인덱스 0이 문제에서 범위 1를 나타낸다.)vector&lt;pair&lt;int, int&gt;&gt; covSet[5];//배터리 정보를 저장할 벡터vector&lt;APInfo&gt; apv;//사용자 A, B의 움직임을 저장할 벡터vector&lt;int&gt; amove, bmove;//지도에서 해당 좌표에 어떤 BC번호가 있는지 저장할 벡터(하나의 좌표에 여러 BC가 있을 수 있음)vector&lt;int&gt; board[11][11];//범위 크기에 따라 계산할 좌표 벡터를 만든다.void makeCoverage() {\t//범위가 1인 경우\tcovSet[0].push_back({ 0, 0 });\tcovSet[0].push_back({ -1, 0 });\tcovSet[0].push_back({ 0, 1 });\tcovSet[0].push_back({ 1, 0 });\tcovSet[0].push_back({ 0, -1 });\t//중복을 방지할 플래그\tbool flag;\t//문제 기준 범위 크기 5까지 만든다.\t//이전 범위에서 상하좌우를 각각 추가해준다.(중복 제외)\tfor (int i = 1; i &lt; 5; ++i) {\t\tcovSet[i] = covSet[i - 1];\t\t//이전 범위에서 좌표 개수\t\tint preSize = covSet[i - 1].size();\t\t//현재 범위에서 좌표 개수\t\tint curSize = covSet[i].size();\t\tfor (int j = 0; j &lt; preSize; ++j) {\t\t\t//상하좌우 추가\t\t\tfor (int k = 1; k &lt; 5; ++k) {\t\t\t\tflag = false;\t\t\t\tint nexty = covSet[i][j].first + my[k];\t\t\t\tint nextx = covSet[i][j].second + mx[k];\t\t\t\t//현재 범위 좌표 벡터에 중복이 있는지 검사한다.\t\t\t\tfor (int l = 0; l &lt; curSize; ++l)\t\t\t\t\tif (covSet[i][l].first == nexty &amp;&amp; covSet[i][l].second == nextx) {\t\t\t\t\t\tflag = true;\t\t\t\t\t\tbreak;\t\t\t\t\t}\t\t\t\t//중복이 없으면 추가한다.\t\t\t\tif (!flag) {\t\t\t\t\tcovSet[i].push_back({ nexty, nextx });\t\t\t\t\tcurSize++;\t\t\t\t}\t\t\t}\t\t}\t}}int main(void){\tmakeCoverage();\tint tc; scanf(\"%d\", &amp;tc);\tfor (int t = 1; t &lt;= tc; ++t) {\t\t//지도 초기화\t\tfor (int i = 0; i &lt; 11; ++i)\t\t\tfor (int j = 0; j &lt; 11; ++j)\t\t\t\tboard[i][j].clear();\t\tint m, a; scanf(\"%d %d\", &amp;m, &amp;a);\t\t//이동하지 않을 때도 충전을 검사해야하기 때문에 가장 처음에 이동하지 않는 경우를 추가한다.\t\t//입력 벡터 초기화\t\tamove = vector&lt;int&gt;(m + 1, 0);\t\tbmove = vector&lt;int&gt;(m + 1, 0);\t\tapv = vector&lt;APInfo&gt;(a);\t\t//이동하지 않은 경우\t\tamove[0] = 0;\t\tbmove[0] = 0;\t\t//시간에 따른 이동 정보 저장\t\tfor (int i = 0; i &lt; m; ++i)\t\t\tscanf(\"%d\", &amp;amove[i + 1]);\t\tfor (int i = 0; i &lt; m; ++i)\t\t\tscanf(\"%d\", &amp;bmove[i + 1]);\t\t//BC정보 입력\t\tfor (int i = 0; i &lt; a; ++i) {\t\t\t//입력은 x좌표부터인 것에 유의한다.\t\t\tscanf(\"%d %d %d %d\", &amp;apv[i].x, &amp;apv[i].y, &amp;apv[i].c, &amp;apv[i].p);\t\t\t//문제에서는 (1, 1)부터 시작이므로 각각 1을 빼준다.\t\t\tapv[i].y -= 1;\t\t\tapv[i].x -= 1;\t\t\t//현재 범위 좌표 벡터의 크기\t\t\tint csize = covSet[apv[i].c - 1].size();\t\t\t//BC범위를 지도에 표시한다.\t\t\tfor (int j = 0; j &lt; csize; ++j) {\t\t\t\tint nexty = apv[i].y + covSet[apv[i].c - 1][j].first;\t\t\t\tint nextx = apv[i].x + covSet[apv[i].c - 1][j].second;\t\t\t\t//범위 내에 있는 경우\t\t\t\tif (nexty &gt;= 0 &amp;&amp; nexty &lt; 10 &amp;&amp; nextx &gt;= 0 &amp;&amp; nextx &lt; 10)\t\t\t\t\tboard[nexty][nextx].push_back(i);\t\t\t}\t\t}\t\tint ans = 0;\t\t//현재 사용자 A, B의 위치 좌표\t\tpair&lt;int, int&gt; cusA, cusB;\t\t//사용자 A의 처음 위치\t\tcusA = make_pair(0, 0);\t\t//사용자 B의 처음 위치\t\tcusB = make_pair(9, 9);\t\t//시뮬레이션(이동하지 않는 경우 포함)\t\tfor (int i = 0; i &lt;= m; ++i) {\t\t\t//사용자 A의 다음 위치\t\t\tcusA.first += my[amove[i]];\t\t\tcusA.second += mx[amove[i]];\t\t\t//사용자 B의 다음 위치\t\t\tcusB.first += my[bmove[i]];\t\t\tcusB.second += mx[bmove[i]];\t\t\t//현재 사용자A, B의 좌표에서 어떤 BC가 있는지 모두 저장할 벡터\t\t\tvector&lt;int&gt; covA, covB;\t\t\t//사용자 A 위치 좌표에서 BC 개수\t\t\tint asize = board[cusA.first][cusA.second].size();\t\t\t//사용자 B 위치 좌표에서 BC 개수\t\t\tint bsize = board[cusB.first][cusB.second].size();\t\t\t//BC 추가\t\t\tfor (int j = 0; j &lt; asize; ++j)\t\t\t\tcovA.push_back(board[cusA.first][cusA.second][j]);\t\t\tfor (int j = 0; j &lt; bsize; ++j)\t\t\t\tcovB.push_back(board[cusB.first][cusB.second][j]);\t\t\tint curChargeA = 0, curChargeB = 0, sumCharge = 0;\t\t\t//현재 좌표에서 최대 충전량을 구할 경우의 수는 총 3가지가 있다.\t\t\t// 1) 사용자 A 좌표에서 BC가 있고 사용자 B 좌표에서 BC가 없는 경우\t\t\tif (asize &gt; 0 &amp;&amp; bsize == 0) {\t\t\t\tfor (int j = 0; j &lt; asize; ++j)\t\t\t\t\tcurChargeA = curChargeA &gt; apv[covA[j]].p ? curChargeA : apv[covA[j]].p;\t\t\t\tsumCharge = curChargeA;\t\t\t}\t\t\t// 2) 사용자 A 좌표에서 BC가 없고 사용자 B 좌표에서 BC가 있는 경우\t\t\telse if (asize == 0 &amp;&amp; bsize &gt; 0) {\t\t\t\tfor (int j = 0; j &lt; bsize; ++j)\t\t\t\t\tcurChargeB = curChargeB &gt; apv[covB[j]].p ? curChargeB : apv[covB[j]].p;\t\t\t\tsumCharge = curChargeB;\t\t\t}\t\t\t// 3) 사용자 A, B 좌표에 BC가 모두 있는 경우\t\t\telse {\t\t\t\tfor (int j = 0; j &lt; asize; ++j) {\t\t\t\t\tfor (int k = 0; k &lt; bsize; ++k) {\t\t\t\t\t\tif (covA[j] == covB[k]) {\t\t\t\t\t\t\tcurChargeA = apv[covA[j]].p / 2;\t\t\t\t\t\t\tcurChargeB = apv[covB[k]].p / 2;\t\t\t\t\t\t}\t\t\t\t\t\telse {\t\t\t\t\t\t\tcurChargeA = apv[covA[j]].p;\t\t\t\t\t\t\tcurChargeB = apv[covB[k]].p;\t\t\t\t\t\t}\t\t\t\t\t\tint tmpSum = curChargeA + curChargeB;\t\t\t\t\t\tsumCharge = sumCharge &gt; tmpSum ? sumCharge : tmpSum;\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tans += sumCharge;\t\t}\t\tprintf(\"#%d %d\\n\", t, ans);\t}\treturn 0;}","categories": ["PS"],
        "tags": ["SW Expert Academy"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/SW-Expert-Academy-5644.%EB%AC%B4%EC%84%A0-%EC%B6%A9%EC%A0%84/",
        "teaser":null},{
        "title": "[SW Expert Academy] 5653.줄기세포배양",
        "excerpt":"줄기세포배양 문제 링크   https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRJ8EKe48DFAUo&amp;categoryId=AWXRJ8EKe48DFAUo&amp;categoryType=CODE해결 방법 시뮬레이션   문제에서 세포 최대 크기가 주어지지 않았지만 초기 상태의 최대 크기가 가로/세로 50이며 최대 배양 시간이 300이므로 최대 크기는 가로/세로 350으로 예상할 수 있다.  세포 배양은 문제에서 주어진 대로 구현하며, 두 개 이상의 줄기 세포가 하나의 그리드 셀에 동시 번식하는 경우는 현재 시간에서 배양할 수 있는 모든 세포를 미리 번식시킨 뒤 생명력 수치를 기준으로 내림차순 정렬하여 수치가 가장 큰 세포가 번식하면 그 아래는 무시한다.결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//상방향부터 시계 방향int my[4] = { -1, 0, 1, 0 };int mx[4] = { 0, 1, 0, -1 };//해당 좌표에 세포가 있는지 검사하는 2차원 배열//문제에서 최대 한방향으로 350만큼 갈 수 있다.bool visited[800][800];//세포 정보class cellInfo {public:\tint y, x;      //세포 좌표\tint lifetime;  //생명력 수치\tint timeCnt;   //시간에 따른 생명력 수치 변화\t               //0 &gt; timeCnt: 비활성 상태\t               //timeCnt == 0: 활성 상태 + 번식할 수 있는 상태                   //0 &gt; timeCnt &gt; -lifetime: 활성 상태\t               //-lifetime &gt;= timeCnt: 죽은 상태};//cv: 해당 시간에 존재하는 세포들의 정보를 저장한 벡터//add: 해당 시간에 추가해야할 세포들의 정보를 저장한 벡터vector&lt;cellInfo&gt; cv, add;//생명력 수치를 내림차순으로 정렬한다.bool comp(const cellInfo &amp;a, const cellInfo &amp;b) {\treturn a.lifetime &gt; b.lifetime;}int main(void){\tint tc; scanf(\"%d\", &amp;tc);\tfor (int t = 1; t &lt;= tc; ++t) {\t\t//초기화\t\tmemset(visited, false, sizeof(visited));\t\tcv.clear();\t\tint n, m, k; scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;k);\t\tfor (int i = 0; i &lt; n; ++i)\t\t\tfor (int j = 0; j &lt; m; ++j) {\t\t\t\tint life; scanf(\"%d\", &amp;life);\t\t\t\t//생명력 수치가 0보다 큰 경우\t\t\t\tif (life &gt; 0) {\t\t\t\t\tcv.push_back({ i, j, life, life });\t\t\t\t\t//좌표를 모두 양수로 만들기 위해 각각 400을 더한다.\t\t\t\t\tvisited[i + 400][j + 400] = true;\t\t\t\t}\t\t\t}\t\tfor (int i = 0; i &lt; k; ++i) {\t\t\tadd.clear();\t\t\tint cvSize = cv.size();\t\t\t//세포가 활성화 상태 + 번식 가능 상태일 때 번식할 세포의 정보를 임시 벡터에 저장한다.\t\t\tfor (int j = 0; j &lt; cvSize; ++j) {\t\t\t\t//상태 검사\t\t\t\tif (cv[j].timeCnt == 0) {\t\t\t\t\tfor (int l = 0; l &lt; 4; ++l) {\t\t\t\t\t\tint nexty = cv[j].y + my[l];\t\t\t\t\t\tint nextx = cv[j].x + mx[l];\t\t\t\t\t\t//이미 해당 좌표에 세포가 있으면 넘어간다.\t\t\t\t\t\tif (visited[nexty + 400][nextx + 400]) continue;\t\t\t\t\t\t//번식할 수 있는 모든 세포를 추가한다.(중복 좌표 포함)\t\t\t\t\t\tadd.push_back({ nexty, nextx, cv[j].lifetime, cv[j].lifetime });\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\t//번식한 세포를 제외한 모든 세포의 시간을 1 감소시킨다.\t\t\tfor (int j = 0; j &lt; cvSize; ++j)\t\t\t\tcv[j].timeCnt--;\t\t\t//번식한 세포들을 생명력 수치를 기준으로 내림차순으로 정렬한다.\t\t\t//해당 좌표에서 가장 큰 생명력 수치를 저장하고 그 이후는 무시하기 위함이다.\t\t\tsort(add.begin(), add.end(), comp);\t\t\tfor (int j = 0; j &lt; add.size(); ++j) {\t\t\t\t//해당 좌표에 세포가 없다면 세포를 추가한다.\t\t\t\tif (!visited[add[j].y + 400][add[j].x + 400]) {\t\t\t\t\tcv.push_back(add[j]);\t\t\t\t\tvisited[add[j].y + 400][add[j].x + 400] = true;\t\t\t\t}\t\t\t}\t\t}\t\tint ans = 0;\t\t//활성 상태와 비활성 상태의 세포의 수를 센다.\t\tfor (int i = 0; i &lt; cv.size(); ++i)\t\t\tif (cv[i].timeCnt &gt; -cv[i].lifetime)\t\t\t\tans++;\t\tprintf(\"#%d %d\\n\", t, ans);\t}\treturn 0;}","categories": ["PS"],
        "tags": ["SW Expert Academy"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/SW-Expert-Academy-5653.%EC%A4%84%EA%B8%B0%EC%84%B8%ED%8F%AC%EB%B0%B0%EC%96%91/",
        "teaser":null},{
        "title": "[SW Expert Academy] 5658.보물상자 비밀번호",
        "excerpt":"보물상자 비밀번호 문제 링크   https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRUN9KfZ8DFAUo&amp;categoryId=AWXRUN9KfZ8DFAUo&amp;categoryType=CODE해결 방법 구현   수열을 string으로 입력받는다.  string을 4개로 나눈다.(사각형의 각 변)  생성된 수 문자열(16진수)를 중복없이 저장한다.  3번 회전한 후, 생성된 모든 수 문자열을 10진수 int형으로 변환한다.  이를 내림차순으로 정렬한 후 k번째를 반환한다.결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;//16진수 한자리 문자를 10진수 정수형으로 변환하여 반환한다.int hexToDec(char h) {\tswitch (h) {\tcase 'A': return 10;\tcase 'B': return 11;\tcase 'C': return 12;\tcase 'D': return 13;\tcase 'E': return 14;\tcase 'F': return 15;\tdefault: return h - '0';\t}}//16진수 숫자 문자열을 10진수 정수형으로 변환하여 반환한다.int changeDec(string hex) {\tint hsize = hex.size();\tint res = 0;\tint mult = hsize - 1;\tfor (int i = 0; i &lt; hsize; ++i) {\t\tint num = hexToDec(hex[i]);\t\tfor (int j = 0; j &lt; mult; ++j)\t\t\tnum *= 16;\t\tmult--;\t\tres += num;\t}\treturn res;}//내림차순bool comp(const int a, const int b) {\treturn a &gt; b;}//회전하여 나타날 수 있는 모든 변의 숫자를 내림차순하여 k번째 숫자를 반환한다.int solution(string number, int k) {\tint ans = 0;\tint size = number.size();\t//변은 총 4개이므로 현재 숫자 길이에서\t//회전할 수 있는 횟수를 계산한다.\tint numOfRot = size / 4;\t//각 변의 숫자 문자열을 저장하는 벡터\tvector&lt;string&gt; n;\t//현재 숫자 문자열\tstring cur;\tcur = number;\tchar tmp[30];\tfor (int i = 0; i &lt; numOfRot; ++i) {\t\t//각 변의 숫자만을 파싱하기 위해 사용할 인덱스(다음 파싱할 문자열의 시작 인덱스)\t\tint nIdx = 0;\t\t//총 4개의 변에서 나타날 수 있는 숫자 문자열을 만든다.\t\tfor (int j = 0; j &lt; 4; ++j) {\t\t\tint cnt = 0;\t\t\tfor (int k = 0; k &lt; numOfRot; ++k)\t\t\t\ttmp[cnt++] = cur[nIdx + k];\t\t\tnIdx += numOfRot;\t\t\ttmp[cnt] = '\\0';\t\t\t//중복을 피하기 위해 사용될 스트링\t\t\tstring check = tmp;\t\t\tbool flag = false;\t\t\t//중복이 있는지 검사\t\t\tfor (int k = 0; k &lt; n.size(); ++k)\t\t\t\tif (check == n[k]) {\t\t\t\t\tflag = true;\t\t\t\t\tbreak;\t\t\t\t}\t\t\t//중복이 없다면 벡터에 추가한다.\t\t\tif (!flag)\t\t\t\tn.push_back(check);\t\t}\t\t//회전\t\t//현재 문자열의 마지막 문자를 임시로 저장한다.\t\tchar first = cur.at(size - 1);\t\t//회전이 끝난 문자열을 저장할 스트링\t\tstring next;\t\t//현재 문자열의 마지막 문자를 회전 후의 문자열 첫번째 인덱스에 위치한다.\t\tnext.push_back(first);\t\t//현재 문자열의 마지막 문자를 제외한 문자열을 순서대로 회전 후의 문자열에 삽입한다.\t\tfor (int j = 0; j &lt; size - 1; ++j)\t\t\tnext.push_back(cur[j]);\t\t//현재 문자열을 갱신한다.\t\tcur = next;\t\t/*cout &lt;&lt; cur &lt;&lt; endl;\t\tfor (int j = 0; j &lt; n.size(); ++j)\t\t\tcout &lt;&lt; n[j] &lt;&lt; \" \";\t\tprintf(\"\\n\");*/\t}\t//문자열을 십진수 숫자로 변환 후 저장할 벡터\tvector&lt;int&gt; num;\t//문자열을 십진수 숫자로 변환\tfor (int i = 0; i &lt; n.size(); ++i)\t\tnum.push_back(changeDec(n[i]));\t//내림차순 정렬\tsort(num.begin(), num.end(), comp);\t//k번째 숫자 저장\tans = num[k - 1];\treturn ans;}int main(void){\tint tc; scanf(\"%d\", &amp;tc);\tfor (int t = 1; t &lt;= tc; ++t) {\t\tint n, k; scanf(\"%d %d\", &amp;n, &amp;k);\t\tstring number;\t\tcin &gt;&gt; number;\t\tprintf(\"#%d %d\\n\", t, solution(number, k));\t}\treturn 0;}","categories": ["PS"],
        "tags": ["SW Expert Academy"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/SW-Expert-Academy-5658.%EB%B3%B4%EB%AC%BC%EC%83%81%EC%9E%90-%EB%B9%84%EB%B0%80%EB%B2%88%ED%98%B8/",
        "teaser":null},{
        "title": "[Algorithm]너비 우선 탐색(BFS)",
        "excerpt":"너비 우선 탐색(BFS)과 최단 거리 알고리즘 너비 우선 탐색으로 최단 거리 구하기   가중치가 없는 그래프에 대해 주로 사용할 수 있다.  최단 경로를 구성하는 정점들의 목록을 구할 수 있다.넓이 우선 탐색으로 최단거리 구하는 과정   간선(u, v)를 통해 정점 v를 처음 발견하여 큐에 넣었다.  시작점으로부터 정점 v까지 최단 거리 distance[v]는 시작적으로부터 정점 u까지 최단 거리 distance[u]에 1을 더한 것이다.  너비 우선 탐색 스패닝 트리를 보면 시작점으로부터 각 정점이 모두 실제 그래프상 최단 경로임을 알 수 있다. 구현   bfs(): 각 정점까지의 최단 거리를 계산하고, 너비 우선 탐색 스패닝 트리를 만든다.  shortestPath(): 너비 우선 탐색 스패닝 트리와 정점을 입력받아, 루트로부터 해당 입력된 정점까지의 최단 경로를 반환한다.          루트로부터 입력 정점까지 경로와 입력 정점으로부터 루트까지 경로가 같은 것을 이용한다.      BFS 스패닝 트리에서 각 정점의 부모 정점을 저장한 배열을 이용하여 계산한다.(parent[])      vector&lt;vector&lt;int&gt;&gt; adj;//start에서 시작해 그래프를 너비 우선 탐색하고 시작점부터 각 정점까지의//최단 거리와 너비 우선 탐색 스패닝 트리를 계산한다.//distance[i] = start부터 i까지의 최단 거리//parent[i] = 너비 우선 탐색 스패닝 트리에서 i의 부모 번호(루트인 경우 자신의 번호)void bfs(int start, vector&lt;int&gt; &amp;distance, vector&lt;int&gt; &amp;parent) {\tdistance = vector&lt;int&gt;(adj.size(), -1);\tparent = vector&lt;int&gt;(adj.size(), -1);\t//방문할 정점 목록을 유지하는 큐\tqueue&lt;int&gt; q;\tdistance[start] = 0;\tparent[start] = start;\tq.push(start);\twhile (!q.empty()) {\t\tint here = q.front();\t\tq.pop();\t\t//here의 모든 인접한 정점을 검사한다.\t\tfor (int i = 0; i &lt; adj[here].size(); ++i) {\t\t\tint there = adj[here][i];\t\t\t//처음 보는 정점이면 방문 목록에 집어넣는다.\t\t\tif(distance[there] == -1) {\t\t\t\tq.push(there);\t\t\t\tdistance[there] = distance[here] + 1;\t\t\t\tparent[there] = here;\t\t\t}\t\t}\t}}//v로부터 시작점까지의 최단 경로를 계산한다.vector&lt;int&gt; shortestPath(int v, const vector&lt;int&gt; &amp;parent) {\tvector&lt;int&gt; path(1, v);\twhile (parent[v] != v) {\t\tv = parent[v];\t\tpath.push_back(v);\t}\treverse(path.begin(), path.end());\treturn path;}상태 객체와 너비 우선 탐색을 사용하여 최단 경로 구하기 예제: 15-퍼즐   4 X 4 격자에 끼워진 15개의 임의의 순서의 숫자 타일이 주어졌을 때, 순서에 맞게 맞추는 퍼즐 문제이다.  게임판의 상태를 정점으로 표현하여 그래프를 만든 후, 문제를 해결할 수 있다.          상태를 정점으로 하는 그래프를 상태 공간(state space)라고 부른다.        게임판에 총 15개의 숫자와 1개의 빈칸이 있으므로, 상태 공간은 총 16!개의 정점을 갖는다.  한 번의 움직임으로 한 상태를 다른 상태로 바꿀 수 있을 때, 두 정점을 간선으로 연결한다.          각 정점마다 최대 4개의 이웃 정점이 있을 수 있다.(위, 아래, 오른쪽, 왼쪽으로 옮길 수 있기 때문)        15-퍼즐 구현               게임판의 상태를 State라는 별도의 객체로 표현한다.          15-퍼즐에 관련된 부분을 전부 State 객체 내에 구현함으로서 bfs()함수와 독립적이다.      State만 바꾸면 다른 문제에서도 활용할 수 있다.        State가 가질 수 있는 값의 종류가 너무 많기 때문에 배열 대신 map을 사용한다.  아직 덜구현된듯 문제에 맞게 구현해서 예제 넣어 풀어보기(State 클래스 구현)//게임판의 상태를 표현한다.class State {\t//인접한 상태들의 목록을 반환한다.\tvector&lt;State&gt; getAdjacent() const;\t//map에 State를 넣기 위한 비교 연산자\tbool operator &lt; (const State &amp;rhs) const;\t//종료 상태와 비교하기 위한 연산자\tbool operator == (const State &amp;rhs) const;};typedef map&lt;State, int&gt; stateMap;//start에서 finish까지 가는 최단 경로의 길이를 반환한다.int bfs(State start, State finish) {\t//예외: start == finish인 경우\tif (start == finish) return 0;\t//각 정점까지의 최단 경로의 길이를 저장한다.\tstateMap c;\t//앞으로 방문할 정점들을 저장한다.\tqueue&lt;State&gt; q;\tq.push(start);\tc[start] = 0;\t//너비 우선 탐색\twhile (!q.empty()) {\t\tState here = q.front();\t\tq.pop();\t\tint cost = c[here];\t\t//인접한 정점들의 번호를 얻어낸다.\t\tvector&lt;State&gt; adjacent = here.getAdjacent();\t\tfor (int i = 0; i &lt; adjacent.size(); ++i) {\t\t\tif (c.count(adjacent[i]) == 0) {\t\t\t\t//답을 찾았나?\t\t\t\tif (adjacent[i] == finish) return cost + 1;\t\t\t\tc[adjacent[i]] = cost + 1;\t\t\t\tq.push(adjacent[i]);\t\t\t}\t\t}\t}\t//답을 찾지 못한 경우\treturn -1;}시간 복잡도 분석   이 문제는 답을 찾는 대로 탐색을 종료하기 때문에, 일반적인 너비 우선 탐색의 시간복잡도 O(|V| + |E|)와 다르다.  너비 우선 탐색이 방문하는 정점의 개수에 비례한다.  이 문제에서 너비 우선 탐색이 방문하는 정점의 개수에 직접적인 영향을 주는 요소는 시작 정점에서 목표 정점까지의 최단 거리 d와 탐색의 분기 수(branching factor) b이다.          분기 수는 경로의 길이가 하나 늘어날 때마다 닿을 수 있는 정점의 개수를 말한다.      이 문제에서 분기 수는 최대 4개 이지만, 이 중에는 돌아가는 정점이나 중복된 정점이 있기 때문에 2나 3으로 계산할 수 있다.        이를 바탕으로, 시간 복잡도는 대략 O(b^d)가 된다.너비 우선 탐색보다 더 효율적인 최단 경로 알고리즘   양방향 탐색  점점 깊어지는 탐색(Iteratively Deeping Search, IDS)탐색 방법 선택하기   상태 공간에서의 최단 경로를 찾는 경우, 너비 우선 탐색을 최우선적으로 고려한다.          탐색의 깊이 한계가 정해져 있지 않거나 너무 깊어서 메모리 사용량이 너무 크지 않은지 확인해야 한다.        탐색의 최대 깊이가 정해져 있고 너비 우선 탐색을 하기에는 메모리와 시간이 부족한 경우 양방향 탐색을 고려한다.  위의 두 탐색이 모두 메모리나 시간이 초과될 경우, 점점 깊어지는 탐색을 사용한다.참고 문헌   프로그래밍 대회에서 배우는 알고리즘 문제해결전략, 인사이트, 구종만 지음","categories": ["Algorithm"],
        "tags": ["그래프"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-BFS%EC%99%80-%EC%B5%9C%EB%8B%A8%EA%B1%B0%EB%A6%AC/",
        "teaser":null},{
        "title": "[Algorithm]깊이 우선 탐색(DFS)의 간선 분류",
        "excerpt":"깊이 우선 탐색(DFS)과 간선의 분류   어떤 그래프를 깊이 우선 탐색을 했을 때, 탐색이 따라가는 간선들만을 모아 보면 트리 형태를 띤다.  예제 그래프   위 그래프를 0번 정점부터 깊이 우선 탐색했을 때 탐색이 따라가는 간선들을 굵은 실선으로 표시하면 아래의 그림과 같다.   굵은 실선이 0번 정점을 루트로 하는 트리 형태를 띠는 것을 볼 수 있다.  이와 같은 트리를 주어진 트리의 깊이 우선 탐색 스패닝 트리 혹은 DFS 스패닝 트리(Spanning Tree)라고 부른다.  DFS 스패닝 트리는 4가지의 간선으로 분류된다.          트리 간선(tree edge): 스패닝 트리에 포함된 간선을 의미한다. (위 그래프의 굵은 선으로 표시된 간선)      순방향 간선(forward edge): 스패닝 트리의 선조에서 자손으로 연결되지만 트리 간선이 아닌 간선을 의미한다. (위 그래프의 (0, 6)간선이 그 예이다.)      역방향 간선(back edge): 스패닝 트리의 자손에서 선조로 연결되는 간선이다. (위 그래프의 (2, 0)간선이 그 예이다.)      교차 간선(cross edge): 위 세 간선을 제외한 나머지 간선을 의미하며, 트리에서 선조와 자손 관계가 아닌 정점들 간에 연결된 간선이다. (위 그래프의 (6, 3)간선이 그 예이다.)        같은 그래프에서도 깊이 우선 탐색이 어느 순서대로 정점을 방문하느냐에 따라 서로 다른 트리가 만들어질 수 있다. (아래 그래프 예제)   무향 그래프에서 간선의 분류          모든 간선은 양방향으로 통행 가능하므로, 교차 간선이 없다.      순방향 간선과 역방향 간선의 구분이 없다.      참고 문헌   프로그래밍 대회에서 배우는 알고리즘 문제해결전략, 인사이트, 구종만 지음","categories": ["Algorithm"],
        "tags": ["그래프"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-DFS%EC%99%80-%EA%B0%84%EC%84%A0%EC%9D%98-%EB%B6%84%EB%A5%98/",
        "teaser":null},{
        "title": "[Algorithm]깊이 우선 탐색(DFS) 사이클",
        "excerpt":"깊이 우선 탐색(DFS)로 사이클 존재 여부 확인하기 개요   미리 알아야 할 내용: DFS와 간선의 분류 링크 해주기  간선의 분류를 이용하면 방향 그래프에서 사이클이 존재하는지 쉽게 알 수 있다.          사이클의 존재 여부는 역방향 간선의 존재 여부와 동치이다.        탐색 과정          어떤 그래프에서 깊이 우선 탐색 중 만나는 한 정점을 u라고 하자.      dfs(u)는 u에서 갈 수 있는 모든 정점들을 방문한 후에 종료된다.      따라서, u이전에 있는 한 정점이 dfs(u)가 종료되기 전에 u정점을 방문을 한다면, 해당 정점은 u로 가는 역방향 간선이 된다.      결과적으로, 이 그래프는 사이클이 존재하는 그래프가 된다.      간선 구분하기   깊이 우선 탐색을 하면서 간선의 종류를 구분하기 위해서는 기존의 저장해야하라 정보보다 더 많은 정보가 필요하다.1. 해당 정점이 몇 번째로 방문 되었는지에 대한 정보(방문 순서 정보)   기존의 깊이 우선 탐색에서 필요한 정보였던 해당 정점이 방문되었는지에 대한 정보를 대체한다.  이 정보로 (u, v)간선이 있을 때, 두 정점의 관계가 선조인지, 자손인지, 아무관계가 없는지를 알 수 있다.  (u, v)간선이 순방향 간선인지 알 수 있다.(역방향 간선과 교차 간선은 구분하지 못함)          (u, v)가 순방향 간선이면 v는 u의 자손이므로, v는 u보다 더 늦게 발견된다.      (u, v)가 역방향 간선이면 v는 u의 선조이므로, v는 u보다 더 일찍 발견된다.      (u, v)가 교차 간선이면 dfs(v)가 종료된 후에 dfs(u)가 호출되므로, v는 u보다 더 일찍 발견된다.        discovered[]배열2. 해당 정점의 dfs()함수가 종료되었는지에 대한 정보   이 정보로 (u v)간선이 역방향 간선인지 교차 간선인지 구분할 수 있다.  (u, v)에서 dfs(v)가 아직 종료되지 않았다면 v는 u의 선조이니 역방향 간선이 되고, 종료되었다면 교차 간선이 된다.  finished[]배열구현 //그래프으이 인접 리스트 표현vector&lt;vector&lt;int&gt;&gt; adj;//discovered[i] = i번 정점의 발견 순서, -1로 초기화//finished[i] = dfs(i)가 종료했으면 1, 아니면 0vector&lt;int&gt; discovered, finished;//지금까지 발견한 정점의 수int counter;void classifyEdgeDfs(int here) {  discovered[here] = counter++;  //모든 인접 정점을 순회하면서  for(int i =0; i &lt; adj[here].size(); ++i) {    int there = adj[here][i];    cout &lt;&lt; \"(\" &lt;&lt; here &lt;&lt; \",\" &lt;&lt; there &lt;&lt; \") is a \";    //아직 방문한 적이 없다면 방문한다. (트리 간선)    if (discovered[there] == -1) {      cout &lt;&lt; \"tree edge\" &lt;&lt; endl;      classifyEdgeDfs(there);    }    //만약 there가 here보다 늦게 발견됐으면 there은 here의 후손이다. (순방향 간선)    else if (discovered[here] &lt; discovered[there])      cout &lt;&lt; \"forward edge\" &lt;&lt; endl;    //만약 classifyEdgeDfs(there)가 아직 종료되지 않았으면 there은 here의 선조이다. (역방향 간선 = 사이클 존재)    else if (finished[there] == 0)      cout &lt;&lt; \"back edge\" &lt;&lt; endl;    //이 외의 모든 경우는 교차 간선    else      cout &lt;&lt; \"cross edge\" &lt;&lt; endl;  }  finished[here] = 1;}참고 문헌   프로그래밍 대회에서 배우는 알고리즘 문제해결전략, 인사이트, 구종만 지음","categories": ["Algorithm"],
        "tags": ["그래프"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-DFS%EC%99%80-%EC%82%AC%EC%9D%B4%ED%81%B4/",
        "teaser":null},{
        "title": "[Algorithm]다익스트라 알고리즘",
        "excerpt":"다익스트라(Dijkstra) 최단 경로 알고리즘   다익스트라 알고리즘은 단일 시작점 최단 경로 알고리즘으로, 시작 정점 s에서부터 다른 정점들까지의 최단거리를 계산한다.  다익스트라 알고리즘은 음수 간선이 있는 그래프(특히, 음수 사이클)에 대해서는 정답을 계산하지 못한다.          음수 간선이 사이클을 이루지 않는다면, 계산을 할 수 있는 경우가 있지만 시간복잡도는 지수적으로 증가한다.      우선순위 큐를 사용하는 너비 우선 탐색으로 구현   다익스트라 알고리즘은 너비 우선 탐색처럼 시작점에서 가까운 순서대로 정점을 방문한다.  다익스트라 알고리즘은 가중치가 있는 그래프에 적용하기 때문에 너비 우선 탐색을 그대로 사용할 수는 없다.          가중치 그래프에서 너비 우선 탐색으로 최단 거리를 차지 못하는 예                   위 그림에서 최단 경로는 s-a-b-c이다.      하지만, 너비 우선 탐색을 사용하면 각 정점을 순서대로 방문해야 하기 때문에 위와 같은 최단 경로를 찾을 수 없다.                  b정점을 늦게 발견하더라도 먼저 방문할 수 있어야 한다.                      위의 문제를 해결하기 위해 우선순위 큐를 활용하여 너비 우선 탐색을 사용한다.구현   dist[]: 시작점에서 각 정점까지의 최단 거리를 저장하는 배열  간선(u, v)에서 정점 v가 아직 발견되지 않은 상태라면, v까지 최단 거리는 dist[v] = dist[u] + w(u, v)가 되고, 우선 순위 큐에 (v, dist[v])형태로 삽입한다.          아직 방문하지 않는 간선 중에 정점 v가 포함되어 있고, 위의 dist[v]보다 더 짧다면 갱신될 수 있다.        위와 같이 한 정점이 중복된다면, 우선 순위 큐에 역시 같은 정점이 여러개 존재할 수 있다.          간단한 구현을 위해, 중복된 정점을 우선 순위 큐에 삽입 하되 나중에 큐에서 꺼내질 때 해당 정점의 현재 최단 거리보다 길다면 무시한다.        C++ STL에 포함된 우선 순위 큐를 사용할 때 주의할 점은 기본적으로 가장 큰 값을 가장 먼저 나오도록 구현되어 있으므로 거리(dist[])의 부호를 바꿔서 큐에 삽입하도록 하여 간단하게 구현한다.          부호가 마이너스인 숫자는 절대값이 큰 값이 더 작은 값이 되기 때문이다.      큐에서 꺼낼때 역시 부호를 바꿔서 양의 숫자로 바꿔주어야 한다.      구현 코드 //정점의 개수int V;//그래프의 인접 리스트 (연결된 정점 번호, 간선 가중치) 쌍을 담는다.vector&lt;pair&lt;int, int&gt;&gt; adj[MAX_V];//다익스트라, 최단 거리 배열을 반환한다.vector&lt;int&gt; dijkstra(int src) {\t//INF: 매우 큰 값\tvector&lt;int&gt; dist(V, INF);\tdist[src] = 0;\t//(해당 정점까지 최단 거리, 해당 정점)쌍  \t//STL내부에서 pair의 첫번째 원소부터 크기 비교를 하기 때문에, 거리값을 첫 원소로 해야 한다.\tpriority_queue&lt;pair&lt;int, int&gt;&gt; pq;\tpq.push(make_pair(0, src));\twhile (!pq.empty()) {    \t\tint here = pq.top().second;\t\tint cost = -pq.top().first;\t\tpq.pop();\t\t//만약 지금 꺼낸 것보다 더 짧은 경로를 알고 있다면 지금 꺼낸 것을 무시한다.\t\tif (dist[here] &lt; cost) continue;\t\t//인접한 정점들을 모두 검사한다.\t\tfor (int i = 0; i &lt; adj[here].size(); ++i) {\t\t\tint there = adj[here][i].first;\t\t\tint nextDist = cost + adj[here][i].second;\t\t\t//더 짧은 경로를 발견하면, dist[]를 갱신하고 우선순위 큐에 넣는다.\t\t\tif (dist[there] &gt; nextDist) {\t\t\t\tdist[there] = nextDist;\t\t\t\tpq.push(make_pair(-nextDist, there));\t\t\t}\t\t}\t}  return dist;}시간 복잡도   각 정점마다 인접한 간선들을 모두 검사하는 작업: O(|E|)  우선순위 큐에 원소를 넣고 삭제하는 작업          너비 우선 탐색에서는 각 정점을 한번 씩만 방문하지만, 다익스트라는 각 간선을 한번 씩 방문하기 때문에 정점을 중복해서 방문한다.      최대 원소의 수: O(|E|)      추가 및 삭제 연산: O(log|E|)      전체 시간 복잡도: O(|E|log|E|)                                    대부분의 그래프에서 간선의 개수          E          는 |V|^2보다 작기 때문에, O(log|E|) == O(log|V|)라고 할 수 있다.                      따라서, 우선순위 큐 다익스트라 알고리즘의 전체 시간 복잡도는 O(|E|log|V|)이다.실제 경로 찾기   너비 우선 탐색에서 경로를 찾는 것과 유사하게, 스패닝 트리를 계산한 후, 스패닝 트리를 거슬러 올라가며 경로를 찾을 수 있다.O(|V|log|V|) 다익스트라 알고리즘   중복 원소를 우선순위 큐에 넣지 않도록 수정하면 O(|V|log|V|)의 시간복잡도를 가질 수 있다.  피보나치 힙이나 이진 검색 트리를 이용해 우선순위 큐를 사용하면 중복 원소를 제거할 수 있지만, 구현이 복잡하고 실제로 시간이 더 오래 걸리는 경우가 많다.참고 문헌   프로그래밍 대회에서 배우는 알고리즘 문제해결전략, 인사이트, 구종만 지음","categories": ["Algorithm"],
        "tags": ["그래프"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/",
        "teaser":null},{
        "title": "[Algorithm]벨만-포드 알고리즘",
        "excerpt":"벨만-포드(Bellman-Ford)의 최단 경로 알고리즘   다익스트라 알고리즘과 똑같은 단일 시작점 최단 경로 알고리즘이지만, 음수 간선이 있는 그래프에서도 최단 경로를 찾을 수 있다.  그래프에서 음수 사이클이 있어서 최단 경로를 찾을 수 없는 경우에도 이를 알려줄 수 있다.벨만-포드의 동작 과정   벨만-포드 알고리즘은 시작점에서 각 정점까지 가는 최단 거리의 상한을 적당히 예측한 뒤, 예측 값과 실제 최단 거리 사이의 오차를 반복적으로 줄여가는 방식으로 동작한다.  upper[]: 각 정점까지의 최단 거리의 상한을 담은 배열  시작점 s의 upper[s] = 0으로 초기화하고, 나머지 원소들은 모두 아주 큰 수로 초기화 한다.  이 배열의 예측 값을 실체 최단 거리에 더 가깝게 갱신하기 위해 다음과 같은 최단 거리의 특성을 이용한다.          dist[v] &lt;= dist[u] + w(u, v)        위 속성을 이용하여 upper[u] + w(u, v) &lt; upper[v]인 상황을 예를 들어 보자.          u까지 가는 최단 거리는 항상 upper[u]이거나 그보다 짧다.      그 뒤에 (u, v)를 붙인 경로의 길이는 최대 upper[u] + w(u, v)이다.      따라서, upper[v]를 upper[u] + w(u, v)로 줄일 수 있다.      위 과정을 통해 upper[v]를 감소하는 작업을 (u, v)를 따라 완화(relax)한다고 한다.        벨만-포드 알고리즘은 위와 같은 완화 과정을 모든 간선에 대해 반복적으로 실시한다.                                                      음수 사이클이 없는 그래프에서 최단 경로가 한 정점을 두 번 지나는 일이 없으므로, V개의 정점 그래프에서 최단 경로를 나타내는 간선의 개수는              V              - 1개 이다.                                                                                      따라서, 모든 간선에 대한 완화 과정은 전체              V              - 1번 수행하면 된다는 것을 알 수 있다.                                          음수 사이클만 없다면 음수 간선이 있더라도, 최단 경로를 찾을 수 있다.      음수 사이클 판정   음수 사이클이 존재하는 그래프에서는 최단 거리를 구할 수 없으므로, 벨만-포드 알고리즘 역시 의미없는 값을 반환한다.                              위에서 말했듯이, 벨만-포드의 동작은 음수 사이클이 없는 그래프에서          V          - 1번만 수행하면 되며 그 이후의 완화는 모두 실패한다.                                                  하지만, 음수 사이클이 있는 그래프에서는          V          - 1번의 수행 이후에도 완화가 계속 성공적으로 이루어 진다.                            음수 사이클을 지날 때는 계속해서 거리 값이 작아지므로, 이를 쉽게 알 수 있다.                                    결과적으로 음수 사이클을 판정하기 위해서는          V          번 동작에서 완화가 성공하는지, 실패하는지로 알 수 있다.                    구현                               해당 구현에서 벨만=포드 알고리즘은          V          번 반복하며, 마지막          V          번째의 완화가 성공하면 음수 사이클이 있는 것으로 판단하고 빈 배열을 반환한다.                      시간 복잡도                                                      V              번 반복과 모든 간선 순회하므로 O(|E|)이다.                                          따라서, 전체 시간 복잡도는 O(|V||E|)가 된다.      //정점의 개수int V;//그래프의 인접 리스트, (연결된 정점 번호, 간선 가중치)쌍을 담는다.vector&lt;pair&lt;int, int&gt;&gt; adj[MAX_V];//음수 사이클이 있을 경우 텅 빈 배열을 반환한다.vector&lt;int&gt; bellmanFord(int src) {\t//시작점을 제외한 모든 정점까지의 거리 상한을 INF로 초기화한다.\tvector&lt;int&gt; upper(V, INF);\tupper[src] = 0;\tbool updated;\t//V번 순회한다.\tfor (int iter = 0; iter &lt; V; ++iter) {\t\tupdated = false;\t\tfor (int here = 0; here &lt; V; ++here) {\t\t\tfor (int i = 0; i &lt; adj[here].size(); ++i) {\t\t\t\tint there = adj[here][i].first;\t\t\t\tint cost = adj[here][i].second;\t\t\t\t//(here, there)간선을 따라 완화를 시도한다.\t\t\t\tif (upper[there] &gt; upper[here] + cost) {\t\t\t\t\t//성공\t\t\t\t\tupper[there] = upper[here] + cost;\t\t\t\t\tupdated = true;\t\t\t\t}\t\t\t}\t\t}\t\t//모든 간선에 대해 완화가 실패했을 경우 V-1번도 수행할 필요 없이 곧장 종료한다.\t\tif (!updated) break;\t}\t//V번째 순회에서도 완화가 성공했다면 음수 사이클이 있다.\tif (updated) upper.clear();\treturn upper;}","categories": ["Algorithm"],
        "tags": ["그래프"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-%EB%B2%A8%EB%A7%8C-%ED%8F%AC%EB%93%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/",
        "teaser":null},{
        "title": "[Algorithm]절단점 찾기 알고리즘",
        "excerpt":"깊이 우선 탐색(DFS)를 활용한 절단점 관련 알고리즘 절단점이란?   절단점(cut vertex): 어떤 무향 그래프의 절단점이란 이 점과 인접한 간선들을 모두 지웠을 때 해당 컴포넌트가 2개 이상으로 나뉘어지는 정점을 말한다.   위 그래프에서 1, 3, 5 정점이 각각 절단점이다.절단점 찾기 알고리즘   무향 그래프에서 한 번의 깊이 우선 탐색으로 그래프의 모든 절단점으르 찾을 수 있다.  무향 그래프에서 절단점을 포함하지 않는 서브그래프를 이중 결합 컴포넌트(biconnected component)라고 부른다.          이중 결합 컴포넌트에서 임의의 한 정점을 지우더라도 정정 간의 연결 관계는 유지된다.        탐색 과정               임의의 정점에서부터 깊이 우선 탐색을 수행하여 DFS 스패닝 트리를 만든다.  무향 그래프에서 어떤 정점 u는 연결된 모든 정점들은 u의 선조 아니면 자손 관계에 있다.          무향 그래프에서는 교차 간선이 없기 때문이다.      따라서, u의 자손들을 루트로 하는 서브트리들은 서로 연결되어 있지 않다.        위의 조건을 이용하면 u가 지워졌을 때, 그래프가 쪼개지지 않는 유일한 경우는 u의 선조와 자손들이 서로 전부 역방향 간선으로 연결되어 있는 경우이다.   u의 자손들이 전부 역방향 간선을 통해 u의 선조로 갈 수 있다면, u는 절단점이 아니다.  u가 스패닝 트리의 루트라서 선조가 없는 경우는 둘 이상의 자손을 가질때만 절단점이 될 수 있다.          u의 선조가 없다고 무조건 절단점이 되는 것은 아니다.      u의 자손이 하나도 없거나 하나만 있을 경우, u정점이 지워져도 그래프는 쪼개지지 않는다.      구현   u정점의 조상들이 항상 u보다 먼저 발견되어야 한다는 점을 활용하여, 깊이 우선 탐색이 해당 정점을 루트로 하는 서브트리에서 역방향 간선을 통해 닿는 정점들의 최소 발견순서를 반환한다.//그래프의 인접 리스트 표현vector&lt;vector&lt;int&gt;&gt; adj;//각 정점의 발견 순서, -1로 초기화vector&lt;int&gt; discovered;//각 정점이 절단점인지 여부를 저장한다. false로 초기화vector&lt;bool&gt; isCutVertex;int counter = 0;//here를 루트로 하는 서브트리에 있는 절단점들을 찾는다.//반환 값은 해당 서브트리에서 역방향 간선으로 갈 수 있는 정점 중 가장 일찍 발견된 정점의 발견 시점.//처음 호출은 isRoot = true이다.int findCutVertex(int here, bool isRoot) {  //발견 순서를 기록한다.  discovered[here] = counter++;  int ret = discovered[here];  //루트인 경우의 절단점 판정을 위해 자손 서브트리의 개수를 센다.  int children = 0;  for(int i = 0; i &lt; adj[here].size(); ++i) {    int there = adj[here][i];    if (discovered[there] == -1) {      ++children;      //이 서브트리에서 갈 수 있는 가장 높은 정점의 번호      int subtree = findCutVertex(there, false);      //그 번호가 자기 자신 이하라면 현재 위치는 절단점!      if (!isRoot &amp;&amp; subtree &gt;= discovered[here])        isCutVertex[here] = true;      ret = min(ret, subtree);    }    else      ret = min(ret, discovered[there]);  }  //루트인 경우 절단점 판정은 서브트리의 개수로 한다.  if(isRoot) isCutVertex[here] = (children &gt;= 2);  return ret;}강결합 컴포넌트 (Strongly Connected Components, SCC) 분리   방향 그래프에서는 무향 그래프의 절단점 정의를 그대로 사용할 수 없으므로, 이중 결합 컴포넌트를 정의할 수 없다.  방향 그래프에서는 이중 결합 컴포넌트와 유사한 강결합 컴포넌트가 있다.          방향 그래프 상에서 두 정점 u, v에 대해 양 방향으로 가는 경로가 모두 있을 때, 두 정점은 같은 SCC에 속해 있다고 말한다.         위 그림은 한 그래프의 각 SCC들을 짙은 색 배경으로 구분한 모습이다.  SCC 특징          위 그래프에서도 볼 수 있듯이, SCC 사이를 연결하는 간선들을 모으면 각 SCC들을 정점으로 하는 DAG를 만들 수 있다.                  원 그래프의 정점들을 SCC별로 분리하고 각 SCC를 표현하는 정점들을 갖는 새로운 그래프를 만드는 과정을 그래프 압축(condensation)이라 부른다.                    한 사이클에 포함된 정점들은 항상 같은 SCC에 속한다.      반대로 한 SCC에 속한 두 정점 사이를 잇는 양방향 경로를 합치면 두 정점을 포함하는 사이클이 된다.      강결합 컴포넌트 분리를 위한 타잔(Tarjan)의 알고리즘   타잔 알고리즘은 한 번의 깊이 우선 탐색으로 강결합 컴포넌트를 분리할 수 있다.1. 알고리즘 과정   임의의 정점에서부터 깊이 우선 탐색을 수행하여 DFS 스패닝 트리를 만든다.   위 그림은 예제 그래프의 가장 왼쪽 정점에서 깊이 우선 탐색을 해서 얻은 스패닝 트리이다.          스패닝 트리를 적절히 자르기만 하면 정점들을 SCC로 분리할 수 있다는 것을 알 수 있다.        동심원으로 표현된 정점들을 각 SCC의 루트라고 하자.  이때 SCC를 분리하기 위해 끊어야할 간선들은 모두 SCC의 루트로 내려가는 트리 간선임을 알 수 있다.          스패닝 트리에서 인접한 두 정점이 서로 다른 SCC에 속한다면, 그 중 자손 정점은 자신이 속한 SCC의 루트여야만 한다.        한 정점이 해당 SCC의 루트에 속하는지 알기 위해서는 절단점 찾기 알고리즘을 응용하여 판단할 수 있다.          어떤 정점 u가 SCC의 루트라면, u의 선조와 u가 서로 다른 SCC에 속한다는 의미이다.      위의 조건을 만족하려면, u에서 그 선조로 가는 경로가 없어야하는데 이 경로를 탐색 없이 확인하는 방법은 절단점 찾기 알고리즘을 응용해야 한다.        u를 루트로 하는 서브 트리 깊이 우선 탐색하면서 만나는 모든 역방향 간선을 이용해 닿을 수 있는 가장 상위 정점을 찾는다.  이 정점이 u의 선조거나 그보다 높이 있다면 이 역방향 간선을 이용해 u에서 그 선조로 갈 수 있으며, 따라서 u는 SCC의 루트가 아니다.  방향 그래프에서는 교차 간선이 존재하므로, 이를 유의해야 한다.          어떤 정점이 SCC의 루트인데, 자손 중 하나가 교차 간선을 통해 다른 정점에 연결되어 있다면 판정이 잘못 될 수 있다.       - 위 그림에서 u에서 깊이 우선 탐색을 시작하여 왼쪽의 SCC를 먼저 탐색한 뒤 v로 왔다고 한다면, w에서 왼쪽으로 가는 교차 간선을 v의 선조로 가는 역방향 간선이라고 판단하여 v가 SCC의 루트가 아니라고 잘못된 판단을 내린다.- 해결 방법은 그래프의 모든 교차 간선은 무시한다.2. 구현   현재 위치를 루트로 하는 서브트리에 남아 있는 정점들을 모두 찾는 방법을 스택을 이용하여 구현한다.          scc()함수는 깊이 우선 탐색 과정에서 지금까지 방문한 정점 중 아직 SCC로 묶이지 않은 모든 정점들을 스택에 담는다.      각 정점을 처음 방문할 때마다 스택에 넣기 때문에, here가 SCC의 루트라는 것을 확인하면 스택에서 here 위에 있는 정점들은 모두 here의 후손이다.      따라서, here를 만날 때까지 계속 스택에서 정점을 꺼내는 방식으로 쉽게 구현이 가능하다.        시간 복잡도: O(|V| + |E|)  SCC의 위상 정렬          아래의 코드에서 새 SCC가 생성되는 시점은 항상 scc()함수가 종료하기 직전이다.      위와 같은 속성때문에, 각 SCC는 위상 정렬의 역순으로 번호가 매겨진다. (dfs()가 늦게 종료하는 정점부터 배열하면 위상 정렬 결과가 나온다)      그래프의 압축을 바로 사용할 수 있다.        구현 코드 및 예제구현 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; adj;//각 정점의 컴포넌트 번호, 컴포넌트 번호는 0부터 시작하며,//같은 강결합 컴포넌트에 속한 정점들의 컴포넌트 번호가 같다.vector&lt;int&gt; sccId, discovered, finished;stack&lt;int&gt; st;  //정점의 번호를 담는 스택int sccCounter, vertexCounter;//here를 루트로 하는 서브트리에서 역방향 간선으로 닿을 수 있는 최소의 발견 순서를 반환한다.int scc(int here) {\tint ret = discovered[here] = vertexCounter++;\t//스택에 here를 넣는다. here의 후손들은 모두 스택에서 here 후에 들어간다.\tst.push(here);\tfor (int i = 0; i &lt; adj[here].size(); ++i) {\t\tint there = adj[here][i];\t\t//(here, there)가 트리 간선\t\tif (discovered[there] == -1)\t\t\tret = min(ret, scc(there));\t\t//(here, there)가 역행 간선인 경우 선조 정점의 발견 순서를 확인한다.\t\telse if (discovered[there] &lt; discovered[here] &amp;&amp; finished[there] == -1)\t\t\tret = min(ret, discovered[there]);\t}\t//here가 강결합 컴포넌트의 루트인지 확인한다.\tif (ret == discovered[here]) {\t\t//here를 루트로 하는 서브트리에 남아 있는 정점들을 전부 하나의 컴포넌트로 묶는다.\t\twhile (true) {\t\t\tint t = st.top();\t\t\tst.pop();\t\t\tsccId[t] = sccCounter;\t\t\tif (t == here) break;\t\t}\t\t++sccCounter;\t}\tfinished[here] = 1;\treturn ret;}//tarjan의 SCC알고리즘vector&lt;int&gt; tarjanSCC() {\t//배열과 카운터 초기화\tsccId = discovered = finished = vector&lt;int&gt;(adj.size(), -1);\tsccCounter = vertexCounter = 0;\t//모든 정점에 대해 scc()호출\tfor (int i = 0; i &lt; adj.size(); ++i)\t\tif (discovered[i] == -1) scc(i);\treturn sccId;}int main(){\t//n: 정점의 개수, m: 간선의 개수\tint n, m; scanf(\"%d %d\", &amp;n, &amp;m);\tadj = vector&lt;vector&lt;int&gt;&gt;(n);\tfor (int i = 0; i &lt; m; i++) {\t\tint s, e; scanf(\"%d %d\", &amp;s, &amp;e);\t\tadj[s].push_back(e);\t}\tvector&lt;int&gt; ans;\tans = tarjanSCC();\tfor (int i = 0; i &lt; n; ++i)\t\tprintf(\"%d \", ans[i]);\treturn 0;}  예제 그래프(위의 예제 그래프에 정점 번호 부여)   예제 입력    11 150 10 71 22 02 33 43 64 55 37 87 98 68 99 1010 8        예제 결과    4 4 4 1 1 1 0 3 2 2 2                  정점 번호      0      1      2      3      4      5      6      7      8      9      10                  SCC 번호      4      4      4      1      1      1      0      3      2      2      2      참고 문헌   프로그래밍 대회에서 배우는 알고리즘 문제해결전략, 인사이트, 구종만 지음","categories": ["Algorithm"],
        "tags": ["그래프"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-%EC%A0%88%EB%8B%A8%EC%A0%90-%EC%B0%BE%EA%B8%B0-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/",
        "teaser":null},{
        "title": "[Algorithm]플로이드 알고리즘",
        "excerpt":"플로이드(Floyd)의 모든 쌍 최단 거리 알고리즘 플로이드 알고리즘의 특징   모든 쌍의 최단 거리를 구할 수 있다.          알고리즘이 간단하기 때문에, 모든 정점에서 다익스트라나 벨만-포드 알고리즘을 수행하는 것보다 훨씬 효율적이다.        실제 경로를 계산할 수 있다.  가중치없는 그래프에서 각 정점 간의 도달 가능성 여부를 계산할 수 있다.          너비 우선 탐색보다 구현이 간단하여 자주 사용한다.      경유점   두 정점 u, v를 잇는 어떤 경로가 있을 때, 이 경로는 u, v외에도 다른 정점을 경유해서 가는 경로가 더 짧을 수도 있다.  위와 같이 경로가 거쳐가는 정점들을 경유점이라고 한다.   위의 그림에서 볼 수 있듯이, 정점 u에서 v까지 가장 짧은 경로는 u -&gt; a -&gt; b -&gt; v인 것을 볼 수 있다.          여기서 경유점은 정점 a, b이다.        플로이드 알고리즘은 시작 정점과 도착 정점 사이의 모든 경로점을 고려하는 것을 시각적으로 이해하기 쉽고 간단하게 구현된 알고리즘이다.플로이드 알고리즘 최적화 과정 1. 시간 복잡도: O(|V|^3), 공간 복잡도: O(|V|^3)   어떤 정점 집합 S에 포함된 정점만을 경유점으로 사용해 u에서 v로 가는 최단 경로를 계산한다고 가정하자.  어떤 정점 x에 대해 2가지를 생각할 수 있다.          경로가 x를 경유하지 않는다: 이 경로는 S - {x} 에 포함된 정점들만을 경유점으로 사용한다.      경로가 x를 경유한다.: 이 경로는 u에서 x의 구간과 x에서 v로 가는 구간으로 나눌 수 있다. 이 두개의 부분 경로는 각각 최단 경로임이 확실하며 x를 경유하지 않는다. 따라서 위와 같이 S - {x}에 포함된 정점들만을 경유점으로 사용한다.        이를 활용하여, S = { 0, 1, 2, ..., k }라 하고 C_k(u, v)는 정점 0번 부터 k번 정점까지만을 경유점을 썼을 때 u에서 v까지 가는 최단 경로의 길이라고 두면 다음과 같은 재귀적인 식이 만들 수 있다.    C_k(u, v) = min(C_k-1(u, k) + C_k-1(k, v), C_k-1(u, v))        C_k는 C_k-1에만 의존하기 때문에, 동적 계획법으로 구현할 수 있다. (C[k][u][v]배열로 메모이제이션)2. 시간 복잡도: O(|V|^3), 공간 복잡도: O(|V|^2)   1번 알고리즘의 문제는 시간 복잡도보다 공간 복잡도이다.          정점의 개수가 1000개라고 가정하면, 시간은 10초가량 소요되지만, 배열 용량은 4GB가 정도가 필요하다.        공간 복잡도를 줄이기 위해서는 위에서 세운 식의 문제점을 파악하면 쉽게 해결가능하다.          C_k-1(u, k) = 시작점으로부터 k-1번 정점까지를 경유점으로 이용해 u에서 k로 가는 최단 경로의 길이      C_k(u, k) = 시작점으로부터 k번 정점까지를 경유점으로 이용해 u에서 k로 가는 최단 경로의 길이      위의 두 식을 보면, 출발점이나 도착점이 k번 정점일 때, 사용가능한 경유점의 목록에 k가 추가되는 것은 아무런 의미가 없다.      즉, 1번에서 C배열의 k가 전혀 필요하지 않다는 것이다.        구현          별도의 배열 C를 만들지 않고, 인접 행렬adj에 직접 최단 거리를 계산한다.      //정점의 개수int V;//그래프의 인접 행렬 표현//adj[u][v] = u에서 v로 가는 가선의 가중치, 간선이 없으면 아주 큰 값으로 초기화int adj[MAX_V][MAX_V];//플로이드의 모든 쌍 최단 거리 알고리즘void floyd() {\tfor (int i = 0; i &lt; V; ++i) adj[i][i] = 0;\tfor (int k = 0; k &lt; V; ++k)\t\tfor (int i = 0; i &lt; V; ++i)\t\t\tfor (int j = 0; j &lt; V; ++j)\t\t\t\tadj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j]);}3. 시간 복잡도 최적화   플로이드 알고리즘의 3중 for문 중 2번째 for문 바로 다음에 i에서 k로 가는 경로가 실제 있는지를 확인한다.  i에서 k로 가는 경로가 없다면 j에 대한 for문은 수행할 필요가 없다.  이는 실제로 그래프에 간선이 적을수록 효과가 좋으며, 경우에 따라 10% ~ 20% 정도의 수행 시간으르 단축시킬 수 있다.실제 경로 계산하기   플로이드 알고리즘에서 실제 경로를 계산하기 위해서는 adj[u][v]를 갱신했을 때 사용했던 k의 값을 저장해두면 된다.          u에서 v로 가는 최단 거리를 정점 w일 때 갱신되었다면, u에서 w로 가는 최단 거리 경로점을 찾고 w에서 v로 가는 최단 거리를 경로점을 찾아 둘을 합치면 최종적으로 u에서 v로 가는 최단 경로를 찾을 수 있다.        구현//정점의 개수int V;//그래프의 인접 행렬 표현//adj[u][v] = u에서 v로 가는 가선의 가중치, 간선이 없으면 아주 큰 값으로 초기화int adj[MAX_V][MAX_V];//via[u][v] = u에서 v까지 가는 최단 경로가 경유하는 점 중 가장 번호가 큰 정점//-1로 초기화한다.int via[MAX_V][MAX_V];//플로이드의 모든 쌍 최단 거리 알고리즘void floyd() {\tfor (int i = 0; i &lt; V; ++i) adj[i][i] = 0;\t//via배열 초기화\tmemset(via, -1, sizeof(via));\tfor (int k = 0; k &lt; V; ++k)\t\tfor (int i = 0; i &lt; V; ++i)\t\t\tfor (int j = 0; j &lt; V; ++j)\t\t\t\tif (adj[i][j] &gt; adj[i][k] + adj[k][j]) {\t\t\t\t\tvia[i][j] = k;\t\t\t\t\tadj[i][j] = adj[i][k] + adj[k][j];\t\t\t\t}}//u에서 v로 가는 최단 경로를 계산해 path에 저장한다.void reconstruct(int u, int v, vector&lt;int&gt; &amp;path) {\t//기저 사례\tif (via[u][v] == -1) {\t\tpath.push_back(u);\t\tif (u != v) path.push_back(v);\t}\telse {\t\tint w = via[u][v];\t\treconstruct(u, w, path);\t\tpath.pop_back(); //w가 중복으로 들어가므로 지워준다.\t\treconstruct(w, v, path);\t}}도달 가능성 확인하기   C_k(u, v): 0번부터 k번 정점까지를 경유점으로 사용한다.  u에서 v로 가는 경로가 있는지 여부를 나타내는 식은 다음과 같다.    C_k(u, v) = C_k-1(u, v) || (C_k-1(u ,k) &amp;&amp; C_k-1(k, v))      ","categories": ["Algorithm"],
        "tags": ["그래프"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/",
        "teaser":null},{
        "title": "[Algorithm]소수 구하기",
        "excerpt":"소수 에라토스테네스의 체 정의   제일 작은 소수 2부터 N-1까지 수 중에서 2의 배수를 모두 체로 거르고, 남은 수중에서 3의 배수를 거르는 과정을 반복하여 루트N 까지 걸러서 남은 수들이 이 범위안의 소수이다.구현 //에라토스테네스의 체prime[0] = prime[1] = 1;  //0,1은 소수 판별에서 제외되는 숫자이기 때문for (int i = 2; i &lt; N; i++) {\tif (prime[i] == 0) {\t       for (int j = i + i; j &lt; N; j += i)\t                prime[j] = 1;\t}}  //prime 배열의 값이 0인 인덱스가 소수이다.  일정 범위 내의 수에서 모든 소수를 구하는 문제에 주로 사용된다.","categories": ["Algorithm"],
        "tags": ["수학"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-%EC%86%8C%EC%88%98-%EA%B5%AC%ED%95%98%EA%B8%B0/",
        "teaser":null},{
        "title": "[Algorithm]순열과 조합",
        "excerpt":"순열과 조합 경우의 수   합의 법칙: 분류          분류의 조건                  동시에 일어나지 않음.          하나도 빠짐없이 포함되어 있어야함.                      곱의 법칙: 동시에 일어나는 일 = 함께 일어나는 일  예제자연수 999이하의 수 중에서 숫자 5가 포함된 수의 개수를 구하라.1. 합의 법칙 = 분류1) 5가 1개 있는 경우의 수 (곱의 법칙)- 5xx = 9 * 9 = 81 * 1- x5x = 9 * 9 = 81 * 1- xx5 = 9 * 9 = 81 * 12) 5가 2개 있는 경우의 수 (곱의 법칙)- 55x = 9 * 2 = 18- 5x5 = 9 * 2 = 18- x55 = 9 * 2 = 183) 5가 3개 있는 경우의 수 (곱의 법칙)- 555 = 1 * 3=&gt; (81 + 81 + 81) + (18 + 18 + 18) + 3 = 300순열(Permutation)   순서 있는 나열  nPr: n개 중에서 r개를 뽑아서 일렬로 나열하는 경우의 수  nPr = n! / (n-r)!STL함수 next_permutation을 활용한 순열 구현(C++)   기본적으로 next_permutation은 nPn을 구하는 함수이다.  nPr을 next_permutation을 활용하여 구할려면 nPn을 구한 상태에서 r크기까지만 저장한다.          하지만, nPn과 시간복잡도가 같다는 단점이 있다.      구현 코드 /*순열은 초기화가 필요하다.for (int i = 0; i &lt; n; ++i)\t\tset.push_back(i);*/void permutationSTL(vector&lt;int&gt; set, int n, int r) {\tdo {\t\tfor (int i = 0; i &lt; r; ++i)\t\t\tprintf(\"%d \", set[i]);\t\tprintf(\"\\n\");\t} while (next_permutation(set.begin(), set.end()));}재귀 함수를 활용한 순열 구현(C++) void swapSet(vector&lt;int&gt; &amp;num, int a, int b) {\tint tmp = num[a];\tnum[a] = num[b];\tnum[b] = tmp;}void permutation(vector&lt;int&gt; set, int setSize, int n, int r) {\t//종료 조건\tif (setSize == r) {\t\tfor (int i = 0; i &lt; setSize; ++i)\t\t\tprintf(\"%d \", set[i]);\t\tprintf(\"\\n\");\t\treturn;\t}\t//분기 조건\tfor (int i = setSize; i &lt; n; ++i) {\t\tswapSet(set, i, setSize);\t\tpermutation(set, setSize + 1, n, r);\t\tswapSet(set, i, setSize);\t}}중복 순열(Repeated permutation)   중복 원소를 포함하는 순서있는 나열void repeatedPerm(vector&lt;int&gt; set, int setSize, int n, int r) {\t//종료 조건\tif (setSize == r) {\t\tfor (int i = 0; i &lt; setSize; ++i)\t\t\tprintf(\"%d \", set[i]);\t\tprintf(\"\\n\");\t\treturn;\t}\t//분기 조건\tfor (int i = 0; i &lt; n; ++i) {\t\tset[setSize] = i;\t\trepeatedPerm(set, setSize + 1, n, r);\t}}조합(Combination)   순서를 고려하지 않고 선택하는 방법의 수  nCr: n개 중에서 r개를 순서에 상관없이 선택하는 방법의 수  nCr = nPr / r! = n! / (n-r)!r!STL함수 next_permutation을 활용한 조합 구현(C++)   n 크기의 배열에서 r 개수만큼의 1을 배열 뒤에서 부터 삽입하고 나머지는 0으로 채운다.  위의 배열을 이용하여 next_permutation 함수를 사용하여 순열을 구한 후 1에 해당하는 인덱스를 뽑는다.구현 코드 void combinationSTL(vector&lt;int&gt; set, int n, int r) {\tfor (int j = 0; j &lt; n - r; ++j)\t\tset.push_back(0);\tfor (int j = 0; j &lt; r; ++j)\t\tset.push_back(1);\tdo {\t\tfor (int j = 0; j &lt; n; ++j)\t\t\tif (set[j])\t\t\t\tprintf(\"%d \", j);\t\tprintf(\"\\n\");\t} while (next_permutation(set.begin(), set.end()));}재귀 함수를 활용한 조합 구현(C++) //set = vector&lt;int&gt;(n);void repeatedComb(vector&lt;int&gt; set, int setSize, int n, int r, int idx) {\t//종료 조건\tif (setSize == r) {\t\tfor (int i = 0; i &lt; setSize; ++i)\t\t\tprintf(\"%d \", set[i]);\t\tprintf(\"\\n\");\t\treturn;\t}\tif (n == idx) return;\t//분기 조건\tset[setSize] = idx;\trepeatedComb(set, setSize + 1, n, r, idx);  //idx 중복 가능\trepeatedComb(set, setSize, n, r, idx + 1);}중복 조합(Repeated combination)   중복 원소를 포함하여 선택하는 방법의 수void repeatedComb(vector&lt;int&gt; set, int setSize, int n, int r, int idx) {\t//종료 조건\tif (setSize == r) {\t\tfor (int i = 0; i &lt; setSize; ++i)\t\t\tprintf(\"%d \", set[i]);\t\tprintf(\"\\n\");\t\treturn;\t}\tif (n == idx) return;\t//분기 조건\tset[setSize] = idx;\trepeatedComb(set, setSize + 1, n, r, idx);  //idx 중복 가능\trepeatedComb(set, setSize, n, r, idx + 1);}결과 main 함수 int main(){\tint n = 3;\tint r = 2;\tvector&lt;int&gt; set;\t//초기화\tfor (int i = 0; i &lt; n; ++i)\t\tset.push_back(i);\tprintf(\"permutationSTL(%d, %d)\\n\", n, r);\tpermutationSTL(set, n, r);\tprintf(\"============================\\n\");\tprintf(\"permutation(%d, %d)\\n\", n, r);\tpermutation(set, 0, n, r);\tprintf(\"============================\\n\");\tprintf(\"repeatedPerm(%d, %d)\\n\", n, r);\trepeatedPerm(set, 0, n, r);\tprintf(\"============================\\n\");\tset.clear();\tprintf(\"combinationSTL(%d, %d)\\n\", n, r);\tcombinationSTL(set, n, r);\tprintf(\"============================\\n\");\tset = vector&lt;int&gt;(n);\tprintf(\"combination(%d, %d)\\n\", n, r);\tcombination(set, 0, n, r, 0);\tprintf(\"============================\\n\");\tprintf(\"repeatedComb(%d, %d)\\n\", n, r);\trepeatedComb(set, 0, n, r, 0);\treturn 0;}결과 화면 permutationSTL(3, 2)0 10 21 01 22 02 1============================permutation(3, 2)0 10 21 01 22 12 0============================repeatedPerm(3, 2)0 00 10 21 01 11 22 02 12 2============================combinationSTL(3, 2)1 20 20 1============================combination(3, 2)0 10 21 2============================repeatedComb(3, 2)0 00 10 21 11 22 2","categories": ["Algorithm"],
        "tags": ["수학"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-%EC%88%9C%EC%97%B4%EA%B3%BC-%EC%A1%B0%ED%95%A9/",
        "teaser":null},{
        "title": "[Algorithm]KMP 알고리즘",
        "excerpt":"KMP 알고리즘   풀네임은 커누스-모리스-프랫(Knuth-Morris-Pratt) 알고리즘으로, 문자열 검색 알고리즘이다.미리 알아 둘점   문자열 S의 길이는 |S|로 표기  문자열 S의 i번부터 j번까지 구성된 부분 문자열을 S[i...j]로 표기  문자열 S의 0번부터 a번까지 구성된 부분 문자열을 접두사(prefix)라 부르고, S[...a]로 표기  문자열 S의 b번부터 끝까지 구성된 부분 문자열을 접미사(suffix)라 부르고, S[b...]로 표기기본 개념   기본적인 검색 알고리즘은 한 문자열의 시작점을 하나씩 옮겨가면서 찾을 문자열을 검색하는 것이다.  KMP 알고리즘은 시작점을 하나씩 옮기는 것이 아니라 최적화 과정을 거쳐 옮길 칸 수를 정한다.  예를 들어, N = “aabaabac”를 찾는 경우가 있다.          H 문자열의 해당 부분 문자열인 H[i...i + 6]이 “aabaaba”까지 일치한다.      그렇다면, i + 1에서 시작하는 N은 H와 일치할 수 없다는 것을 알 수 있다.      가능성이 있는 위치는 i + 3, i + 6 이라는 것을 아래의 그림을 보면 알 수 있다.       다음 시작 위치 찾기   다음 시작 위치를 어떻게 찾는지 예제 그림을 보며, 알아보자   위 그림에서 시작 위치 i일때, H와 N을 맞춰보면 matched글자가 일치하고 다음 글자가 불일치하는 상황을 볼 수 있다.  matched글자가 일치했기 때문에, N의 접두사 N[...matced - 1]가  H[i...i + matched - 1]와 일치했음을 알 수 있다.(회색으로 칠해진 부분)  시작 위치 i + k가 답이 될려면, B와 C가 서로 같아야 하며, 결과적으로 A와 C도 같아야 한다.(굵은 선 네모 부분)          A = C는 N[...matced - 1]의 접두사이기도 하고 접미사이기도 한다.      시작 위치 i + k가 답을 찾을 수 있기 위해서는 N[...matced - 1]의 길이 matched - k인 접두사와 접미사가 같아야 한다.        정리하면, 답이 될 수 있는 바로 다음 위치를 찾기 위해서는 N의 각 접두사에 대해 접두사도 되고 접미사도 되는 문자열의 최대 길이를 계산해야 한다.          위의 예제 “aabaaba”에서 접두사도 되고 접미사도 되는 문자열은 “aaba”와 “a” 두가지 있다.      여기서 최대 길이 문자열은 “aaba”이기 때문에, 시작 위치를 3만큼 옮겨주었던 것이다.      KMP 알고리즘 구현   다음 시작 위치를 찾는 배열을 다음과 같이 정의한다.          pi[i] = N[...i]의 접두사도 되고 접미사도 되는 문자열의 최대 길이        pi[]는 어디까지 일치했는지가 주어질 때 다음 시작 위치를 알려주기 때문에, 이를 흔히 부분 일치 테이블(partial match table) 또는 실패 함수(faulure function)이라 부른다.          찾는 문자열 “aabaabac”의 각 접두사에 대한 부분 일치 테이블은 밑에와 같이 계산된다.                                i          N[…i]          접두사이면서 접미사인 최대 문자열          pi[i]                                      0          a          (없음)          0                          1          aa          a          1                          2          aab          (없음)          0                          3          aaba          a          1                          4          aabaa          aa          2                          5          aabaab          aab          3                          6          aabaaba          aaba          4                          7          aabaabac          (없음)          0                      KMP 알고리즘 동작 과정          초기에는 단순한 알고리즘과 같이 시작 위치 0부터 시작한다.      만약 matched글자가 일치한 후 불일치가 발생한다면, 위 그림의 A의 길이는 pi[matched - 1]이다.      시작 위치를 matched - pi[matched - 1]만큼 증가 시킨다.                  위와 같이 동작하면, 시작 위치를 움직인 이후 첫 글자부터 다시 대응시켜 나갈 필요가 없다는 것이 중요한 관점이다.          새로운 위치에서 비교를 시작하더라도 N의 첫 pi[matched - 1]글자는 대응되는 H의 글자와 일치하기 때문이다.(위 그림에서 B와 C가 서로 같기 때문이다.)                    matched를 pi[matched - 1]로 변경하고 비교를 계속한다.      답을 찾은 경우에는 현재 시작 위치를 답의 목록에 추가해주고, 불일치가 발생한 경우와 같이 다음 시작 위치에서부터 다시 검색을 한다.      matched = 0이면 한 글자도 일치하지 않았다는 의미이므로, 바로 다음 시작 위치에서 처음부터 검색을 시작한다.        구현 코드          참고사항으로, 부분 일치 테이블의 구현과 관련된 점은 아래에서 설명한다.      //'짚더미' H의 부분 문자열로 '바늘' N이 출현하는 시작 위치들을 모두 반환한다.vector&lt;int&gt; kmpSearch(const string &amp;H, const string &amp;N) {\tint n = H.size(), m = N.size();\tvector&lt;int&gt; ret;\t//pi[i] = N[...i]의 접미사도 되고 접두사도 되는 문자열의 최대 길이\tvector&lt;int&gt; pi = getPartialMatch(N);\t//begin = matched = 0 에서부터 시작\tint begin = 0, matched = 0;\twhile (begin &lt;= n - m) {\t\t//만약 짚더미의 해당 글자가 바늘의 해당 글자와 같다면\t\tif (matched &lt; m &amp;&amp; H[begin + matched] == N[matched]) {\t\t\t++matched;\t\t\t//결과적으로 m글자가 모두 일치했다면 답에 추가한다.\t\t\tif (matched == m) ret.push_back(begin);\t\t}\t\telse {\t\t\t//예외: matched가 0인 경우에는 다음 칸에서부터 계속\t\t\tif (matched == 0)\t\t\t\t++begin;\t\t\telse {\t\t\t\tbegin += matched - pi[matched - 1];\t\t\t\t//begin을 옮겼다고 처음부터 다시 비교할 필요가 없다.\t\t\t\t//옮긴 후에도 pi[matched - 1]만큼은 항상 일치하기 때문이다.\t\t\t\tmatched = pi[matched - 1];\t\t\t}\t\t}\t}\treturn ret;}  시간 복잡도          getPartialMatch() 시간 복잡도는 아직 고려하지 않는다.      while문에서 begin + matched 는 절대 감소하지 않는다.                  matched가 감소하면 그만큼 begin이 증가하기 때문이다.                    따라서, 최대 시간 복잡도는 O(|H|)입니다.      부분 일치 테이블 생성하기 1. 간단한 알고리즘   N의 각 접두사에 대해 가능한 모든 답을 시도한다.  길이 p인 접두사 N[...p - 1]이 주어졌을때, 길이 p - 1, p - 2, ...들을 순회하며 이들이 N[... p - 1]의 접미사가 되는지 확인한다.  모든 접두사에 대해 한꺼번에 계산한다면, 시간 복잡도는 O(|N|^2)이다.  구현 코드    //N에서 자기 자신을 찾으면서 나타나는 부분 일치를 이용해 pi[]를 계산한다.//pi[i] = N[...i]의 접미사도 되고 접두사도 되는 문자열의 최대 길이vector&lt;int&gt; getPartialMatchNaive(const string &amp;N) {  int m = N.size();  vector&lt;int&gt; pi(m, 0);  //단순한 문자열 검색 알고리즘을 구현한다.  for (int begin = 1; begin &lt; m; ++begin) {      for (int i = 0; i &lt; m; ++i) {          if (N[begin + i] != N[i]) break;          //i + 1글자가 서로 대응되었다.          pi[begin + i] = max(pi[begin + i], i + 1);      }  }  return pi;}      2. KMP 알고리즘 활용   고려 사항          begin을 옮길 때 이전에 계산한 pi[] 값을 사용한다.                  현재 matched글자가 일치했다면 pi[matched - 1]는 항상 계산된 뒤임을 증명할 수 있기 때문이다.                    pi[]의 각 원소는 최대 한 번만 변경되기 때문에 위의 간단한 알고리즘에서 처럼 max()연산을 해줄 필요가 없다.        구현 코드vector&lt;int&gt; getPartialMatch(const string &amp;N) {\tint m = N.size();\tvector&lt;int&gt; pi(m, 0);\t//KMP로 자기 자신을 찾는다.\t//N을 N에서 찾는다. begin = 0이면 자기 자신을 찾아버리니까 안됨!\tint begin = 1, matched = 0;\t//비교할 문자가 N의 끝에 도달할 때까지 찾으면서 부분 일치를 모두 기록한다.\twhile (begin + matched &lt; m) {\t\tif (N[begin + matched] == N[matched]) {\t\t\t++matched;\t\t\tpi[begin + matched - 1] = matched;\t\t}\t\telse {\t\t\tif (matched == 0)\t\t\t\t++begin;\t\t\telse {\t\t\t\tbegin += matched - pi[matched - 1];\t\t\t\tmatched = pi[matched - 1];\t\t\t}\t\t}\t}\treturn pi;}  시간 복잡도: O(|N|)","categories": ["Algorithm"],
        "tags": ["유명 알고리즘"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-KMP%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/",
        "teaser":null},{
        "title": "[Algorithm]LCS 알고리즘",
        "excerpt":"Longest Common Subsequence(LCS) 알고리즘 개요   최장 공통 부분 문자열  예제 그림 관련 문제 문제 링크   LCS 길이 구하기          https://www.acmicpc.net/problem/9251        LCS 길이 + LCS 문자열 구하기          https://www.acmicpc.net/problem/9252      추가 테스트 케이스   입력AKAKAAK  출력4AAK코드 분석 LCS 길이 구하기   동적 계획법  str1[]: 입력 배열1, str2[]: 입력 배열2  dp[x][y]: str1[x], str2[y] 일때, LCS 길이          점화식 계산을 위해 인덱스 0일 때, 모든 값을 0으로 채워준다.(즉 str1, str2길이가 n일 때, dp[n+1][n+1]이어야 한다.)        점화식: for문 i: 1 ~ str1 문자열 길이, j: 1 ~ str2 문자열 길이str1[i - 1] == str2[j - 1] =&gt; dp[i][j] = dp[i - 1][j - 1] + 1str1[i - 1] != str2[j - 1] =&gt; MAX(dp[i - 1][j], dp[i][j - 1])  예제 배열 최종 결과 그림   시간 복잡도: str1, str2 중 최대 문자열 길이를 N이라 할때, O(N^2)LCS 문자열 구하기   check[x][y]: str1[x] == str2[y]일때 LCS 길이, 아니면 0값이다.          위의 LCS 길이를 구하는 점화식에서 두 문자열이 같을 때의 dp배열값을 같은 인덱스 위치 check배열에 삽입한다.        maxLen: LCS 길이 값  슈도 코드for( i: str1 문자열길이 ~ 1)  for( j: str2 문자열길이 ~ 1)    if(check[i][j] == maxLen)      정답 배열[maxLen - 1] = str1[i - 1] or str2[j - 1]      maxLen--      break  예제 배열 그림   시간복잡도: O(N^2)결과 코드   LCS 길이 + LCS 문자열 구하기#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define max(a,b) ((a) &gt; (b) ? (a) : (b))#define N 1002//str1, str2: 입력 배열char str1[N], str2[N];//dp: LCS 길이를 계산할 배열, check: LCS 문자열을 계산할 배열int dp[N][N], check[N][N];//ans: LCS 문자열을 저장할 배열char ans[N];int main(){\tscanf(\"%s %s\", str1, str2);\tint len1 = strlen(str1);\tint len2 = strlen(str2);\t//LCS 길이 계산\tfor (int i = 1; i &lt; len1 + 1; i++) {\t\tfor (int j = 1; j &lt; len2 + 1; j++) {\t\t\tif (str1[i - 1] == str2[j - 1]) {\t\t\t\tdp[i][j] = dp[i - 1][j - 1] + 1;\t\t\t\tcheck[i][j] = dp[i][j];\t\t\t}\t\t\telse\t\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\t\t}\t}\tprintf(\"%d\\n\", dp[len1][len2]);\t//LCS 문자열 계산\tint maxlen = dp[len1][len2];\tfor (int i = len1; i &gt;= 1; i--) {\t\tif (!maxlen) break;\t\tfor (int j = len2; j &gt;= 1; j--) {\t\t\tif (check[i][j] == maxlen) {\t\t\t\tans[maxlen - 1] = str1[i - 1];\t\t\t\tmaxlen--;\t\t\t\tbreak;\t\t\t}\t\t}\t}\tprintf(\"%s\\n\", ans);\treturn 0;}","categories": ["Algorithm"],
        "tags": ["유명 알고리즘"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-LCS%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/",
        "teaser":null},{
        "title": "[Algorithm]LCS 알고리즘",
        "excerpt":"Longest Increasing Subsequence(LIS) 알고리즘 개요   가장 긴 증가하는 부분 수열  예제 그림   두번째 줄의 노란색 박스 부분이 LIS를 나타내는 모습이다.구현 1. 동적 계획법   알고스팟 LIS 문제 분석          Top-down, Bottom-up 방식        시간복잡도: O(N^2)2. Lower-bound   알고리즘 과정          num[]: 입력 수열, lis[]: LIS를 만들기 위해 비어있는 수열                  lis배열에 아무 값이 없다면(초기화), num배열의 가장 첫번째 값을 삽입한다.          lis배열에서 가장 큰 값(= 가장 오른쪽에 있는 값)보다 현재 보고 있는 num[i]값이 크다면 lis배열에 num[i]값을 추가한다.          작다면 lower_bound(주어진 집합의 어떤 원소보다 작거나 같은 원소)를 이용하여 해당 위치에 num[i]값을 삽입한다.                      시간복잡도: O(NlogN)구현 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define N 1001int num[N], lis[N];int _lower_bound(int start, int end, int target){\tint mid;\twhile (start &lt; end) {\t\tmid = (start + end) / 2;\t\tif (lis[mid] &lt; target)\t\t\tstart = mid + 1;\t\telse\t\t\tend = mid;\t}\treturn end;}int main(){\tint n; scanf(\"%d\", &amp;n);\tfor (int i = 0; i &lt; n; i++)\t\tscanf(\"%d\", &amp;num[i]);\tint idx = 0;\tlis[idx] = num[0];\tfor (int i = 1; i &lt; n; i++) {\t\tif (lis[idx] &lt; num[i])\t\t\tlis[++idx] = num[i];\t\telse {\t\t\tint next = _lower_bound(0, idx, num[i]);\t\t\tlis[next] = num[i];\t\t}\t}\tprintf(\"%d\\n\", idx + 1);\treturn 0;}관련 문제   https://www.acmicpc.net/problem/11053  https://algospot.com/judge/problem/read/LIS  이외에 LIS알고리즘을 응용하는 다양한 문제들이 있다.","categories": ["Algorithm"],
        "tags": ["유명 알고리즘"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-LIS%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/",
        "teaser":null},{
        "title": "[Algorithm]이분 탐색",
        "excerpt":"Binary Search / Lower Bound / Upper Bound 개요   Binary Search: 원하는 값 K를 찾는 과정  Lower Bound: 원하는 값 K 이상인 값 이 처음 나오는 위치를 찾는 과정  Upper Bound: 원하는 값 K 초과인 값 이 처음 나오는 위치를 찾는 과정Lower Bound 알고리즘 과정   arr[] = { 1, 3, 5, 7, 9, 11 }, target = 8 일때, Louwer Bound를 구하라.   시작 인덱스 = 0, 끝 인덱스 = 5, 중간 인덱스 = 2 이다.          중간 인덱스 2의 값은 5이고, 이 값은 타겟인 8보다 작기 때문에 시작 인덱스 = 중간 인덱스 + 1로 설정하고 다음 반복문으로 간다.         시작 인덱스 = 3, 끝 인덱스 = 5, 중간 인덱스 = 4 이다.          9는 타겟인 8보다 크기 때문에 끝 인덱스 = 중간 인덱스로 설정하고 다음 반복문으로 간다.         시작 인덱스 = 3, 끝 인덱스 = 4, 중간 인덱스 = 3 이다.          7은 타겟 8보다 작기 때문에 시작 인덱스 = 중간 인덱스 + 1로 설정한다.         시작 인덱스 = 4, 끝 인덱스 = 4, 중간 인덱스 = 4 이다.          시작 인덱스와 끝 인덱스가 같기 때문에 반복문에 들어가지 않으며, 끝 인덱스를 Lower Bound가 찾는 인덱스로 반환한다.        Bound의 반환 값은 인덱스가 0부터 시작하므로 +1을 해서 몇 번째인지 바로 반환할 수도 있고, 반환받은 값에서 +1을해도 상관없다.구현 코드   Binary Search예제 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int binarySearch(int *arr, int size, int target){\tint first = 0;\tint last = size - 1;\tint mid;\twhile (first &lt;= last) {\t\tmid = (first + last) / 2;\t\tif (arr[mid] == target)\t\t\treturn mid;\t\tif (mid &gt; target)\t\t\tlast = mid - 1;\t\telse\t\t\tfirst = mid + 1;\t}\treturn -1;}int main(){\tint arr[6] = { 1, 3, 5, 7, 9, 11 };\tint target = 8;\tint find;\t//Binary Search\tfind = binarySearch(arr, sizeof(arr), target);\tprintf(\"Binary Search, target: 8 =&gt; INDEX: %d, VALUE: %d\\n\", find, find == -1 ? -1 : arr[find]);\treturn 0;}결과 Binary Search, target: 8 =&gt; INDEX: -1, VALUE: -1  Lower Bound예제 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int lowerBound(int *arr, int size, int target){\tint start = 0;\tint end = size - 1;\tint mid;\twhile (start &lt; end) {\t\tmid = (start + end) / 2;\t\tif (arr[mid] &lt; target)\t\t\tstart = mid + 1;\t\telse\t\t\tend = mid;\t}\treturn end;}int main(){\tint arr[6] = { 1, 3, 5, 7, 9, 11 };\tint target = 8;\tint find;\t//Lower Bound\tfind = lowerBound(arr, sizeof(arr), target);\tprintf(\"Lower Bound, target: 8 =&gt; INDEX: %d, VALUE: %d\\n\", find, arr[find]);\treturn 0;}결과 Lower Bound, target: 8 =&gt; INDEX: 4, VALUE: 9  Upper Bound예제 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int upperBound(int *arr, int size, int target){\tint start = 0;\tint end = size - 1;\tint mid;\twhile (start &lt; end) {\t\tmid = (start + end) / 2;\t\tif (arr[mid] &lt;= target)\t\t\tstart = mid + 1;\t\telse\t\t\tend = mid;\t}\treturn end;}int main(){\tint arr[6] = { 1, 3, 5, 7, 9, 11 };\tint target = 8;\tint find;\t//Upper Bound\tfind = upperBound(arr, sizeof(arr), target);\tprintf(\"Upper Bound, target: 8 =&gt; INDEX: %d, VALUE: %d\\n\", find, arr[find]);\treturn 0;}결과 Upper Bound, target: 8 =&gt; INDEX: 4, VALUE: 9","categories": ["Algorithm"],
        "tags": ["유명 알고리즘"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/",
        "teaser":null},{
        "title": "[DataStructure]N^2 정렬 알고리즘",
        "excerpt":"O(N^2) 정렬 알고리즘 버블 정렬(Bubble Sort)   버블 정렬은 인접한 두 원소를 검사하여 정렬하는 방법이다.  버블 정렬 알고리즘 순서(오름차순)          주어진 배열 범위 중에서 첫 번째 위치와 두 번재 위치 크기를 비교하여 크기가 큰 수를 두 번째 위치에 둔다.      첫 번째 위치를 한 칸 뒤로 옮겨 과정 1을 반복한다.                  두 번째 위치가 주어진 배열 범위의 끝에 도달하면 마지막 위치를 제외하여 배열 범위를 설정하고 과정 1로 돌아간다.  (첫 번째 과정이 끝나면 가장 큰 원소가 가장 끝에 위치한다.)                      총 비교 횟수: (n-1) + (n-2) + (n-3) ... + 1   구현 코드(C언어)//오름차순//arr[]: 입력 배열, n: arr배열 크기void BubbleSort(int arr[], int n) {\tint i, j;\tint temp;\tfor(i = 0; i &lt; n - 1; i++)\t\tfor(j = 0; j &lt; (n - i) - 1; j++)\t\t\tif(arr[j] &gt; arr[j + 1]) {\t\t\t\ttemp = arr[j];\t\t\t\tarr[j] = arr[j + 1];\t\t\t\tarr[j + 1] = temp;\t\t\t}}선택 정렬(Selection Sort)   선택 정렬 알고리즘 순서(오름차순)          주어진 배열 범위 중에서 최소값을 찾는다.      해당 값을 가장 앞에 위치한 값과 교환한다.      가장 앞에 위치한 값을 제외하여 배열 범위를 설정하고 과정 1로 돌아간다.         구현 코드(C언어)//오름차순//arr[]: 입력 배열, n: arr배열 크기void SelectionSort(int arr[], int n) {\tint i, j;\tint maxIdx;\tint temp;\tfor(i = 0; i &lt; n - 1; i++) {\t\tmaxIdx = i;    // 정렬 순서상 가장 앞서는 데이터의 index    // 최소값 탐색\t\tfor(j = i + 1; j &lt; n; j++) {\t\t\tif(arr[j] &lt; arr[maxIdx])\t\t\t\tmaxIdx = j;\t\t}\t\t/* 교환 */\t\ttemp = arr[i];\t\tarr[i] = arr[maxIdx];\t\tarr[maxIdx] = temp;\t}}삽입 정렬(Insertion Sort)   삽입 정렬 알고리즘 순서(오름차순)          배열의 두 번째 위치부터 시작한다.      현재 위치보다 앞선 위치를 차례대로 순회하며 현재 값보다 작은 값을 찾는다.      작은 값을 찾으면, 그 바로 다음 위치로 옮기고 현재 위치 바로 다음 위치에서 과정 1을 반복한다.         구현 코드(C언어)//오름차순//arr[]: 입력 배열, n: arr배열 크기void InserSort(int arr[], int n) {\tint i, j;\tint insData;  //두 번째 위치부터 시작\tfor(i = 1; i &lt; n; i++) {\t\tinsData = arr[i];          // 정렬 대상을 insData에 저장\t\tfor(j = i - 1; j &gt;= 0 ; j--) {\t\t\tif(arr[j] &gt; insData)\t\t\t\tarr[j + 1] = arr[j];   // 비교 대상 한 칸 뒤로 밀기\t\t\telse\t\t\t\tbreak;                 // 삽입 위치 찾았으니 탈출!\t\t}\t\tarr[j + 1] = insData;        // 찾은 위치에 정렬 대상 삽입!\t}}","categories": ["DataStructure"],
        "tags": ["정렬"],
        "url": "https://codemcd.github.io/pages/CODEMCD/datastructure/DataStructure-N-2-%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/",
        "teaser":null},{
        "title": "[DataStructure]NlogN 정렬 알고리즘",
        "excerpt":"O(NlogN) 정렬 알고리즘 합병 정렬(Merge Sort)   합병 정렬은 분할 정복(Divide and conquer)방식으로 설계한 알고리즘이다.  합병 정렬 알고리즘 순서(오름차순)          분할 과정                  주어진 배열 범위를 반으로 분할한다.          반으로 분할된 배열의 크기가 0 또는 1일때 까지 반복한다.                    합병 과정                  두 배열 A, B를 합병한다고 가정하자.          두 배열 A, B를 합친 크기의 배열 C를 만든다.          배열 A부터 시작하는 인덱스와 배열 B부터 시작하는 인덱스를 설정하여 순서대로 서로 비교하여 작은 값부터 배열 C에 차례대로 삽입한다. (배열A, B는 반복된 위의 과정으로 오름차순으로 정렬되어 있다.)          배열 C가 원래 주어진 배열의 크기와 같을때까지 반복한다.                       구현 코드(C언어)void MergeTwoArea(int arr[], int left, int mid, int right) {\tint fIdx = left;\tint rIdx = mid+1;\tint i;  //두 배열을 합친 크기의 임의의 배열\tint * sortArr = (int*)malloc(sizeof(int)*(right+1));\tint sIdx = left;\twhile(fIdx &lt;= mid &amp;&amp; rIdx &lt;= right) {\t\tif(arr[fIdx] &lt;= arr[rIdx])\t\t\tsortArr[sIdx] = arr[fIdx++];\t\telse\t\t\tsortArr[sIdx] = arr[rIdx++];\t\tsIdx++;\t}\tif(fIdx &gt; mid) {\t\tfor(i = rIdx; i &lt;= right; i++, sIdx++)\t\t\tsortArr[sIdx] = arr[i];\t}\telse {\t\tfor(i = fIdx; i &lt;= mid; i++, sIdx++)\t\t\tsortArr[sIdx] = arr[i];\t}  //기존 배열의 원래 위치에 정렬된 배열을 삽입한다.\tfor(i = left; i &lt;= right; i++)\t\tarr[i] = sortArr[i];\tfree(sortArr);}//오름차순//arr[]: 입력 배열, left: arr배열의 가장 왼쪽 인덱스, right: arr배열의 가장 오른쪽 인덱스void MergeSort(int arr[], int left, int right) {\tint mid;\tif(left &lt; right) {\t\t// 중간 지점을 계산한다.\t\tmid = (left + right) / 2;\t\t// 둘로 나눠서 각각을 정렬한다.\t\tMergeSort(arr, left, mid);\t\tMergeSort(arr, mid + 1, right);\t\t// 정렬된 두 배열을 병합한다.\t\tMergeTwoArea(arr, left, mid, right);\t}}퀵 정렬(Quick Sort)   퀵 정렬은 분할 정복(Divide and conquer)방식으로 설계한 알고리즘이다.  퀵 정렬 알고리즘 순서(오름차순)          pivot을 설정한다.                  pivot을 설정하는 방법은 배열의 특정 위치나 배열 원소의 값 중 중간값, 랜덤값 n번째 값으로 설정한다.                    현재 주어진 배열에서 pivot 위치를 찾아서 그 위치로 교환한다.                  pivot보다 작은 값들은 모두 pivot 앞에 위치하고 큰 값은 모두 뒤에 위치해야한다.                    pivot을 기준으로 둘도 분할한 뒤 과정 1을 반복한다.      퀵 정렬 특징   퀵 정렬의 최악의 시간 복잡도는 O(N^2)이다.          pivot의 위치가 지속적으로 주어진 배열의 가장 왼쪽 또는 오른쪽에 위치하여 2개로 분할하지 못하는 경우이다.        하지만, 퀵 정렬은 평균적으로 정렬 알고리즘 중에서 가장 빠르다.          최초 pivot을 설정하는 방법 중에서 주어진 배열을 2개로 분할할 수 있는 효율적인 방법들이 존재한다.      퀵 정렬의 내부 루프는 대부분의 컴퓨터 아키텍처에서 효율적으로 동작하도록 설계되어 있다.                  메모리 참조가 지역화되어 있으므로 CPU의 cache 히트률이 높기 때문이다.                       구현 코드(C언어)void Swap(int arr[], int idx1, int idx2) {\tint temp = arr[idx1];\tarr[idx1] = arr[idx2];\tarr[idx2] = temp;}// pivot의 위치를 반환한다.int Partition(int arr[], int left, int right) {\tint pivot = arr[left];    // 피벗의 위치는 가장 왼쪽!\tint low = left+1;\tint high = right;  // 교차되지 않을 때까지 반복\twhile(low &lt;= high) {\t\twhile(pivot &gt;= arr[low] &amp;&amp; low &lt;= right)\t\t\tlow++;\t\twhile(pivot &lt;= arr[high] &amp;&amp; high &gt;= (left + 1))\t\t\thigh--;    // 교차되지 않은 상태라면 Swap 실행\t\tif(low &lt;= high)\t\t\tSwap(arr, low, high);\t}  //현재 high의 위치가 pivot이 있어야할 위치이다.\tSwap(arr, left, high);    \treturn high;}//오름차순//arr[]: 입력 배열, left: arr배열의 가장 왼쪽 인덱스, right: arr배열의 가장 오른쪽 인덱스void QuickSort(int arr[], int left, int right) {\tif(left &lt;= right) {\t\tint pivot = Partition(arr, left, right);    // pivot 설정 후 위치를 찾는다.\t\tQuickSort(arr, left, pivot-1);              // 왼쪽 영역을 정렬\t\tQuickSort(arr, pivot+1, right);             // 오른쪽 영역을 정렬\t}}","categories": ["DataStructure"],
        "tags": ["정렬"],
        "url": "https://codemcd.github.io/pages/CODEMCD/datastructure/DataStructure-NlogN-%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/",
        "teaser":null},{
        "title": "[DataStructure]배열과 리스트",
        "excerpt":"선형 자료 구조 동적 배열(dynamic array)   동적 배열은 일반 배열을 이용해 만든 별도의 자료구조이다.          대부분 언어의 표준 라이브러리에 포함되어 있다.        일반 배열의 특징(동적 배열 포함)          원소들은 메모리의 연속된 위치에 저장된다.      주어진 위치의 원소를 반환하거나 변경하는 동작을 O(1)에 할 수 있다.        동적 배열만의 특징          배열의 크기를 변경하는 reaize() 연산이 가능하다.                  이 동작을 수행하는데 배열의 크기 N에 비례하는 시간이 소요된다.                    주어진 원소를 배열의 맨 끝에 추가함으로써 크기를 1 늘리는 append() 연산을 지원한다.                  이 동작을 수행하는데 상수 시간 1이 소요된다.                      append() 연산의 원리          append()연산이 상수 시간이 걸리는 이유                  메모리를 할당받을 때 배열의 크기가 커질때를 대비해서 여유분의 메모리를 미리 할당받아 둔다.                    capacity: 이미 할당받은 메모리의 크기(배열의 용량)      size:  실제 원소 개수(배열의 크기), 프로그램이 실제 인식하는 배열의 크기                   미리 할당해둔 메모리가 꽉 찼을 때, append()연산을 할 경우 재할당이 필요하다.                  일반적인 재할당 코드의 시간 복잡도는 O(N + M)으로 선형 시간이 소요된다.(M: 추가할 메모리 크기)          하지만, 재할당을 할때 정해진 개수(M)로 추가하는 것이 아니라 현재 가진 원소의 개수에 비례해서 여유분을 확보하면 평균적으로 O(1)의 시간 복잡도로 append()연산을 수행할 수 있다.                    append()를 여러 번 수행할 때, 배열의 최종 크기를 미리 알 수 있다면, 동적 배열의 용량(capacity)를 미리 늘려둠으로써 재할당에 드는 비용을 없애는것이 좋다.                  동적 배열을 사용했을 때 느려지는 대부분의 이유이다.                      동적 배열은 c++의 vector, C#과 Java에서 ArrayList로 표준 라이브러리에서 제공한다.연결 리스트(linked list)   연결 리스트는 배열과 달리 원소들이 메모리 여기저기 흩어져 있고, 각 원소들이 이전과 다음 원소를 가르키는 포인터(양방향 리스트) 방식으로 구현된다.  일반적인 노드(node) 구조체struct ListNode {  int element;            //담고 있는 원소  ListNode *prev, *next;  //이전 노드, 다음 노드의 포인터}  연결 리스트는 첫 번째 노드와 마지막 노드에 대한 포인트를 가지는데, 이들을 각각 머리(head)와 꼬리(tail)이라고 부른다.          머리와 꼬리를 포인터가 아니라 값이 정의되지 않는 텅 빈 노드(더미 노드)로 두면, 항상 이전 노드와 다음 노드가 존재한다고 가정할 수 있기 때문에 구현이 더욱 간단해진다.        연결 리스트의 특징          노드들이 메모리 여기저기에 흩어져 있기 때문에 특정 위치 값을 찾기 힘들다.                  리스트의 머리부터 꼬리까지 포인터를 따라 가며 탐색해야 하기 때문에 선형 시간이 소요된다.                    노드의 삽입, 삭제가 간단하다.                  삽입, 삭제될 해당 노드의 이전 노드와 다음 노드의 포인트만 바꿔주면 된다.                      연결 리스트 응용 연산들          잘라 붙이기 연산(splicing): 두 개의 서로 다른 리스트에서 각각의 일부 리스트를 서로 잘라서 붙이는 연산이다.                  시간 복잡도는 리스트의 길이인 선형 시간에 비례하며, 잘라 붙였을 때의 크기를 알 수 없어 불안정하다.                    삭제했던 원소 돌려놓기(undo)      두 연산은 대부분 표준 라이브러리에서 제공하지 않는다.        연결 리스트는 C++의 list, C#과 java의 LinkedList로 표준 라이브러리에서 제공한다.동적 배열과 연결 리스트 비교   동적 배열          임의의 원소에 빠르게 접근 가능하다.      원소들이 메모리에 연속해 배치되어 있어 CPU 캐시의 효율을 높여준다.      삽입과 삭제가 거의 없고, 끝에 추가만 하면 될 경우에 활용하기 좋다.        연결 리스트          삽입과 삭제가 빠르다.      삽입과 삭제가 많이 수행하는 작업에 활용하기 좋다.                                작업          동적 배열          연결 리스트                                      이전 원소/다음 원소 찾기          O(1)          O(1)                          맨 뒤에 원소 추가/삭제하기          O(1)          O(1)                          맨 뒤 이외의 위치에 원소 추가/삭제하기          O(N)          O(1)                          임의의 위치의 원소 찾기          O(1)          O(N)                          크기 구하기          O(1)          O(N), 구현에 따라 O(1)가능                    ","categories": ["DataStructure"],
        "tags": ["선형자료구조"],
        "url": "https://codemcd.github.io/pages/CODEMCD/datastructure/DataStructure-%EB%B0%B0%EC%97%B4%EA%B3%BC%EB%A6%AC%EC%8A%A4%ED%8A%B8/",
        "teaser":null},{
        "title": "[DataStructure]정렬 알고리즘 비교",
        "excerpt":"정렬 알고리즘 비교 정렬 알고리즘 비교 표             Sort      Best      Worst      Stable      Memory                  버블 정렬      N      N^2      TRUE      1              선택 정렬      N^2      N^2      FALSE      1              삽입 정렬      N      N^2      TRUE      1              셸 정렬      NlogN      Nlog^2N      FALSE      1              합병 정렬      NlogN      NlogN      TRUE      N              퀵 정렬      NlogN      N^2      FALSE      logN ~ N      추천 링크   정렬 시뮬레이션: https://www.toptal.com/developers/sorting-algorithms","categories": ["DataStructure"],
        "tags": ["정렬"],
        "url": "https://codemcd.github.io/pages/CODEMCD/datastructure/DataStructure-%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B9%84%EA%B5%90/",
        "teaser":null},{
        "title": "[Database]SQL 개념 정리",
        "excerpt":"SQL(Structed Query Language) SQL에서 지원하는 기본 데이터 타입   정수(Integer): INT(4Byte), SMALLINT(2Byte)  실수(Float): FLOAT, REAL, DOUBLE PRECISION  형식화된 숫자: DEC(i, j) (i = 전체 자릿수, j = 소수부 자릿수)  고정길이 문자: CHAR(n) (n = 문자수)  가변길이 문자: VARCHAR(n) (n = 최대 문자 수)  고정길이 비트 열(Bit String): BIT(n)  가변길이 비트 열: VARBIT(n)  날짜: DATE  시간: TIMEDDL(Data Define Language)   DDL로 정의된 내용은 메타데이터가 되며, 시스템카탈로그에 저장한다.  CREATE, ALTER, DROP 명령문이 존재한다.    CREATE     스키마, 도메인 테이블, 뷰 인덱스를 정의한다.    CREATE SCHEMA     스키마를 정의하는 명령문  스키마는 하나의 응용(사용자)에 속하는 테이블과 기타 구성 요소등을 그룹짓기 위함이다.CREATE SCHEMA 스키마명 AUTHORIZATION 사용자ID;예제   ID가 홍길동인 사용자의 스키마 ‘대학교’를 정의하는 SQL문CREATE SCHEMA 대학교 AUTHORIZATION 홍길동;CREATE DOMAIN   도메인을 정의하는 명령문  도메인은 하나의 속성이 취할 수 있는 동일한 타입의 원자값들의 집합이다.CREATE DOMAIN 도메인명 데이터타입  [DEFAULT 기본값]  [CONSTRAINT 제약조건명 CHECK (범위값)];  데이터타입: SQL에서 지원하는 데이터 타입  기본값: 데이터를 입력하지 않았을 때 자동으로 입력되는 값예제   성별을 ‘남’ 또는 ‘여’와 같은 정해진 1개의 문자로 표현되는 도메인 SEX를 정의하는 SQL문CREATE DOMAIN SEX CHAR(1)  DEFAULT '남'  CONSTRAINT VALID-SEX CHECK (VALUE IN('남', '여'));CREATE TABLE   테이블을 정의하는 명령문CREATE TABLE 테이블명  (속성명 데이터타입[NOT NULL], ...  [, PRIMARY KEY (기본키 속성명, ...)]  [, UNIQUE (대채키 속성명, ...)]  [, FOREIGN KEY (외래키 속성명, ...)    REFERENCES 참조테이블(기본키 속성명, ...)]    [ON DELETE 옵션]    [ON UPDATE 옵션]  [, CONSTRAINT 제약조건명][CHECK (조건식)]);  옵션 종류          NO ACTION: 참조 테이블에 변화가 있어도 기본 테이블에는 아무런 조취를 취하지 않는다.      CASCADE: 참조 테이블의 튜플이 삭제되거나 속성이 변경되면 그에 해당하는 기본 테이블의 모든 튜플이 그에 맞게 갱신된다.      SET NULL: 참조 테이블에 변화가 생기면 기본 테이블의 관련 튜플의 속성 값을 NULL로 변경한다.      SET DEFAULT: 참조 테이블에 변화가 있으면 기본 테이블의 관련 튜플의 속성 값을 기본값으로 변경한다.        CONSTRAINT: 제약  조건의 이름을 지정하며, 반드시 지정할 필요는 없다.예제   이름, 학번, 전공, 성별, 생년월일로 구성된  테이블을 정의하는 SQL문          이름은 NULL이 올 수 없고, 학번은 기본키이다.      전공은  테이블의 학과코드를 참조하는 외래키로 사용된다.               테이블에서 삭제가 일어나면 관련된 튜플들의 전공 값을 NULL로 만든다.                     테이블에서 학과코드가 변경되면 전공 값도 같은 값으로 변경된다.            생년월일은 1980-01-01 이후의 데이터만 저장할 수 있다.      제약 조건의 이름은 ‘생년월일제약’으로 한다.      각 속성의 데이터형은 적당하게 지정한다. 단 성별은 도메인 ‘SEX’를 사용한다.      CREATE TABLE 학생  (이름 VARCHAR(15) NOT NULL,  학번 CHAR(8),  전공 CHAR(5),  성별 SEX,  생년월일 DATE,  PRIMARY KEY(학번),  FOREIGN KEY(전공) REFERENCES 학과(학과코드)    ON DELETE SET NULL    ON UPDATE CASCADE,  CONSTRAINT 생년월일제약 CHECK(생년월일 &gt;= '1980-01-01'));CREATE VIEW   뷰를 정의하는 명령문  뷰(View)는 하나 이상의 기본 테이블로부터 유도되는 이름을 갖는 가상 테이블이다.CREATE VIEW 뷰명[(속성명[, 속성명, ...])]AS SELECT문;  SELECT문을 서브 쿼리로 사용하여 SELECT문의 결과로서 뷰를 생성한다.예제        테이블에서 주소가 '안산시'인 고객들의 성명과 전화번호를 '안산고객'이라는 뷰로 정의한다.  CREATE VIEW 안산고객(성명, 전화번호)AS SELECT 성명, 전화번호FROM 고객WHERE 주소='안산시';CREATE INDEX   인덱스를 정의하는 명령문  인덱스는 검색을 빠르게 하기 위해 만든 보조적인 데이터 구조이다.CREATE [UNIQUE] INDEX &lt;인덱스명&gt;  ON 테이블명({속성명 [ASC | DESC] [,속성명 [ASC | DESC]]})  [CLUSTER];  UNIQUE          사용된 경우: 중복 값이 없는 속성으로 인덱스를 생성한다.      생략된 경우: 중복 값을 허용하는 속성으로 인덱스를 생성한다.        정렬 여부 지정          ASC: 오름차순 정렬      DESC: 내림차순 정렬      생략된 경우: 오름차순으로 정렬된다.        CLUSTER: 지정된 키에 따라 튜플들으르 그룹으로 지정하기 위해 사용된다.예시        테이블에서 UNIQUE한 특성을 갖는 고객번호 속성에 대해 내림차순으로 정렬하여 '고객번호_idx'라는 이름으로 인덱스를 정의한다.  CREATE UNIQUE INDEX 고객번호_idx  ON 고객(고객번호 DESC);ALTER ALTER TABLE   테이블에 대한 정의를 변경하는 명령문ALTER TABLE 테이블명 ADD 속성명 데이터타입 [DEFAULT '기본값'];ALTER TABLE 테이블명 ALTER 속성명 [SET DEFAULT '기본값'];ALTER TABLE 테이블명 DROP COLUMN 속성명 [CASCADE];  ADD: 새로운 속성을 추가한다.  ALTER:  속성의 기본값을 변경한다.  DROP COLUMN: 속성을 제거한다.예시        테이블에 최대 3문자로 구성되는 학년 속성을 추가하는 SQL문  ALTER TABLE 학생 ADD 학년 VARCHAR(3);DROP   스키마, 도메인, 테이블, 뷰, 인덱스, 트리거를 제거하는 명령문DROP SCHEMA 스키마명 [CASCADE | RESTRICT];DROP DOMAIN 도메인명 [CASCADE | RESTRICT];DROP TABLE 테이블명 [CASCADE | RESTRICT];DROP VIEW 뷰명 [CASCADE | RESTRICT];DROP INDEX 인덱스명 [CASCADE | RESTRICT];DROP TRIGGER 트리거명 [CASCADE | RESTRICT];DROP CONSTRAINT 제약조건명;  CASCADE: 제거할 개체를 참조하는 다른 모든 개체를 함께 제거한다. 즉, 주 테이블의 데이터 제거 시, 각각의 외래키와 관계를 맺고 있는 모든 데이터를 함께 제거한다.(참조 무결성 제약 조건을 위함)  RESTRICT: 다른 개체가 제거할 개체를 참조중일 경우 제거가 취소된다.SELECT   테이블을 구성하는 튜플들 중에서 전체 또는 조건을 만족하는 튜플을 검색하여 주기억장치에 임시 테이블로 구성하는 명령문이다.SELECT [PREDICATE] [테이블명.]속성명[ AS 별칭][, [테이블명.]속성명, ...]FROM 테이블명[, 테이블명, ...][WHERE 조건][GROUP BY 속성명[, 속성명, ...]][HAVING 조건][ORDER BY 속성명 [ASC | DESC][, 속성명 [ASC | DESC], ...]];  PREDICATE: 검색할 튜플을 제한할 목적으로 사용되는 조건이다.          ALL: 모든 튜플들을 검삭할 때 사용되며, 기본값이다.      DISTINCT: 중복된 튜플들을 제거할 때 사용된다.      DISTINCTROW: 중복된 튜플을 제거하지만, 선택된 속성의 값이 아닌 튜플의 전체 값을 대상으로 사용된다.        AS: 속성 및 연산의 이름을 다른 제목으로 표시하기 위해 사용된다.  FROM절: 검색할 데이터가 들어 있는 테이블명을 기술한다.  WHERE절: 검색할 조건을 기술한다.  GROUP BY절: 특정 속성을 기준으로 그룹화하여 검색할 때 사용된다. 일반적으로 그룹 함수와 함께 사용한다.  HAVING절: 그룹에 대한 조건을 기술한다.  ORDER BY절: 특정 속성을 기분으로 정렬하여 검색할 때 사용된다.    하위 질의          테이블에서 취미가 '나이트댄스'인 사원에 대해  테이블에서 해당 사원의 이름과 주소를 검색하는 SQL문  SELECT 이름, 주소FROM 사원WHERE 이름 IN(SELECT 이름 FROM 여가활동 WHERE 취미='나이트댄스');복수 테이블 검색   경력이 10년 이상인 사원의 이름, 부서, 취미, 경력을 검색하는 SQL문SELECT 사원.이름, 사원.부서, 여가활동.취미, 여가활동.경력FROM 사원, 여가활동WHERE 여가활동.경력 &gt;= 10 AND 사원.이름 = 여가활동.이름;통합(UNION) 질의   UNION은 일반 집합 이론에서의 합집합과 같다.  두 테이블을 합치면 두 테이블에 모두 속해 있는 튜플은 중복이 제거되어 1개만 표시된다.  사원들의 명단이  테이블과  테이블에 저장되어 있다. 두 테이블을 통합하는 SQL문(중복 제거)SELECT *FROM 임원UNION SELECT * 직원;JOIN   조인은 2개의 테이블에 대해 연관된 튜플들을 결합하여, 하나의 새로운 릴레이션을 반환한다.  조인은 크게 INNER JOIN과 OUTER JOIN으로 구분된다.    INNER JOIN     INNER JOIN은 일반적으로 EQUI JOIN과 NON-EQUI JOIN으로 구분된다.    EQUI JOIN     EQUI JOIN은 JOIN 대상 테이블에서 공통 속성을 기준으로 ‘=’(equal)비교에 의해 같은 값을 가지는 행을 연결하여 결과를 생성하는 방법이다.  중복된 속성을 제거하여 같은 속성을 한 번만 표기하는 방법을 NATURAL JOIN이라 한다.  WHERE절을 이용한 EQUI JOINSELECT [테이블명1.]속성명, [테이블명2.]속성명, ...FROM 테이블명1, 테이블명2, ...WHERE 테이블명1.속성명 = 테이블명2.속성명;  NATURAL JOIN을 이용한 EQUI JOINSELECT [테이블명1.]속성명, [테이블명2.]속성명, ...FROM 테이블명1 NATURAL JOIN 테이블명2;  JOIN ~ USING절을 이용한 EQUI JOINSELECT [테이블명1.]속성명, [테이블명2.]속성명, ...FROM 테이블명1 JOIN 테이블명2 USING(속성명);예제        테이블과  테이블에서 학과코드 값이 같은 튜플을 JOIN하여 학번, 이름, 학과코드, 학과명을 출력하는 SQL문  SELECT 학번, 이름, 학생.학과코드, 학과명FROM 학생, 학과WHERE 학생.학과코드 = 학과.학과코드;SELECT 학번, 이름, 학생.학과코드, 학과명FROM 학생 NATURAL JOIN 학과;SELECT 학번, 이름, 학생.학과코드, 학과명FROM 학생 JOIN 학과 USING(학과코드);NON-EQUI JOIN   NON-EQUI JOIN은 JOIN조건에 ‘=’ 조건이 아닌 나머지 비교 연산자인 ‘&gt;’, ‘&lt;’, ‘&lt;=’, ‘&gt;=’ 연산자를 사용하는 방법이다.예제        테이블과  테이블을 JOIN하여 각 학생의 학번, 이름, 성적, 등급을 출력하는 SQL문  SELECT 학번, 이름, 성적, 등급FROM 학생, 성적등급WHERE 학생.성적 BETWEEN 성적등급.최저 AND 성적등급.최고;OUTER JOIN   OUTER JOIN은 릴레이션에서 JOIN조건에 만족하지 않는 튜플도 결과로 출력하기 위한 JOIN 방법이다.    LEFT OUTER JOIN     INNER JOIN의 결과를 구한 후, 우측 항 릴레이션과 맞지 않는 좌측 항 릴레이션의 튜플에 NULL값을 대입한다.  좌측 릴레이션은 모두 출력된다.SELECT [테이블명1.]속성명, [테이블명2.]속성명, ...FROM 테이블명1 LEFT OUTER JOIN 테이블명2ON 테이블명1.속성명 = 테이블명2.속성명;SELECT [테이블명1.]속성명, [테이블명2.]속성명, ...FROM 테이블명1, 테이블명2WHERE 테이블명1.속성명 = 테이블명2.속성명(+);RIGHT OUTER JOIN   INNER JOIN의 결과를 구한 후, 좌측 항 릴레이션과 맞지 않는 우측 항 릴레이션의 튜플에 NULL값을 대입한다.  우측 릴레이션은 모두 출력된다.SELECT [테이블명1.]속성명, [테이블명2.]속성명, ...FROM 테이블명1 RIGHT OUTER JOIN 테이블명2ON 테이블명1.속성명 = 테이블명2.속성명;SELECT [테이블명1.]속성명, [테이블명2.]속성명, ...FROM 테이블명1, 테이블명2WHERE 테이블명1.속성명(+) = 테이블명2.속성명;FULL OUTER JOIN   LEFT OUTER JOIN과 RIGHT OUTER JOIN을 합쳐 놓은 것이다.  양쪽 릴레이션이 모두 출력된다.SELECT [테이블명1.]속성명, [테이블명2.]속성명, ...FROM 테이블명1 FULL OUTER JOIN 테이블명2ON 테이블명1.속성명 = 테이블명2.속성명;SELF JOIN   SELF JOIN은 같은 테이블에서 2개의 속성을 연결하여 EQUI JOIN을 하는 방법이다.SELECT [별칭1.]속성명, [별칭2.]속성명, ...FROM 테이블명1 [AS] 별칭1 JOIN 테이블명1 [AS] 별칭2ON 별칭1.속성명 = 별칭2.속성명;SELECT [별칭1.]속성명, [별칭2.]속성명, ...FROM 테이블명1 [AS] 별칭1, 테이블명1 [AS] 별칭2WHERE 별칭1.속성명 = 별칭2.속성명;DML(Date Manipulation Language)   DML은 데이터베이스 사용자가 응용 프로그램이나 질의어를 통해 저장된 데이터를 실질적으로 관리하는데 사용되는 언어이다.  DML은 데이터베이스 사용자와 데이터베이스 관리 시스템 간의 인터페이스를 제공한다.  INSERT, DELETE, UPDATE 명령문이 있다.    INSERT문     테이블에 새로운 튜플을 삽입할 때 사용하는 명령문이다.INSERT INTO 테이블명[(속성명1, 속성명2, ...)]VALUES (데이터1, 데이터2, ...);예시        테이블에 이름이 \"이순신\"이고, 부서가 \"기획\"인 사원을 삽입하는 SQL문  INSERT INTO 사원(이름, 부서) VALUES ('이순신', '기획');       테이블에 있는 편집 부서의 모든 튜플을 &lt;편집부원(이름, 생일, 주소, 기본급)&gt; 테이블에 삽입하는 SQL문  INSERT INTO 편집부원(이름, 생일, 주소, 기본급)SELECT 이름, 생일, 주소, 기본급 FROM 사원 WHERE 부서='편집';DELETE문   테이블에 있는 튜플들 중에서 특정 튜플을 삭제할 때 사용하는 명령문이다.DELETE FROM 테이블명 WHERE 조건;예시        테이블에서 이름이 \"임꺽정\"인 튜플을 삭제하는 SQL문  DELETE FROM 사원 WHERE 이름='임꺽정';       테이블의 모든 튜플을 삭제하는 SQL문  DELETE FROM 사원;UPDATE문   테이블에 있는 튜플들 중에서 특정 튜플의 내용을 갱신할 때 사용하는 명령문이다.UPDATE 테이블명SET 속성명=데이터[, 속성명=데이터, ...]WHERE 조건;예시        테이블에서 홍길동의 주소를 \"퇴계동\"으로 갱신하는 SQL문  UPDATE 사원 SET 주소='퇴계동' WHERE 이름='홍길동';       테이블에서 황진이의 부서를 \"기획\"으로 변경하고 기본급을 5 인상하는 SQL문  UPDATE 사원 SET 부서='기획', 기본급=기본급+5 WHERE 이름='황진이';DCL(Data Control Language)   DCL은 데이터의 보안, 무결성, 회복, 병행 제어 등을 정의하는데 사용하는 언어이다.  DCL은 데이터베이스 관리자(DBA)가 데이터 관리를 목적으로 사용한다.  COMMIT, ROLLBACK, GRANT, REVOKE 명령문이 있다.    COMMIT     트랜잭션의 모든 변경 내용들을 영구적으로 데이터베이스에 반영하는 명령어이다.    ROLLBACK     변경된 모든 내용들을 취소하고 데이터베이스를 이전 상태로 되돌리는 명령어이다.  트랜잭션의 일부를 성공적으로 끝내지 못하면 데이터베이스가 비일관성인 상태를 가질 수 있으므로 모든 내용들을 취소해야한다.    GRANT     데이터베이스 관리자가 데이터베이스 사용자에게 권한을 부여하기 위한 명령어이다.  사용자등급 지정GRANT 사용자등급 TO 사용자ID리스트[IDENTIFIED BY 암호];  사용자 등급: DBA(데이터베이스 관리자), RESOURCE(데이터베이스 및 테이블 생성 가능자), CONNECT(단순 사용자)  테이블 및 속성에 대한 권한 부여GRANT 권한리스트 ON 개체 TO 사용자 [WITH GRANT OPTION];REVOKE   권한 취소를 위한 명령어이다.  사용자등급 해제REVOKE 사용자등급 FROM 사용자ID리스트;  테이블 및 속성에 대한 권한 취소REVOKE [GRANT OPTION FOR] 권한리스트 ON 개채 FROM 사용자 [CASCADE];","categories": ["Database"],
        "tags": ["개념 정리"],
        "url": "https://codemcd.github.io/pages/CODEMCD/database/Database-SQL-%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC/",
        "teaser":null},{
        "title": "[Database]개념 정리",
        "excerpt":"데이터베이스(Database) 데이터베이스 개념 정의   특정 조직의 업무를 수행하는데 있어서 필요한 상호 관련된 데이터들의 모임  통합 데이터(Integrated Data): 검색의 효율성을 위해 중복을 최소화한 데이터  저장 데이터(Stored Data): 컴퓨터가 접근 가능한 저장 매체에 저장된 데이터  운영 데이터(Operational Data): 조직의 목표를 위해 존재 가치가 확실하고 반드시 필요한 데이터  공유 데이터(Shared Data): 여러 프로그램들이 공동으로 사용하는 데이터    특징     실시간 접근성(Real Time Accessibility): 사용자의 질의(query)에 대해 즉시 처리하여 응답한다.  계속적인 진화(Continuous Evolution): 항상 최근의 정확한 데이터를 동적으로 유지한다.  동시 공유(Concurrent Sharing): 여러 사용자가 동시에 원하는 데이터를 사용가능하다.  내용에 의한 참조(Content Reference): 데이터를 참조할 때 내용으로 참조한다.(물리적 주소값이 아님)  독립성(Independence)          논리적 독립성(응용프로그램과 데이터베이스와의 관계): 데이터의 논리적 구조를 변경하더라도 응용프로그램에는 영향을 주지 않는다.      물리적 독립성(응용프로그램과 보조기억장치와의 관계): 새로운 저장장치의 추가에도 응용프로그램에는 영향을 주지 않는다.        무결성(Integrity): 데이터베이스에 저장된 데이터 값과 실제 값이 일치하는 정확성          무결성 제약 조건: 정확하지 않은 데이터가 데이터베이스내에 저장되는 것을 방지하기 위한 제약 조건                  널 무결성(NULL Integrity): 특정 속성(attribute)값이 NULL일 수 없다.          고유 무결성(Unique Integrity): 특정 속성에 대해 각 튜플들은 서로 다른 값이어야 한다.          키 무결성(Key Integrity): 하나의 릴레이션에는 적어도 하나의 key가 있어야 한다.          도메인 무결성(Domain Integrity): 특정 속성값이 해당 속성이 정의된 도메인에 속한 값이어야 한다.          관계 무결성(Relationship Integrity): 릴레이션에서 튜플의 삽입 가능 여부와 서로 다른 릴레이션의 튜플들 사이의 관계가 적절해야 한다.          참조 무결성(Referential Integrity): Foreign key는 NULL값이거나 참조 릴레이션의 primary key와 동일해야한다.          개체 무결성(Entity Integrity): Primary key를 구성하는 속성은 NULL일 수 없다.                      보안성  일관성  데이터 중복 최소    Data Language     데이터베이스의 구축과 사용을 위해 DBMS와의 통신 수단이다.  종류          DDL(Data Definition Language): 데이터베이스의 구조, 형식, 접근방식 등을 구축하거나 변경한다.      DML(Data Manipulation Language): 데이터 처리를 위한 연산의 집합(검색, 삽입, 삭제, 갱신)이다.      DCL(Data Control Language): 보안 및 권한제어, 무결성, 회복, 벙행제어를 수행한다.        데이터베이스 사용자               DBA(DataBase Administrator, 데이터베이스 관리자): 데이터베이스를 정의하고 제어하는 사람 또는 그룹  DA(Data Administrator, 데이터 관리자): 조직내에서 데이터에 대한 정의, 체계화, 감독 및 보안 업무를 수행한다.  DA(Data Architect, 데이터 설계자): 데이터의 구조를 체계적으로 정의한다.시스템 카탈로그(System Catalog)   DBA의 도구로써, 데이터베이스에 저장되어 있는 모든 데이터 개체들에 대한 정의와 명세와 같은 정보들이 저장되어 있는 테이블이다.  데이터 사전(Data Dictionary) 라고도 불린다.  시스템 카탈로그에 저장된 내용을 메타 데이터(Meta Data)라고 한다.  시스템 카탈로그는 DBMS에 의해 생성되고 유지되며, 사용자가 SQL문으로 수정할 수 없다.(DBMS와 사용자가 접근 가능하다.)DBMS(Database Management System)   다수의 사용자들이 데이터베이스 내의 데이터를 접근할 수 있도록 해주는 소프트웨어 도구의 집합이다.  주어진 설정에 따라 데이터베이스 스키마를 생성하고, 생성된 스키마를 참조하여 명령을 수행한다.  DDL 컴파일러와 트랜잭션 관리자로 구성되어 있다.    기능     사용자 또는 다른 프로그램의 요구를 처리하고 적절히 응답하여 데이터를 사용할 수 있도록 도와준다.  정의: 데이터에 대한 형식, 구조, 제약조선들을 명세하는 기능(데이터베이스에 대한 정의 및 설명은 카탈로그나 사전의 형태로 저장된다.)  구축: DBMS가 관리하는 기억 장치에 데이터를 저장하는 기능  조작: 특정한 데이터를 검색하기 위한 질의, 데이터베이스의 갱신, 보고서 생성 기능 등  공유: 여러 사용자와 프로그램이 데이터베이스에 동시에 접근하도록 하는 기능  보호: 하드웨어나 소프트웨어의 오동작 또는 권한이 없는 악의적인 접근으로부터 시스템을 보호  유지보수: 시간이 지남에 따라 변화하는 요구사항을 반영할 수 있도록 하는 기능    장점     데이터의 통합성 향상  데이터의 접근성 용이  데이터 통제 강화  애플리케이션 프로그램들을 쉽게 개발 및 관리가 가능  보안 강화스키마(Schema)   데이터베이스에서 데이터의 구조, 표현 방법, 관계를 형식 언어로 정의한 구조이다.  외부 스키마(External Schema): 프로그래머나 사용자의 입장에서 데이터베이스 모습을 정의한다.  개념 스키마(Conceptual Schema): 모든 응용 시스템과 사용자들의 관점에서 데이터베이스 구조를 논리적으로 정의한다.  내부 스키마(Internal Schema): 전체 데이터베이스의 물리적 저장 형태를 기술한다.데이터베이스 설계 1. 요구 조건 분석 2. 개념적 설계   개념 스키마 모델링: ER Model과 같은 추상화 기법을 통해 개념 스키마를 만든다.  트랜잭션 모델링    3. 논리적 설계     논리 스키마를 설계한다.  관계형 DBMS의 경우 ER Model을 relation schema로 변환한다.(정규화 수행)  트랜잭션의 전체적인 구조를 설계하고 인터페이스를 정의한다.    4. 물리적 설계     물리 스키마를 설계한다.  데이터베이스 파일에 대한 저장 구조와 접근 경로를 설정한다.    5. 데이터베이스 구현     DBMS의 DDL을 사용하여 데이터베이스를 구축한다.Model Relationship Data Model   대표적인 논리적 데이터 모델로서, 테이블(Table) 또는 릴레이션(Relation)의 구조로 표현한다.  테이블 그림 삽입  Relation: 데이터를 표현하는 2차원 테이블          Relation Schema: Relation의 이름, 각 attribute에 대한 정의      Relation Instance: Relation에 들어있는 tuple들의 집합        Attribute(속성): Relation의 columns  Tuple(튜플): Relation의 rows  Domain: 하나의 attribute가 가질 수 있는 같은 타입의 값들의 집합  Degree: Relation의 attribute의 개수  Cardinality: Relation의 tuple의 개수    ER Model(Entity - Relationship Model)     대표적인 개념적 데이터 모델로서, Entity, Relationship, Attribute 를 도형화하여 표현한 것이다.  위를 ERD(ER Diagram)이라고 부른다.  그림 삽입key |          Key          \t|                             특징                             \t| 유일성 \t| 최소성 \t||:———————:\t|:————————————————————:\t|:——:\t|:——:\t||   Super Key(슈퍼키)   \t|              한 릴레이션 내에 있는 속성들의 집합             \t|    O   \t|    X   \t|| Candidate Key(후보키) \t|      한 릴레이션에서 튜플을 유일하게 식별할 수 있는 속성     \t|    O   \t|    O   \t||  Primary Key(기본키)  \t| 후보키 중 특별히 선정된 키(중복된 값과 NULL을 가질 수 없음) \t|    O   \t|    O   \t|| Alternate Key(대체키) \t|            후보키중 기본키를 제외한 나머지 속성들            \t|    O   \t|    O   \t||  Foreign Key(외래키)  \t|   다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합(중복된 값과 NULL을 가질 수 없음)  \t|    O   \t|    O   \t| 관계대수와 관계해석   관계대수로 표현한 식은 관계해석으로도 표현 가능하다.  관계해석과 관계대수는 관계형 데이터베이스를 처리하는 기능과 능력면에서는 동등하다.    관계대수(Relation Algebra)     관계형 데이터베이스에서 원하는 정보를 검색하기 위해서 어떻게 유도할지를 기술한 절차적 언어로 연산자와 연산규칙을 제공한다.  질의에 대한 해를 구하기 위해 수행해야할 연산의 순서를 명시한다.(절차적 성격)  순수 관계 연산자          표 그림 삽입        일반 집합 연산자          표 그림 삽입        관계해석(Relation Calculus)               E.F.Codd박사가 제안한 것으로 수학의 술어해석에 기반을 둔다.  원하는 정보가 무엇이라는 것만 정의하는 비절차적 특징을 갖는다.  SQL문과 같은 질의어를 사용하며 튜플 관계해석과 도메인 해석으로 구성된다.정규화(Normalization)   테이블 속성들 사이의 종속적인 관계를 이용하여 테이블을 손실없이 분해하는 과정이다.  이러한 분해를 통해, 중복을 최대한 제거하고 이상(anomaly)의 발생 가능성을 줄인다.    이상(Anomaly)     테이블 일부 속성들이 종속으로인해 중복이 발생하여 테이블 조작에 문제가 발생하는 현상이다.  종류          삽입 이상(Insert Anomaly): 원하지 않는 데이터가 삽입되거나 삽입하는데 데이터가 부족하여 삽입이 되지 않는 문제점을 말한다.      삭제 이상(Delete Anomaly): 하나의 데이터만을 삭제하는 동작에서 해당 데이터가 포함된 튜플 전체가 삭제됨과 같은 원하지 않는 정보 손실이 발생하는 문제점을 말한다.      갱신 이상(Update Anomaly): 튜플에 있는 속성값을 갱신하는 동작에서 일부 튜플 정보만 갱신되어 정보에 불일치성이 생기는 문제점을 말한다.        원인: 여러가지 종류의 값들을 하나의 릴레이션에 표현하기 때문이다.  해결 방안: 속성들간의 종속성을 분석하여 하나의 종속성은 하나의 릴레이션에 표현되도록 분해한다.(정규화)    함수적 종속(Functional Dependency)     임의의 테이블 R에서 X와 Y를 각각 R의 속성 집합의 부분 집합이라고 할때, X의 값이 Y의 값을 유일하게(unique) 결정한다면 “X는 Y를 함수적으로 결정한다”라고 한다.  이를 X -&gt; Y로 표기하며, X를 결정자(Determinant), Y를 종속자(Dependent)라고 부른다.  완전 함수적 종속(Full Functional Dependency): X -&gt; Y일때, X의 임의의 애트리뷰트를 제거하면 더 이상 함수적 종속성이 성립하지 않는 경우를 말한다.  부분 함수적 종속(Partial Functional Dependency): X -&gt; Y일때, X의 임의이 애트리뷰트를 제거하더라도 함수적 종속성을 성립하는 경우를 말한다.  이행 함수적 종속(Transitive Functional Dependency): X -&gt; Y, Y -&gt; Z의 경우에서 추론될 수 있는 X -&gt; Z가 성립하는 경우를 말한다.  다치종속(Multi-Valued Dependency, MVD): X, Y -&gt; Z와 X -&gt; Z가 성립하는 경우이다.  조인 종속: 테이블 R과 R의 프로젝션들을 모두 조인한 결과가 동일한 경우를 말한다.    정규화 과정     제 1 정규형(1NF)     애트리뷰트의 도메인이 오직 원자값 만을 포함하고, 튜플의 모든 애트리뷰트가 도메인에 속하는 하나의 값을 가져야 한다.  복합 애트리뷰트, 다중값 애트리뷰트, 중첩 릴레이션 등 비원자적인 애트리뷰트를 혀용하지 않는 릴레이션 형태이다.    제 2 정규형(2NF)     모든 비주요 애트리뷰트들이 주요 애트리뷰트에 대해서 완전 함수적 종속 이면 제 2 정규형을 만족한다.  기본키가 아닌 모든 애트리뷰트들이 기본키에 완전 함수적 종속이 되는 릴레이션 형태이다.    제 3 정규형(3NF)     모든 비주요 애트리뷰트들이 기본키에 대해서 이행 함수적 종속이 성립하지 않으면 제 3 정규형을 만족한다.  비주요 애트리뷰트가 비주요 애트리뷰트에 의해 종속되는 경우가 없는 릴레이션 형태를 말한다.    BCNF(Boyce-Codd) 정규형     여러 후보키가 존재하는 릴레이션에 해당하는 정규화이다.  모든 종속의 결정자가 후보키가 되면 BCNF 정규형을 만족한다.    제 4 정규형(4NF)     다치종속관계 가 성립되는 경우를 모두 제거한 형태를 말한다.    제 5 정규형(5NF)     조인종속 이 후보키를 통해서만 성립되는 형태를 말한다.인덱스(Index)   DBMS가 데이터베이스 테이블의 데이터를 빠르게 검색하기 위해서 &lt;데이터, 데이터가 저장된 주소&gt; 쌍으로 구성되는 데이터 구조이다.  DBMS의 인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 탐색하는것은 빠르지만 새로운 값을 추가, 삭제, 수정하는 경우에는 느리다.  즉, 인덱스는 데이터의 저장 성능을 희생하는 대신 데이터의 읽기 속도를 높이는 역할을 한다.    인덱스 종류     기본 인덱스          기본키를 위한 인덱스      관계형 DBMS에서는 모든 기본키에 자동적으로 기본 인덱스를 생성한다.        보조 인덱스: 기본 인덱스가 아닌 나머지 인덱스  클러스터드(Clustered) 인덱스          인덱스 테이블의 키 값 순서와 튜플의 물리적 순서를 동일하게 유지하는 인덱스(물리적으로 인접한 장소에 저장되어 있는 데이터들)      클러스터드 인덱스는 기본키에 대해서만 적용되며, 기본키가 비슷한 레코드끼리 묶어서 저장한 것이다.      기본키값에 따라 레코드의 저장 위치가 결졍되므로 기본키값이 변경되면 해당 레코드의 물리적인 저장 위치 역시 변경되어야 한다.      클러스터드 인덱스는 테이블당 기본키와 같이 한 개만 생성할 수 있다.(Non-clustered 인덱스는 한 테이블당 여러개를 생성할 수 있다.)        인덱스 자료구조         B+-Tree 인덱스 알고리즘               일반적으로 사용되는 인덱스 알고리즘은 B+-Tree 알고리즘이다.  B+-Tree 인덱스는 칼럼의 값을 변형하지 않고(사실, 값의 일부분만 잘라서 관리함), 원래의 값을 이용해 인덱싱하는 알고리즘이다.    Hash 인덱스 알고리즘     칼럼 값을 해시 값으로 계산해서 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원한다.  값을 변형해서 인덱싱하므로, 특정 문자로 시작하는 검색인 전방 일치 검색과 같이 값의 일부만으로 검색하고자 할 때는 사용할 수 없다.  주로 메모리 기반의 데이터베이스에 사용된다.    왜 index를 생성하는데 주로 B-Tree를 사용하는가?     데이터에 접근하는 시간복잡도가 O(1)인 hash table이 더 효율적일 것 같지만, SELECT질의의 조건에는 부등호(&lt; &gt;)연산도 포함이 되는데 이는 hash table에서 사용할 수 없다.  동등 연산(=)에 특화된 hash table은 데이터베이서의 자료구조에 적합하지 않다.    인덱스 성능     인덱스를 사용하면 SELECT 쿼리의 성능을 크게 상향시킬 수 있다.  그에 반해 INSERT, DELETE, UPDATE 쿼리를 실행할 때 별도의 과정이 추가적으로 발생하기 때문에 오히려 전체적인 성능은 떨어진다.          INSERT는 인덱스에 대한 데이터도 따로 추가해한다.      DELETE는 인덱스에 존재하는 값은 삭제하지 않고 사용을 안한다는 표시로만 남는다.(즉, row의 수는 그대로이다.)        결과적으로, 인덱스는 꼭 필요한 컬럼에만 적용해야 한다.트랜잭션(Transaction)   트랜잭션은 작업의 완전성 을 보장해준다.  논리적인 작업 셋을 모두 완벽하게 처리한다. 만약 처리하지 못할 경우에는 원래 상태로 복구해서 작업의 일부만 적용되는 현상을 막아주는 기능을 한다.  사용자의 입장에서는 작업의 논리적 단위로 볼 수 있고, 시스템의 입장에서는 데이터들을 접근 또는 변경하는 프로그램의 단위가 된다.  COMMIT: 하나의 트랜잭션이 정상적으로 종료될 경우 수행되는 연산  ROLLBACK: 하나의 트랜잭션이 비정상적으로 종료될 경우 수행되는 연산    특징     ACID    원자성(Atomicity)     만약 트랜잭션 중간에 어떤 문제가 발생했다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행해되어서는 안된다. 즉, 아무런 문제가 발생하지 않았을 경우에만 모든 작업이 수행된다.    일관성(Consistency)     트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.    고립성(Isolation)     각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.    지속성(Durability)     트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.    상태     그림 삽입  Active: 트랜잭션의 활동 상태, 트랜잭션이 실행중이며 동작중인 상태를 말한다.  Failed: 트랜잭션 실패 상태, 트랜잭션이 더이상 정상적으로 진행할 수 없는 상태를 말한다.  Partial Committed: 트랜잭션의 Commit 명령어가 도착한 상태, 트랜잭션의 commit 이전의 sql 문이 수행되고 commit 만 남은 상태를 말한다.  Committed: 트랜잭션 완료 상태, 트랜잭션이 정상적으로 완료된 상태를 말한다.  Aborted: 트랜잭션 취소 상태, 트랜잭션이 취소되고 트랜잭션 실행 이전 데이터로 돌아간 상태를 말한다.    Partial Committed 와 Committed 의 차이     Commit 요청이 들어오면 트랜잭션의 상태는 Partial Committed 상태가 된다. 이후 commit 을 문제없이 수행할 수 있으면 Committed 상태로 전이되고, 만약 오류가 발생하면 Failed 상태가 된다. 즉, Partial Committed 는 commit 요청이 들어왔을때를 말하며, Committed 는 commit 을 정상적으로 완료한 상태를 말한다.    병행제어(Concurrency Control)     병행제어란 다중 프로그램의 이점을 활용하여 동시에 여러개의 트랜잭션을 병행 수행할 때, 동시에 실행되는 트랜잭션들이 데이터베이스의 일관성을 파괴하지 않도록 트랜잭션 간의 상호작용을 제어하는 것이다.    목적     데이터베이스의 공유를 최대화한다.  시스템의 활용도를 최대화한다.  데이터베이스의 일관성을 유지한다.  사용자에 대한 응답시간을 최소화한다.    문제점     갱신 분실(Lost Update): 두 개 이상의 트랜잭션이 같은 자료를 공유하여 갱신할 때 갱신 결과의 일부가 없어지는 현상이다.  비완료 의존성(Uncommitted Dependency): 하나의 트랜잭션 수행이 실패한 후 이를 회복하기 전에 다른 트랜잭션이 그 실패한 갱신 결과를 참조하는 현상이며, 임시 갱신이라고도 한다.  모순성(Inconsistency): 두 개의 트랜잭션이 병행수행될 때 원치 않는 자료를 이용함으로써 발생하는 문제이며, 불일치 분석이라고도 한다.  연쇄 복귀(Cascading Rollback): 병행수행하는 트랜잭션들 중 어느 하나에 문제가 발생하여 Rollback 하는 경우 다른 트랜잭션도 함께 Rollback 되는 현상이다.    병행제어 기법의 종류           로킹(Locking, 잠금)        로킹은 주요 데이터의 접근을 상호 배타적으로 하는 것이다.  트랜잭션들이 어떤 로킹 단위를 접근하기 전에 Lock(잠금)을 요청하여 접근을 허용해주어야만 그 로킹 단위에 접근할 수 있는 기법이다.  데이터 갱신 과정: 잠금(Lock) -&gt; 실행(Excute) -&gt; 해제(Unlock)  잠금 단위          병행제어에서 한 번에 잠금할 수 있는 단위는 데이터베이스, 테이블, 레코드, 필드 등이 있다.      단위가 커지면 Locking Overhead는 감소하지만 공유성이 낮아진다.      단위가 작아지면 Locking Overhead는 증가하지만 공유성은 높아진다.        종류: 공유 잠금, 배타 잠금, 의도 잠금, 의도 공유 잠금, 배타 의도 잠금, 공유 의도 독점 잠금  2단계 잠금 규약(Two-Phase Lock Protocol)          각 트랜잭션의 잠금 요청과 해제 요청을 2단계로 실시한다.      직렬성을 보장하는 대표적인 잠금 규약이다.      확장 단계: 새로운 Lock은 수행할 수 있지만, Unlock은 수행할 수 없다.      축소 단계: 새로운 Unlick은 수행할 수 있지만, Lock은 수행할 수 없다.      직렬성을 보장하지만, 교착상태를 예방할 수 없다.    2. 타임 스탬프 순서(Time Stamp Ordering)        직렬성 순서를 결정하기 위해 트랜잭션 간의 처리 순서를 선택하는 기법 중 가장 보편적인 방법이다.  트랜잭션과 트랜잭션이 읽거나 갱신한 데이터에 대해 트랜잭션이 실행을 시작하기 전에 시간표(Time Stamp)를 만들어 정해진 시간에 따라 작업을 수행하는 기법이다.  교착상태가 발생하지 않는다.          최적 병행 수행(검증 기법, 확인 기법, 낙관적 기법)        병행수행하고자 하는 트랜잭션의 대부분이 읽기 전용(Read only) 트랜잭션일 경우, 트랜잭션 간의 충돌방생률이 매우 낮으므로 병행제어 기법을 사용하지 않아도 시스템의 일관성을 유지할 수 있다는 점을 이용하는 기법이다.          다중 버전 기법        타임 스탬프의 개념을 이용하는 기법으로, 다중 버전 타임 스탬프 기법이라고도 한다.  타임 스탬프 기법은 트랜잭션 및 데이터들의 이용 시간을 시간표로 관리하지만, 다중 버전 기법은 갱신될 때마다의 버전을 만들어 관리한다.    회복(Recovery)     데이터베이스 운영 도중 예기치 못한 장애(Failure)가 발생한 경우, 데이터베이스를 장애 발생 이전의 일관된 상태(Consistent State)로 복원시키는 것이다.  데이터베이스 관리 시스템에 회복 기능이 없을 경우, 데이터베이스에 저장된 내용을 신뢰할 수 없으므로 핵심적인 역할을 담당하는 회복 관리기(Recovery Manager)가 필요하다.    장애(Failure) 유형     실행 장애(Action Failure): 사용자의 실수나 무결성 규칙 위반 등 질의 실행이 실패한 경우.  트랜잭션 장애(Transaction Failure): 내부적인 오류나 Deadlock과 같은 오류로 정상적으로 트랜잭션을 실행할 수 없는 경우.  시스템 장애(System Failure): 전원, 하드웨어, 소프트웨어 등의 고장으로 모든 트랜잭션을 사용할 수 없는 경우.  미디어 장애(Media Failure): 저장장치의 손상이나 오류로 데이터베이스의 일부 또는 전체가 물리적으로 손상되는 경우.    회복 관리기(Recovery Manager)     Log, Memory Dump 등을 이용하여 회복을 수행하는 DBMS의 핵심 구성요소이다.  트랜잭션이 성공적으로 완료되지 않았을 때, Log를 이용하여 트랜잭션이 데이터베이스의 모든 변화를 취소(Undo)하여 회복한다.  트랜잭션이 성공적으로 완료되었으나 저장장치에 반영되지 않았을 때, Log를 이용하여 재작업(Redo)를 수행한다.    회복 기법     연기 갱신(Differed Update)          트랜잭션이 성공적으로 종료될 때까지 데이터베이스에 대한 실질적인 갱신을 연기한다.      실행되는 동안 변경된 내용은 Log에 보관하며 부분완료 시점에 Log에 저장된 내용을 데이터베이스에 반영한다.      내용을 Log에 저장하고 데이터베이스에 적용을 하지 않기 때문에 장애가 발생하면 Redo 작업만을 수행하면 된다.        즉각 갱신(Immediate Update)          트랜잭션이 데이터를 변경하면 트랜잭션이 부분 완료가 되기 전이라도 데이터베이스에 바로 반영한다.      장애를 대비하여 모든 변경 내용을 Log에 저장한다.      Undo, Redo 모두 수행한다.        그림자 페이지(Shadow Paging)          갱신 이전의 데이터베이스를 페이지단위로 구성하여 복사해놓고, 실제 페이지를 대상으로 트랜잭션에 대한 변경 작업을 반영한다.      장애가 발생하여 Rollback을 할 때, 해당 페이지만 복구한다.      Log와 Undo, Redo 모두 수행할 필요가 없다.        검사점(Check Point)          Undo, Redo를 수행할 때 Log 전체를 조사해야하는 것을 피하기 위한 기법이다.      트랜잭션 실행 중 주기적으로 변경 내용과 검사점을 같이 Log에 저장한다.      장애가 발생할 때, 전체 Log를 조회하지 않고 가장 최근 검사점을 기준으로 회복 작업을 수행한다.        미디어 회복(Media Recovery)          데이터베이스의 내용을 주기적으로 안전한 저장소에 덤프한다.      장애가 발생하면 가장 최근의 덤프를 디스크에 적재하고, Log를 조회하여 최근의 트랜잭션에 대하여 Redo를 수행한다.      고급 데이터베이스 분산 데이터베이스(Distributed Database)   논리적으로 같은 시스템에 속하지만, 물리적으로 분산되어있는 데이터베이스    분산 데이터베이스 시스템 구성요소     분산 처리기: 지리적으로 분산되어있는 컴퓨터 시스템, 자체 처리 능력을 가진다.  분산 데이터베이스: 지리적으로 분산되어있는 데이터베이스  통신 네트워크: 분산 처리기들을 통신망으로 연결해 하나의 시스템처럼 작동할 수 있는 네트워크    목표     위치 투명성(Location Transparency): 접근하려는 데이터베이스의 실제 위치를 알 필요는 없다.  중복 투명성(Replication Transparency): 동일한 데이터가 여러 곳에 중복되어도 하나의 데이터만 존재하는 것처럼 사용할 수 있다.  병행 투명성(Concurrency Transparency): 다수의 트랜잭션들이 동시에 수행되어도 서로 영향을 주지 않는다.  장애 투명성(Failure Transparency): 각종 장애에도 불구하고 트랜잭션은 정확히 수행된다.    멀티미디어 데이터베이스(Multimedia Database)     텍스트, 그래픽, 정지화상, 동영상, 음성 등이 복합적으로 구성된 데이터베이스    주기억장치 데이터베이스(Main Memory Database)     데이터베이스 전체를 주기억장치에 저장한 후, 데이터베이스 연산을 수행하는 시스템  디스크 I/O가 발생하지 않는다.    데이터 웨어하우스(Data Warehouse)     다량의 데이터를 효과적으로 분석하여 정보화하고, 이를 계층의 사용자가 효율적으로 사용하도록 하는 데이터베이스  다양한 원본 데이터베이스로부터 정제되어 추출된 데이터만을 저장하고 필요한 인덱스를 생성한다.  빠르고 정확한 의사결정을 도와준다.    데이터 마트(Data Mart)     전사적으로 구축된 데이터 웨어하우스로부터, 특정 주제나 부서 중심으로 구성된 단일 주제의 데이터 웨어하우스    데이터 마이닝(Data Mining)     데이터 웨어하우스에 저장된 데이터 집합에서 사용자의 요구에 따라 유용하고 가능성 있는 정보를 발견하기 위한 기법    기법 종류     연관, 연속, 분류, 클러스터링, 특성화, 패턴 분석, 경향 분석 등    OLAP(Online Analytical Processing)     다차원으로 이루어진 데이터로부터, 통계적인 요약 정보를 분석하여 의사결정에 활용하는 방식  데이터 웨어하우스, 데이터 마트 같은 시스템과 상호 연관되는 시스템  데이터 웨어하우스의 데이터를 전략적인 정보로 변환시키는 역할  중간 매개체 없이 이용자들이 직접 컴퓨터를 이용해 데이터에 접근하는데 있어서 필수적인 시스템    OLAP 연산     Roll-up: 더 요약된 정보보기  Drill-down: 더 구체적인 정보보기  Pivoting: 보고서의 행/열/페이지 차원을 바꾸어 보는 기능  Slicing: 다차원 데이터 항목들을 다양한 각도에서 조회하고 자유롭게 비교하는 기능  Dicing: Slicing을 더 세분화하는 기능    OLAP 종류     ROLAP(Relational-OLAP): 관계형 데이터베이스와 관계형 질의어를 사용하여 다차원 데이터를 저장하고 분석한다.  MOLAP(Multi-dimension OLAP)          다차원 데이터를 저장하기 위해 특수한 구조의 다차원 데이터베이스를 사용한다.      검색 속도를 위해 큐브 캐시(Cube Cache)라고 하는 주기억장치 속에 데이터 큐브를 저장한다.      데이터 큐브(Data Cube): 특정 목적의 OLAP에서 사용하기 위한 큐브형태의 다차원 논리적 구조        HOLAP(Hybrid OLAP)          ROLAP와 MOLAP의 특성을 모두 가지고 있다.      빠른 검색을 필요할 때는 요약을 메모리에 저장하고 다른 요약들은 관계형 데이터베이스에 저장한다.        OLTP(Online Transaction Processing)               온라인 업무 처리 형태의 하나로 네트워크 상에서 다수의 유저가 데이터베이스의 데이터를 갱신, 검색하는 등의 트랜잭션을 처리하는 방식이다.  OLTP 시스템은 일반적으로 빠른 응답 시간을 요구하며, 개개의 레코드를 효율적으로 조회하고 수정할 수 있도록 정규화 되어 있다.    OLTP와 OLAP 비교     |        구분        \t|                OLTP                \t|                OALP                \t||:——————:\t|:———————————-:\t|:———————————-:\t||    데이터의 구조   \t|    복잡(운영시스템 계산에 적합)    \t|       단순(사업 분석에 적합)       \t||    데이터의 갱신   \t|             순간적/동적            \t|             주기적/정적            \t||      응답 시간     \t|         2,3초 ~ 몇 초 이내         \t|            수 초 ~ 몇 분           \t||    데이터의 범위   \t|          과거 30일 ~ 90일          \t|           과거 5년 ~ 10년          \t||     데이터 성격    \t| 정규/핵심 업무 데이터, 변경 어려움 \t| 비정규/일기 전용 데이터, 변경 용이 \t||    데이터의 크기   \t|            수 Giga Byte            \t|            수 Tera Byte            \t||    데이터의 내용   \t|             상세 데이터            \t|    기록 보관된 요약/계산 데이터    \t||     데이터 특성    \t|      트랜잭션 중심, 중복 배제      \t|    주제(subject) 중심, 중복 허용   \t|| 데이터 액세스 빈도 \t|                높음                \t|           보통 혹은 낮음           \t||   데이터의 사용법  \t|      고도로 구조화된 연속 처리     \t|     고도로 비구조화된 분석 처리    \t||     쿼리의 성격    \t|          예언 가능, 주기적         \t|       예측하기 어려움, 특수함      \t|     ODBC(Open Database Connectivity)     프로그램과 데이터베이스의 종류에 관계업이 자유롭게 사용할 수 있도록 MS에서 만든 API  구조상 데이터베이스 바로 위에 ODBC가 위치한다.    구조     Application: ODBC API를 이용해 데이터베이스에 접근한다.  Driver Manager: 애플리케이션과 ODBC Driver 간의 통신을 관리하는 라이브러리  DSN(Domain Service Name): 서버에 연결할 때 필요한 드라이버와 데이터베이스 정보를 저장한다.  ODBC Driver: ODBC API가 지원하는 함수를 구현하는 라이브러리  데이터베이스: ODBC Driver에서 요청한 SQL에 대한 결과를 반환한다.","categories": ["Database"],
        "tags": ["개념 정리"],
        "url": "https://codemcd.github.io/pages/CODEMCD/database/Database-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC/",
        "teaser":null}]
