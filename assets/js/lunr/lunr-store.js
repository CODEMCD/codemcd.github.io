var store = [{
        "title": "[ALGOSPOT]DRAGON",
        "excerpt":"Dragon 문제 링크   https://algospot.com/judge/problem/read/DRAGON코드 분석 k번째 답을 계산하는 동적 계획법   더 간단한 문제 풀기          드래곤 커브 문자열의 일부를 계산하는 문제 대신 문자열 중 주어진 위치의 한 글자만을 계산하는 문제로 바꾼다.      이 문제를 빠르게 풀 수 있다면 l번 반복만 한다면 문제를 해결할 수 있다.      결과적으로, n세대 드래곤 커브의 p번째 글자를 찾는 것으로 변경한다.        p번째 글자를 찾는 함수          먼저 전체 드래곤 커브 문자열을 생성하는 알고리즘을 재귀적인 방법으로 구현한다.      curve(seed, generations) = 초기 문자열 seed를 generations세대 진화시킨 결과를 출력한다.      위 함수에서 p번째 글자만을 출력하기 위해 skip 전역변수(건너뛰어야 하는 글자 수)를 두어, 문자열 혹은 문자를 출력할 때마다 skip과 출력할 부분의 길이를 비교한다.        계산 결과 미리 계산하기(동적 계획법)          p번째 글자를 출력하는 재귀 호출 코드를 최적화하려면, 재귀 호출 때마다 몇 글자를 출력할지를 미리 알고 skip과 이 값을 비교할 수 있어야 한다.      genrations 세대 값의 크기에 상관 없이, 이전 세대의 드래곤 커브를 계속 유지하며 확장하기 때문에 skip 값의 길이 만큼의 generations 세대까지만 가면 된다.      curve(seed, generations)함수에서 seed는 ‘X+TF’ 혹은 ‘FX-Y’로 확장하기 때문에 간단히 동적 계획법 알고리즘을 만들 수 있다.                  xLength(n) = 문자열 “X”를 n세대  진화시킨 결과의 길이 반환          yLength(n) = 문자열 “Y”를 n세대  진화시킨 결과의 길이 반환          xLength(n) = xLength(n - 1) + yLength(n - 1) + 2          yLength(n) = xLength(n - 1) + yLength(n - 1) + 2          최적화: length(n) = length(n - 1) * 2 + 2                      시간 복잡도          재귀 호출 함수가 최대 n번 호출되고, 출력 길이 l의 최대 값이 50이므로, O(n * 50)이다.      결과적으로, O(n)이다.      결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cassert&gt;using namespace std;#define min(a,b) ((a) &lt; (b) ? (a) : (b))#define N 51//오버 플로 방지const int MAX = 1000000000 + 51;//length[i] = X나 Y를 i번 치환 후의 길이int length[N];//계산 결과를 미리 계산하는 동적 계획법 알고리즘void precalc() {\tlength[0] = 1;\tfor (int i = 1; i &lt; N; ++i)\t\tlength[i] = min(MAX, length[i - 1] * 2 + 2);}const string EXPAND_X = \"X+YF\";const string EXPAND_Y = \"FX-Y\";//dragonCurve를 generations 진화시킨 결과에서 skip번째 문자를 반환한다.char expand(const string &amp;dragonCurve, int generations, int skip) {\t//기저 사례\tif (generations == 0) {\t\t//assert(skip &lt; (int)dragonCurve.size());\t\treturn dragonCurve[skip];\t}\tfor (int i = 0; i &lt; (int)dragonCurve.size(); ++i) {\t\t//문자열이 확장되는 경우\t\tif (dragonCurve[i] == 'X' || dragonCurve[i] == 'Y') {\t\t\tif (skip &gt;= length[generations])\t\t\t\tskip -= length[generations];\t\t\telse if (dragonCurve[i] == 'X')\t\t\t\treturn expand(EXPAND_X, generations - 1, skip);\t\t\telse\t\t\t\treturn expand(EXPAND_Y, generations - 1, skip);\t\t}\t\t//확장되진 않지만 건너뛰어야 할 경우\t\telse if (skip &gt; 0)\t\t\t--skip;\t\t//답을 찾은 경우\t\telse\t\t\treturn dragonCurve[i];\t}\treturn '#';  //이 줄은 수행되지 않음}int main(){\tint tc; scanf(\"%d\", &amp;tc);\tprecalc();\twhile (tc--) {\t\tint n, p, l; scanf(\"%d %d %d\", &amp;n, &amp;p, &amp;l);\t\tstring seed = \"FX\";\t\tfor (int skip = p - 1; skip &lt; p + l - 1; ++skip)\t\t\tprintf(\"%c\", expand(seed, n, skip));\t\tprintf(\"\\n\");\t}\treturn 0;}HOME ","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-DRAGON/",
        "teaser":null},{
        "title": "[ALGOSPOT]ARCTIC",
        "excerpt":"남극 기지 문제 링크   https://algospot.com/judge/problem/read/ARCTIC코드 분석 1. 최적화 문제 결정 문제로 바꿔 풀기   최적화 문제: optimize(P)          P에 주어진 기지들을 모두 연결하는 연락망을 구축할 때 가능한 최소 무전기 반경은 얼마인가?      기지들을 모두 연결하는 연락망의 경우의 수는 매우 많으며, 이 중 무전기의 반경 d가 최소화되는 답을 찾고 있으므로 이 문제는 최적화 문제이다.        결정 문제: decision(P, d)          모든 기지를 하나로 연결하되, 가장 먼 두 가지 간의 거리가 d 이하인 연락망이 있는가?      이 질문은 “x 또는 그보다 좋은 답이 있는가?”의 형태를 유지하고 있다.      이 질문의 구현은 서로 거리가 d 이하인 기지들이 하나로 연결될 수 있는지를 확인한다.                  너비 우선 탐색 알고리즘          두 기지 사이의 거리를 이용하는 암시적 그래프를 탐색한다.                      시간 복잡도          너비 우선 탐색의 시간 복잡도: O(V + E)      거리 계산: O(n^2)      결과적으로, O(n^2)이다.      2. 다른 해법   크루스칼의 최소 스패닝 알고리즘  플로이드의 모든 쌍 최단 거리 알고리즘결과 코드   최적화 문제 결정문제로 바꿔 풀기```#define _CRT_SECURE_NO_WARNINGS#include #include #include #include #include #include #include using namespace std;#define abs(a) ((a) &gt; 0 ? (a) : (-1 * a))#define N 101vector&lt;pair&lt;double, double&gt;&gt; bsv;double dist[N][N];int n; //두 기지 사이 거리 계산double calcDist(int b1, int b2) {\tdouble dy = (bsv[b1].first - bsv[b2].first) *\t\t(bsv[b1].first - bsv[b2].first);\tdouble dx = (bsv[b1].second - bsv[b2].second) *\t\t(bsv[b1].second - bsv[b2].second);\treturn sqrt(dy + dx);} //거리 d인하인 기지들만을 연결했을 때 모든 기지가 연결되는지 여부를 반환한다.bool decision(double d) {\tvector visited(n, false);\tvisited[0] = true;\tqueue q;\tq.push(0);\tint seen = 0;\twhile (!q.empty()) {\t\tint here = q.front();\t\tq.pop();\t\t++seen;\t\tfor(int there = 0; there &lt; n; ++there)\t\t\tif (!visited[there] &amp;&amp; dist[here][there] &lt;= d) {\t\t\t\tvisited[there] = true;\t\t\t\tq.push(there);\t\t\t}\t}\treturn seen == n;} //모든 기지를 연결할 수 있는 최소 d를 반환한다.double optimize() {\tdouble lo = 0, hi = 1416.00;\tfor (int it = 0; it &lt; 100; ++it) {\t\tdouble mid = (lo + hi) / 2;\t\t//mid가 가능하다면, 더 좋은(작은) 답을 찾는다.\t\tif (decision(mid))\t\t\thi = mid;\t\t//mid가 불가능하다면, 더 나쁜(큰) 답을 찾는다.\t\telse\t\t\tlo = mid;\t}\treturn hi;} int main(){\tint tc; scanf(“%d”, &amp;tc);\twhile(tc–) {\t\tbsv.clear();\t\tmemset(dist, 0, sizeof(dist)); \tscanf(\"%d\", &amp;n);\tfor (int i = 0; i &lt; n; i++) {\t\tdouble y, x; scanf(\"%lf %lf\", &amp;y, &amp;x);\t\tbsv.push_back({ y, x });\t}\tfor (int i = 0; i &lt; n; i++)\t\tfor (int j = 0; j &lt; n; j++)\t\t\tdist[i][j] = calcDist(i, j);\tprintf(\"%.2lf\\n\", optimize());}return 0; } ```HOME ","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-ARCTIC/",
        "teaser":null},{
        "title": "[ALGOSPOT]ASYMTILING",
        "excerpt":"비대칭 타일링 문제 링크   https://algospot.com/judge/problem/read/ASYMTILING](https://algospot.com/judge/problem/read/ASYMTILING)코드 분석 전체 타일링 경우의 수 - 대칭 타일링 경우의 수   전체 타일링 경우의 수는 쉽게 구할 수 있다.  비대칭 타일링 경우의 수를 찾는 것 보다 대칭 타일링 경우의 수를 찾는 것이 더욱 간단하다.   n이 홀수인 경우, 위 그림의 (a)에 해당한다.  n이 짝수인 경우, 위 그림의 (b)와 (c)에 해당한다.  회색부분은 양쪽이 대칭이기 때문에 한 부분의 경우의 수만 빼주면 된다.  두 값을 빼줄 때, mod계산에 주의하자!  시간복잡도: 전체 타일링의 경우의 수 O(n) + 대칭 타일링 경우의 수 O(n) = 총 O(n) 이다.비대칭 타일링 경우의 수   총 4가지 패턴의 비대칭 방법이 있다.   (a), (b): 가운데 남은 회색 부분을 덮은 방법을 재귀 호출로 찾는다. 물론 이 방법은 대칭이 아니어야 한다.  (c), (d): 가운데 남은 회색 부분을 덮는 방법을 찾으며, 이는 대칭이어도 상관없다.  시간복잡도: O(n)  답이 제대로 나오지 않음 - 보류…결과 코드   전체 타일링 경우의 수 - 대칭 타일링 경우의 수```#define _CRT_SECURE_NO_WARNINGS#include #include #include using namespace std;#define N 101#define M 1000000007int tile[N]; int asymmetric(int width){\tif (width % 2 == 1)  //(a)\t\treturn (tile[width] - tile[width / 2] + M) % M;\tint ret = tile[width];\tret = (ret - tile[width / 2 - 1] + M) % M;  //(b)\tret = (ret - tile[width / 2] + M) % M;      //(c)\treturn ret;} int main(void){\t//전체 타일링 경우의 수 구하기\ttile[1] = 1; tile[2] = 2;\tfor (int i = 3; i &lt; N; i++)\t\ttile[i] = (tile[i - 1] % M + tile[i - 2] % M) % M; int tc;scanf(\"%d\", &amp;tc);while (tc--) {\tint n;\tscanf(\"%d\", &amp;n);\tif (n == 1 || n == 2)\t\tprintf(\"0\\n\");\telse\t\tprintf(\"%d\\n\", asymmetric(n));}return 0; } ```HOME ","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-ASYMTILNG/",
        "teaser":null},{
        "title": "[ALGOSPOT]BOARDCOVER",
        "excerpt":"BOARDCOVER 문제 링크   https://algospot.com/judge/problem/read/BOARDCOVER내 코드 분석 논리 분석   한 칸에 8개의 L자 모양을 만들 수 있다.  재귀 함수를 이용하여, 전체 경우의 수를 계산한다.  하지만, 아직 재귀 함수가 익숙하지 않아 완성하지 못하였다.  재귀 함수 공부를 위해 다른 방법은 생각하지 않았다.해답 논리 분석   재귀 호출의 각 단계마다 아직 흰 칸중에서 가장 윗 줄, 가장 왼쪽 칸부터 덮도록 규칙을 정한다.  위 규칙을 적용하면, 위에서 정한 칸 이전은 모두 채워졌다는 것을 알 수 있으므로 내가 생각했던 8가지 모양이 아니라 4가지 모양이 나온다. (아래 그림 참고) 코드   출처 : 알고리즘 문제해결전략 책~~~#define _CRT_SECURE_NO_WARNINGS#include #include #include using namespace std; //주어진 칸을 덮을 수 있는 네 가지 방법//블록을 구성하는 세 칸의 상대적 위치 (dy, dx)의 목록(위 그림 참고)const int coverType[4][3][2] = {\t{ { 0, 0 },{ 1, 0 },{ 0, 1 } },\t{ { 0, 0 },{ 0, 1 },{ 1, 1 } },\t{ { 0, 0 },{ 1, 0 },{ 1, 1 } },\t{ { 0, 0 },{ 1, 0 },{ 1, -1 } }};//board의 (y, x)를 type번 방법으로 덮거나, 덮었던 블록을 없앤다.//delta = 1이면 덮고, -1이면 덮었던 블록을 없앤다.//만약 블록이 제대로 덮이지 않은 경우(게임판 밖으로 나가거나, 겹쳐지거나, 검은 칸일 때) false를 반환한다.bool set(vector&lt;vector&gt;&amp;board, int y, int x, int type, int delta){\tbool ok = true;\tfor (int i = 0; i &lt; 3; i++) {\t\tconst int ny = y + coverType[type][i][0];\t\tconst int nx = x + coverType[type][i][1];\t\tif (ny &lt; 0 || ny &gt;= (int)board.size() || nx &lt; 0 || nx &gt;= (int)board[0].size())\t\t\tok = false;\t\telse if ((board[ny][nx] += delta) &gt; 1)\t\t\tok = false;\t}\treturn ok;} //board의 모든 빈 칸을 덮을 수 있는 방법의 수를 반환한다.//board[i][j] = 1 이미 덮인 칸 혹은 검은 칸//board[i][j] = 0 아직 덮이지 않은 칸int cover(vector&lt;vector&gt;&amp;board){\t//아직 채우지 못한 칸 중 가장 윗줄 왼쪽에 있는 칸을 찾는다.\tint y = -1, x = -1;  //flag 기능을 추가하기 위해 -1로 초기화\tfor (int i = 0; i &lt; (int)board.size(); i++) {\t\tfor (int j = 0; j &lt; (int)board[i].size(); j++) {\t\t\tif (board[i][j] == 0) {\t\t\t\ty = i;\t\t\t\tx = j;\t\t\t\tbreak;\t\t\t}\t\t}\t\tif (y != -1) break;\t}\t//기저 사례: 모든 칸을 채웠으면 1을 반환한다.\tif (y == -1) return 1;\tint ret = 0;\tfor (int type = 0; type &lt; 4; type++) {\t\t//만약 board[y][x]를 type 형태로 덮을 수 있으면 재귀 호출한다.\t\tif (set(board, y, x, type, 1))\t\t\tret += cover(board);\t\t//덮었던 블록을 치운다.\t\tset(board, y, x, type, -1);\t}\treturn ret;} int main(void){\tint tc;\tscanf(“%d”, &amp;tc);\twhile (tc–) {\t\tvector&lt;vector&gt; board;\t\tvector v;\t\tchar row[21];\t\tint h, w;\t\tscanf(\"%d %d\", &amp;h, &amp;w);\t\tfor (int i = 0; i &lt; h; i++) {\t\t\tscanf(\"%s\", row);\t\t\tfor (int j = 0; j &lt; w; j++) {\t\t\t\tif (row[j] == '#')\t\t\t\t\tv.push_back(1);\t\t\t\telse\t\t\t\t\tv.push_back(0);\t\t\t}\t\t\tboard.push_back(v);\t\t\tv.clear();\t\t}\t\t/*for (int i = 0; i &lt; (int)board.size(); i++) {\t\t\tfor (int j = 0; j &lt; (int)board[i].size(); j++) {\t\t\t\tprintf(\"%d \", board[i][j]);\t\t\t}\t\t\tprintf(\"\\n\");\t\t}*/ \tprintf(\"%d\\n\", cover(board));}return 0; } ~~~ ### 결과 및 코드 분석 - 수행 시간: 0ms - 최대 시간 복잡도: 블록을 하나 놓을 때마다 4가지 선택지가 있다. 최대 16개의 블록을 놓기 때문에 가능한 최대 연산 수는 4^16(2^32)으로 시간내에 불가능하게 느껴진다. 하지만 6칸이 있다고 가정하면, 4^2으로 16가지 방법이 있어야 하는데 실제로 계산하면 2가지 방법밖에 없다. 이렇게 프로그램을 작성하고 직접 여러 예제를 넣어 이론과 다른 실제 시간복잡도를 계산할 수 있어야 한다.알아둘 점 1) 재귀를 구현하는 논리 흐름2) 이중 Vector 함수   사용법 (위 main함수 참고)    vector&lt;vector&lt;int&gt;&gt; board;vector&lt;int&gt; v;char row[21];int h, w;scanf(\"%d %d\", &amp;h, &amp;w);for (int i = 0; i &lt; h; i++) {      scanf(\"%s\", row);      for (int j = 0; j &lt; w; j++) {          if (row[j] == '#')              v.push_back(1);          else              v.push_back(0);      }      board.push_back(v);      v.clear();}        장점          크기를 지정하지 않고 입력을 줄 수 있다.      STL이기 때문에 효율성을 보장받을 수 있다.      HOME ","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-BOARDCOVER/",
        "teaser":null},{
        "title": "[ALGOSPOT]BOGGLE",
        "excerpt":"BOGGLE 문제 링크   https://algospot.com/judge/problem/read/BOGGLE내 코드 분석 논리 분석   char 형인 알파벳을 아스키 코드값을 이용하여 int형으로 사용한다.  check 배열을 선언하여 5 x 5 배열입력에서 사용된 알파벳을 저장하여 문자 입력 시 5 x 5 배열에 없는 알파벳이 있을 경우 바로 ‘NO’를 출력한다.(시간복잡도를 줄이기 위함)  BFS를 활용하여 문자가 5 x 5배열에서 만들어질 수 있는지 판단한다.  check_cnt 배열은 BFS 수행과정에서 해당 문자의 다음 알파벳을 비교하기 위해 수행과정에서의 문자 길이를 갱신한다.구현 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;#define N 26bool check[N];  // 5 x 5 맵에 입력된 알파벳 종류 확인int check_cnt[5][5];  // BFS에서 다음 문자 알파벳을 판단하기 위한 2차원 배열int map[5][5];  // 5 x 5 알파벳을 입력할 2차원 배열int word[11];  // 문자를 저장할 배열int mx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };int my[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };void init(void){\tfor (int i = 0; i &lt; 5; ++i)\t\tfor (int j = 0; j &lt; 5; ++j)\t\t\tmap[i][j] = 0;\tfor (int i = 0; i &lt; N; ++i)\t\tcheck[i] = false;\tfor (int i = 0; i &lt; 11; ++i)\t\tword[i] = -1;\tfor (int i = 0; i &lt; 5; ++i)\t\tfor (int j = 0; j &lt; 5; ++j)\t\t\tcheck_cnt[i][j] = 0;}void init_cnt(void){\tfor (int i = 0; i &lt; 5; ++i)\t\tfor (int j = 0; j &lt; 5; ++j)\t\t\tcheck_cnt[i][j] = 0;}int main(void){\tint tc;\tcin &gt;&gt; tc;\t//scanf(\"%d\", &amp;tc);\t//while (getchar() != '\\n');  //입력 버퍼에서 엔터 지우기\twhile (tc--) {\t\tinit();  //다음 테스트 케이스를 위한 초기화\t\tfor (int i = 0; i &lt; 5; ++i) {  // 5 x 5 알파벳 배열 입력\t\t\tfor (int j = 0; j &lt; 5; ++j) {\t\t\t\tchar alph;\t\t\t\t//scanf(\"%c\", &amp;alph);\t\t\t\tcin &gt;&gt; alph;\t\t\t\tmap[i][j] = alph - 'A';  //char -&gt; int 로 사용하기 위함\t\t\t\tif (!check[alph - 'A'])  \t\t\t\t\tcheck[alph - 'A'] = true;\t\t\t}\t\t\t//while (getchar() != '\\n');\t\t}\t\tint n;\t\tcin &gt;&gt; n;\t\t//scanf(\"%d\", &amp;n);\t\t//while (getchar() != '\\n');\t\tint str_len;  //단어 길이\t\tbool flag = false;  // 단어를 맵에서 찾을 수 있으면 TRUE, 못 찾으면 FALSE\t\tpair&lt;int, int&gt; p;  //큐에 2차원 배열 인덱스를 저장하기 위한 pair\t\tqueue&lt;pair&lt;int, int&gt;&gt; q;  //BFS를 위한 큐\t\tfor (int i = 0; i &lt; n; ++i) {\t\t\tfor (int ii = 0; ii &lt; 11; ++ii)  //단어 입력 초기화\t\t\t\tword[ii] = -1;\t\t\tflag = false;\t\t\tchar inputW[11];\t\t\tcin &gt;&gt; inputW;\t\t\t//scanf(\"%s\", inputW);\t\t\t//while (getchar() != '\\n');\t\t\tstr_len = strlen(inputW);\t\t\tfor (int j = 0; j &lt; str_len; ++j)\t\t\t\tword[j] = inputW[j] - 'A';\t\t\tfor (int j = 0; j &lt; str_len; ++j) {  //map에 알파벳이 없을 때 바로 NO출력하고 다음 단어\t\t\t\tif (!check[word[j]]) {\t\t\t\t\tfor (int l = 0; l &lt; str_len; ++l)\t\t\t\t\t\tprintf(\"%c\", word[l] + 'A');\t\t\t\t\tprintf(\" NO\\n\");\t\t\t\t\tflag = true;\t\t\t\t}\t\t\t\tif (flag) break;\t\t\t}\t\t\tif (str_len == 1 &amp;&amp; check[word[0]]) {  //문자 길이가 1일 때 처리\t\t\t\tfor (int ll = 0; ll &lt; str_len; ++ll)\t\t\t\t\tprintf(\"%c\", word[ll] + 'A');\t\t\t\tprintf(\" YES\\n\");\t\t\t\tflag = true;\t\t\t}\t\t\tif (flag) continue;  //문자 판단이 끝났으므로 다음으로 넘어감\t\t\tflag = false;\t\t\tfor (int j = 0; j &lt; 5; ++j) {\t\t\t\tfor (int k = 0; k &lt; 5; ++k) {\t\t\t\t\tif (map[j][k] == word[check_cnt[j][k]]) {  // 5 x 5 배열중 문자의 첫 알파벳 위치\t\t\t\t\t\tp = make_pair(j, k);\t\t\t\t\t\tq.push(p);  //큐에 삽입\t\t\t\t\t\twhile (!q.empty()) {\t\t\t\t\t\t\tint nowx = q.front().second;\t\t\t\t\t\t\tint nowy = q.front().first;\t\t\t\t\t\t\tq.pop();\t\t\t\t\t\t\tfor (int l = 0; l &lt; 8; ++l) {  // 8방향으로 모두 체크\t\t\t\t\t\t\t\tint nextx = nowx + mx[l];\t\t\t\t\t\t\t\tint nexty = nowy + my[l];\t\t\t\t\t\t\t\tif (!flag &amp;&amp; nextx &gt;= 0 &amp;&amp; nextx &lt; 5 &amp;&amp; nexty &gt;= 0 &amp;&amp; nexty &lt; 5) {  // 5 x 5 배열 밖으로 나갔는지 체크\t\t\t\t\t\t\t\t\tif (word[check_cnt[nowy][nowx] + 1] != -1 &amp;&amp; map[nexty][nextx] == word[check_cnt[nowy][nowx] + 1]) {  // 다음 알파벳과 일치하면\t\t\t\t\t\t\t\t\t\tcheck_cnt[nexty][nextx] = check_cnt[nowy][nowx] + 1;  // 현재 문자열 길이 갱신\t\t\t\t\t\t\t\t\t\tif ((check_cnt[nexty][nextx] + 1) == str_len) {  // 현재 체크중인 문자열 길이와 최종 문자열 길이가 일치하면 YES출력\t\t\t\t\t\t\t\t\t\t\tflag = true;\t\t\t\t\t\t\t\t\t\t\tfor (int ll = 0; ll &lt; str_len; ++ll)\t\t\t\t\t\t\t\t\t\t\t\tprintf(\"%c\", word[ll] + 'A');\t\t\t\t\t\t\t\t\t\t\tprintf(\" YES\\n\");\t\t\t\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\tp = make_pair(nexty, nextx);\t\t\t\t\t\t\t\t\t\tq.push(p);\t\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t}\t\t\t\t\t\t\tif (flag) break;\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t\tinit_cnt();\t\t\t\t\twhile (!q.empty()) q.pop();  //정답을 제출하고 바로 반복문을 빠져나갔기 때문에 큐에 남은 인덱스가 있을 수 있기 때문\t\t\t\t\tif (flag) break;\t\t\t\t}\t\t\t\tif (flag) break;\t\t\t}\t\t\tif (!flag) {  //못찾으면 NO 출력\t\t\t\tfor (int l = 0; l &lt; str_len; ++l)\t\t\t\t\tprintf(\"%c\", word[l] + 'A');\t\t\t\tprintf(\" NO\\n\");\t\t\t}\t\t}\t}\treturn 0;}결과   수행 시간 : 4ms  오답  디버깅과 직접 그리면서 코드를 분석하였지만 틀린 부분을 찾을 수 없었다.  위의 참고 예제를 통과하면 왠만한 예제는 통과하였다고 생각한다.  다른 의견          재귀를 활용하여 구현하면 시간 초과가 난다고 한다.      다이나믹 프로그래밍으로 구현하는 것이 가장 효율적이라고 생각한다.      알아둘 점 1) 입력 버퍼 지우기 while (getchar() != '\\n');  문자열을 입력할 때 입력버퍼에 엔터키(\\n)가 남아있는 현상으로 다음 문자열을 입력할 때 제대로된 입력을 받을 수 없었다.  입력함수 바로 밑에 위의 코드를 추가하여 해결하였다.  cin 을 사용하여 해결할 수도 있다.2) BFS에서 경로 순서 확인하기   BFS는 큐를 활용하기 때문에 경로를 찾아가는 것이 순차적으로 하기 않는다.  위의 이유로 똑같은 크기의 2차원 배열을 선언하여 이전의 값에 +1을 하며 해당 배열에 저장한다.  위의 코드에서는 check_cnt 배열이 그 역할을 한다.해답 코드   출처 : http://b.mystika.me/26~~~#define _CRT_SECURE_NO_WARNINGS#include #include #include #include using namespace std; char map[5][5];char word[11];int dp[5][5][10];int mx[8] = { 0,1,1,1,0,-1,-1,-1 };int my[8] = { -1,-1,0,1,1,1,0,-1 }; int solve(int y, int x, int idx){\tint &amp;ret = dp[y][x][idx];\t//초기화 오류 처리\tif (ret != -1) return ret;\tfor (int i = 0; i &lt; 8; i++) {\t\tint nexty = y + my[i];\t\tint nextx = x + mx[i]; \tif (nexty &gt;= 0 &amp;&amp; nexty &lt; 5 &amp;&amp; nextx &gt;= 0 &amp;&amp; nextx &lt; 5) {\t\t//단어와 일치되는 알파벳을 찾았을 때,\t\tif (map[nexty][nextx] == word[idx]) {\t\t\t//단어의 다음 문자가 NULL이면, 모두 찾았기 때문에 TRUE를 반환\t\t\tif (word[idx + 1] == '\\0') return ret = 1;\t\t\t//아직 단어를 찾을 것이 남아있다면 다시 재귀함수 호출\t\t\tret = solve(nexty, nextx, idx + 1);  \t\t\t//문자열을 찾았다면 남은 재귀함수에서 모두 1(TRUE)값을 반환하여 마지막 결과에 1을 반환하도록 한다.\t\t\tif (ret) return ret;\t\t}\t}}//문자를 모두 매칭할 수 없으므로 FALSE를 반환return false; }int find(){\tfor (int i = 0; i &lt; 5; i++) {\t\tfor (int j = 0; j &lt; 5; j++) {\t\t\tint &amp;ret = dp[i][j][0];\t\t\t//초기화가 안됬다면 바로 리턴(오류 처리)\t\t\tif (ret != -1) return ret;\t\t\t//첫 단어를 map에서 찾았다면\t\t\tif (map[i][j] == word[0]) {\t\t\t\tret = solve(i, j, 1);\t\t\t\tif (ret) return ret;\t\t\t}\t\t}\t}\treturn false;} int main(void){\tint tc;\tscanf(“%d”, &amp;tc);\twhile (tc–) {\t\tfor (int i = 0; i &lt; 5; i++)\t\t\tscanf(“%s”, map[i]);\t\tint n;\t\tscanf(“%d”, &amp;n);\t\tfor (int i = 0; i &lt; n; i++) {\t\t\tmemset(dp, -1, sizeof(dp));\t\t\tscanf(“%s”, word);\t\t\tprintf(“%s %s\\n”, word, find() ? “YES” : “NO”);\t\t}\t}\treturn 0;}~~~   출처를 참고하여 다시 구현해 본 코드이다.  DP를 사용하였으며, dp[y][x][idx]는 해당 맵의 좌표(map[y][x])에서 현재 단어(word[idx]) 이후를 찾을 수 있는지를 판단한다.알아둘 점 1) 재귀함수를 이용하여 DP를 구현하는 방식2) 삼항 연산자를 이용하여 간단히 출력하는 방식   특히, 삼항 연산자를 사용하기 위해 함수를 사용한 부분을 참고하자.HOME ","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-BOGGLE/",
        "teaser":null},{
        "title": "[ALGOSPOT]DARPA",
        "excerpt":"DARPA Grand Challenge 문제 링크   https://algospot.com/judge/problem/read/DARPA코드 분석 최적화 문제 결정 문제로 바꿔 풀기   최적화 문제          optimize(locations, cameras) = 카메라를 설치할 수 있는 위치 locations와 카메라의 수 cameras가 주어질 때, 카메라 간 최소 간격의 최대치를반환한다.        결정 문제          decision(locations, cameras, gap) = 카메라를 설치할 수 있는 위치 locations와 카메라의 수 cameras가 주어질 때, 이들을 적절히 배치해모든 카메라의 간격이 gap이상이 되도록 하는 방법이 있는가?      “카메라 간의 최소 간격이 gap인 방법이 있는가?”가 아니라 “카메라들의 간의 최소 간격이 gap이상인 방법이 있는가?” 임을 유의하자.                  이와 같이 질문해야 최적화 문제를 풀 수 있다.          “이상”이라 함은 그 범위의 값들을 모두 포함할 수 있기 때문에 답의 후보 범위를 계속 반으로 줄여서 최적화를 할 수 있다.(이분법)                    카메라들이 항상 xkm 이상 떨어져 있다고 할때, 0km위치에 카메라를 항상 설치할 수 있다.                  만약, 0km에 설치하지 않는다고 하면 이를 0km로 옮겨도 똑같은 답이 된다.          결과적으로, 탐욕법으로 이 문제를 해결할 수 있다는 사실을 떠올릴 수 있어야 한다.                      구현 함수          optimize(): 이분법을 구현하는 함수이다.      decision(): 첫 번째로 만나는 위치에 무조건 카메라를 설치한 뒤, 각 위치를 순회하며 카메라를 설치할 수 있을때마다 카메라를 설치한다. 그 후설치한 카메라의 수가 문제에서 요구한 설치 개수 이상이 되면 참을 반환한다      결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;//결정 문제: 정렬되어 있는 locations 중 cameras를 선택해 모든 카메라 간의 간격이//gap 이상이 되는 방법이 있는지를 반환한다.bool decision(const vector&lt;double&gt; &amp;location, int cameras, double gap) {\t//카메라를 설치할 수 있을 때마다 설치하는 탐욕적 알고리즘\tdouble limit = -1;\tint installed = 0;\tfor (int i = 0; i &lt; (int)location.size(); i++) {\t\tif (limit &lt;= location[i]) {\t\t\t++installed;\t\t\t//location[i] + gap 이후는 되어야 카메라를 설치할 수 있다.\t\t\tlimit = location[i] + gap;\t\t}\t}\t//결과적으로 cameras대 이상을 설치할 수 있으면 참 반환\treturn installed &gt;= cameras;}//최적화 문제: 정렬되어 있는 locations 중 cameras를 선택해 최소 간격을 최대화 한다.double optimize(const vector&lt;double&gt; &amp;location, int cameras) {\tdouble lo = 0., hi = 241.;\t//반복문 불변식: decision(lo) &amp;&amp; !decision(hi)\tfor (int it = 0; it &lt; 100; it++) {\t\tdouble mid = (lo + hi) / 2.0;\t\t//간격이 mid 이상이 되도록 할 수 있으면 답은 [mid, hi]에 있다.\t\tif (decision(location, cameras, mid))\t\t\tlo = mid;\t\t//간격이 mid 이상이 되도록 할 수 없으면 답은 [lo, mid]에 있다.\t\telse\t\t\thi = mid;\t}\treturn lo;}int main(){\tint tc; scanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tint n, m; scanf(\"%d %d\", &amp;n, &amp;m);\t\tvector&lt;double&gt; lv;\t\tfor (int i = 0; i &lt; m; i++) {\t\t\tdouble in; scanf(\"%lf\", &amp;in);\t\t\tlv.push_back(in);\t\t}\t\tprintf(\"%.2lf\\n\", optimize(lv, n));\t}\treturn 0;}HOME ","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-DARPA/",
        "teaser":null},{
        "title": "[ALGOSPOT]DICTIONARY",
        "excerpt":"고대어 사전 문제 링크   https://algospot.com/judge/problem/read/DICTIONARY코드 분석 위상 정렬 문제 1. 그래프 모델링   각 알파벳을 정점으로 표현하고, 한 알파벳이 다른 알파벳 앞에 와야 할 때 두 정점을 방향 간선으로 연결한다.          문제가 원하는 알파벳들의 순서는 위 그래프의 위상 정렬 결과가 된다.      makeGraph()함수가 이를 구현하는 모습을 볼 수 있다.2. 인접한 단어들만 검사하기        만약 세 단어 A, B, C가 순서대로 등장한다면, (A,C)는 검사하지 않고 (A,B), (B,C)만 검사해도 답을 해결할 수 있다.          예를 들어, A = impr, C = impo 라고 할때, B는 다음과 같이 3가지의 경우가 있다.                  B의 네 번째 글자가 ‘r’인 경우: (B,C)를 검사할 때 ‘r’이 ‘o’보다 앞에 온다는 사실을 알 수 있다.          B의 네 번째 글자가 ‘o’인 경우: (A,B)를 검사할 때 ‘r’이 ‘o’보다 앞에 온다는 사실을 알 수 있다.          B의 네 번째 글자가 ‘r’, ‘o’ 둘다 아닌 경우: (A,B)를 검사할 때 ‘r’이 이 글자보다 앞에 온다는 사실을 알 수 있고, (B,C)를 검사할 때 이 글자가 ‘o’보다 앞에 온다는 사실을 알 수 있다. 결과적으로 ‘r’은 ‘o’보다 앞에 온다.3. 위상 정렬 적용                      위의 규칙을 적용하여 그래프를 생성한 뒤, 해당 그래프가 사이클이 없다면 문제의 사전은 논리에 맞는 것으로 알파벳 순서를 정상적으로 만들 수 있다.구현 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;#define min(a,b) ((a) &lt; (b) ? (a) : (b))//알파벳의 각 글자에 대한 인접 행렬 표현//간선 (i, j)는 알파벳 i가 j보다 앞에 와야 함을 나타낸다.vector&lt;vector&lt;int&gt;&gt; adj;//주어진 단어들로부터 알파벳 간의 선후관계 그래프를 생성한다.void makeGraph(const vector&lt;string&gt; &amp;words) {\tadj = vector&lt;vector&lt;int&gt;&gt;(26, vector&lt;int&gt;(26, 0));\tfor (int j = 1; j &lt; words.size(); ++j) {\t\tint i = j - 1, len = min(words[i].size(), words[j].size());\t\t//word[i]가 word[j]앞에 오는 이유를 찾는다.\t\tfor (int k = 0; k &lt; len; ++k)\t\t\tif (words[i][k] != words[j][k]) {\t\t\t\tint a = words[i][k] - 'a';\t\t\t\tint b = words[j][k] - 'a';\t\t\t\tadj[a][b] = 1;\t\t\t\tbreak;\t\t\t}\t}}vector&lt;int&gt; seen, order;void dfs(int here) {\tseen[here] = 1;\tfor (int there = 0; there &lt; adj.size(); ++there)\t\tif (adj[here][there] &amp;&amp; !seen[there])\t\t\tdfs(there);\torder.push_back(here);}//adj에 주어진 그래프를 위상정렬한 결과를 반환한다.//그래프가 DAG가 아니라면 빈 벡터를 반환한다.vector&lt;int&gt; topologicalSort() {\tint n = adj.size();\tseen = vector&lt;int&gt;(n, 0);\torder.clear();\tfor (int i = 0; i &lt; n; ++i)\t\tif (!seen[i])\t\t\tdfs(i);\treverse(order.begin(), order.end());\t//만약 그래프가 DAG가 아니라면 정렬 결과에 역방향 간선이 있다.\tfor (int i = 0; i &lt; n; ++i)\t\tfor (int j = i + 1; j &lt; n; ++j)\t\t\tif (adj[order[j]][order[i]])\t\t\t\treturn vector&lt;int&gt;();\t//없는 경우라면 깊이 우선 탐색에서 얻은 순서를 반환한다.\treturn order;}int main(){\tint tc; scanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tint n; scanf(\"%d\", &amp;n);\t\tvector&lt;string&gt; sv;\t\tfor (int i = 0; i &lt; n; i++) {\t\t\tstring str; cin &gt;&gt; str;\t\t\tsv.push_back(str);\t\t}\t\tmakeGraph(sv);\t\tvector&lt;int&gt; ans;\t\tans = topologicalSort();\t\tif (!ans.size())\t\t\tprintf(\"INVALID HYPOTHESIS\");\t\telse {\t\t\tfor (int i = 0; i &lt; ans.size(); ++i)\t\t\t\tprintf(\"%c\", ans[i] + 'a');\t\t}\t\tprintf(\"\\n\");\t}\treturn 0;}HOME ","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-DICTIONARY/",
        "teaser":null},{
        "title": "[ALGOSPOT]DRUNKEN",
        "excerpt":"음주 운전 단속 문제 링크   https://algospot.com/judge/problem/read/DRUNKEN코드 분석 플로이드 최단 거리 알고리즘   플로이드 알고리즘은 아무 정점도 경유하지 않은 최단 거리에서 시작해 경유할 수 있는 정점으르 하나씩 추가해 가며 최단 거리를 갱신한다.          이 과정에서 0번부터 V-1번까지 정점들을 순서대로 추가하지만, 이 순서는 단지 편의를 위함이지 순서가 바뀐다고 해도 알고리즘의 정당성에는 어떠한 영향도 미치지 않는다.        위 속성을 이용하여, 각 정점을 단속에 걸리는 시간 별로 오름차순으로 정렬한 뒤, 순서대로 플로이드 알고리즘을 수행하면 해당 문제의 답을 찾을 수 있다.          단속 시간이 짧은 정점부터 알고리즘을 수행하면, 순서대로 한 경유점의 가중치를 포함한 최단 거리를 계산하면서 가장 가중치가 큰 경유점에서의 최단 거리 경로를 찾을 수 있다. (오름차순으로 가중치가 가장 큰 경유점이 마지막에 있기 때문)      이는 플로이드 알고리즘은 반복문을 사용하기 때문에 경유점의 가중치가 입력된 순서가 결과값에 영향을 미치기 때문이다.        C_k(u, v) = k 혹은 그보다 단속 시간이 적게 걸리는 정점들만을 경유해서 u에서 v로 가는 최단 거리  W[][]: 최소 예상 시간  E[w]: 정점 w에서 소요되는 단속 시간    W[u][v] = min(C_w(u, w) + C_w(w, v) + E[w])      구현 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define N 501const int INF = 987654321;int map[N][N];//각 정점까지 음주단속 시간을 포함한 가장 짧은 시간을 저장int W[N][N];//각 정점에서 음주 운전 단속을 할 때 걸리는 시간int delay[N];int v, e;void solve() {\t//모든 정점들을 예상 시간 별로 정렬한다.\tvector&lt;pair&lt;int, int&gt;&gt; order;\tfor (int i = 0; i &lt; v; ++i)\t\torder.push_back(make_pair(delay[i], i));\tsort(order.begin(), order.end());\t//정점을 하나도 거치지 않고 얻을 수 있는 최단 경로\tfor (int i = 0; i &lt; v; ++i)\t\tfor (int j = 0; j &lt; v; ++j)\t\t\tif (i == j)\t\t\t\tW[i][j] = 0;\t\t\telse\t\t\t\tW[i][j] = map[i][j];\tfor (int k = 0; k &lt; v; ++k) {\t\t//k번째로 예상 시간이 적게 걸리는 정점 w까지를 지나서 얻을 수 있는 최단 거리\t\tint w = order[k].second;\t\tfor(int i=0; i&lt;v; ++i)\t\t\tfor (int j = 0; j &lt; v; ++j) {\t\t\t\tmap[i][j] = min(map[i][j], map[i][w] + map[w][j]);\t\t\t\tW[i][j] = min(W[i][j], map[i][w] + delay[w] + map[w][j]);\t\t\t}\t}}int main(){\tscanf(\"%d %d\", &amp;v, &amp;e);\tfor (int i = 0; i &lt; v; ++i)\t\tscanf(\"%d\", &amp;delay[i]);\tfor (int i = 0; i &lt; e; ++i) {\t\tint a, b, c;\t\tscanf(\"%d %d %d\", &amp;a, &amp;b, &amp;c);\t\tmap[a - 1][b - 1] = c;\t\tmap[b - 1][a - 1] = c;\t}\tfor (int i = 0; i &lt; v; ++i)\t\tfor (int j = 0; j &lt; v; ++j)\t\t\tif (!map[i][j])\t\t\t\tmap[i][j] = INF;\tsolve();\tint tc; scanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tint start, end;\t\tscanf(\"%d %d\", &amp;start, &amp;end);\t\tprintf(\"%d\\n\", W[start - 1][end - 1]);\t}\treturn 0;}HOME ","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-DRUNKEN/",
        "teaser":null},{
        "title": "[ALGOSPOT]FENCE",
        "excerpt":"FENCE 문제 링크   https://algospot.com/judge/problem/read/FENCE코드 분석   출처: 알고리즘 문제해결전략, 분할정복  n개의 판자를 절반으로 나눠 분할한다.          부분문제 1: 가장 큰 직사각형을 왼쪽 부분 문제에서만 잘라낼 수 있다.      부분문제 2: 가장 큰 직사각형을 오른쪽 부분 문제에서만 잘라낼 수 있다.      부분문제 3: 가장 큰 직사각형은 왼쪽 부분 문제와 오른쪽 부분 문제에 결쳐 있다.      중요 조건: 가장 큰 직사각형은 반드시 부분 문제 경계에 있는 두 판자를 포함한다.      결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;#define max(a, b) ((a) &gt; (b) ? (a) : (b))#define min(a, b) ((a) &lt; (b) ? (a) : (b))//각 판자의 높이를 저장하는 배열vector&lt;int&gt; h;//h[left,...,right]구간에서 찾아낼 수 있는 가장 큰 사각형의 넓이를 반환int solve(int left, int right){\t//기저 사례: 판자가 하나밖에 없는 경우\tif (left == right) return h[left];\t//[left, mid],[mid+1, right]의 두 구간으로 문제를 분할\tint mid = (left + right) / 2;\t//분할한 문제를 각개격파(부분문제1, 부분문제2)\tint ret = max(solve(left, mid), solve(mid + 1, right));\t//부분문제3: 두 부분에 모두 걸치는 사각형 중 가장 큰 것을 찾는다.\tint lo = mid;\tint hi = mid + 1;\tint height = min(h[lo], h[hi]);\t//[mid, mid+1]만 포합하는 너비 2인 사각형을 고려한다.\tret = max(ret, height * 2);\t//사각형이 입력 전체를 덮을 때까지 확장해 나간다.\twhile (left &lt; lo || hi &lt; right) {\t\t//left ~ right 범위안에 있을 경우\t\tif (hi &lt; right &amp;&amp; (lo == left || h[lo - 1] &lt; h[hi + 1])) {\t\t\thi++;\t\t\theight = min(height, h[hi]);\t\t}\t\telse {\t\t\tlo--;\t\t\theight = min(height, h[lo]);\t\t}\t\t//확장한 후 사각형의 넓이\t\tret = max(ret, height * (hi - lo + 1));\t}\treturn ret;}int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tint n;\t\tscanf(\"%d\", &amp;n);\t\tfor (int i = 0; i &lt; n; i++) {\t\t\tint height;\t\t\tscanf(\"%d\", &amp;height);\t\t\th.push_back(height);\t\t}\t\tprintf(\"%d\\n\", solve(0, n - 1));\t\th.clear();\t}\treturn 0;}HOME ","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-FENCE/",
        "teaser":null},{
        "title": "[ALGOSPOT]FIRETRUCKS",
        "excerpt":"소방차 문제 링크   https://algospot.com/judge/problem/read/FIRETRUCKS코드 분석 다익스트라 알고리즘 응용   이 문제에서 최대 정점 개수는 1000개, 최대 간선 개수는 50만개이므로, 아래와 같은 단순한 알고리즘으로는 풀 수 없다.          각 불난 위치에서 다익스트라 알고리즘을 실행하여 가장 가까운 소방서를 찾는다. (O(nElogV))      각 소방서마다 다익스트라 알고리즘을 실행하여 가장 가까운 불난 위치를 찾는다. (O(mElogV))      플로이드 알고리즘 (O(V^3))        이 문제는 어느 소방서에서 소방차가 오느냐는 중요하지 않고, 무조건 소방서로부터 거리만 최소로 하면 된다.  따라서, 모든 소방서를 임의의 한 정점으로 연결한 후, 거리를 0으로 두면 단 한번의 다익스트라 알고리즘으로 문제를 해결할 수 있다.   위 그래프는 임의의 정점을 추가한 모습이다.  시간 복잡도는 다익스트라 알고리즘과 같다.구현 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;deque&gt;#include &lt;map&gt;using namespace std;#define MAX_V 1001const int INF = 987654321;int v, e, n, m;vector&lt;pair&lt;int, int&gt;&gt; adj[MAX_V];//minDist: 한 소방서에서 각 불난 위치의 정점까지 최소 거리//fireStation: 소방서 정점//fire: 불난 위치 정점int minDist[MAX_V], fireStation[MAX_V], fire[MAX_V];void dijkstra(int src) {   vector&lt;int&gt; dist(v + 1, INF);   dist[src] = 0;   priority_queue&lt;pair&lt;int, int&gt;&gt; pq;   pq.push(make_pair(0, src));   while (!pq.empty()) {      int here = pq.top().second;      int cost = -pq.top().first;      pq.pop();      if (dist[here] &lt; cost) continue;      for (int i = 0; i &lt; adj[here].size(); ++i) {         int there = adj[here][i].first;         int nextDist = cost + adj[here][i].second;         if (dist[there] &gt; nextDist) {            dist[there] = nextDist;            pq.push(make_pair(-nextDist, there));         }         //해당 정점이 불난 위치이며, 현재까지의 거리보다 짧다면 갱신한다.         for (int j = 0; j &lt; n; ++j)            if (there == fire[j] &amp;&amp; minDist[fire[j]] &gt; nextDist)               minDist[fire[j]] = nextDist;      }   }}int main(){   int tc; scanf(\"%d\", &amp;tc);   while (tc--) {      for (int i = 0; i &lt; MAX_V; ++i) {         adj[i].clear();         minDist[i] = INF;         fireStation[i] = 0;         fire[i] = 0;      }      scanf(\"%d %d %d %d\", &amp;v, &amp;e, &amp;n, &amp;m);      for (int i = 0; i &lt; e; ++i) {         int a, b, t;         scanf(\"%d %d %d\", &amp;a, &amp;b, &amp;t);         adj[a].push_back(make_pair(b, t));         adj[b].push_back(make_pair(a, t));      }      for (int i = 0; i &lt; n; ++i)         scanf(\"%d\", &amp;fire[i]);      //소방서의 정점을 입력 받은 후, 임의의 정점 0을 연결한다.(거리 0)      for (int i = 0; i &lt; m; ++i) {         scanf(\"%d\", &amp;fireStation[i]);         adj[0].push_back(make_pair(fireStation[i], 0));      }      //임의의 정점 0을 시작으로 다익스트라 알고리즘을 한번 실행한다.      dijkstra(0);      int ans = 0;      for (int i = 0; i &lt; n; ++i)         ans += minDist[fire[i]];      printf(\"%d\\n\", ans);   }   return 0;}HOME ","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-FIRETRUCKS/",
        "teaser":null},{
        "title": "[ALGOSPOT]GALLERY",
        "excerpt":"감시 카메라 설치 문제 링크   https://algospot.com/judge/problem/read/GALLERY코드 분석 루트 없는 트리의 지배 집합 찾기   지배 집합(domination set): 각 정점이 자기 자신과 모든 인접한 정점들을 지배한다고 할때, 그래프의 모든 정점을 지배하는 정점들의 부분집합을 그래프의 지배 집합이라고 한다.          그래프에서 지배 집합을 찾는 문제는 NP-완전 문제 중 하나로, 정점 개수의 지수 함수에 비례한다.      1. 루트 없는 트리(unrooted tree)   이 문제가 그래프가 아닌 루트 없는 트리라는 것을 알 수 있는 점은 문제 속에 있다.          문제 설명의 마지막에 미술관에서 한 번 지나간 갤러리를 다시 지나기 위해서는 전에 지난 복도를 반드시 지나야 한다.      사이클이 없다. = 트리로 표현할 수 있다.        위와 같이 그래프가 트리의 형태를 하는 것을 루트 없는 트리라고 부른다.  어떤 그래프가 루트 없는 트리인지를 알기 위해서는 아래와 같은 특징 중 한 가지가 성립해야 한다.(서로 동치 관계에 있음)          정확히 V - 1개의 간선이 있다.      사이클이 존재하지 않는다.      두 정점 사이를 연결하는 단순 경로가 정확히 하나만 존재한다.      2. 루트 없는 트리 문제 풀기   루트 없는 트리를 다루는 가장 간단한 방법은 임의의 시작점에서 깊이 우선 탐색을 수행하는 것이다.  이 결과로 얻은 깊이 탐색 스패닝 트리는 원래 그래프의 구조를 그대로 가지면서, 부모 자식 관계르르 갖는 일반적인 트리 형태가 된다.  문제 설명에서 모든 갤러리가 서로 연결되어 있을 필요가 없다고 명시되어 있기 때문에, 그래프의 각 컴포넌트는 트리 형태인 것을 알 수 있다.3. 트리의 지배 집합 찾기   트리의 최소 지배 집합을 찾는 가장 간단한 방법은 트리의 맨 아래에서부터 시작해서 위로 올라오는 것이다.          잎 노드는 부모 노드와 자기 자신밖에 지배하지 못하므로, 최소 지배 집합을 만들 수 없기 때문에 절대 선택해선 안된다.        알고리즘 과정          잎 노드는 선택하지 않는다.      이 외의 노드에 대해, 트리의 맨 밑에서부터 올라오면서 다음과 같이 선택 여부를 결정 한다.                  자기 자손 중 아직 지배당하지 않은 노드가 하나라도 있다면 현재 노드를 선택한다.          이 외의 경우는 현재 노드를 선택하지 않는다.                      첫 번째 예제 데이터 그래프 형태 구현   dfs(here)는 here를 루트로 하는 서브트리를 방문하고, 반환하면서 해당 노드가 지배 집합의 일부인지, 다른 노드에 지배당하고 있는지, 지배당하지 않고 있는지 3가지 중 하나를 반환한다.  시간 복잡도: O(g + h)구현 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;#define MAX_V 1001int V;vector&lt;int&gt; adj[MAX_V];vector&lt;bool&gt; visited;const int UNWATCHED = 0;const int WATCHED = 1;const int INSTALLED = 2;//지금까지 설치한 카메라의 총 수int installed;//here로부터 깊이 우선 탐색을 하고, here의 정보를 반환한다.int dfs(int here) {\tvisited[here] = true;\tint children[3] = { 0,0,0 }; //UNWATCHED, WATCHED, INSTALLED 정보\tfor (int i = 0; i &lt; adj[here].size(); ++i) {\t\tint there = adj[here][i];\t\tif (!visited[there])\t\t\t++children[dfs(there)];\t}\t//자손 노드 중 감시되지 않는 노드가 있을 경우 카메라를 설치한다.\tif (children[UNWATCHED]) {\t\t++installed;\t\treturn INSTALLED;\t}\t//자손 노드 중 카메라가 설치된 노드가 있을 경우 설치할 필요가 없다.\tif (children[INSTALLED])\t\treturn WATCHED;\treturn UNWATCHED;}//그래프를 감시하는데 필요한 카메라의 최소 수를 반환한다.int installCamera() {\tinstalled = 0;\tvisited = vector&lt;bool&gt;(V, false);\tfor (int u = 0; u &lt; V; ++u)\t\tif (!visited[u] &amp;&amp; dfs(u) == UNWATCHED)\t\t\t++installed;\treturn installed;}int main(){\tint tc; scanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tfor (int i = 0; i &lt; MAX_V; ++i)\t\t\tadj[i].clear();\t\tint h; scanf(\"%d %d\", &amp;V, &amp;h);\t\tfor (int i = 0; i &lt; h; ++i) {\t\t\tint s, e; scanf(\"%d %d\", &amp;s, &amp;e);\t\t\tadj[s].push_back(e);\t\t\tadj[e].push_back(s);\t\t}\t\tprintf(\"%d\\n\", installCamera());\t}\treturn 0;}HOME ","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-GALLERY/",
        "teaser":null},{
        "title": "[ALGOSPOT]LIS",
        "excerpt":"LIS(Longest Increasing Sequence) 문제 링크   https://algospot.com/judge/problem/read/LIS코드 분석   Bottom-up          DP[N]: 현재 인덱스에서 가장 긴 증가 부분 수열의 길이를 저장한다.      Input[N]: 입력 값을 저장한다.      현재 인덱스가 i일 때, j: (1 ~ i - 1)중 만약 input[i] &lt; input[j]이라면 DP[i] = DP[j] + 1로 갱신한다.      갱신된 값 중 가장 큰 값을 해당 인덱스의 최적해로 판단한다.      시간 복잡도: 1 + 2 + 3 + ... + n이므로, O(n^2)이다.        Top-down          chache[N]: 현재 인덱스에서 가장 긴 증가 부분 수열의 길이를 저장한다.(메모이제이션)      S[N]: 입력 배열      lis(start) = S[start]에서 시작하는 부분 증가 수열 중 최대의 길이를 반환한다.      별도의 기저 사례 없이, for문의 조건문을 이용한다.      시간 복잡도: 총 n개의 부분 문제를 갖고, 하나를 해결할 때마다 n번 연산하므로 O(n^2)이다.      결과 코드   Bottom-up```#define _CRT_SECURE_NO_WARNINGS#include #include #include using namespace std;#define N 501int dp[N];int input[N]; int main(void){\tint tc;\tscanf(“%d”, &amp;tc);\twhile (tc–) {\t\tmemset(dp, 0, sizeof(dp));\t\tmemset(input, 0, sizeof(input)); \tint n;\tscanf(\"%d\", &amp;n);\tfor (int i = 0; i &lt; n; i++)\t\tscanf(\"%d\", &amp;input[i]);\t//dp배열을 모두 1로 초기화(숫자가 한개 이면 길이가 1이기 때문)\tfor (int i = 0; i &lt; n; i++)\t\tdp[i] = 1;\t//i: 현재 인덱스, j: 이전 인덱스\t//dp배열에서 이전의 인덱스들의 값들은 최적해이다.\t//입력 배열에서 현재 인덱스의 값이 이전의 인덱스의 값보다 크다면\t//해당 dp배열의 값에서 1을 더하여 갱신하며, 갱신 값중의 최대값을 최적해라고 판단한다.\tfor (int i = 1; i &lt; n; i++) {\t\tfor (int j = 0; j &lt; i; j++) {\t\t\tif (input[j] &lt; input[i]) {\t\t\t\tif (dp[i] &lt; (dp[j] + 1))\t\t\t\t\tdp[i] = dp[j] + 1;\t\t\t}\t\t}\t}\tint max = 0;\tfor (int i = 0; i &lt; n; i++)\t\tif (max &lt; dp[i])\t\t\tmax = dp[i];\tprintf(\"%d\\n\", max);}return 0; } ```  Top-down```#define _CRT_SECURE_NO_WARNINGS#include #include #include using namespace std;#define max(a, b) ((a)&gt;(b)?(a):(b))#define N 501int n;int cache[N], S[N]; int lis(int start){\tint &amp;ret = cache[start];\tif (ret != -1) return ret;\tret = 1;\tfor (int next = start + 1; next &lt; n; ++next)\t\tif (S[start] &lt; S[next])\t\t\tret = max(ret, lis(next) + 1);\treturn ret;} int main(void){\tint tc;\tscanf(“%d”, &amp;tc);\twhile (tc–) {\t\tmemset(cache, -1, sizeof(cache));\t\tmemset(S, 0, sizeof(S)); \tscanf(\"%d\", &amp;n);\tfor (int i = 0; i &lt; n; i++)\t\tscanf(\"%d\", &amp;S[i]);\tint max = 0;\tfor (int i = 0; i &lt; n; i++) {\t\tint res = lis(i);\t\tif (max &lt; res)\t\t\tmax = res;\t}\tprintf(\"%d\\n\", max);}return 0; } ```HOME ","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-LIS/",
        "teaser":null},{
        "title": "[ALGOSPOT]MORSE",
        "excerpt":"모스 부호 사전 문제 링크   K번째 답 계산하기  https://algospot.com/judge/problem/read/MORSE코드 분석 1. 완전 탐색   장점인 신호가 단점인 신호보다 사전순으로 항상 앞으로 오는 모든 신호 만들기    //s: 지금까지 만든 신호//n: 더 필요한 '-'의 개수//m: 더 필요한 'o'의 개수void generate(int n, int m, string s) {  //기저 사례: n = m = 0  if (n == 0 &amp;&amp; m == 0) {      if (skip == 0) cout &lt;&lt; s &lt;&lt; endl;      --skip;      return;  }  if (bino[n + m][n] &lt;= skip) {      skip -= bino[n + m][n];      return;  }  if (n &gt; 0) generate(n - 1, m, s + \"-\");  if (m &gt; 0) generate(n, m - 1, s + \"o\");}        k - 1개 건너뛰기    //skip개를 건너뛰고 출력한다.void generate(int n, int m, string s) {  //기저 사례: skip &lt; 0 (skip=-1이란 것은 이미 k번째 신호가 출력됨)  if (skip &lt; 0) return;  //기저 사례: n = m = 0  if (n == 0 &amp;&amp; m == 0) {      //더 건너뛸 신호가 없는 경우      if (skip == 0) cout &lt;&lt; s &lt;&lt; endl;      --skip;      return;  }  if (bino[n + m][n] &lt;= skip) {      skip -= bino[n + m][n];      return;  }  if (n &gt; 0) generate(n - 1, m, s + \"-\");  if (m &gt; 0) generate(n, m - 1, s + \"o\");}        전역 변수 skip은 k - 1로 초기화해야 한다.  시간 복잡도          n, m의 최대 크기는 각각 100이다.      모든 경우의 수는 이항 계수 C(n + m, n)이므로 C(200, 100)이다. 이는 시간내에 절대 계산할 수 없다.      2. 동적 계획법   모든 신호를 만드는 경우의 수는 C(n + m. n)이다.  skip이 C(n + m. n)와 같거나 크다면 generate(n, m, s)가 종료될 때, skip은 C(n + m. n)만큼 줄어 있고 답은 못찾은 상태이다.  그렇다면, 함수를 실행할 필요 없이 skip만 줄여 버리고 종료해도 똑같은 결과가 나온다.  skip 변수의 오버플로를 막기 위해 문제에서 k가 항상 10억 이하라는 점을 이용한다.          이항계수 계산을 C(n, r)대신 min( C(n, r), 10^9 )으로 한다.        시간 복잡도          generate() 함수는 k번째 신호 외에는 어떤 신호도 만들지 않는다. =&gt; O(n + m)      calcBino() 함수는 이항 계수를 미리 모두 계산하는 함수이다. =&gt; O(nm)      결과적으로, 총 시간 복잡도는 O(nm)이다.      결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;#define min(a,b) ((a) &lt; (b) ? (a) : (b))#define N 201//k의 최대값  + 100, 오버플로를 막기 위해 이보다 큰 값은 구하지 않는다.const int M = 1000000000 + 100;int bino[N][N];int skip;//필요한 모든 이항계수를 미리 계산해 둔다.void calcBino() {\tmemset(bino, 0, sizeof(bino));\tfor (int i = 0; i &lt; N; i++) {\t\tbino[i][0] = bino[i][i] = 1;\t\tfor (int j = 1; j &lt; i; j++)\t\t\tbino[i][j] = min(M, bino[i - 1][j - 1] + bino[i - 1][j]);\t}}//s: 지금까지 만든 신호//n: 더 필요한 '-'의 개수//m: 더 필요한 'o'의 개수//skip개를 건너뛰고 출력한다.void generate(int n, int m, string s) {\t//기저 사례: skip &lt; 0 (skip=-1이란 것은 이미 k번째 신호가 출력됨)\tif (skip &lt; 0) return;\t//기저 사례: n = m = 0\tif (n == 0 &amp;&amp; m == 0) {\t\t//더 건너뛸 신호가 없는 경우\t\tif (skip == 0) cout &lt;&lt; s &lt;&lt; endl;\t\t--skip;\t\treturn;\t}\tif (bino[n + m][n] &lt;= skip) {\t\tskip -= bino[n + m][n];\t\treturn;\t}\tif (n &gt; 0) generate(n - 1, m, s + \"-\");\tif (m &gt; 0) generate(n, m - 1, s + \"o\");}int main(){\tint tc; scanf(\"%d\", &amp;tc);\tcalcBino();\twhile (tc--) {\t\tint n, m, k; scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;k);\t\tstring s;\t\t//skip 초기화\t\tskip = k - 1;\t\tgenerate(n, m, s);\t}\treturn 0;}HOME ","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-MORSE/",
        "teaser":null},{
        "title": "[ALGOSPOT]PACKING",
        "excerpt":"여행 짐 싸기 문제 링크   https://algospot.com/judge/problem/read/PACKING코드 분석 1. 완전 탐색   시간 복잡도: 각 물건에 대해 가져가거나 말거나 두 가지의 선택이 있다.          O(2^N)        pack(items) = 지금까지 고른 문건들의 목록이 items에 주어질 때, 남은 용량을 채워 얻을 수 있는 최대 절박도의 합2. 동적 계획법   완전 탐색에서 메모이제이션을 적용해보자.          items를 넣고 남은 용량에 담을 수 있는 물건들의 절박도 합만을 반환하도록 pack()을 바꾼다.      그 결과, 지금까지 고른 물건들의 목록은 상관이 없어진다.      중요한 것은 마지막으로 고른 물건의 번호(같은 물건을 두 번 고르면 안되므로)와 캐리어에 남아있는 용량이다.        capacity: 남은 용량, item: 물건의 번호, volume[item]: 해당 물건의 부피, need[item]: 해당 물건의 절박도  pack(capacity, item) = 캐리어에 용량이 capacity만큼 남았을 때, item 이후의 물건들을 싸서 얻을 수 있는 최대 절박도          해당 물건을 가져가는 경우: pack(capacity - volume[item], item + 1) + need[item]      해당 물건을 가져가지 않는 경우: pack(capacity, item + 1)        시간 복잡도: 용량 w, 물건의 개수 n 일때, 부분 문제의 수는 nw개이고 각 부분 문제를 해결하는데 걸리는 시간은 상수 시간이다.          O(nw)      3. 답 추적하기   각 부분 문제에서 선택지가 두 가지밖에 없으므로 따로 선택으르 저장하지 않고도 답을 역추적할 수 있다.  pack(capacity, item) 부분 문제에서 item을 선택했는지를 알고 싶으면 pack(capacity, item + 1)과 pack(capacity, item)이 같은지 비교하면 된다.          만약 두 값이 같다면, item을 선택하지 않고도 최대 절박도를 얻을 수 있다는 말이므로 item을 무시한다.      다르면, 목록에 item을 추가한다.      결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;#define max(a,b) ((a) &gt; (b) ? (a) : (b))#define N 101int n, w;int cache[1001][N];//물건의 정보를 저장할 구조체typedef struct _product{\tstring name;\tint volume;\tint need;}product;vector&lt;product&gt; pv;//캐리어에 남은 용량이 capacity일때, item 이후의 물건들을//담아 얻을 수 있는 최대 절박도의 합을 반환한다.int pack(int capacity, int item) {\t//기저 사례: 더 담을 물건이 없을 때\tif (item == n) return 0;\tint &amp;ret = cache[capacity][item];\tif (ret != -1) return ret;\t//이 물건을 담지 않을 경우\tret = pack(capacity, item + 1);\t//이 물건을 담을 경우\tif (capacity &gt;= pv[item].volume)\t\tret = max(ret, pack(capacity - pv[item].volume, item + 1) +\t\t\tpv[item].need);\treturn ret;}//pack(capacity, item)이 선택한 물건들의 목록을 packed에 저장한다.void reconstruct(int capacity, int item, vector&lt;string&gt; &amp;packed) {\t//기저 사례: 모든 물건을 다 고려했을 때\tif (item == n) return;\tif (pack(capacity, item) == pack(capacity, item + 1))\t\treconstruct(capacity, item + 1, packed);\telse {\t\tpacked.push_back(pv[item].name);\t\treconstruct(capacity - pv[item].volume, item + 1, packed);\t}}//초기화void init() {\tmemset(cache, -1, sizeof(cache));\tpv.clear();}int main(){\tint tc; scanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tinit();\t\tscanf(\"%d %d\", &amp;n, &amp;w);\t\tfor (int i = 0; i &lt; n; i++) {\t\t\tproduct in;\t\t\tcin &gt;&gt; in.name;\t\t\tscanf(\"%d %d\", &amp;in.volume, &amp;in.need);\t\t\tpv.push_back(in);\t\t}\t\tvector&lt;string&gt; packed;\t\treconstruct(w, 0, packed);\t\tint psize = packed.size();\t\tprintf(\"%d %d\\n\", pack(w, 0), psize);\t\tfor (int i = 0; i &lt; psize; i++)\t\t\tcout &lt;&lt; packed[i] &lt;&lt; endl;\t}\treturn 0;}HOME ","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-PACKING/",
        "teaser":null},{
        "title": "[ALGOSPOT]PI",
        "excerpt":"PI 문제 링크   https://algospot.com/judge/problem/read/PI테스트 케이스   기본 테스트 케이스          입력        51234123411111222121222222222222212673939                    출력        425214                    코드 분석   동적 계획법(메모이제이션)          첫 조각의 길이는 3, 4, 5 중의 하나이므로 각 경우마다 하나씩의 부분 문제를 해결한다, 이때 세 개의 부분 문제의 최적화(최소값)을 각각 구하면 전체 문제의 최적해가 된다.                  길이 3인 조각의 난이도 +3글자 빼고 나머지 수열에 대한 최적해          길이 4인 조각의 난이도 +4글자 빼고 나머지 수열에 대한 최적해          길이 5인 조각의 난이도 +5글자 빼고 나머지 수열에 대한 최적해                    begin: 부분 수열의 시작 위치, memorize(): 최소 난이도를 반환하는 함수, returnLevel(): 해당 수열의 난이도를 반환하는 함수      memorize(begin) = min(memorize(begin + L) + returnLevel(N[begin…begin + L])), L: 3 ~ 5        returnLevel() 함수          checkLevel() 함수                  수열의 길이 3, 4, 5에 대해서만 적용할 수 있는 함수이다.          시간복잡도면에서 효율적이다. (소요시간: 24ms)                    classify() 함수                  모든 수열의 길이에 대해 적용 가능하다.          시간이 오래 걸린다. (소요시간: 250ms)                    결과 코드   링크:```#define _CRT_SECURE_NO_WARNINGS#include #include #include #include #include #include using namespace std;#define N 10001#define min(a, b) ((a) &lt; (b) ? (a) : (b))string arr;const int INF = 987654321;int cache[N]; //1) arr[s]부터 size만큼 크기의 난이도를 반환int checkLevel(int s, int size){\tif (size == 3) {\t\tint s1, s2, s3;\t\ts1 = arr[s]; s2 = arr[s + 1]; s3 = arr[s + 2];\t\tif (s1 == s2 &amp;&amp; s2 == s3)\t\t\treturn 1;\t\tint d1, d2;\t\td1 = s2 - s1; d2 = s3 - s2;\t\tif (d1 == d2) {\t\t\tif (d1 == 1 || d1 == -1)\t\t\t\treturn 2;\t\t\telse\t\t\t\treturn 5;\t\t}\t\tif (s1 == s3)\t\t\treturn 4;\t}\telse if (size == 4) {\t\tint s1, s2, s3, s4;\t\ts1 = arr[s]; s2 = arr[s + 1]; s3 = arr[s + 2]; s4 = arr[s + 3];\t\tif (s1 == s2 &amp;&amp; s2 == s3 &amp;&amp; s3 == s4)\t\t\treturn 1;\t\tint d1, d2, d3;\t\td1 = s2 - s1; d2 = s3 - s2; d3 = s4 - s3;\t\tif (d1 == d2 &amp;&amp; d2 == d3) {\t\t\tif (d1 == 1 || d1 == -1)\t\t\t\treturn 2;\t\t\telse\t\t\t\treturn 5;\t\t}\t\tif (s1 == s3 &amp;&amp; s2 == s4)\t\t\treturn 4;\t}\telse if (size == 5) {\t\tint s1, s2, s3, s4, s5;\t\ts1 = arr[s]; s2 = arr[s + 1]; s3 = arr[s + 2];\t\ts4 = arr[s + 3]; s5 = arr[s + 4];\t\tif (s1 == s2 &amp;&amp; s2 == s3 &amp;&amp; s3 == s4 &amp;&amp; s4 == s5)\t\t\treturn 1;\t\tint d1, d2, d3, d4;\t\td1 = s2 - s1; d2 = s3 - s2; d3 = s4 - s3; d4 = s5 - s4;\t\tif (d1 == d2 &amp;&amp; d2 == d3 &amp;&amp; d3 == d4) {\t\t\tif (d1 == 1 || d1 == -1)\t\t\t\treturn 2;\t\t\telse\t\t\t\treturn 5;\t\t}\t\tif ((s1 == s3 &amp;&amp; s3 == s5) &amp;&amp; s2 == s4)\t\t\treturn 4;\t}\treturn 10;} //2) arr[a,b]구간의 난이도를 반환한다.int classify(int a, int b){\t//숫자 조각을 가져온다.\tstring M = arr.substr(a, b - a + 1);\t//첫 글자만으로 이루어진 문자열과 같은으면 난이도 1\tif (M == string(M.size(), M[0])) return 1;\t//등차수열인지 검사한다.\tbool progressive = true;\tfor (int i = 0; i &lt; (int)M.size() - 1; i++)\t\tif (M[i + 1] - M[i] != M[1] - M[0])\t\t\tprogressive = false;\t//등차수열이고 공차가 1 or -1 이면 난이도 2\tif (progressive &amp;&amp; abs(M[1] - M[0]) == 1)\t\treturn 2;\t//두 수가 번갈아 등장하는지 확인한다.\tbool alternating = true;\tfor (int i = 0; i &lt; (int)M.size(); i++)\t\tif (M[i] != M[i % 2])\t\t\talternating = false;\tif (alternating) return 4;  //두 수가 번갈아 등장하면 난이도 4\tif (progressive) return 5;  //공차가 1 아닌 등차수열이면 난이도 5\treturn 10;                  //이 외는 모두 난이도 10} //수열 arr[begin…]를 외우는 방법 중 난이도의 최소 합을 출력한다.int memorize(int begin){\t//기저 사례: 수열의 끝에 도달했을 경우\tif (begin == arr.size()) return 0;\t//메모이제이션\tint &amp;ret = cache[begin];\tif (ret != -1) return ret;\tret = INF;\tfor (int L = 3; L &lt;= 5; ++L) {\t\tif (begin + L &lt;= (int)arr.size())\t\t\tret = min(ret, memorize(begin + L) + checkLevel(begin, L));              //방법 1)\t\t\t//ret = min(ret, memorize(begin + L) + classify(begin, begin + L - 1));  //방법 2)\t}\treturn ret;} int main(void){\tint tc;\tscanf(“%d”, &amp;tc);\twhile (tc–) {\t\tmemset(cache, -1, sizeof(cache));\t\tarr.clear();\t\tcin » arr;\t\tprintf(“%d\\n”, memorize(0));\t} return 0; } ```HOME ","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-PI/",
        "teaser":null},{
        "title": "[ALGOSPOT]PICNIC",
        "excerpt":"PICNIC 문제 링크   https://algospot.com/judge/problem/read/PICNIC내 코드 분석 논리 분석   입력받은 친구가 가능한 쌍을 2차원 배열에 중복없이 저장한다. ((1,0), (0,1)도 중복으로 처리한다.)  경우의 수를 체크하기 위해 가능한 쌍의 최대 크기(45)만큼 가로, 세로 크기를 갖는 2차원 배열을 선언한다.  모든 친구들이 쌍을 이루었는지 체크하는 1차원 배열을 선언한다.  최대 시간복잡도는 O(m^2)로 예상한다. (최대 반복 수는 45 * (45 + 45) 로 예사됨)구현 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;#define N 11  //최대 친구 수#define M 46  //최대 친구 쌍의 수bool checkF[N];  //모든 친구들이 짝이 만들어졌는지 체크bool checkP[M][M];  //짝지을 수 있는 방법을 저장할 배열(중복되지 않음)int _pair[M][2];   //가능한 친구 쌍을 저장할 배열bool tmp[M];  //짝지을 방법를 임시로 저장할 배열void init_checkF_tmp(void){\tfor (int i = 0; i &lt; N; i++)\t\tcheckF[i] = false;\tfor (int i = 0; i &lt; M; i++)\t\ttmp[i] = false;}void init_pair(void){\tfor (int i = 0; i &lt; M; i++) {\t\t_pair[i][0] = 0;\t\t_pair[i][1] = 0;\t\tfor (int j = 0; j &lt; M; j++)\t\t\tcheckP[i][j] = false;\t}}bool full_checkF(int n){\tfor (int i = 0; i &lt; n; i++) {\t\tif (!checkF[i])\t\t\treturn false;\t}\treturn true;}//n은 현재 방법의 수bool check_pair(int n, int m){\tbool flag = false;\tfor (int i = 0; i &lt; n; i++) {\t\tfor (int j = 0; j &lt; m; j++) {\t\t\t//하나라도 다른 부분이 있다면 다음 방법으로 넘어가서 검사한다.\t\t\tif (tmp[j] == checkP[i][j])\t\t\t\tflag = true;\t\t\telse {\t\t\t\tflag = false;\t\t\t\tbreak;\t\t\t}\t\t}\t\t//완전히 같으면 FALSE 반환\t\tif (flag) return false;\t}\treturn true;}int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tinit_pair();\t\tint n, m;\t\tscanf(\"%d %d\", &amp;n, &amp;m);\t\tbool repet_flag = false;\t\tint repet_cnt = 0;\t\tfor (int i = 0; i &lt; m; i++) {\t\t\tint f, s;\t\t\tscanf(\"%d %d\", &amp;f, &amp;s);\t\t\t//(0, 1), (1, 0)과 같은 중복을 방지하기 위해 서로 같은 쌍은 입력하지 않는다.\t\t\trepet_flag = false;\t\t\tfor (int j = 0; j &lt; i; j++) {\t\t\t\tif (_pair[j][0] == f &amp;&amp; _pair[j][1] == s) repet_flag = true;\t\t\t\tif (_pair[j][0] == s &amp;&amp; _pair[j][1] == f) repet_flag = true;\t\t\t}\t\t\tif (repet_flag)\t\t\t\trepet_cnt++;\t\t\telse {\t\t\t\t_pair[i - repet_cnt][0] = f;\t\t\t\t_pair[i - repet_cnt][1] = s;\t\t\t}\t\t}\t\tm -= repet_cnt;\t\tint ans = 0;\t\tfor (int i = 0; i &lt; m; i++) {\t\t\tinit_checkF_tmp();\t\t\tcheckF[_pair[i][0]] = true;\t\t\tcheckF[_pair[i][1]] = true;\t\t\ttmp[i] = true;\t\t\tfor (int j = 0; j &lt; m; j++) {\t\t\t\t//중복을 피해기 위함\t\t\t\tif (i == j)\t\t\t\t\tcontinue;\t\t\t\t//친구쌍의 두 친구가 모두 check배열에 false면 해당 쌍을 사용한다.(중복검사)\t\t\t\tif (!checkF[_pair[j][0]] &amp;&amp; !checkF[_pair[j][1]]) {\t\t\t\t\tcheckF[_pair[j][0]] = true;\t\t\t\t\tcheckF[_pair[j][1]] = true;\t\t\t\t\ttmp[j] = true;\t\t\t\t}\t\t\t}\t\t\t//모든 친구들이 짝을 이루었고, 이전에 방법과 다르다면 새로운 방법이다.\t\t\tif (full_checkF(n) &amp;&amp; check_pair(ans, m)) {\t\t\t\tfor (int j = 0; j &lt; m; j++)\t\t\t\t\tcheckP[ans][j] = tmp[j];\t\t\t\tans++;\t\t\t}\t\t}\t\tprintf(\"%d\\n\", ans);\t}\treturn 0;}결과   수행시간 : 0ms  오답  디버깅과 다른 예제를 만들어서 테스트한 결과 틀린 부분을 찾을 수 없었다.알아둘 점   재귀에 관한 이해가 더욱 필요하다.  위의 문제도 책의 해답에서는 재귀를 사용하였다.해답 코드   출처 : 알고리즘 문제해결전략 책~~~#define _CRT_SECURE_NO_WARNINGS#include #include using namespace std;#define N 10int n;bool areFriends[N][N];//taken[i] = i번째 학생이 짝을 이미 찾았으면 true, 아니면 falseint countPairings(bool taken[N]){\t//남은 학생들 중 가장 번호가 빠른 학생을 찾는다.\tint firstFree = -1;\tfor (int i = 0; i &lt; n; i++) {\t\tif (!taken[i]) {\t\t\tfirstFree = i;\t\t\tbreak;\t\t}\t}\t//기저 사례 : 모든 학생이 짝을 찾았으면 한 가지 방법을 찾았으니 종료한다.\tif (firstFree == -1) return 1;\tint ret = 0;\t//이 학생과 짝지을 학생을 결정한다.\tfor (int pairWith = firstFree + 1; pairWith &lt; n; pairWith++) {\t\tif (!taken[pairWith] &amp;&amp; areFriends[firstFree][pairWith]) {\t\t\ttaken[firstFree] = taken[pairWith] = true;\t\t\tret += countPairings(taken);\t\t\t//모든 경우의 수를 구해야하기 때문에 초기화해야함\t\t\ttaken[firstFree] = taken[pairWith] = false;\t\t}\t}\treturn ret;} int main(void){\tint tc;\tscanf(“%d”, &amp;tc);\twhile (tc–) {\t\tfor (int i = 0; i &lt; N; i++)\t\t\tfor (int j = 0; j &lt; N; j++)\t\t\t\tareFriends[i][j] = false;\t\tint m;\t\tscanf(“%d %d”, &amp;n, &amp;m);\t\tfor (int i = 0; i &lt; m; i++) {\t\t\tint f, s;\t\t\tscanf(“%d %d”, &amp;f, &amp;s);\t\t\tareFriends[f][s] = areFriends[s][f] = true;\t\t}\t\tbool taken[10] = { false, };\t\tint ans = countPairings(taken);\t\tprintf(“%d\\n”, ans);\t} return 0; } ~~~결과 및 코드 분석   수행 시간 : 0ms  최대 시간 복잡도 : 열 명의 학생이 모두 친구인 경우(9 * 7 * 5 * 3 * 1 = 945)  재귀 함수 사용  공간 복잡도면에서, 2차원 배열 1개와 1차원 배열 1개를 사용하여 내가 구현한 코드보다 더 효율적이다.  친구 쌍이 가능한지를 저장하는 2차원 배열에서 그 반대의 경우도 모두 저장해주어야 정확한 답이 나온다.알아둘 점 1) 재귀 함수 구현 능력&lt;/br&gt;2) 재귀 함수를 사용하기 위한 입력 형식을 만드는 방법 HOME ","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-PICNIC/",
        "teaser":null},{
        "title": "[ALGOSPOT]QUADTREE",
        "excerpt":"QUADTREE 문제 링크   https://algospot.com/judge/problem/read/QUADTREE코드 분석   출처: 알고리즘 문제해결전략, 분할정복  재귀 호출을 이용해 네 부분을 각각 상하로 뒤집은 결과를 얻은 뒤, 이들을 병합한다.  STL의 string 함수 사용  STL의 문자열에서 지원하는 반복자(iterator) 활용  시간복잡도 분석: O(n)          주어진 문자열 길이: n      재귀 함수를 호출할 때 마다 주어진 문자열의 한 글자씩을 사용한다.      결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;string reserve(string::iterator &amp;it){\tchar head = *it;\t++it;\tif (head == 'b' || head == 'w')\t\treturn string(1, head);\tstring upperLeft = reserve(it);\tstring upperRight = reserve(it);\tstring lowerLeft = reserve(it);\tstring lowerRight = reserve(it);\t//각각 위와 아래 조각들의 위치를 바꾼다.\treturn string(\"x\") + lowerLeft + lowerRight +\t\tupperLeft + upperRight;}int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tstring map;\t\tcin &gt;&gt; map;\t\tstring::iterator it = map.begin();\t\tcout &lt;&lt; reserve(it) &lt;&lt; endl;\t}\treturn 0;}결과 분석   수행시간: 4msHOME ","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-QUADTREE/",
        "teaser":null},{
        "title": "[ALGOSPOT]QUANTIZE",
        "excerpt":"QUANTIZE 문제 링크   https://algospot.com/judge/problem/read/QUANTIZE코드 분석   완전 탐색          시간복잡도: O(1000C10^n)이고, 최대 연산수 1000C10^100이므로 시간안에 풀 수 없다.        동적 계획법(메모이제이션)          주어진 수열을 오름차순 or 내림차순으로 정렬하면, 같은 숫자로 양자화되는 숫자들은 항상 인접해 있다!                  예를들어, a &lt; b에 대해 a에 대응되는 숫자가 b에 대응되는 숫자보다 커서는 안된다.          이는 몇 개의 작은 입력들을 풀어보면 알 수 있는 조건이며, 시간내에 풀기 위해 알아야하는 중요한 조건이다.                    기본 테스트 케이스의 한 예를 사용하면, {1, 4, 6, 744, 755, 777, 890, 897, 902} =&gt; {1, 4, 6}: 4, {744, 755, 777}: 759, {890, 897, 902}: 896 로 대응된다.      이를 형식화하면, from번째 이후의 숫자들을 parts개의 묶음으로 묶을 때, 최소 오류 제곱 합을 반환하는 함수 quantize(from, parts)가 있다.      quantize(from, parts) = min[minError(from, from + size - 1) + quantize(from + size, parts - 1)], size: 1 ~ n-from      minError(a,b): a번째 숫자부터 b번째 숫자까지 하나의 수로 표현했을 때의 최소 오류를 반환하는 함수                  주어진 구간을 어떤 수로 표현해야 할지 결정하기          결정한 수 m으로 해당 구간을 표현했을 때 오차를 계산하기                          위의 역할을 완전 탐색으로 구현하여도 시간안에 해결할 수 있지만, 밑의 구현 코드는 좀 더 복잡하며 효율적인 방법을 사용한다.          이는 오차 제곱의 합을 미분하여 값을 도출하며, 이를 부분 합 계산 방식으로 시간복잡도 O(1)의 방법으로 푸는 방법이며, 이 설명은 추후 추가할 예정이다.시간복잡도: 부분 문제의 수 ns개를 각각 n번 계산해야 하기 때문에 총 O(sn^2)이다.                    결과 코드   링크:```#define _CRT_SECURE_NO_WARNINGS#include #include #include #include using namespace std;#define N 10001#define min(a,b) ((a)&lt;(b)?(a):(b)) const int INF = 987654321;//A[]: 양자화해야 할 수열, 정렬한 상태//pSum[]: A[]의 부분합을 저장한다. pSum[i]는 A[0]…A[i]의 합//qSuSum[]: A[]제곱의 부분합을 저장한다. pSqSum[i]는 A[0]^2…A[i]^2의 합int n;int A[N], pSum[N], pSqSum[N]; //A를 정렬하고 가가 부분합을 계산한다.void precalc(){\tsort(A, A + n);\tpSum[0] = A[0];\tpSqSum[0] = A[0] * A[0];\tfor (int i = 1; i &lt; n; i++) {\t\tpSum[i] = pSum[i - 1] + A[i];\t\tpSqSum[i] = pSqSum[i - 1] + A[i] * A[i];\t}} //A[lo]…A[hi] 구간을 하나의 숫자로 표현할 때 최소 오차 합을 반환한다.int minError(int lo, int hi){\t//부분합을 이용해 A[lo] ~ A[hi]까지의 합을 구한다.\tint sum = pSum[hi] - (lo == 0 ? 0 : pSum[lo - 1]);\tint sqSum = pSqSum[hi] - (lo == 0 ? 0 : pSqSum[lo - 1]);\t//평균을 반올림한 값으로 이 수 들을 표현한다.\tint m = int(0.5 + (double)sum / (hi - lo + 1));\t//sum(A[i] - m)^2를 전개한 결과를 부분 합으로 표현\tint ret = sqSum - 2 * m *sum + m *m *(hi - lo + 1);\treturn ret;} int cache[N][11];int quantize(int from, int parts){\t//기저 사례: 모든 숫자들 양자화했을 떄\tif (from == n) return 0;\t//기저 사례: 숫자는 아직 남았는데 더 묶을 수 없을 때 아주 큰 값으르 반환한다.\tif (parts == 0) return INF;\tint &amp;ret = cache[from][parts];\tif (ret != -1) return ret;\tret = INF;\t//조각의 길이를 변화시켜 가며 최소값을 찾는다.\tfor (int partSize = 1; from + partSize &lt;= n; partSize++)\t\tret = min(ret, minError(from, from + partSize - 1)\t\t\t+ quantize(from + partSize, parts - 1));\treturn ret;} int main(void){\tint tc;\tscanf(“%d”, &amp;tc);\twhile (tc–) {\t\tmemset(cache, -1, sizeof(cache));\t\tmemset(A, 0, sizeof(A));\t\tmemset(pSum, 0, sizeof(pSum));\t\tmemset(pSqSum, 0, sizeof(pSqSum));\t\tint s;\t\tscanf(“%d %d”, &amp;n, &amp;s);\t\tfor (int i = 0; i &lt; n; i++)\t\t\tscanf(“%d”, &amp;A[i]);\t\tprecalc();\t\tprintf(“%d\\n”, quantize(0, s));\t} return 0; } ```HOME ","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-QUANTIZE/",
        "teaser":null},{
        "title": "[ALGOSPOT]SNAIL",
        "excerpt":"장마가 찾아왔다 문제 링크   https://algospot.com/judge/problem/read/SNAIL코드 분석 동적 계획법을 활용한 확률 계산   예제 문제: 우물의 깊이 n미터, 장마 기간 m일, 비가올 확률 50%, 달팽이는 비가 안올 때 1m 올라가고 비가 올 때 2m를 올라간다. 이때, 올라갈 수 있는확률을 구하라.    int cache[N][2 * N + 1];int n, m;//달팽이가 days일 동안 climbed미터를 기어올라 왔다고 할 때,//m일 전까지 n미터를 기어올라갈 수 있는 경우의 수int climb(int days, int climbed){  //기저 사례: m일이 모두 지난 경우  if (days == m) return climbed &gt;= n ? 1 : 0;  //메모이제이션  int &amp;ret = cache[days][climbed];  if (ret != -1) return ret;  return ret = climb(days + 1, climbed + 2) + climb(days + 1, climbed + 1);}        완전 탐색 알고리즘에서 동적 계획법으로 순서          완전 탐색      climb(C): 지금까지 만든 날씨 조합C를 완성해서 원소의 합이 n이상이 되도록 하는 방법의 수      점화식: climb(C) = climb(C + [1]) + climb(C + [2])                  C + [x]는 배열 C의 맨 뒤에 x를 덧붙인 결과이다.          이 점화식은 C의 종류가 너무 많기 때문에 메모이제이션을 활용할 수 없다!          날씨 조합C =&gt; C의 길이와 C의 원소의 합만을 활용한다.                    동적 계획법      climbed(days, climbed): 지금까지 만든 날씨 조합C의 크기가 days, 그 원소들의 합이 climbed일 때, C를 완성해서 원소의 합이 n이상이 되게 하는방법의 수                  최대 부분 문제의 수: n * m          얻은 결과의 경우의 수를 2^m으로 나누면 최종 확률을 얻을 수 있다.                    SNAIL 문제   위와 문제의 구조는 동일하지만, 비가 올 확률이 50%에서 75%으로 증가하였다.  점화식: climb(days, climbed) = 0.25 * climb(days + 1, climbed + 1) + 0.75 * climb(days + 1, climbed + 2)          위의 예제와 달리 날씨의 조합마다 출현할 확률이 달라지므로, 재귀함수 결과를 경우의 수가 아닌 직접 확률을 계산해야 한다.      결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;#define N 1001double cache[N][2 * N + 1];int n, m;double climb(int days, int climbed){\t//기저 사례\tif (days == m) return climbed &gt;= n ? 1. : 0.;\t//메모이제이션\tdouble &amp;ret = cache[days][climbed];\tif (ret != -1.) return ret;\treturn ret = 0.75 * climb(days + 1, climbed + 2) + 0.25 * climb(days + 1, climbed + 1);}int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tfor (int i = 0; i &lt; N; i++)\t\t\tfor (int j = 0; j &lt; 2 * N + 1; j++)\t\t\t\tcache[i][j] = -1.;\t\tscanf(\"%d %d\", &amp;n, &amp;m);\t\tprintf(\"%.10lf\\n\", climb(0, 0));\t}\treturn 0;}HOME ","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-SNAIL/",
        "teaser":null},{
        "title": "[ALGOSPOT]SORTGAME",
        "excerpt":"Sorting Game 문제 링크   https://algospot.com/judge/problem/read/SORTGAME코드 분석 그래프화한 뒤 넓이 우선 탐색(BFS) 사용하기 1. 그래프로 바꾸기   각 배열을 정점으로 표현하고, 부분 구간을 뒤집어 한 배열에서 다른 배열을 만들 수 있을 때 두 정점을 간선으로 연결한다.  n원소가 있을 때 이들을 배열하는 방법은 n!이며, 최대 정점의 개수도 이와 같다.   위 그래프를 넓이 우선 탐색하면서 정렬된 상태를 나타내는 정점까지의 거리를 계산한다.  구현          그래프를 생성하는 과정은 생략하고, 입력 배열의 부분 구간을 뒤집으면서 그때 그때 그래프의 간선을 만들어 넓이 우선 탐색을 실행한다.      정점 큐의 각 원소를 정수 배열로 하며, 거리를 계산할 distance[]는 정수 배열을 키(key)로 갖는 map을 사용한다.        //perm을 정렬하기 위해 필요한 최소 뒤집기 연산의 수를 계산 후 반환한다.int bfs(const vector&lt;int&gt; &amp;perm) {int n = perm.size();//목표 정점을 미리 계산한다.(오름차순된 배열)vector&lt;int&gt; sorted = perm;sort(sorted.begin(), sorted.end());//방문 목록(큐)queue&lt;vector&lt;int&gt;&gt; q;//시작점으로부터 각 정점까지의 거리(map)map&lt;vector&lt;int&gt;, int&gt; distance;//시작점의 거리는 0distance[perm] = 0;//시작점을 큐에 넣는다.q.push(perm);while (!q.empty()) {    vector&lt;int&gt; here = q.front();    q.pop();    //목표 정점을 발견했으면 곧장 종료한다.    if (here == sorted) return distance[here];    int cost = distance[here];    //가능한 모든 부분 구간을 뒤집어 본다.    for (int i = 0; i &lt; n; ++i) {        //reverse함수의 배열 범위에 주의한다.        for (int j = i + 1; j &lt;= n; ++j) {            reverse(here.begin() + i, here.begin() + j);            if (distance.count(here) == 0) {                distance[here] = cost + 1;                q.push(here);            }            reverse(here.begin() + i, here.begin() + j);        }    }}//실행되지 않음return -1;}                    2. 더 빠른 해결방법   위 방법은 최악의 경우 8! = 40320개의 정점을 탐색하며, map에 접근해야한다. 그리고 최대 1000개의 테스트 케이스가 있기 때문에 시간안에 해결하기 힘들다.  위 알고리즘을 최적화하기 위해 2가지를 알고 있어야 한다.          숫자들이 다르더라도 상대적인 크기가 같은 배열들에 대한 답은 같다.                  예를들어, 두 배열 {30, 40, 10, 20}과 {3, 4, 1, 2}는 모두 최소 연산수가 2이다.                    이 문제의 그래프는 양방향 그래프이기 때문에, 시작 정점에서 목표 정점으로 가는 최단 거리는 그 반대인 목표 정점에서 시작 정점으로 가는 최단 거리와 같다.                  한 배열을 정렬하는데 드는 연산의 수는 정렬된 배열을 원래 배열로 바꾸는데 드는 연산의 수와 같다.                      위 2가지 속성을 이용하면, 모든 n(최대 크기 8)에 대해 정렬된 배열 [0, 1, 2, …, n-1]에서 모든 상태를 미리 계산한다.  입력 배열을 [0, n-1] 범위의 값으로 상대적인 크기를 유지한 상태로 바꾸면 위에서 미리 계산된 연산의 수로 답을 바로 알 수 있다.3. 구현 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;map&lt;vector&lt;int&gt;, int&gt; toSort;//[0, ..., n-1]의 모든 순열에 대해 toSort[]를 계산해 저장한다.void precalc(int n) {\tvector&lt;int&gt; perm(n);\tfor (int i = 0; i &lt; n; ++i) perm[i] = i;\tqueue&lt;vector&lt;int&gt;&gt; q;\tq.push(perm);\ttoSort[perm] = 0;\twhile (!q.empty()) {\t\tvector&lt;int&gt; here = q.front();\t\tq.pop();\t\tint cost = toSort[here];\t\tfor (int i = 0; i &lt; n; ++i) {\t\t\tfor (int j = i + 1; j &lt;= n; ++j) {\t\t\t\treverse(here.begin() + i, here.begin() + j);\t\t\t\tif (toSort.count(here) == 0) {\t\t\t\t\ttoSort[here] = cost + 1;\t\t\t\t\tq.push(here);\t\t\t\t}\t\t\t\treverse(here.begin() + i, here.begin() + j);\t\t\t}\t\t}\t}}int solve(const vector&lt;int&gt; &amp;perm) {  //perm을 [0, ..., n-1]의 순열로 변환한다.\tint n = perm.size();\tvector&lt;int&gt; fixed(n);\tfor (int i = 0; i &lt; n; ++i) {\t\tint smaller = 0;\t\tfor (int j = 0; j &lt; n; ++j) {\t\t\tif (perm[j] &lt; perm[i])\t\t\t\tsmaller++;\t\t}\t\tfixed[i] = smaller;\t}\treturn toSort[fixed];}int main(){\tfor (int i = 1; i &lt;= 8; ++i)\t\tprecalc(i);\tint tc; scanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tint n; scanf(\"%d\", &amp;n);\t\tvector&lt;int&gt; in(n);\t\tfor (int i = 0; i &lt; n; ++i)\t\t\tscanf(\"%d\", &amp;in[i]);\t\tprintf(\"%d\\n\", solve(in));\t}\treturn 0;}HOME ","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-SORTGAME/",
        "teaser":null},{
        "title": "[ALGOSPOT]STRJOIN",
        "excerpt":"문자열 합치기 문제 링크   https://algospot.com/judge/problem/read/STRJOIN코드 분석   그리디 알고리즘  문자열 길이가 가장 짧은 2개를 계속 더해나간다.          더한 값 역시 문자열 길이가 저장되어 있는 배열에 갱신해야 한다.        vector로 구현          vector의 멤버함수인 push_back과 pop_back을 사용하기 위해 내림차순으로 정렬하여 구현하였다.      시간 복잡도: 내림차순 정렬O(NlogN) + 문자열 길이 2개 더하고 vector 갱신하기O(N) = O(N^2 * logN)        우선순위 큐로 구현          시간복잡도: 우선순위 큐O(logN) + 문자열 길이 2개 더하고 큐 갱신O(N) = O(NlogN)      허프만 압축 알고리즘을 응용한다.      결과 코드   vector로 구현한 코드```#define _CRT_SECURE_NO_WARNINGS#include #include #include #include using namespace std;vector len; //내림차순bool compare(const int a, const int b){ return a &gt; b; } int main(){\tint tc; scanf(“%d”, &amp;tc);\twhile (tc–) {\t\tint n; scanf(“%d”, &amp;n);\t\tfor (int i = 0; i &lt; n; i++) {\t\t\tint num; scanf(“%d”, &amp;num);\t\t\tlen.push_back(num);\t\t}\t\tint vlen = len.size();\t\t//내림차순 정렬\t\tsort(len.begin(), len.end(), compare);\t\t/for (int i = 0; i &lt; vlen; i++)\t\t\tprintf(“%d “, len[i]);/\t\tint ans = 0, num1, num2, sum;\t\t//문자열 길이가 2개 이상이면 계속 더해나간다.\t\twhile (vlen &gt; 1) {\t\t\t//문자열 길이가 가장 짧은 2개를 뽑아서 더한다.\t\t\tnum1 = len[vlen - 1];\t\t\tnum2 = len[vlen - 2];\t\t\tlen.pop_back();\t\t\tlen.pop_back();\t\t\tsum = num1 + num2;\t\t\tans += sum;\t\t\t//더한 값 역시 vector에 추가한다.\t\t\tlen.push_back(sum);\t\t\t//vector 길이를 갱신한다.\t\t\tvlen = len.size();\t\t\t//다시 내림차순 정렬을 한다.\t\t\tsort(len.begin(), len.end(), compare);\t\t}\t\tprintf(“%d\\n”, ans);\t\tlen.clear();\t} return 0; }``` HOME ","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-STRJOIN/",
        "teaser":null},{
        "title": "[ALGOSPOT]TRIANGLEPATH",
        "excerpt":"TRIANGLEPATH 문제 링크   https://algospot.com/judge/problem/read/TRIANGLEPATH코드 분석   Bottom-up          DP[y][x] = (y,x)일 때, 최대합      DP[0][0] = triangle[0][0]      DP[y][x] = triangle[y][x] + max(DP[y-1][x], DP[y-1][x-1])      시간복잡도: O(n^2), 부분 문제 수 n^2 * 부분 문제 계산 2        Top-down + 메모이제이션          y, x는 재귀 호출이 풀어야 할 부분 문제를 지정한다. 즉, 이들은 앞으로 풀어야 할 조각들에 대한 정볼르 주는 입력들이다.      path(y,x)는 (y,x)에서 시작해서 맨 아래줄까지 내려가는 부분 경로의 최대합을 반환한다.      점화식: path(y,x) = trinangle[y][x] + max(path(y+1,x), path(y+1, x+1))      시간복잡도: O(n^2), 부분 문제수 n^2 * 부분 문제 계산 시간 M(상수)        최적 부분 구조          동적 계획법의 중요한 요소로서, 어떤 문제와 분할 방식에 성립하는 조건이다.      각 부분 문제의 최적해만 있으면 전체 문제의 최적해를 쉽게 얻어낼 수 있는 경우이다.      대두분의 최적 부분 구조는 직관적으로 이해할 수 있지만, 그렇지 않은 경우는 대게 귀류법이나 대우를 이용해 증명할 수 있다.      결과 코드   Bottom-up```#define _CRT_SECURE_NO_WARNINGS#include #include #include using namespace std;#define N 101int dp[N][N];int tri[N][N];int mj[2] = { -1, 0 };int mi[2] = { -1, -1 }; int main(void){\tint tc;\tscanf(“%d”, &amp;tc);\twhile (tc–) {\t\tmemset(dp, 0, sizeof(dp));\t\tmemset(tri, 0, sizeof(dp));\t\tint n;\t\tscanf(“%d”, &amp;n);\t\tfor (int i = 0; i &lt; n; i++) {\t\t\tfor (int j = 0; j &lt; n; j++) {\t\t\t\tif (j &gt; i)\t\t\t\t\tbreak;\t\t\t\tscanf(“%d”, &amp;tri[i][j]);\t\t\t}\t\t}\t\t//윗 줄부터 차례대로 내려가면서 최대합을 계산한다.\t\tdp[0][0] = tri[0][0];\t\tfor (int i = 1; i &lt; n; i++) {\t\t\tfor (int j = 0; j &lt; n; j++) {\t\t\t\tif (j &gt; i)\t\t\t\t\tbreak;\t\t\t\tfor (int f = 0; f &lt; 2; f++) {\t\t\t\t\tint fi = i + mi[f];\t\t\t\t\tint fj = j + mj[f];\t\t\t\t\tif (fj &gt;= 0 &amp;&amp; fj &lt; i)\t\t\t\t\t\tif (dp[i][j] &lt; (tri[i][j] + dp[fi][fj]))\t\t\t\t\t\t\tdp[i][j] = tri[i][j] + dp[fi][fj];\t\t\t\t}\t\t\t}\t\t}\t\t/for (int i = 0; i &lt; n; i++) {\t\tfor (int j = 0; j &lt; n; j++)\t\tprintf(“%d “, dp[i][j]);\t\tprintf(“\\n”);\t\t}/\t\tint max = 0;\t\tfor (int i = 0; i &lt; n; i++) {\t\t\tif (max &lt; dp[n - 1][i])\t\t\t\tmax = dp[n - 1][i];\t\t}\t\tprintf(“%d\\n”, max);\t} return 0; } ```  Top-down + 메모이제이션```#define _CRT_SECURE_NO_WARNINGS#include #include #include using namespace std;#define N 100#define max(a,b) ((a)&gt;(b)?(a):(b))int n, triangle[N][N];int cache[N][N]; //(y, x) 위치부터 맨 아래줄까지 내려가면서 얻을 수 있는 최대 경로의 합을 반환한다.int path(int y, int x){\t//기저 사례: 맨 아래 줄까지 도달했을 경우\tif (y == n - 1) return triangle[y][x];\t//메모이제이션\tint &amp; ret = cache[y][x];\tif (ret != -1) return ret;\treturn ret = max(path(y + 1, x), path(y + 1, x + 1))\t\t+ triangle[y][x];} int main(void){\tint tc;\tscanf(“%d”, &amp;tc);\twhile (tc–) {\t\tmemset(triangle, 0, sizeof(triangle));\t\tmemset(cache, -1, sizeof(cache));\t\tscanf(“%d”, &amp;n);\t\tfor (int i = 0; i &lt; n; i++) {\t\t\tfor (int j = 0; j &lt; n; j++) {\t\t\t\tif (j &gt; i) break;\t\t\t\tscanf(“%d”, &amp;triangle[i][j]);\t\t\t}\t\t}\t\tprintf(“%d\\n”, path(0, 0));\t} return 0; } ```결과 분석   Bottom-up          시간: 12ms        Top-down + 메모이제이션          시간: 8ms      HOME ","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-TRIANCLEPATH/",
        "teaser":null},{
        "title": "[ALGOSPOT]WILDCARD",
        "excerpt":"WILDCARD 문제 링크   https://algospot.com/judge/problem/read/WILDCARD코드 분석 완전 탐색: 4가지 경우   s[pos]와 w[pos]가 대응되지 않는다.: 대응 실패  w 끝에 도달했다.: 패턴에 *가 하나도 없는 경우, 패턴과 문자열의 길이가 정확히 같아야 대응 할 수 있다.  s 끝에 도달했다.: 패턴은 남아있지만 문자열은 끝난 경우, 남은 패턴이 모두 *면 대응 가능하지만 아니면 대응 실패이다.  w[pos]가 *인 경우: *가 몇 글자에 대응될지 모르기 때문에, 0 글자부터 남은 문자열의 길이까지를 순회하며 모든 가능성을 검사해야한다.이때 w는 pos+1이후를 패턴 w’으로 하고, s의 pos + skip(현재 인덱스(pos) 이후 문자열 끝까지) 이후를 문자열 s’로 하여 match(w’, s’)로 재귀 호출했을 때 답이 하나라도 참이면 대응 가능하다.DP   w와 s는 각각 최대 101개이다.  match()가 101 * 101 = 10201번 이상 호출되었다면 비둘기집의 원리에 따라 어떤 부분 문제가 반드시 여러 번 계산되고 있다는 뜻이다.  중복되는 계산은 메모이제이션을 사용하여 해결 가능하다.  w는 항상 전체 패턴 W의 접미사이기 때문에 w의 길이가 결정되면 w 또한 결정된다. 이를 이용하여 101 X 101 크기의 배열에 모든 부분 문제를 저장할 수 있다.결과 코드   완전 탐색#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;#define N 1001vector&lt;string&gt; res;//와일드카드 패턴 w가 문자열 s에 대응되는지 여부를 반환한다.bool match(const string &amp;w, const string &amp;s){\t//w[pos]와 s[pos]를 맞춰나간다.\tint pos = 0;\twhile (pos &lt; (int)s.size() &amp;&amp; pos &lt; (int)w.size() &amp;&amp;\t\t(w[pos] == '?' || w[pos] == s[pos]))\t\t++pos;\t//더이상 대응할 수 없으면 왜 while문이 끝났는지 확인한다.\t//2. 패턴 끝에 도달해서 끝난 경우: 문자열도 끝났어야 대응됨\tif (pos == w.size())\t\treturn pos == s.size();\t//4. *를 만나서 끝난 경우: *에 몇 글자를 대응해야 할지 재귀 호출하면서 확인한다.\tif (w[pos] == '*')\t\tfor (int skip = 0; pos + skip &lt;= (int)s.size(); ++skip)\t\t\t//하나라도 대응되는 것이 있으면 TRUE 반환\t\t\tif (match(w.substr(pos + 1), s.substr(pos + skip)))\t\t\t\treturn true;\t//이 외의 경우에는 모두 대응되지 않는다.\treturn false;}int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tstring wild;\t\tcin &gt;&gt; wild;\t\tint n;\t\tscanf(\"%d\", &amp;n);\t\twhile (n--) {\t\t\tstring file;\t\t\tcin &gt;&gt; file;\t\t\tif (match(wild, file))\t\t\t\tres.push_back(file);\t\t}\t\tsort(res.begin(), res.end());\t\tfor (int i = 0; i &lt; (int)res.size(); i++)\t\t\tcout &lt;&lt; res[i] &lt;&lt; endl;\t\tres.clear();\t}\treturn 0;}  DP#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;#define N 101vector&lt;string&gt; res;//-1: 아직 답이 계산되지 않음//1: 해당 입력들이 서로 대응됨//0: 해당 입력들이 서로 대응되지 않음int cache[N][N];//패턴과 문자열string W, S;//와일드카드 패턴 W[w...]가 문자열 S[s...]에 대응되는지 여부를 반환int matchMemoized(int w, int s){\t//메모이제이션\tint &amp;ret = cache[w][s];\tif(ret != -1) return ret;\t//W[w]와 S[s]를 맞춰나간다.\twhile (s &lt; (int)S.size() &amp;&amp; w &lt; (int)W.size() &amp;&amp;\t\t(W[w] == '?' || W[w] == S[s])) {\t\t++w;\t\t++s;\t}\t//더이상 대응할 수 없으면 왜 while문이 끝났는지 확인한다.\t//2. 패턴 끝에 도달해서 끝난 경우: 문자열도 끝났어야 참이다.\tif (w == W.size()) return ret = (s == (int)S.size());\t//4. *를 만나서 끝난 경우: *에 몇 글자를 대응해야 할지 재귀 호출하면서 확인한다.\tif (W[w] == '*')\t\tfor (int skip = 0; skip + s &lt;= (int)S.size(); ++skip)\t\t\tif (matchMemoized(w + 1, s + skip))\t\t\t\treturn ret = 1;\t//3. 이 외의 경우에는 모두 대응되지 않는다.\treturn ret = 0;}int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tcin &gt;&gt; W;\t\tint n;\t\tscanf(\"%d\", &amp;n);\t\twhile (n--) {\t\t\tmemset(cache, -1, sizeof(cache));\t\t\tcin &gt;&gt; S;\t\t\tif (matchMemoized(0, 0))\t\t\t\tres.push_back(S);\t\t\tS.clear();\t\t}\t\tsort(res.begin(), res.end());\t\tfor (int i = 0; i &lt; (int)res.size(); i++)\t\t\tcout &lt;&lt; res[i] &lt;&lt; endl;\t\tres.clear();\t\tW.clear();\t}\treturn 0;}결과 분석   완전 탐색          소요 시간: 44ms        DP          소요 시간: 4ms      ","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-WILDCARD/",
        "teaser":null},{
        "title": "[ALGOSPOT]WORDCHAIN",
        "excerpt":"단어 제한 끝말잇기 문제 링크   https://algospot.com/judge/problem/read/WORDCHAIN코드 분석 1. 해밀토니안 경로(Hamiltonian path)   그래프의 모든 정점을 정확히 한 번씩 지나는 경로  해밀토니안 경로를 찾는 유일한 방법은 조합 탐색으로, 모든 정점의 배열을 하나하나 시도하며 이들이 경로가 되는지 확인하는 것이다.          시간 복잡도: 최악의 경우 O(N!)이다.      이 문제 최대 크기인 100인 경우 100!이므로, 시간안에 절대 해결할 수 없다.        예제 그림   구현 코드#define N 101bool check[N];int adj[N][N];vector&lt;string&gt; sv, ans;int n;//행의 마지막 글자가 열의 첫 번째 글자와 일치하면 1값을 넣어,//각각 단어를 이을 수 있는 지를 그래프로 표현한다.(인접 행렬)void makeAdj() {\tfor (int i = 0; i &lt; n; ++i)\t\tfor (int j = 0; j &lt; n; ++j)\t\t\tif (i != j) {\t\t\t\tchar iBackCh = sv[i][(int)sv[i].size() - 1];\t\t\t\tchar jFrontCh = sv[j][0];\t\t\t\tif (iBackCh == jFrontCh)\t\t\t\t\tadj[i][j] = 1;\t\t\t}}//단어 정점을 하나씩 방문하며 경로가 되는지 검사한다.(DFS)bool dfs(int here) {\tcheck[here] = true;\tans.push_back(sv[here]);\tbool flag = true;\tfor (int j = 0; j &lt; n; ++j)\t\tif (!check[j]) {\t\t\tflag = false;\t\t\tbreak;\t\t}\tif (flag) return true;\tfor (int there = 0; there &lt; n; ++there) {\t\tif (!check[there] &amp;&amp; adj[here][there]) {\t\t\tif (dfs(there)) return true;\t\t\tcheck[there] = false;\t\t}\t}\treturn false;}//모든 정점에서 경로를 만들 수 있는지 검사한다.bool dfsAll() {\tmakeAdj();\tfor (int i = 0; i &lt; n; ++i) {\t\tmemset(check, false, sizeof(check));\t\tans.clear();\t\tif (dfs(i))\t\t\treturn true;\t}\treturn false;}2. 오일러 트레일 혹은 서킷   입력으로 주어진 각 단어를 정점이 아닌 간선으로 갖는 방향 그래프를 만든다.  각 정점은 알파벳으로 이루어져 있고, 각 단어의 첫글자에서 마지막 글자로 가는 간선을 만든다.   위 그림에서와 같은 그래프에서 오일러 트레일 혹은 서킷을 활용하면, 답이 될 수 있는 것을 알 수 있다.  오일러 서킷 및 트레일의 자세한 내용은 링크: (추가 예정)  방향 그래프에서의 오일러 서킷          무향 그래프에서는 각 정점에서ㅓ 인접하나 간선이 짝수 개여야 하지만, 방향 그래프에서는 둘 중 한 방향만 쓸 수 있기 때문에 각 정점에 들어오는 간선의 수와 나가는 간선의 수가 같아야 한다.      방향 그래프에서 오일러 서킷을 통해 오일러 트레일(a에서 시작, b에 도착)을 찾는 방법                  간선 (b, a)를 추가 한다.          정점 a에서는 나가는 간선이 들어오는 간선보다 하나 많고, 정점 b는 들어오는 간선이 나가는 간선보다 하나 많아야 한다.          위 두 정점을 제외한 나머지 정점은 나가는 간선과 들어오는 간선의 수가 같아야 한다.                      구현 코드#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;/* 끝말잊기 문제의 입력을 그래프로 만들기*///그래프의 인점 행렬 표현, adj[i][j] = i와 j사이의 간선의 수vector&lt;vector&lt;int&gt;&gt; adj;//graph[i][j] = i로 시작해서 j로 끝나는 단어의 수vector&lt;string&gt; graph[26][26];//indegree[i] = i로 시작하는 단어의 수//outdegree[i] = i로 끝나는 단어의 수vector&lt;int&gt; indegree, outdegree;void makeGraph(const vector&lt;string&gt; &amp;words) {\t//전역 변수 초기화\tfor (int i = 0; i &lt; 26; ++i)\t\tfor (int j = 0; j &lt; 26; ++j)\t\t\tgraph[i][j].clear();\tadj = vector&lt;vector&lt;int&gt;&gt;(26, vector&lt;int&gt;(26, 0));\tindegree = outdegree = vector&lt;int&gt;(26, 0);\t//각 단어를 그래프에 추가한다.\tfor (int i = 0; i &lt; words.size(); ++i) {\t\tint a = words[i][0] - 'a';\t\tint b = words[i][words[i].size() - 1] - 'a';\t\tgraph[a][b].push_back(words[i]);\t\tadj[a][b]++;\t\toutdegree[a]++;\t\tindegree[b]++;\t}}/* 방향 그래프에서 오일러 서킷 혹은 트레일 찾아내기 *///유향 그래프의 인접 행렬 adj가 주어질 때 오일러 서킷 혹은 트레일을 계산한다.void getEulerCircuit(int here, vector&lt;int&gt; &amp;circuit) {\tfor (int there = 0; there &lt; adj.size(); ++there)\t\twhile (adj[here][there] &gt; 0) {\t\t\tadj[here][there]--;  //간선을 지운다\t\t\tgetEulerCircuit(there, circuit);\t\t}\tcircuit.push_back(here);}//현재 그래프의 오일러 트레일이나 서킷을 반환한다.vector&lt;int&gt; getEulerTrailOrCircuit() {\tvector&lt;int&gt; circuit;\t//우선 트레일을 찾아본다: 시작점이 존재하는 경우\tfor(int i = 0; i &lt; 26; ++i)\t\tif (outdegree[i] == indegree[i] + 1) {\t\t\tgetEulerCircuit(i, circuit);\t\t\treturn circuit;\t\t}\t//아니면 서킷이니, 간선에 인접한 아무 정점에서나 시간한다.\tfor(int i = 0; i &lt; 26; ++i)\t\tif (outdegree[i]) {\t\t\tgetEulerCircuit(i, circuit);\t\t\treturn circuit;\t\t}\t//모두 실패한 경우 빈 배열을 반환한다.\treturn circuit;}/* 끝말잇기 문제를 오일러 트레일 문제로 바꿔 해결하는 알고리즘 */string solve(const vector&lt;string&gt; &amp;words) {\tmakeGraph(words);\t//오일러 서킷이나 트레일으르 찾아낸다.\tvector&lt;int&gt; circuit = getEulerTrailOrCircuit();\t//모든 간선을 방문하지 못했으면 실패\tif (circuit.size() != words.size() + 1) return \"IMPOSSIBLE\";\t//아닌 경우 방문 순서를 뒤집은 뒤 간선들을 모아 문자열로 만들어 반환한다.\treverse(circuit.begin(), circuit.end());\tstring ret;\tfor (int i = 1; i &lt; circuit.size(); ++i) {\t\tint a = circuit[i - 1], b = circuit[i];\t\tif (ret.size()) ret += \" \";\t\tret += graph[a][b].back();\t\tgraph[a][b].pop_back();\t}\treturn ret;}int main(){\tint tc; scanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tvector&lt;string&gt; sv;\t\tint n;  scanf(\"%d\", &amp;n);\t\tfor (int i = 0; i &lt; n; ++i) {\t\t\tstring str;\t\t\tcin &gt;&gt; str;\t\t\tsv.push_back(str);\t\t}\t\tcout &lt;&lt; solve(sv) &lt;&lt; endl;\t}\treturn 0;}예외 사항   위 오일러 서킷 및 트레일 코드에 예외 사항이 발생한다.          결과는 정답으로 나온다.        getEulerCircuit()함수에서 갈 수 없는 경로를 가는 경우가 발생하여 vector에 추가하지 못하는데, solve()함수에서 정답을 출력하려 하기 때문에 존재하지 않는 vector 인덱스에 접근하여 오류로 강제 종료된다.  예외 테스트 케이스15goddoggunnewnurse  나중에 수정 및 해결 해볼것…","categories": ["PS"],
        "tags": ["Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/ps/ALGOSPOT-WORDCHAIN/",
        "teaser":null}]
