var store = [{
        "title": "[ALGOSPOT]DRAGON",
        "excerpt":"Dragon 문제 링크   https://algospot.com/judge/problem/read/DRAGON코드 분석 k번째 답을 계산하는 동적 계획법   더 간단한 문제 풀기          드래곤 커브 문자열의 일부를 계산하는 문제 대신 문자열 중 주어진 위치의 한 글자만을 계산하는 문제로 바꾼다.      이 문제를 빠르게 풀 수 있다면 l번 반복만 한다면 문제를 해결할 수 있다.      결과적으로, n세대 드래곤 커브의 p번째 글자를 찾는 것으로 변경한다.        p번째 글자를 찾는 함수          먼저 전체 드래곤 커브 문자열을 생성하는 알고리즘을 재귀적인 방법으로 구현한다.      curve(seed, generations) = 초기 문자열 seed를 generations세대 진화시킨 결과를 출력한다.      위 함수에서 p번째 글자만을 출력하기 위해 skip 전역변수(건너뛰어야 하는 글자 수)를 두어, 문자열 혹은 문자를 출력할 때마다 skip과 출력할 부분의 길이를 비교한다.        계산 결과 미리 계산하기(동적 계획법)          p번째 글자를 출력하는 재귀 호출 코드를 최적화하려면, 재귀 호출 때마다 몇 글자를 출력할지를 미리 알고 skip과 이 값을 비교할 수 있어야 한다.      genrations 세대 값의 크기에 상관 없이, 이전 세대의 드래곤 커브를 계속 유지하며 확장하기 때문에 skip 값의 길이 만큼의 generations 세대까지만 가면 된다.      curve(seed, generations)함수에서 seed는 ‘X+TF’ 혹은 ‘FX-Y’로 확장하기 때문에 간단히 동적 계획법 알고리즘을 만들 수 있다.                  xLength(n) = 문자열 “X”를 n세대  진화시킨 결과의 길이 반환          yLength(n) = 문자열 “Y”를 n세대  진화시킨 결과의 길이 반환          xLength(n) = xLength(n - 1) + yLength(n - 1) + 2          yLength(n) = xLength(n - 1) + yLength(n - 1) + 2          최적화: length(n) = length(n - 1) * 2 + 2                      시간 복잡도          재귀 호출 함수가 최대 n번 호출되고, 출력 길이 l의 최대 값이 50이므로, O(n * 50)이다.      결과적으로, O(n)이다.      결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cassert&gt;using namespace std;#define min(a,b) ((a) &lt; (b) ? (a) : (b))#define N 51//오버 플로 방지const int MAX = 1000000000 + 51;//length[i] = X나 Y를 i번 치환 후의 길이int length[N];//계산 결과를 미리 계산하는 동적 계획법 알고리즘void precalc() {\tlength[0] = 1;\tfor (int i = 1; i &lt; N; ++i)\t\tlength[i] = min(MAX, length[i - 1] * 2 + 2);}const string EXPAND_X = \"X+YF\";const string EXPAND_Y = \"FX-Y\";//dragonCurve를 generations 진화시킨 결과에서 skip번째 문자를 반환한다.char expand(const string &amp;dragonCurve, int generations, int skip) {\t//기저 사례\tif (generations == 0) {\t\t//assert(skip &lt; (int)dragonCurve.size());\t\treturn dragonCurve[skip];\t}\tfor (int i = 0; i &lt; (int)dragonCurve.size(); ++i) {\t\t//문자열이 확장되는 경우\t\tif (dragonCurve[i] == 'X' || dragonCurve[i] == 'Y') {\t\t\tif (skip &gt;= length[generations])\t\t\t\tskip -= length[generations];\t\t\telse if (dragonCurve[i] == 'X')\t\t\t\treturn expand(EXPAND_X, generations - 1, skip);\t\t\telse\t\t\t\treturn expand(EXPAND_Y, generations - 1, skip);\t\t}\t\t//확장되진 않지만 건너뛰어야 할 경우\t\telse if (skip &gt; 0)\t\t\t--skip;\t\t//답을 찾은 경우\t\telse\t\t\treturn dragonCurve[i];\t}\treturn '#';  //이 줄은 수행되지 않음}int main(){\tint tc; scanf(\"%d\", &amp;tc);\tprecalc();\twhile (tc--) {\t\tint n, p, l; scanf(\"%d %d %d\", &amp;n, &amp;p, &amp;l);\t\tstring seed = \"FX\";\t\tfor (int skip = p - 1; skip &lt; p + l - 1; ++skip)\t\t\tprintf(\"%c\", expand(seed, n, skip));\t\tprintf(\"\\n\");\t}\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/ALGOSPOT-DRAGON/",
        "teaser":null},{
        "title": "[ALGOSPOT]ARCTIC",
        "excerpt":"남극 기지 문제 링크   https://algospot.com/judge/problem/read/ARCTIC코드 분석 1. 최적화 문제 결정 문제로 바꿔 풀기   최적화 문제: optimize(P)          P에 주어진 기지들을 모두 연결하는 연락망을 구축할 때 가능한 최소 무전기 반경은 얼마인가?      기지들을 모두 연결하는 연락망의 경우의 수는 매우 많으며, 이 중 무전기의 반경 d가 최소화되는 답을 찾고 있으므로 이 문제는 최적화 문제이다.        결정 문제: decision(P, d)          모든 기지를 하나로 연결하되, 가장 먼 두 가지 간의 거리가 d 이하인 연락망이 있는가?      이 질문은 “x 또는 그보다 좋은 답이 있는가?”의 형태를 유지하고 있다.      이 질문의 구현은 서로 거리가 d 이하인 기지들이 하나로 연결될 수 있는지를 확인한다.                  너비 우선 탐색 알고리즘          두 기지 사이의 거리를 이용하는 암시적 그래프를 탐색한다.                      시간 복잡도          너비 우선 탐색의 시간 복잡도: O(V + E)      거리 계산: O(n^2)      결과적으로, O(n^2)이다.      2. 다른 해법   크루스칼의 최소 스패닝 알고리즘  플로이드의 모든 쌍 최단 거리 알고리즘결과 코드   최적화 문제 결정문제로 바꿔 풀기#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;#define abs(a) ((a) &gt; 0 ? (a) : (-1 * a))#define N 101vector&lt;pair&lt;double, double&gt;&gt; bsv;double dist[N][N];int n;//두 기지 사이 거리 계산double calcDist(int b1, int b2) {\tdouble dy = (bsv[b1].first - bsv[b2].first) *\t\t(bsv[b1].first - bsv[b2].first);\tdouble dx = (bsv[b1].second - bsv[b2].second) *\t\t(bsv[b1].second - bsv[b2].second);\treturn sqrt(dy + dx);}//거리 d인하인 기지들만을 연결했을 때 모든 기지가 연결되는지 여부를 반환한다.bool decision(double d) {\tvector&lt;bool&gt; visited(n, false);\tvisited[0] = true;\tqueue&lt;int&gt; q;\tq.push(0);\tint seen = 0;\twhile (!q.empty()) {\t\tint here = q.front();\t\tq.pop();\t\t++seen;\t\tfor(int there = 0; there &lt; n; ++there)\t\t\tif (!visited[there] &amp;&amp; dist[here][there] &lt;= d) {\t\t\t\tvisited[there] = true;\t\t\t\tq.push(there);\t\t\t}\t}\treturn seen == n;}//모든 기지를 연결할 수 있는 최소 d를 반환한다.double optimize() {\tdouble lo = 0, hi = 1416.00;\tfor (int it = 0; it &lt; 100; ++it) {\t\tdouble mid = (lo + hi) / 2;\t\t//mid가 가능하다면, 더 좋은(작은) 답을 찾는다.\t\tif (decision(mid))\t\t\thi = mid;\t\t//mid가 불가능하다면, 더 나쁜(큰) 답을 찾는다.\t\telse\t\t\tlo = mid;\t}\treturn hi;}int main(){\tint tc; scanf(\"%d\", &amp;tc);\twhile(tc--) {\t\tbsv.clear();\t\tmemset(dist, 0, sizeof(dist));\t\tscanf(\"%d\", &amp;n);\t\tfor (int i = 0; i &lt; n; i++) {\t\t\tdouble y, x; scanf(\"%lf %lf\", &amp;y, &amp;x);\t\t\tbsv.push_back({ y, x });\t\t}\t\tfor (int i = 0; i &lt; n; i++)\t\t\tfor (int j = 0; j &lt; n; j++)\t\t\t\tdist[i][j] = calcDist(i, j);\t\tprintf(\"%.2lf\\n\", optimize());\t}\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/ALGOSPOT-ARCTIC/",
        "teaser":null},{
        "title": "[ALGOSPOT]ASYMTILING",
        "excerpt":"비대칭 타일링 문제 링크   https://algospot.com/judge/problem/read/ASYMTILING](https://algospot.com/judge/problem/read/ASYMTILING)코드 분석 전체 타일링 경우의 수 - 대칭 타일링 경우의 수   전체 타일링 경우의 수는 쉽게 구할 수 있다.  비대칭 타일링 경우의 수를 찾는 것 보다 대칭 타일링 경우의 수를 찾는 것이 더욱 간단하다.   n이 홀수인 경우, 위 그림의 (a)에 해당한다.  n이 짝수인 경우, 위 그림의 (b)와 (c)에 해당한다.  회색부분은 양쪽이 대칭이기 때문에 한 부분의 경우의 수만 빼주면 된다.  두 값을 빼줄 때, mod계산에 주의하자!  시간복잡도: 전체 타일링의 경우의 수 O(n) + 대칭 타일링 경우의 수 O(n) = 총 O(n) 이다.비대칭 타일링 경우의 수   총 4가지 패턴의 비대칭 방법이 있다.   (a), (b): 가운데 남은 회색 부분을 덮은 방법을 재귀 호출로 찾는다. 물론 이 방법은 대칭이 아니어야 한다.  (c), (d): 가운데 남은 회색 부분을 덮는 방법을 찾으며, 이는 대칭이어도 상관없다.  시간복잡도: O(n)  답이 제대로 나오지 않음 - 보류…결과 코드   전체 타일링 경우의 수 - 대칭 타일링 경우의 수#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define N 101#define M 1000000007int tile[N];int asymmetric(int width){\tif (width % 2 == 1)  //(a)\t\treturn (tile[width] - tile[width / 2] + M) % M;\tint ret = tile[width];\tret = (ret - tile[width / 2 - 1] + M) % M;  //(b)\tret = (ret - tile[width / 2] + M) % M;      //(c)\treturn ret;}int main(void){\t//전체 타일링 경우의 수 구하기\ttile[1] = 1; tile[2] = 2;\tfor (int i = 3; i &lt; N; i++)\t\ttile[i] = (tile[i - 1] % M + tile[i - 2] % M) % M;\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tint n;\t\tscanf(\"%d\", &amp;n);\t\tif (n == 1 || n == 2)\t\t\tprintf(\"0\\n\");\t\telse\t\t\tprintf(\"%d\\n\", asymmetric(n));\t}\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/ALGOSPOT-ASYMTILNG/",
        "teaser":null},{
        "title": "[ALGOSPOT]BOARDCOVER",
        "excerpt":"BOARDCOVER 문제 링크   https://algospot.com/judge/problem/read/BOARDCOVER내 코드 분석 논리 분석   한 칸에 8개의 L자 모양을 만들 수 있다.  재귀 함수를 이용하여, 전체 경우의 수를 계산한다.  하지만, 아직 재귀 함수가 익숙하지 않아 완성하지 못하였다.  재귀 함수 공부를 위해 다른 방법은 생각하지 않았다.해답 논리 분석   재귀 호출의 각 단계마다 아직 흰 칸중에서 가장 윗 줄, 가장 왼쪽 칸부터 덮도록 규칙을 정한다.  위 규칙을 적용하면, 위에서 정한 칸 이전은 모두 채워졌다는 것을 알 수 있으므로 내가 생각했던 8가지 모양이 아니라 4가지 모양이 나온다. (아래 그림 참고) 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;//주어진 칸을 덮을 수 있는 네 가지 방법//블록을 구성하는 세 칸의 상대적 위치 (dy, dx)의 목록(위 그림 참고)const int coverType[4][3][2] = {\t{ { 0, 0 },{ 1, 0 },{ 0, 1 } },\t{ { 0, 0 },{ 0, 1 },{ 1, 1 } },\t{ { 0, 0 },{ 1, 0 },{ 1, 1 } },\t{ { 0, 0 },{ 1, 0 },{ 1, -1 } }};//board의 (y, x)를 type번 방법으로 덮거나, 덮었던 블록을 없앤다.//delta = 1이면 덮고, -1이면 덮었던 블록을 없앤다.//만약 블록이 제대로 덮이지 않은 경우(게임판 밖으로 나가거나, 겹쳐지거나, 검은 칸일 때) false를 반환한다.bool set(vector&lt;vector&lt;int&gt;&gt;&amp;board, int y, int x, int type, int delta){\tbool ok = true;\tfor (int i = 0; i &lt; 3; i++) {\t\tconst int ny = y + coverType[type][i][0];\t\tconst int nx = x + coverType[type][i][1];\t\tif (ny &lt; 0 || ny &gt;= (int)board.size() || nx &lt; 0 || nx &gt;= (int)board[0].size())\t\t\tok = false;\t\telse if ((board[ny][nx] += delta) &gt; 1)\t\t\tok = false;\t}\treturn ok;}//board의 모든 빈 칸을 덮을 수 있는 방법의 수를 반환한다.//board[i][j] = 1 이미 덮인 칸 혹은 검은 칸//board[i][j] = 0 아직 덮이지 않은 칸int cover(vector&lt;vector&lt;int&gt;&gt;&amp;board){\t//아직 채우지 못한 칸 중 가장 윗줄 왼쪽에 있는 칸을 찾는다.\tint y = -1, x = -1;  //flag 기능을 추가하기 위해 -1로 초기화\tfor (int i = 0; i &lt; (int)board.size(); i++) {\t\tfor (int j = 0; j &lt; (int)board[i].size(); j++) {\t\t\tif (board[i][j] == 0) {\t\t\t\ty = i;\t\t\t\tx = j;\t\t\t\tbreak;\t\t\t}\t\t}\t\tif (y != -1) break;\t}\t//기저 사례: 모든 칸을 채웠으면 1을 반환한다.\tif (y == -1) return 1;\tint ret = 0;\tfor (int type = 0; type &lt; 4; type++) {\t\t//만약 board[y][x]를 type 형태로 덮을 수 있으면 재귀 호출한다.\t\tif (set(board, y, x, type, 1))\t\t\tret += cover(board);\t\t//덮었던 블록을 치운다.\t\tset(board, y, x, type, -1);\t}\treturn ret;}int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tvector&lt;vector&lt;int&gt;&gt; board;\t\tvector&lt;int&gt; v;\t\tchar row[21];\t\tint h, w;\t\tscanf(\"%d %d\", &amp;h, &amp;w);\t\tfor (int i = 0; i &lt; h; i++) {\t\t\tscanf(\"%s\", row);\t\t\tfor (int j = 0; j &lt; w; j++) {\t\t\t\tif (row[j] == '#')\t\t\t\t\tv.push_back(1);\t\t\t\telse\t\t\t\t\tv.push_back(0);\t\t\t}\t\t\tboard.push_back(v);\t\t\tv.clear();\t\t}\t\t/*for (int i = 0; i &lt; (int)board.size(); i++) {\t\t\tfor (int j = 0; j &lt; (int)board[i].size(); j++) {\t\t\t\tprintf(\"%d \", board[i][j]);\t\t\t}\t\t\tprintf(\"\\n\");\t\t}*/\t\tprintf(\"%d\\n\", cover(board));\t}\treturn 0;}결과 및 코드 분석   수행 시간: 0ms  최대 시간 복잡도: 블록을 하나 놓을 때마다 4가지 선택지가 있다. 최대 16개의 블록을 놓기 때문에 가능한 최대 연산 수는 4^16(2^32)으로시간내에 불가능하게 느껴진다. 하지만 6칸이 있다고 가정하면, 4^2으로 16가지 방법이 있어야 하는데 실제로 계산하면 2가지 방법밖에 없다.이렇게 프로그램을 작성하고 직접 여러 예제를 넣어 이론과 다른 실제 시간복잡도를 계산할 수 있어야 한다.알아둘 점 1) 재귀를 구현하는 논리 흐름2) 이중 Vector 함수   사용법 (위 main함수 참고)vector&lt;vector&lt;int&gt;&gt; board;vector&lt;int&gt; v;char row[21];int h, w;scanf(\"%d %d\", &amp;h, &amp;w);for (int i = 0; i &lt; h; i++) {\t\tscanf(\"%s\", row);\t\tfor (int j = 0; j &lt; w; j++) {\t\t\tif (row[j] == '#')\t\t\t\tv.push_back(1);\t\t\telse\t\t\t\tv.push_back(0);\t\t}\t\tboard.push_back(v);\t\tv.clear();}  장점          크기를 지정하지 않고 입력을 줄 수 있다.      STL이기 때문에 효율성을 보장받을 수 있다.      ","categories": ["Algorithm"],
        "tags": ["Algorithm_Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/ALGOSPOT-BOARDCOVER/",
        "teaser":null},{
        "title": "[ALGOSPOT]BOGGLE",
        "excerpt":"BOGGLE 문제 링크   https://algospot.com/judge/problem/read/BOGGLE내 코드 분석 논리 분석   char 형인 알파벳을 아스키 코드값을 이용하여 int형으로 사용한다.  check 배열을 선언하여 5 x 5 배열입력에서 사용된 알파벳을 저장하여 문자 입력 시 5 x 5 배열에 없는 알파벳이 있을 경우 바로 ‘NO’를 출력한다.(시간복잡도를 줄이기 위함)  BFS를 활용하여 문자가 5 x 5배열에서 만들어질 수 있는지 판단한다.  check_cnt 배열은 BFS 수행과정에서 해당 문자의 다음 알파벳을 비교하기 위해 수행과정에서의 문자 길이를 갱신한다.구현 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;#define N 26bool check[N];  // 5 x 5 맵에 입력된 알파벳 종류 확인int check_cnt[5][5];  // BFS에서 다음 문자 알파벳을 판단하기 위한 2차원 배열int map[5][5];  // 5 x 5 알파벳을 입력할 2차원 배열int word[11];  // 문자를 저장할 배열int mx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };int my[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };void init(void){\tfor (int i = 0; i &lt; 5; ++i)\t\tfor (int j = 0; j &lt; 5; ++j)\t\t\tmap[i][j] = 0;\tfor (int i = 0; i &lt; N; ++i)\t\tcheck[i] = false;\tfor (int i = 0; i &lt; 11; ++i)\t\tword[i] = -1;\tfor (int i = 0; i &lt; 5; ++i)\t\tfor (int j = 0; j &lt; 5; ++j)\t\t\tcheck_cnt[i][j] = 0;}void init_cnt(void){\tfor (int i = 0; i &lt; 5; ++i)\t\tfor (int j = 0; j &lt; 5; ++j)\t\t\tcheck_cnt[i][j] = 0;}int main(void){\tint tc;\tcin &gt;&gt; tc;\t//scanf(\"%d\", &amp;tc);\t//while (getchar() != '\\n');  //입력 버퍼에서 엔터 지우기\twhile (tc--) {\t\tinit();  //다음 테스트 케이스를 위한 초기화\t\tfor (int i = 0; i &lt; 5; ++i) {  // 5 x 5 알파벳 배열 입력\t\t\tfor (int j = 0; j &lt; 5; ++j) {\t\t\t\tchar alph;\t\t\t\t//scanf(\"%c\", &amp;alph);\t\t\t\tcin &gt;&gt; alph;\t\t\t\tmap[i][j] = alph - 'A';  //char -&gt; int 로 사용하기 위함\t\t\t\tif (!check[alph - 'A'])  \t\t\t\t\tcheck[alph - 'A'] = true;\t\t\t}\t\t\t//while (getchar() != '\\n');\t\t}\t\tint n;\t\tcin &gt;&gt; n;\t\t//scanf(\"%d\", &amp;n);\t\t//while (getchar() != '\\n');\t\tint str_len;  //단어 길이\t\tbool flag = false;  // 단어를 맵에서 찾을 수 있으면 TRUE, 못 찾으면 FALSE\t\tpair&lt;int, int&gt; p;  //큐에 2차원 배열 인덱스를 저장하기 위한 pair\t\tqueue&lt;pair&lt;int, int&gt;&gt; q;  //BFS를 위한 큐\t\tfor (int i = 0; i &lt; n; ++i) {\t\t\tfor (int ii = 0; ii &lt; 11; ++ii)  //단어 입력 초기화\t\t\t\tword[ii] = -1;\t\t\tflag = false;\t\t\tchar inputW[11];\t\t\tcin &gt;&gt; inputW;\t\t\t//scanf(\"%s\", inputW);\t\t\t//while (getchar() != '\\n');\t\t\tstr_len = strlen(inputW);\t\t\tfor (int j = 0; j &lt; str_len; ++j)\t\t\t\tword[j] = inputW[j] - 'A';\t\t\tfor (int j = 0; j &lt; str_len; ++j) {  //map에 알파벳이 없을 때 바로 NO출력하고 다음 단어\t\t\t\tif (!check[word[j]]) {\t\t\t\t\tfor (int l = 0; l &lt; str_len; ++l)\t\t\t\t\t\tprintf(\"%c\", word[l] + 'A');\t\t\t\t\tprintf(\" NO\\n\");\t\t\t\t\tflag = true;\t\t\t\t}\t\t\t\tif (flag) break;\t\t\t}\t\t\tif (str_len == 1 &amp;&amp; check[word[0]]) {  //문자 길이가 1일 때 처리\t\t\t\tfor (int ll = 0; ll &lt; str_len; ++ll)\t\t\t\t\tprintf(\"%c\", word[ll] + 'A');\t\t\t\tprintf(\" YES\\n\");\t\t\t\tflag = true;\t\t\t}\t\t\tif (flag) continue;  //문자 판단이 끝났으므로 다음으로 넘어감\t\t\tflag = false;\t\t\tfor (int j = 0; j &lt; 5; ++j) {\t\t\t\tfor (int k = 0; k &lt; 5; ++k) {\t\t\t\t\tif (map[j][k] == word[check_cnt[j][k]]) {  // 5 x 5 배열중 문자의 첫 알파벳 위치\t\t\t\t\t\tp = make_pair(j, k);\t\t\t\t\t\tq.push(p);  //큐에 삽입\t\t\t\t\t\twhile (!q.empty()) {\t\t\t\t\t\t\tint nowx = q.front().second;\t\t\t\t\t\t\tint nowy = q.front().first;\t\t\t\t\t\t\tq.pop();\t\t\t\t\t\t\tfor (int l = 0; l &lt; 8; ++l) {  // 8방향으로 모두 체크\t\t\t\t\t\t\t\tint nextx = nowx + mx[l];\t\t\t\t\t\t\t\tint nexty = nowy + my[l];\t\t\t\t\t\t\t\tif (!flag &amp;&amp; nextx &gt;= 0 &amp;&amp; nextx &lt; 5 &amp;&amp; nexty &gt;= 0 &amp;&amp; nexty &lt; 5) {  // 5 x 5 배열 밖으로 나갔는지 체크\t\t\t\t\t\t\t\t\tif (word[check_cnt[nowy][nowx] + 1] != -1 &amp;&amp; map[nexty][nextx] == word[check_cnt[nowy][nowx] + 1]) {  // 다음 알파벳과 일치하면\t\t\t\t\t\t\t\t\t\tcheck_cnt[nexty][nextx] = check_cnt[nowy][nowx] + 1;  // 현재 문자열 길이 갱신\t\t\t\t\t\t\t\t\t\tif ((check_cnt[nexty][nextx] + 1) == str_len) {  // 현재 체크중인 문자열 길이와 최종 문자열 길이가 일치하면 YES출력\t\t\t\t\t\t\t\t\t\t\tflag = true;\t\t\t\t\t\t\t\t\t\t\tfor (int ll = 0; ll &lt; str_len; ++ll)\t\t\t\t\t\t\t\t\t\t\t\tprintf(\"%c\", word[ll] + 'A');\t\t\t\t\t\t\t\t\t\t\tprintf(\" YES\\n\");\t\t\t\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\tp = make_pair(nexty, nextx);\t\t\t\t\t\t\t\t\t\tq.push(p);\t\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t}\t\t\t\t\t\t\tif (flag) break;\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t\tinit_cnt();\t\t\t\t\twhile (!q.empty()) q.pop();  //정답을 제출하고 바로 반복문을 빠져나갔기 때문에 큐에 남은 인덱스가 있을 수 있기 때문\t\t\t\t\tif (flag) break;\t\t\t\t}\t\t\t\tif (flag) break;\t\t\t}\t\t\tif (!flag) {  //못찾으면 NO 출력\t\t\t\tfor (int l = 0; l &lt; str_len; ++l)\t\t\t\t\tprintf(\"%c\", word[l] + 'A');\t\t\t\tprintf(\" NO\\n\");\t\t\t}\t\t}\t}\treturn 0;}결과   수행 시간 : 4ms  오답  디버깅과 직접 그리면서 코드를 분석하였지만 틀린 부분을 찾을 수 없었다.  위의 참고 예제를 통과하면 왠만한 예제는 통과하였다고 생각한다.  다른 의견          재귀를 활용하여 구현하면 시간 초과가 난다고 한다.      다이나믹 프로그래밍으로 구현하는 것이 가장 효율적이라고 생각한다.      알아둘 점 1) 입력 버퍼 지우기 while (getchar() != '\\n');  문자열을 입력할 때 입력버퍼에 엔터키(\\n)가 남아있는 현상으로 다음 문자열을 입력할 때 제대로된 입력을 받을 수 없었다.  입력함수 바로 밑에 위의 코드를 추가하여 해결하였다.  cin 을 사용하여 해결할 수도 있다.2) BFS에서 경로 순서 확인하기   BFS는 큐를 활용하기 때문에 경로를 찾아가는 것이 순차적으로 하기 않는다.  위의 이유로 똑같은 크기의 2차원 배열을 선언하여 이전의 값에 +1을 하며 해당 배열에 저장한다.  위의 코드에서는 check_cnt 배열이 그 역할을 한다.해답 코드   출처 : http://b.mystika.me/26#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;char map[5][5];char word[11];int dp[5][5][10];int mx[8] = { 0,1,1,1,0,-1,-1,-1 };int my[8] = { -1,-1,0,1,1,1,0,-1 };int solve(int y, int x, int idx){\tint &amp;ret = dp[y][x][idx];\t//초기화 오류 처리\tif (ret != -1) return ret;\tfor (int i = 0; i &lt; 8; i++) {\t\tint nexty = y + my[i];\t\tint nextx = x + mx[i];\t\tif (nexty &gt;= 0 &amp;&amp; nexty &lt; 5 &amp;&amp; nextx &gt;= 0 &amp;&amp; nextx &lt; 5) {\t\t\t//단어와 일치되는 알파벳을 찾았을 때,\t\t\tif (map[nexty][nextx] == word[idx]) {\t\t\t\t//단어의 다음 문자가 NULL이면, 모두 찾았기 때문에 TRUE를 반환\t\t\t\tif (word[idx + 1] == '\\0') return ret = 1;\t\t\t\t//아직 단어를 찾을 것이 남아있다면 다시 재귀함수 호출\t\t\t\tret = solve(nexty, nextx, idx + 1);  \t\t\t\t//문자열을 찾았다면 남은 재귀함수에서 모두 1(TRUE)값을 반환하여 마지막 결과에 1을 반환하도록 한다.\t\t\t\tif (ret) return ret;\t\t\t}\t\t}\t}\t//문자를 모두 매칭할 수 없으므로 FALSE를 반환\treturn false;}int find(){\tfor (int i = 0; i &lt; 5; i++) {\t\tfor (int j = 0; j &lt; 5; j++) {\t\t\tint &amp;ret = dp[i][j][0];\t\t\t//초기화가 안됬다면 바로 리턴(오류 처리)\t\t\tif (ret != -1) return ret;\t\t\t//첫 단어를 map에서 찾았다면\t\t\tif (map[i][j] == word[0]) {\t\t\t\tret = solve(i, j, 1);\t\t\t\tif (ret) return ret;\t\t\t}\t\t}\t}\treturn false;}int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tfor (int i = 0; i &lt; 5; i++)\t\t\tscanf(\"%s\", map[i]);\t\tint n;\t\tscanf(\"%d\", &amp;n);\t\tfor (int i = 0; i &lt; n; i++) {\t\t\tmemset(dp, -1, sizeof(dp));\t\t\tscanf(\"%s\", word);\t\t\tprintf(\"%s %s\\n\", word, find() ? \"YES\" : \"NO\");\t\t}\t}\treturn 0;}  출처를 참고하여 다시 구현해 본 코드이다.  DP를 사용하였으며, dp[y][x][idx]는 해당 맵의 좌표(map[y][x])에서 현재 단어(word[idx]) 이후를 찾을 수 있는지를 판단한다.알아둘 점 1) 재귀함수를 이용하여 DP를 구현하는 방식 2) 삼항 연산자를 이용하여 간단히 출력하는 방식   특히, 삼항 연산자를 사용하기 위해 함수를 사용한 부분을 참고하자.","categories": ["Algorithm"],
        "tags": ["Algorithm_Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/ALGOSPOT-BOGGLE/",
        "teaser":null},{
        "title": "[ALGOSPOT]DARPA",
        "excerpt":"DARPA Grand Challenge 문제 링크   https://algospot.com/judge/problem/read/DARPA코드 분석 최적화 문제 결정 문제로 바꿔 풀기   최적화 문제          optimize(locations, cameras) = 카메라를 설치할 수 있는 위치 locations와 카메라의 수 cameras가 주어질 때, 카메라 간 최소 간격의 최대치를반환한다.        결정 문제          decision(locations, cameras, gap) = 카메라를 설치할 수 있는 위치 locations와 카메라의 수 cameras가 주어질 때, 이들을 적절히 배치해모든 카메라의 간격이 gap이상이 되도록 하는 방법이 있는가?      “카메라 간의 최소 간격이 gap인 방법이 있는가?”가 아니라 “카메라들의 간의 최소 간격이 gap이상인 방법이 있는가?” 임을 유의하자.                  이와 같이 질문해야 최적화 문제를 풀 수 있다.          “이상”이라 함은 그 범위의 값들을 모두 포함할 수 있기 때문에 답의 후보 범위를 계속 반으로 줄여서 최적화를 할 수 있다.(이분법)                    카메라들이 항상 xkm 이상 떨어져 있다고 할때, 0km위치에 카메라를 항상 설치할 수 있다.                  만약, 0km에 설치하지 않는다고 하면 이를 0km로 옮겨도 똑같은 답이 된다.          결과적으로, 탐욕법으로 이 문제를 해결할 수 있다는 사실을 떠올릴 수 있어야 한다.                      구현 함수          optimize(): 이분법을 구현하는 함수이다.      decision(): 첫 번째로 만나는 위치에 무조건 카메라를 설치한 뒤, 각 위치를 순회하며 카메라를 설치할 수 있을때마다 카메라를 설치한다. 그 후설치한 카메라의 수가 문제에서 요구한 설치 개수 이상이 되면 참을 반환한다      결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;//결정 문제: 정렬되어 있는 locations 중 cameras를 선택해 모든 카메라 간의 간격이//gap 이상이 되는 방법이 있는지를 반환한다.bool decision(const vector&lt;double&gt; &amp;location, int cameras, double gap) {\t//카메라를 설치할 수 있을 때마다 설치하는 탐욕적 알고리즘\tdouble limit = -1;\tint installed = 0;\tfor (int i = 0; i &lt; (int)location.size(); i++) {\t\tif (limit &lt;= location[i]) {\t\t\t++installed;\t\t\t//location[i] + gap 이후는 되어야 카메라를 설치할 수 있다.\t\t\tlimit = location[i] + gap;\t\t}\t}\t//결과적으로 cameras대 이상을 설치할 수 있으면 참 반환\treturn installed &gt;= cameras;}//최적화 문제: 정렬되어 있는 locations 중 cameras를 선택해 최소 간격을 최대화 한다.double optimize(const vector&lt;double&gt; &amp;location, int cameras) {\tdouble lo = 0., hi = 241.;\t//반복문 불변식: decision(lo) &amp;&amp; !decision(hi)\tfor (int it = 0; it &lt; 100; it++) {\t\tdouble mid = (lo + hi) / 2.0;\t\t//간격이 mid 이상이 되도록 할 수 있으면 답은 [mid, hi]에 있다.\t\tif (decision(location, cameras, mid))\t\t\tlo = mid;\t\t//간격이 mid 이상이 되도록 할 수 없으면 답은 [lo, mid]에 있다.\t\telse\t\t\thi = mid;\t}\treturn lo;}int main(){\tint tc; scanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tint n, m; scanf(\"%d %d\", &amp;n, &amp;m);\t\tvector&lt;double&gt; lv;\t\tfor (int i = 0; i &lt; m; i++) {\t\t\tdouble in; scanf(\"%lf\", &amp;in);\t\t\tlv.push_back(in);\t\t}\t\tprintf(\"%.2lf\\n\", optimize(lv, n));\t}\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/ALGOSPOT-DARPA/",
        "teaser":null},{
        "title": "[ALGOSPOT]DICTIONARY",
        "excerpt":"고대어 사전 문제 링크   https://algospot.com/judge/problem/read/DICTIONARY코드 분석 위상 정렬 문제 1. 그래프 모델링   각 알파벳을 정점으로 표현하고, 한 알파벳이 다른 알파벳 앞에 와야 할 때 두 정점을 방향 간선으로 연결한다.          문제가 원하는 알파벳들의 순서는 위 그래프의 위상 정렬 결과가 된다.      makeGraph()함수가 이를 구현하는 모습을 볼 수 있다.        2. 인접한 단어들만 검사하기               만약 세 단어 A, B, C가 순서대로 등장한다면, (A,C)는 검사하지 않고 (A,B), (B,C)만 검사해도 답을 해결할 수 있다.          예를 들어, A = impr, C = impo 라고 할때, B는 다음과 같이 3가지의 경우가 있다.                  B의 네 번째 글자가 ‘r’인 경우: (B,C)를 검사할 때 ‘r’이 ‘o’보다 앞에 온다는 사실을 알 수 있다.          B의 네 번째 글자가 ‘o’인 경우: (A,B)를 검사할 때 ‘r’이 ‘o’보다 앞에 온다는 사실을 알 수 있다.          B의 네 번째 글자가 ‘r’, ‘o’ 둘다 아닌 경우: (A,B)를 검사할 때 ‘r’이 이 글자보다 앞에 온다는 사실을 알 수 있고, (B,C)를 검사할 때 이 글자가 ‘o’보다 앞에 온다는 사실을 알 수 있다. 결과적으로 ‘r’은 ‘o’보다 앞에 온다.            3. 위상 정렬 적용                                 위의 규칙을 적용하여 그래프를 생성한 뒤, 해당 그래프가 사이클이 없다면 문제의 사전은 논리에 맞는 것으로 알파벳 순서를 정상적으로 만들 수 있다.구현 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;#define min(a,b) ((a) &lt; (b) ? (a) : (b))//알파벳의 각 글자에 대한 인접 행렬 표현//간선 (i, j)는 알파벳 i가 j보다 앞에 와야 함을 나타낸다.vector&lt;vector&lt;int&gt;&gt; adj;//주어진 단어들로부터 알파벳 간의 선후관계 그래프를 생성한다.void makeGraph(const vector&lt;string&gt; &amp;words) {\tadj = vector&lt;vector&lt;int&gt;&gt;(26, vector&lt;int&gt;(26, 0));\tfor (int j = 1; j &lt; words.size(); ++j) {\t\tint i = j - 1, len = min(words[i].size(), words[j].size());\t\t//word[i]가 word[j]앞에 오는 이유를 찾는다.\t\tfor (int k = 0; k &lt; len; ++k)\t\t\tif (words[i][k] != words[j][k]) {\t\t\t\tint a = words[i][k] - 'a';\t\t\t\tint b = words[j][k] - 'a';\t\t\t\tadj[a][b] = 1;\t\t\t\tbreak;\t\t\t}\t}}vector&lt;int&gt; seen, order;void dfs(int here) {\tseen[here] = 1;\tfor (int there = 0; there &lt; adj.size(); ++there)\t\tif (adj[here][there] &amp;&amp; !seen[there])\t\t\tdfs(there);\torder.push_back(here);}//adj에 주어진 그래프를 위상정렬한 결과를 반환한다.//그래프가 DAG가 아니라면 빈 벡터를 반환한다.vector&lt;int&gt; topologicalSort() {\tint n = adj.size();\tseen = vector&lt;int&gt;(n, 0);\torder.clear();\tfor (int i = 0; i &lt; n; ++i)\t\tif (!seen[i])\t\t\tdfs(i);\treverse(order.begin(), order.end());\t//만약 그래프가 DAG가 아니라면 정렬 결과에 역방향 간선이 있다.\tfor (int i = 0; i &lt; n; ++i)\t\tfor (int j = i + 1; j &lt; n; ++j)\t\t\tif (adj[order[j]][order[i]])\t\t\t\treturn vector&lt;int&gt;();\t//없는 경우라면 깊이 우선 탐색에서 얻은 순서를 반환한다.\treturn order;}int main(){\tint tc; scanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tint n; scanf(\"%d\", &amp;n);\t\tvector&lt;string&gt; sv;\t\tfor (int i = 0; i &lt; n; i++) {\t\t\tstring str; cin &gt;&gt; str;\t\t\tsv.push_back(str);\t\t}\t\tmakeGraph(sv);\t\tvector&lt;int&gt; ans;\t\tans = topologicalSort();\t\tif (!ans.size())\t\t\tprintf(\"INVALID HYPOTHESIS\");\t\telse {\t\t\tfor (int i = 0; i &lt; ans.size(); ++i)\t\t\t\tprintf(\"%c\", ans[i] + 'a');\t\t}\t\tprintf(\"\\n\");\t}\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/ALGOSPOT-DICTIONARY/",
        "teaser":null},{
        "title": "[ALGOSPOT]DRUNKEN",
        "excerpt":"음주 운전 단속 문제 링크   https://algospot.com/judge/problem/read/DRUNKEN코드 분석 플로이드 최단 거리 알고리즘   플로이드 알고리즘은 아무 정점도 경유하지 않은 최단 거리에서 시작해 경유할 수 있는 정점으르 하나씩 추가해 가며 최단 거리를 갱신한다.          이 과정에서 0번부터 V-1번까지 정점들을 순서대로 추가하지만, 이 순서는 단지 편의를 위함이지 순서가 바뀐다고 해도 알고리즘의 정당성에는 어떠한 영향도 미치지 않는다.        위 속성을 이용하여, 각 정점을 단속에 걸리는 시간 별로 오름차순으로 정렬한 뒤, 순서대로 플로이드 알고리즘을 수행하면 해당 문제의 답을 찾을 수 있다.          단속 시간이 짧은 정점부터 알고리즘을 수행하면, 순서대로 한 경유점의 가중치를 포함한 최단 거리를 계산하면서 가장 가중치가 큰 경유점에서의 최단 거리 경로를 찾을 수 있다. (오름차순으로 가중치가 가장 큰 경유점이 마지막에 있기 때문)      이는 플로이드 알고리즘은 반복문을 사용하기 때문에 경유점의 가중치가 입력된 순서가 결과값에 영향을 미치기 때문이다.        C_k(u, v) = k 혹은 그보다 단속 시간이 적게 걸리는 정점들만을 경유해서 u에서 v로 가는 최단 거리  W[][]: 최소 예상 시간  E[w]: 정점 w에서 소요되는 단속 시간    W[u][v] = min(C_w(u, w) + C_w(w, v) + E[w])      구현 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define N 501const int INF = 987654321;int map[N][N];//각 정점까지 음주단속 시간을 포함한 가장 짧은 시간을 저장int W[N][N];//각 정점에서 음주 운전 단속을 할 때 걸리는 시간int delay[N];int v, e;void solve() {\t//모든 정점들을 예상 시간 별로 정렬한다.\tvector&lt;pair&lt;int, int&gt;&gt; order;\tfor (int i = 0; i &lt; v; ++i)\t\torder.push_back(make_pair(delay[i], i));\tsort(order.begin(), order.end());\t//정점을 하나도 거치지 않고 얻을 수 있는 최단 경로\tfor (int i = 0; i &lt; v; ++i)\t\tfor (int j = 0; j &lt; v; ++j)\t\t\tif (i == j)\t\t\t\tW[i][j] = 0;\t\t\telse\t\t\t\tW[i][j] = map[i][j];\tfor (int k = 0; k &lt; v; ++k) {\t\t//k번째로 예상 시간이 적게 걸리는 정점 w까지를 지나서 얻을 수 있는 최단 거리\t\tint w = order[k].second;\t\tfor(int i=0; i&lt;v; ++i)\t\t\tfor (int j = 0; j &lt; v; ++j) {\t\t\t\tmap[i][j] = min(map[i][j], map[i][w] + map[w][j]);\t\t\t\tW[i][j] = min(W[i][j], map[i][w] + delay[w] + map[w][j]);\t\t\t}\t}}int main(){\tscanf(\"%d %d\", &amp;v, &amp;e);\tfor (int i = 0; i &lt; v; ++i)\t\tscanf(\"%d\", &amp;delay[i]);\tfor (int i = 0; i &lt; e; ++i) {\t\tint a, b, c;\t\tscanf(\"%d %d %d\", &amp;a, &amp;b, &amp;c);\t\tmap[a - 1][b - 1] = c;\t\tmap[b - 1][a - 1] = c;\t}\tfor (int i = 0; i &lt; v; ++i)\t\tfor (int j = 0; j &lt; v; ++j)\t\t\tif (!map[i][j])\t\t\t\tmap[i][j] = INF;\tsolve();\tint tc; scanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tint start, end;\t\tscanf(\"%d %d\", &amp;start, &amp;end);\t\tprintf(\"%d\\n\", W[start - 1][end - 1]);\t}\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/ALGOSPOT-DRUNKEN/",
        "teaser":null},{
        "title": "[ALGOSPOT]FENCE",
        "excerpt":"FENCE 문제 링크   https://algospot.com/judge/problem/read/FENCE코드 분석   출처: 알고리즘 문제해결전략, 분할정복  n개의 판자를 절반으로 나눠 분할한다.          부분문제 1: 가장 큰 직사각형을 왼쪽 부분 문제에서만 잘라낼 수 있다.      부분문제 2: 가장 큰 직사각형을 오른쪽 부분 문제에서만 잘라낼 수 있다.      부분문제 3: 가장 큰 직사각형은 왼쪽 부분 문제와 오른쪽 부분 문제에 결쳐 있다.      중요 조건: 가장 큰 직사각형은 반드시 부분 문제 경계에 있는 두 판자를 포함한다.      결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;#define max(a, b) ((a) &gt; (b) ? (a) : (b))#define min(a, b) ((a) &lt; (b) ? (a) : (b))//각 판자의 높이를 저장하는 배열vector&lt;int&gt; h;//h[left,...,right]구간에서 찾아낼 수 있는 가장 큰 사각형의 넓이를 반환int solve(int left, int right){\t//기저 사례: 판자가 하나밖에 없는 경우\tif (left == right) return h[left];\t//[left, mid],[mid+1, right]의 두 구간으로 문제를 분할\tint mid = (left + right) / 2;\t//분할한 문제를 각개격파(부분문제1, 부분문제2)\tint ret = max(solve(left, mid), solve(mid + 1, right));\t//부분문제3: 두 부분에 모두 걸치는 사각형 중 가장 큰 것을 찾는다.\tint lo = mid;\tint hi = mid + 1;\tint height = min(h[lo], h[hi]);\t//[mid, mid+1]만 포합하는 너비 2인 사각형을 고려한다.\tret = max(ret, height * 2);\t//사각형이 입력 전체를 덮을 때까지 확장해 나간다.\twhile (left &lt; lo || hi &lt; right) {\t\t//left ~ right 범위안에 있을 경우\t\tif (hi &lt; right &amp;&amp; (lo == left || h[lo - 1] &lt; h[hi + 1])) {\t\t\thi++;\t\t\theight = min(height, h[hi]);\t\t}\t\telse {\t\t\tlo--;\t\t\theight = min(height, h[lo]);\t\t}\t\t//확장한 후 사각형의 넓이\t\tret = max(ret, height * (hi - lo + 1));\t}\treturn ret;}int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tint n;\t\tscanf(\"%d\", &amp;n);\t\tfor (int i = 0; i &lt; n; i++) {\t\t\tint height;\t\t\tscanf(\"%d\", &amp;height);\t\t\th.push_back(height);\t\t}\t\tprintf(\"%d\\n\", solve(0, n - 1));\t\th.clear();\t}\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/ALGOSPOT-FENCE/",
        "teaser":null},{
        "title": "[ALGOSPOT]FIRETRUCKS",
        "excerpt":"소방차 문제 링크   https://algospot.com/judge/problem/read/FIRETRUCKS코드 분석 다익스트라 알고리즘 응용   이 문제에서 최대 정점 개수는 1000개, 최대 간선 개수는 50만개이므로, 아래와 같은 단순한 알고리즘으로는 풀 수 없다.          각 불난 위치에서 다익스트라 알고리즘을 실행하여 가장 가까운 소방서를 찾는다. (O(nElogV))      각 소방서마다 다익스트라 알고리즘을 실행하여 가장 가까운 불난 위치를 찾는다. (O(mElogV))      플로이드 알고리즘 (O(V^3))        이 문제는 어느 소방서에서 소방차가 오느냐는 중요하지 않고, 무조건 소방서로부터 거리만 최소로 하면 된다.  따라서, 모든 소방서를 임의의 한 정점으로 연결한 후, 거리를 0으로 두면 단 한번의 다익스트라 알고리즘으로 문제를 해결할 수 있다.   위 그래프는 임의의 정점을 추가한 모습이다.  시간 복잡도는 다익스트라 알고리즘과 같다.구현 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;deque&gt;#include &lt;map&gt;using namespace std;#define MAX_V 1001const int INF = 987654321;int v, e, n, m;vector&lt;pair&lt;int, int&gt;&gt; adj[MAX_V];//minDist: 한 소방서에서 각 불난 위치의 정점까지 최소 거리//fireStation: 소방서 정점//fire: 불난 위치 정점int minDist[MAX_V], fireStation[MAX_V], fire[MAX_V];void dijkstra(int src) {   vector&lt;int&gt; dist(v + 1, INF);   dist[src] = 0;   priority_queue&lt;pair&lt;int, int&gt;&gt; pq;   pq.push(make_pair(0, src));   while (!pq.empty()) {      int here = pq.top().second;      int cost = -pq.top().first;      pq.pop();      if (dist[here] &lt; cost) continue;      for (int i = 0; i &lt; adj[here].size(); ++i) {         int there = adj[here][i].first;         int nextDist = cost + adj[here][i].second;         if (dist[there] &gt; nextDist) {            dist[there] = nextDist;            pq.push(make_pair(-nextDist, there));         }         //해당 정점이 불난 위치이며, 현재까지의 거리보다 짧다면 갱신한다.         for (int j = 0; j &lt; n; ++j)            if (there == fire[j] &amp;&amp; minDist[fire[j]] &gt; nextDist)               minDist[fire[j]] = nextDist;      }   }}int main(){   int tc; scanf(\"%d\", &amp;tc);   while (tc--) {      for (int i = 0; i &lt; MAX_V; ++i) {         adj[i].clear();         minDist[i] = INF;         fireStation[i] = 0;         fire[i] = 0;      }      scanf(\"%d %d %d %d\", &amp;v, &amp;e, &amp;n, &amp;m);      for (int i = 0; i &lt; e; ++i) {         int a, b, t;         scanf(\"%d %d %d\", &amp;a, &amp;b, &amp;t);         adj[a].push_back(make_pair(b, t));         adj[b].push_back(make_pair(a, t));      }      for (int i = 0; i &lt; n; ++i)         scanf(\"%d\", &amp;fire[i]);      //소방서의 정점을 입력 받은 후, 임의의 정점 0을 연결한다.(거리 0)      for (int i = 0; i &lt; m; ++i) {         scanf(\"%d\", &amp;fireStation[i]);         adj[0].push_back(make_pair(fireStation[i], 0));      }      //임의의 정점 0을 시작으로 다익스트라 알고리즘을 한번 실행한다.      dijkstra(0);      int ans = 0;      for (int i = 0; i &lt; n; ++i)         ans += minDist[fire[i]];      printf(\"%d\\n\", ans);   }   return 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/ALGOSPOT-FIRETRUCKS/",
        "teaser":null},{
        "title": "[ALGOSPOT]GALLERY",
        "excerpt":"감시 카메라 설치 문제 링크   https://algospot.com/judge/problem/read/GALLERY코드 분석 루트 없는 트리의 지배 집합 찾기   지배 집합(domination set): 각 정점이 자기 자신과 모든 인접한 정점들을 지배한다고 할때, 그래프의 모든 정점을 지배하는 정점들의 부분집합을 그래프의 지배 집합이라고 한다.          그래프에서 지배 집합을 찾는 문제는 NP-완전 문제 중 하나로, 정점 개수의 지수 함수에 비례한다.      1. 루트 없는 트리(unrooted tree)   이 문제가 그래프가 아닌 루트 없는 트리라는 것을 알 수 있는 점은 문제 속에 있다.          문제 설명의 마지막에 미술관에서 한 번 지나간 갤러리를 다시 지나기 위해서는 전에 지난 복도를 반드시 지나야 한다.      사이클이 없다. = 트리로 표현할 수 있다.        위와 같이 그래프가 트리의 형태를 하는 것을 루트 없는 트리라고 부른다.  어떤 그래프가 루트 없는 트리인지를 알기 위해서는 아래와 같은 특징 중 한 가지가 성립해야 한다.(서로 동치 관계에 있음)          정확히 V - 1개의 간선이 있다.      사이클이 존재하지 않는다.      두 정점 사이를 연결하는 단순 경로가 정확히 하나만 존재한다.      2. 루트 없는 트리 문제 풀기   루트 없는 트리를 다루는 가장 간단한 방법은 임의의 시작점에서 깊이 우선 탐색을 수행하는 것이다.  이 결과로 얻은 깊이 탐색 스패닝 트리는 원래 그래프의 구조를 그대로 가지면서, 부모 자식 관계르르 갖는 일반적인 트리 형태가 된다.  문제 설명에서 모든 갤러리가 서로 연결되어 있을 필요가 없다고 명시되어 있기 때문에, 그래프의 각 컴포넌트는 트리 형태인 것을 알 수 있다.3. 트리의 지배 집합 찾기   트리의 최소 지배 집합을 찾는 가장 간단한 방법은 트리의 맨 아래에서부터 시작해서 위로 올라오는 것이다.          잎 노드는 부모 노드와 자기 자신밖에 지배하지 못하므로, 최소 지배 집합을 만들 수 없기 때문에 절대 선택해선 안된다.        알고리즘 과정          잎 노드는 선택하지 않는다.      이 외의 노드에 대해, 트리의 맨 밑에서부터 올라오면서 다음과 같이 선택 여부를 결정 한다.                  자기 자손 중 아직 지배당하지 않은 노드가 하나라도 있다면 현재 노드를 선택한다.          이 외의 경우는 현재 노드를 선택하지 않는다.                      첫 번째 예제 데이터 그래프 형태 구현   dfs(here)는 here를 루트로 하는 서브트리를 방문하고, 반환하면서 해당 노드가 지배 집합의 일부인지, 다른 노드에 지배당하고 있는지, 지배당하지 않고 있는지 3가지 중 하나를 반환한다.  시간 복잡도: O(g + h)구현 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;#define MAX_V 1001int V;vector&lt;int&gt; adj[MAX_V];vector&lt;bool&gt; visited;const int UNWATCHED = 0;const int WATCHED = 1;const int INSTALLED = 2;//지금까지 설치한 카메라의 총 수int installed;//here로부터 깊이 우선 탐색을 하고, here의 정보를 반환한다.int dfs(int here) {\tvisited[here] = true;\tint children[3] = { 0,0,0 }; //UNWATCHED, WATCHED, INSTALLED 정보\tfor (int i = 0; i &lt; adj[here].size(); ++i) {\t\tint there = adj[here][i];\t\tif (!visited[there])\t\t\t++children[dfs(there)];\t}\t//자손 노드 중 감시되지 않는 노드가 있을 경우 카메라를 설치한다.\tif (children[UNWATCHED]) {\t\t++installed;\t\treturn INSTALLED;\t}\t//자손 노드 중 카메라가 설치된 노드가 있을 경우 설치할 필요가 없다.\tif (children[INSTALLED])\t\treturn WATCHED;\treturn UNWATCHED;}//그래프를 감시하는데 필요한 카메라의 최소 수를 반환한다.int installCamera() {\tinstalled = 0;\tvisited = vector&lt;bool&gt;(V, false);\tfor (int u = 0; u &lt; V; ++u)\t\tif (!visited[u] &amp;&amp; dfs(u) == UNWATCHED)\t\t\t++installed;\treturn installed;}int main(){\tint tc; scanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tfor (int i = 0; i &lt; MAX_V; ++i)\t\t\tadj[i].clear();\t\tint h; scanf(\"%d %d\", &amp;V, &amp;h);\t\tfor (int i = 0; i &lt; h; ++i) {\t\t\tint s, e; scanf(\"%d %d\", &amp;s, &amp;e);\t\t\tadj[s].push_back(e);\t\t\tadj[e].push_back(s);\t\t}\t\tprintf(\"%d\\n\", installCamera());\t}\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/ALGOSPOT-GALLERY/",
        "teaser":null},{
        "title": "[ALGOSPOT]LIS",
        "excerpt":"LIS(Longest Increasing Sequence) 문제 링크   https://algospot.com/judge/problem/read/LIS코드 분석 Bottom-up   DP[N]: 현재 인덱스에서 가장 긴 증가 부분 수열의 길이를 저장한다.  Input[N]: 입력 값을 저장한다.  현재 인덱스가 i일 때, j: (1 ~ i - 1)중 만약 input[i] &lt; input[j]이라면 DP[i] = DP[j] + 1로 갱신한다.  갱신된 값 중 가장 큰 값을 해당 인덱스의 최적해로 판단한다.  시간 복잡도: 1 + 2 + 3 + ... + n이므로, O(n^2)이다.Top-down   chache[N]: 현재 인덱스에서 가장 긴 증가 부분 수열의 길이를 저장한다.(메모이제이션)  S[N]: 입력 배열  lis(start) = S[start]에서 시작하는 부분 증가 수열 중 최대의 길이를 반환한다.  별도의 기저 사례 없이, for문의 조건문을 이용한다.  시간 복잡도: 총 n개의 부분 문제를 갖고, 하나를 해결할 때마다 n번 연산하므로 O(n^2)이다.결과 코드   Bottom-up#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define N 501int dp[N];int input[N];int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tmemset(dp, 0, sizeof(dp));\t\tmemset(input, 0, sizeof(input));\t\tint n;\t\tscanf(\"%d\", &amp;n);\t\tfor (int i = 0; i &lt; n; i++)\t\t\tscanf(\"%d\", &amp;input[i]);\t\t//dp배열을 모두 1로 초기화(숫자가 한개 이면 길이가 1이기 때문)\t\tfor (int i = 0; i &lt; n; i++)\t\t\tdp[i] = 1;\t\t//i: 현재 인덱스, j: 이전 인덱스\t\t//dp배열에서 이전의 인덱스들의 값들은 최적해이다.\t\t//입력 배열에서 현재 인덱스의 값이 이전의 인덱스의 값보다 크다면\t\t//해당 dp배열의 값에서 1을 더하여 갱신하며, 갱신 값중의 최대값을 최적해라고 판단한다.\t\tfor (int i = 1; i &lt; n; i++) {\t\t\tfor (int j = 0; j &lt; i; j++) {\t\t\t\tif (input[j] &lt; input[i]) {\t\t\t\t\tif (dp[i] &lt; (dp[j] + 1))\t\t\t\t\t\tdp[i] = dp[j] + 1;\t\t\t\t}\t\t\t}\t\t}\t\tint max = 0;\t\tfor (int i = 0; i &lt; n; i++)\t\t\tif (max &lt; dp[i])\t\t\t\tmax = dp[i];\t\tprintf(\"%d\\n\", max);\t}\treturn 0;}  Top-down```cpp#define _CRT_SECURE_NO_WARNINGS#include #include #include using namespace std;#define max(a, b) ((a)&gt;(b)?(a):(b))#define N 501int n;int cache[N], S[N]; int lis(int start){\tint &amp;ret = cache[start];\tif (ret != -1) return ret;\tret = 1;\tfor (int next = start + 1; next &lt; n; ++next)\t\tif (S[start] &lt; S[next])\t\t\tret = max(ret, lis(next) + 1);\treturn ret;} int main(void){\tint tc;\tscanf(“%d”, &amp;tc);\twhile (tc–) {\t\tmemset(cache, -1, sizeof(cache));\t\tmemset(S, 0, sizeof(S)); \tscanf(\"%d\", &amp;n);\tfor (int i = 0; i &lt; n; i++)\t\tscanf(\"%d\", &amp;S[i]);\tint max = 0;\tfor (int i = 0; i &lt; n; i++) {\t\tint res = lis(i);\t\tif (max &lt; res)\t\t\tmax = res;\t}\tprintf(\"%d\\n\", max);}return 0; } ```","categories": ["Algorithm"],
        "tags": ["Algorithm_Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/ALGOSPOT-LIS/",
        "teaser":null},{
        "title": "[ALGOSPOT]MORSE",
        "excerpt":"모스 부호 사전 문제 링크   K번째 답 계산하기  https://algospot.com/judge/problem/read/MORSE코드 분석 1. 완전 탐색   장점인 신호가 단점인 신호보다 사전순으로 항상 앞으로 오는 모든 신호 만들기//s: 지금까지 만든 신호//n: 더 필요한 '-'의 개수//m: 더 필요한 'o'의 개수void generate(int n, int m, string s) {\t//기저 사례: n = m = 0\tif (n == 0 &amp;&amp; m == 0) {\t\tif (skip == 0) cout &lt;&lt; s &lt;&lt; endl;\t\t--skip;\t\treturn;\t}\tif (bino[n + m][n] &lt;= skip) {\t\tskip -= bino[n + m][n];\t\treturn;\t}\tif (n &gt; 0) generate(n - 1, m, s + \"-\");\tif (m &gt; 0) generate(n, m - 1, s + \"o\");}  k - 1개 건너뛰기//skip개를 건너뛰고 출력한다.void generate(int n, int m, string s) {\t//기저 사례: skip &lt; 0 (skip=-1이란 것은 이미 k번째 신호가 출력됨)\tif (skip &lt; 0) return;\t//기저 사례: n = m = 0\tif (n == 0 &amp;&amp; m == 0) {\t\t//더 건너뛸 신호가 없는 경우\t\tif (skip == 0) cout &lt;&lt; s &lt;&lt; endl;\t\t--skip;\t\treturn;\t}\tif (bino[n + m][n] &lt;= skip) {\t\tskip -= bino[n + m][n];\t\treturn;\t}\tif (n &gt; 0) generate(n - 1, m, s + \"-\");\tif (m &gt; 0) generate(n, m - 1, s + \"o\");}  전역 변수 skip은 k - 1로 초기화해야 한다.  시간 복잡도          n, m의 최대 크기는 각각 100이다.      모든 경우의 수는 이항 계수 C(n + m, n)이므로 C(200, 100)이다. 이는 시간내에 절대 계산할 수 없다.      2. 동적 계획법   모든 신호를 만드는 경우의 수는 C(n + m. n)이다.  skip이 C(n + m. n)와 같거나 크다면 generate(n, m, s)가 종료될 때, skip은 C(n + m. n)만큼 줄어 있고 답은 못찾은 상태이다.  그렇다면, 함수를 실행할 필요 없이 skip만 줄여 버리고 종료해도 똑같은 결과가 나온다.  skip 변수의 오버플로를 막기 위해 문제에서 k가 항상 10억 이하라는 점을 이용한다.          이항계수 계산을 C(n, r)대신 min( C(n, r), 10^9 )으로 한다.        시간 복잡도          generate() 함수는 k번째 신호 외에는 어떤 신호도 만들지 않는다. =&gt; O(n + m)      calcBino() 함수는 이항 계수를 미리 모두 계산하는 함수이다. =&gt; O(nm)      결과적으로, 총 시간 복잡도는 O(nm)이다.      결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;#define min(a,b) ((a) &lt; (b) ? (a) : (b))#define N 201//k의 최대값  + 100, 오버플로를 막기 위해 이보다 큰 값은 구하지 않는다.const int M = 1000000000 + 100;int bino[N][N];int skip;//필요한 모든 이항계수를 미리 계산해 둔다.void calcBino() {\tmemset(bino, 0, sizeof(bino));\tfor (int i = 0; i &lt; N; i++) {\t\tbino[i][0] = bino[i][i] = 1;\t\tfor (int j = 1; j &lt; i; j++)\t\t\tbino[i][j] = min(M, bino[i - 1][j - 1] + bino[i - 1][j]);\t}}//s: 지금까지 만든 신호//n: 더 필요한 '-'의 개수//m: 더 필요한 'o'의 개수//skip개를 건너뛰고 출력한다.void generate(int n, int m, string s) {\t//기저 사례: skip &lt; 0 (skip=-1이란 것은 이미 k번째 신호가 출력됨)\tif (skip &lt; 0) return;\t//기저 사례: n = m = 0\tif (n == 0 &amp;&amp; m == 0) {\t\t//더 건너뛸 신호가 없는 경우\t\tif (skip == 0) cout &lt;&lt; s &lt;&lt; endl;\t\t--skip;\t\treturn;\t}\tif (bino[n + m][n] &lt;= skip) {\t\tskip -= bino[n + m][n];\t\treturn;\t}\tif (n &gt; 0) generate(n - 1, m, s + \"-\");\tif (m &gt; 0) generate(n, m - 1, s + \"o\");}int main(){\tint tc; scanf(\"%d\", &amp;tc);\tcalcBino();\twhile (tc--) {\t\tint n, m, k; scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;k);\t\tstring s;\t\t//skip 초기화\t\tskip = k - 1;\t\tgenerate(n, m, s);\t}\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/ALGOSPOT-MORSE/",
        "teaser":null},{
        "title": "[ALGOSPOT]PACKING",
        "excerpt":"여행 짐 싸기 문제 링크   https://algospot.com/judge/problem/read/PACKING코드 분석 1. 완전 탐색   시간 복잡도: 각 물건에 대해 가져가거나 말거나 두 가지의 선택이 있다.          O(2^N)        pack(items) = 지금까지 고른 문건들의 목록이 items에 주어질 때, 남은 용량을 채워 얻을 수 있는 최대 절박도의 합2. 동적 계획법   완전 탐색에서 메모이제이션을 적용해보자.          items를 넣고 남은 용량에 담을 수 있는 물건들의 절박도 합만을 반환하도록 pack()을 바꾼다.      그 결과, 지금까지 고른 물건들의 목록은 상관이 없어진다.      중요한 것은 마지막으로 고른 물건의 번호(같은 물건을 두 번 고르면 안되므로)와 캐리어에 남아있는 용량이다.        capacity: 남은 용량, item: 물건의 번호, volume[item]: 해당 물건의 부피, need[item]: 해당 물건의 절박도  pack(capacity, item) = 캐리어에 용량이 capacity만큼 남았을 때, item 이후의 물건들을 싸서 얻을 수 있는 최대 절박도          해당 물건을 가져가는 경우: pack(capacity - volume[item], item + 1) + need[item]      해당 물건을 가져가지 않는 경우: pack(capacity, item + 1)        시간 복잡도: 용량 w, 물건의 개수 n 일때, 부분 문제의 수는 nw개이고 각 부분 문제를 해결하는데 걸리는 시간은 상수 시간이다.          O(nw)      3. 답 추적하기   각 부분 문제에서 선택지가 두 가지밖에 없으므로 따로 선택으르 저장하지 않고도 답을 역추적할 수 있다.  pack(capacity, item) 부분 문제에서 item을 선택했는지를 알고 싶으면 pack(capacity, item + 1)과 pack(capacity, item)이 같은지 비교하면 된다.          만약 두 값이 같다면, item을 선택하지 않고도 최대 절박도를 얻을 수 있다는 말이므로 item을 무시한다.      다르면, 목록에 item을 추가한다.      결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;#define max(a,b) ((a) &gt; (b) ? (a) : (b))#define N 101int n, w;int cache[1001][N];//물건의 정보를 저장할 구조체typedef struct _product{\tstring name;\tint volume;\tint need;}product;vector&lt;product&gt; pv;//캐리어에 남은 용량이 capacity일때, item 이후의 물건들을//담아 얻을 수 있는 최대 절박도의 합을 반환한다.int pack(int capacity, int item) {\t//기저 사례: 더 담을 물건이 없을 때\tif (item == n) return 0;\tint &amp;ret = cache[capacity][item];\tif (ret != -1) return ret;\t//이 물건을 담지 않을 경우\tret = pack(capacity, item + 1);\t//이 물건을 담을 경우\tif (capacity &gt;= pv[item].volume)\t\tret = max(ret, pack(capacity - pv[item].volume, item + 1) +\t\t\tpv[item].need);\treturn ret;}//pack(capacity, item)이 선택한 물건들의 목록을 packed에 저장한다.void reconstruct(int capacity, int item, vector&lt;string&gt; &amp;packed) {\t//기저 사례: 모든 물건을 다 고려했을 때\tif (item == n) return;\tif (pack(capacity, item) == pack(capacity, item + 1))\t\treconstruct(capacity, item + 1, packed);\telse {\t\tpacked.push_back(pv[item].name);\t\treconstruct(capacity - pv[item].volume, item + 1, packed);\t}}//초기화void init() {\tmemset(cache, -1, sizeof(cache));\tpv.clear();}int main(){\tint tc; scanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tinit();\t\tscanf(\"%d %d\", &amp;n, &amp;w);\t\tfor (int i = 0; i &lt; n; i++) {\t\t\tproduct in;\t\t\tcin &gt;&gt; in.name;\t\t\tscanf(\"%d %d\", &amp;in.volume, &amp;in.need);\t\t\tpv.push_back(in);\t\t}\t\tvector&lt;string&gt; packed;\t\treconstruct(w, 0, packed);\t\tint psize = packed.size();\t\tprintf(\"%d %d\\n\", pack(w, 0), psize);\t\tfor (int i = 0; i &lt; psize; i++)\t\t\tcout &lt;&lt; packed[i] &lt;&lt; endl;\t}\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/ALGOSPOT-PACKING/",
        "teaser":null},{
        "title": "[ALGOSPOT]PI",
        "excerpt":"PI 문제 링크   https://algospot.com/judge/problem/read/PI코드 분석 동적 계획법(메모이제이션)   첫 조각의 길이는 3, 4, 5 중의 하나이므로 각 경우마다 하나씩의 부분 문제를 해결한다, 이때 세 개의 부분 문제의 최적화(최소값)을 각각 구하면 전체 문제의 최적해가 된다.          길이 3인 조각의 난이도 +3글자 빼고 나머지 수열에 대한 최적해            길이 4인 조각의 난이도 +4글자 빼고 나머지 수열에 대한 최적해     길이 5인 조각의 난이도 +5글자 빼고 나머지 수열에 대한 최적해          begin: 부분 수열의 시작 위치, memorize(): 최소 난이도를 반환하는 함수, returnLevel(): 해당 수열의 난이도를 반환하는 함수      memorize(begin) = min(memorize(begin + L) + returnLevel(N[begin…begin + L])), L: 3 ~ 5        returnLevel() 함수             checkLevel() 함수            수열의 길이 3, 4, 5에 대해서만 적용할 수 있는 함수이다.     시간복잡도면에서 효율적이다. (소요시간: 24ms)          classify() 함수            모든 수열의 길이에 대해 적용 가능하다.     시간이 오래 걸린다. (소요시간: 250ms)결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;limits.h&gt;using namespace std;#define N 10001#define min(a, b) ((a) &lt; (b) ? (a) : (b))string arr;const int INF = 987654321;int cache[N];//1) arr[s]부터 size만큼 크기의 난이도를 반환int checkLevel(int s, int size){\tif (size == 3) {\t\tint s1, s2, s3;\t\ts1 = arr[s]; s2 = arr[s + 1]; s3 = arr[s + 2];\t\tif (s1 == s2 &amp;&amp; s2 == s3)\t\t\treturn 1;\t\tint d1, d2;\t\td1 = s2 - s1; d2 = s3 - s2;\t\tif (d1 == d2) {\t\t\tif (d1 == 1 || d1 == -1)\t\t\t\treturn 2;\t\t\telse\t\t\t\treturn 5;\t\t}\t\tif (s1 == s3)\t\t\treturn 4;\t}\telse if (size == 4) {\t\tint s1, s2, s3, s4;\t\ts1 = arr[s]; s2 = arr[s + 1]; s3 = arr[s + 2]; s4 = arr[s + 3];\t\tif (s1 == s2 &amp;&amp; s2 == s3 &amp;&amp; s3 == s4)\t\t\treturn 1;\t\tint d1, d2, d3;\t\td1 = s2 - s1; d2 = s3 - s2; d3 = s4 - s3;\t\tif (d1 == d2 &amp;&amp; d2 == d3) {\t\t\tif (d1 == 1 || d1 == -1)\t\t\t\treturn 2;\t\t\telse\t\t\t\treturn 5;\t\t}\t\tif (s1 == s3 &amp;&amp; s2 == s4)\t\t\treturn 4;\t}\telse if (size == 5) {\t\tint s1, s2, s3, s4, s5;\t\ts1 = arr[s]; s2 = arr[s + 1]; s3 = arr[s + 2];\t\ts4 = arr[s + 3]; s5 = arr[s + 4];\t\tif (s1 == s2 &amp;&amp; s2 == s3 &amp;&amp; s3 == s4 &amp;&amp; s4 == s5)\t\t\treturn 1;\t\tint d1, d2, d3, d4;\t\td1 = s2 - s1; d2 = s3 - s2; d3 = s4 - s3; d4 = s5 - s4;\t\tif (d1 == d2 &amp;&amp; d2 == d3 &amp;&amp; d3 == d4) {\t\t\tif (d1 == 1 || d1 == -1)\t\t\t\treturn 2;\t\t\telse\t\t\t\treturn 5;\t\t}\t\tif ((s1 == s3 &amp;&amp; s3 == s5) &amp;&amp; s2 == s4)\t\t\treturn 4;\t}\treturn 10;}//2) arr[a,b]구간의 난이도를 반환한다.int classify(int a, int b){\t//숫자 조각을 가져온다.\tstring M = arr.substr(a, b - a + 1);\t//첫 글자만으로 이루어진 문자열과 같은으면 난이도 1\tif (M == string(M.size(), M[0])) return 1;\t//등차수열인지 검사한다.\tbool progressive = true;\tfor (int i = 0; i &lt; (int)M.size() - 1; i++)\t\tif (M[i + 1] - M[i] != M[1] - M[0])\t\t\tprogressive = false;\t//등차수열이고 공차가 1 or -1 이면 난이도 2\tif (progressive &amp;&amp; abs(M[1] - M[0]) == 1)\t\treturn 2;\t//두 수가 번갈아 등장하는지 확인한다.\tbool alternating = true;\tfor (int i = 0; i &lt; (int)M.size(); i++)\t\tif (M[i] != M[i % 2])\t\t\talternating = false;\tif (alternating) return 4;  //두 수가 번갈아 등장하면 난이도 4\tif (progressive) return 5;  //공차가 1 아닌 등차수열이면 난이도 5\treturn 10;                  //이 외는 모두 난이도 10}//수열 arr[begin...]를 외우는 방법 중 난이도의 최소 합을 출력한다.int memorize(int begin){\t//기저 사례: 수열의 끝에 도달했을 경우\tif (begin == arr.size()) return 0;\t//메모이제이션\tint &amp;ret = cache[begin];\tif (ret != -1) return ret;\tret = INF;\tfor (int L = 3; L &lt;= 5; ++L) {\t\tif (begin + L &lt;= (int)arr.size())\t\t\tret = min(ret, memorize(begin + L) + checkLevel(begin, L));              //방법 1)\t\t\t//ret = min(ret, memorize(begin + L) + classify(begin, begin + L - 1));  //방법 2)\t}\treturn ret;}int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tmemset(cache, -1, sizeof(cache));\t\tarr.clear();\t\tcin &gt;&gt; arr;\t\tprintf(\"%d\\n\", memorize(0));\t}\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/ALGOSPOT-PI/",
        "teaser":null},{
        "title": "[ALGOSPOT]PICNIC",
        "excerpt":"PICNIC 문제 링크   https://algospot.com/judge/problem/read/PICNIC코드 분석 논리 분석   입력받은 친구가 가능한 쌍을 2차원 배열에 중복없이 저장한다. ((1,0), (0,1)도 중복으로 처리한다.)  경우의 수를 체크하기 위해 가능한 쌍의 최대 크기(45)만큼 가로, 세로 크기를 갖는 2차원 배열을 선언한다.  모든 친구들이 쌍을 이루었는지 체크하는 1차원 배열을 선언한다.  최대 시간복잡도는 O(m^2)로 예상한다. (최대 반복 수는 45 * (45 + 45) 로 예사됨)구현 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;#define N 11  //최대 친구 수#define M 46  //최대 친구 쌍의 수bool checkF[N];  //모든 친구들이 짝이 만들어졌는지 체크bool checkP[M][M];  //짝지을 수 있는 방법을 저장할 배열(중복되지 않음)int _pair[M][2];   //가능한 친구 쌍을 저장할 배열bool tmp[M];  //짝지을 방법를 임시로 저장할 배열void init_checkF_tmp(void){\tfor (int i = 0; i &lt; N; i++)\t\tcheckF[i] = false;\tfor (int i = 0; i &lt; M; i++)\t\ttmp[i] = false;}void init_pair(void){\tfor (int i = 0; i &lt; M; i++) {\t\t_pair[i][0] = 0;\t\t_pair[i][1] = 0;\t\tfor (int j = 0; j &lt; M; j++)\t\t\tcheckP[i][j] = false;\t}}bool full_checkF(int n){\tfor (int i = 0; i &lt; n; i++) {\t\tif (!checkF[i])\t\t\treturn false;\t}\treturn true;}//n은 현재 방법의 수bool check_pair(int n, int m){\tbool flag = false;\tfor (int i = 0; i &lt; n; i++) {\t\tfor (int j = 0; j &lt; m; j++) {\t\t\t//하나라도 다른 부분이 있다면 다음 방법으로 넘어가서 검사한다.\t\t\tif (tmp[j] == checkP[i][j])\t\t\t\tflag = true;\t\t\telse {\t\t\t\tflag = false;\t\t\t\tbreak;\t\t\t}\t\t}\t\t//완전히 같으면 FALSE 반환\t\tif (flag) return false;\t}\treturn true;}int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tinit_pair();\t\tint n, m;\t\tscanf(\"%d %d\", &amp;n, &amp;m);\t\tbool repet_flag = false;\t\tint repet_cnt = 0;\t\tfor (int i = 0; i &lt; m; i++) {\t\t\tint f, s;\t\t\tscanf(\"%d %d\", &amp;f, &amp;s);\t\t\t//(0, 1), (1, 0)과 같은 중복을 방지하기 위해 서로 같은 쌍은 입력하지 않는다.\t\t\trepet_flag = false;\t\t\tfor (int j = 0; j &lt; i; j++) {\t\t\t\tif (_pair[j][0] == f &amp;&amp; _pair[j][1] == s) repet_flag = true;\t\t\t\tif (_pair[j][0] == s &amp;&amp; _pair[j][1] == f) repet_flag = true;\t\t\t}\t\t\tif (repet_flag)\t\t\t\trepet_cnt++;\t\t\telse {\t\t\t\t_pair[i - repet_cnt][0] = f;\t\t\t\t_pair[i - repet_cnt][1] = s;\t\t\t}\t\t}\t\tm -= repet_cnt;\t\tint ans = 0;\t\tfor (int i = 0; i &lt; m; i++) {\t\t\tinit_checkF_tmp();\t\t\tcheckF[_pair[i][0]] = true;\t\t\tcheckF[_pair[i][1]] = true;\t\t\ttmp[i] = true;\t\t\tfor (int j = 0; j &lt; m; j++) {\t\t\t\t//중복을 피해기 위함\t\t\t\tif (i == j)\t\t\t\t\tcontinue;\t\t\t\t//친구쌍의 두 친구가 모두 check배열에 false면 해당 쌍을 사용한다.(중복검사)\t\t\t\tif (!checkF[_pair[j][0]] &amp;&amp; !checkF[_pair[j][1]]) {\t\t\t\t\tcheckF[_pair[j][0]] = true;\t\t\t\t\tcheckF[_pair[j][1]] = true;\t\t\t\t\ttmp[j] = true;\t\t\t\t}\t\t\t}\t\t\t//모든 친구들이 짝을 이루었고, 이전에 방법과 다르다면 새로운 방법이다.\t\t\tif (full_checkF(n) &amp;&amp; check_pair(ans, m)) {\t\t\t\tfor (int j = 0; j &lt; m; j++)\t\t\t\t\tcheckP[ans][j] = tmp[j];\t\t\t\tans++;\t\t\t}\t\t}\t\tprintf(\"%d\\n\", ans);\t}\treturn 0;}결과   수행시간 : 0ms  오답  디버깅과 다른 예제를 만들어서 테스트한 결과 틀린 부분을 찾을 수 없었다.알아둘 점   재귀에 관한 이해가 더욱 필요하다.  위의 문제도 책의 해답에서는 재귀를 사용하였다.해답 코드   출처 : 알고리즘 문제해결전략 책#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;#define N 10int n;bool areFriends[N][N];//taken[i] = i번째 학생이 짝을 이미 찾았으면 true, 아니면 falseint countPairings(bool taken[N]){\t//남은 학생들 중 가장 번호가 빠른 학생을 찾는다.\tint firstFree = -1;\tfor (int i = 0; i &lt; n; i++) {\t\tif (!taken[i]) {\t\t\tfirstFree = i;\t\t\tbreak;\t\t}\t}\t//기저 사례 : 모든 학생이 짝을 찾았으면 한 가지 방법을 찾았으니 종료한다.\tif (firstFree == -1) return 1;\tint ret = 0;\t//이 학생과 짝지을 학생을 결정한다.\tfor (int pairWith = firstFree + 1; pairWith &lt; n; pairWith++) {\t\tif (!taken[pairWith] &amp;&amp; areFriends[firstFree][pairWith]) {\t\t\ttaken[firstFree] = taken[pairWith] = true;\t\t\tret += countPairings(taken);\t\t\t//모든 경우의 수를 구해야하기 때문에 초기화해야함\t\t\ttaken[firstFree] = taken[pairWith] = false;\t\t}\t}\treturn ret;}int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tfor (int i = 0; i &lt; N; i++)\t\t\tfor (int j = 0; j &lt; N; j++)\t\t\t\tareFriends[i][j] = false;\t\tint m;\t\tscanf(\"%d %d\", &amp;n, &amp;m);\t\tfor (int i = 0; i &lt; m; i++) {\t\t\tint f, s;\t\t\tscanf(\"%d %d\", &amp;f, &amp;s);\t\t\tareFriends[f][s] = areFriends[s][f] = true;\t\t}\t\tbool taken[10] = { false, };\t\tint ans = countPairings(taken);\t\tprintf(\"%d\\n\", ans);\t}\treturn 0;}결과 및 코드 분석   수행 시간 : 0ms  최대 시간 복잡도 : 열 명의 학생이 모두 친구인 경우(9 * 7 * 5 * 3 * 1 = 945)  재귀 함수 사용  공간 복잡도면에서, 2차원 배열 1개와 1차원 배열 1개를 사용하여 내가 구현한 코드보다 더 효율적이다.  친구 쌍이 가능한지를 저장하는 2차원 배열에서 그 반대의 경우도 모두 저장해주어야 정확한 답이 나온다.알아둘 점 1) 재귀 함수 구현 능력&lt;/br&gt;2) 재귀 함수를 사용하기 위한 입력 형식을 만드는 방법 ","categories": ["Algorithm"],
        "tags": ["Algorithm_Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/ALGOSPOT-PICNIC/",
        "teaser":null},{
        "title": "[ALGOSPOT]QUADTREE",
        "excerpt":"QUADTREE 문제 링크   https://algospot.com/judge/problem/read/QUADTREE코드 분석   출처: 알고리즘 문제해결전략, 분할정복  재귀 호출을 이용해 네 부분을 각각 상하로 뒤집은 결과를 얻은 뒤, 이들을 병합한다.  STL의 string 함수 사용  STL의 문자열에서 지원하는 반복자(iterator) 활용  시간복잡도 분석: O(n)          주어진 문자열 길이: n      재귀 함수를 호출할 때 마다 주어진 문자열의 한 글자씩을 사용한다.      결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;string reserve(string::iterator &amp;it){\tchar head = *it;\t++it;\tif (head == 'b' || head == 'w')\t\treturn string(1, head);\tstring upperLeft = reserve(it);\tstring upperRight = reserve(it);\tstring lowerLeft = reserve(it);\tstring lowerRight = reserve(it);\t//각각 위와 아래 조각들의 위치를 바꾼다.\treturn string(\"x\") + lowerLeft + lowerRight +\t\tupperLeft + upperRight;}int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tstring map;\t\tcin &gt;&gt; map;\t\tstring::iterator it = map.begin();\t\tcout &lt;&lt; reserve(it) &lt;&lt; endl;\t}\treturn 0;}결과 분석   수행시간: 4ms","categories": ["Algorithm"],
        "tags": ["Algorithm_Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/ALGOSPOT-QUADTREE/",
        "teaser":null},{
        "title": "[ALGOSPOT]QUANTIZE",
        "excerpt":"QUANTIZE 문제 링크   https://algospot.com/judge/problem/read/QUANTIZE코드 분석 완전 탐색   시간복잡도: O(1000C10^n)이고, 최대 연산수 1000C10^100이므로 시간안에 풀 수 없다.    동적 계획법(메모이제이션)     주어진 수열을 오름차순 or 내림차순으로 정렬하면, 같은 숫자로 양자화되는 숫자들은 항상 인접해 있다!          예를들어, a &lt; b에 대해 a에 대응되는 숫자가 b에 대응되는 숫자보다 커서는 안된다.      이는 몇 개의 작은 입력들을 풀어보면 알 수 있는 조건이며, 시간내에 풀기 위해 알아야하는 중요한 조건이다.        기본 테스트 케이스의 한 예를 사용하면, {1, 4, 6, 744, 755, 777, 890, 897, 902} =&gt; {1, 4, 6}: 4, {744, 755, 777}: 759, {890, 897, 902}: 896 로 대응된다.  이를 형식화하면, from번째 이후의 숫자들을 parts개의 묶음으로 묶을 때, 최소 오류 제곱 합을 반환하는 함수 quantize(from, parts)가 있다.  quantize(from, parts) = min[minError(from, from + size - 1) + quantize(from + size, parts - 1)], size: 1 ~ n-from  minError(a,b): a번째 숫자부터 b번째 숫자까지 하나의 수로 표현했을 때의 최소 오류를 반환하는 함수          주어진 구간을 어떤 수로 표현해야 할지 결정하기        결정한 수 m으로 해당 구간을 표현했을 때 오차를 계산하기  위의 역할을 완전 탐색으로 구현하여도 시간안에 해결할 수 있지만, 밑의 구현 코드는 좀 더 복잡하며 효율적인 방법을 사용한다.  이는 오차 제곱의 합을 미분하여 값을 도출하며, 이를 부분 합 계산 방식으로 시간복잡도 O(1)의 방법으로 푸는 방법이며, 이 설명은 추후 추가할 예정이다.시간복잡도: 부분 문제의 수 ns개를 각각 n번 계산해야 하기 때문에 총 O(sn^2)이다.결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define N 10001#define min(a,b) ((a)&lt;(b)?(a):(b))const int INF = 987654321;//A[]: 양자화해야 할 수열, 정렬한 상태//pSum[]: A[]의 부분합을 저장한다. pSum[i]는 A[0]...A[i]의 합//qSuSum[]: A[]제곱의 부분합을 저장한다. pSqSum[i]는 A[0]^2...A[i]^2의 합int n;int A[N], pSum[N], pSqSum[N];//A를 정렬하고 가가 부분합을 계산한다.void precalc(){\tsort(A, A + n);\tpSum[0] = A[0];\tpSqSum[0] = A[0] * A[0];\tfor (int i = 1; i &lt; n; i++) {\t\tpSum[i] = pSum[i - 1] + A[i];\t\tpSqSum[i] = pSqSum[i - 1] + A[i] * A[i];\t}}//A[lo]...A[hi] 구간을 하나의 숫자로 표현할 때 최소 오차 합을 반환한다.int minError(int lo, int hi){\t//부분합을 이용해 A[lo] ~ A[hi]까지의 합을 구한다.\tint sum = pSum[hi] - (lo == 0 ? 0 : pSum[lo - 1]);\tint sqSum = pSqSum[hi] - (lo == 0 ? 0 : pSqSum[lo - 1]);\t//평균을 반올림한 값으로 이 수 들을 표현한다.\tint m = int(0.5 + (double)sum / (hi - lo + 1));\t//sum(A[i] - m)^2를 전개한 결과를 부분 합으로 표현\tint ret = sqSum - 2 * m *sum + m *m *(hi - lo + 1);\treturn ret;}int cache[N][11];int quantize(int from, int parts){\t//기저 사례: 모든 숫자들 양자화했을 떄\tif (from == n) return 0;\t//기저 사례: 숫자는 아직 남았는데 더 묶을 수 없을 때 아주 큰 값으르 반환한다.\tif (parts == 0) return INF;\tint &amp;ret = cache[from][parts];\tif (ret != -1) return ret;\tret = INF;\t//조각의 길이를 변화시켜 가며 최소값을 찾는다.\tfor (int partSize = 1; from + partSize &lt;= n; partSize++)\t\tret = min(ret, minError(from, from + partSize - 1)\t\t\t+ quantize(from + partSize, parts - 1));\treturn ret;}int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tmemset(cache, -1, sizeof(cache));\t\tmemset(A, 0, sizeof(A));\t\tmemset(pSum, 0, sizeof(pSum));\t\tmemset(pSqSum, 0, sizeof(pSqSum));\t\tint s;\t\tscanf(\"%d %d\", &amp;n, &amp;s);\t\tfor (int i = 0; i &lt; n; i++)\t\t\tscanf(\"%d\", &amp;A[i]);\t\tprecalc();\t\tprintf(\"%d\\n\", quantize(0, s));\t}\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/ALGOSPOT-QUANTIZE/",
        "teaser":null},{
        "title": "[ALGOSPOT]SNAIL",
        "excerpt":"장마가 찾아왔다 문제 링크   https://algospot.com/judge/problem/read/SNAIL코드 분석 동적 계획법을 활용한 확률 계산   예제 문제: 우물의 깊이 n미터, 장마 기간 m일, 비가올 확률 50%, 달팽이는 비가 안올 때 1m 올라가고 비가 올 때 2m를 올라간다. 이때, 올라갈 수 있는확률을 구하라.int cache[N][2 * N + 1];int n, m;//달팽이가 days일 동안 climbed미터를 기어올라 왔다고 할 때,//m일 전까지 n미터를 기어올라갈 수 있는 경우의 수int climb(int days, int climbed){\t//기저 사례: m일이 모두 지난 경우\tif (days == m) return climbed &gt;= n ? 1 : 0;\t//메모이제이션\tint &amp;ret = cache[days][climbed];\tif (ret != -1) return ret;\treturn ret = climb(days + 1, climbed + 2) + climb(days + 1, climbed + 1);}  완전 탐색 알고리즘에서 동적 계획법으로 순서          완전 탐색      climb(C): 지금까지 만든 날씨 조합C를 완성해서 원소의 합이 n이상이 되도록 하는 방법의 수      점화식: climb(C) = climb(C + [1]) + climb(C + [2])                  C + [x]는 배열 C의 맨 뒤에 x를 덧붙인 결과이다.          이 점화식은 C의 종류가 너무 많기 때문에 메모이제이션을 활용할 수 없다!          날씨 조합C =&gt; C의 길이와 C의 원소의 합만을 활용한다.                    동적 계획법      climbed(days, climbed): 지금까지 만든 날씨 조합C의 크기가 days, 그 원소들의 합이 climbed일 때, C를 완성해서 원소의 합이 n이상이 되게 하는방법의 수                  최대 부분 문제의 수: n * m          얻은 결과의 경우의 수를 2^m으로 나누면 최종 확률을 얻을 수 있다.                    SNAIL 문제   위와 문제의 구조는 동일하지만, 비가 올 확률이 50%에서 75%으로 증가하였다.  점화식: climb(days, climbed) = 0.25 * climb(days + 1, climbed + 1) + 0.75 * climb(days + 1, climbed + 2)          위의 예제와 달리 날씨의 조합마다 출현할 확률이 달라지므로, 재귀함수 결과를 경우의 수가 아닌 직접 확률을 계산해야 한다.      결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;#define N 1001double cache[N][2 * N + 1];int n, m;double climb(int days, int climbed){\t//기저 사례\tif (days == m) return climbed &gt;= n ? 1. : 0.;\t//메모이제이션\tdouble &amp;ret = cache[days][climbed];\tif (ret != -1.) return ret;\treturn ret = 0.75 * climb(days + 1, climbed + 2) + 0.25 * climb(days + 1, climbed + 1);}int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tfor (int i = 0; i &lt; N; i++)\t\t\tfor (int j = 0; j &lt; 2 * N + 1; j++)\t\t\t\tcache[i][j] = -1.;\t\tscanf(\"%d %d\", &amp;n, &amp;m);\t\tprintf(\"%.10lf\\n\", climb(0, 0));\t}\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/ALGOSPOT-SNAIL/",
        "teaser":null},{
        "title": "[ALGOSPOT]SORTGAME",
        "excerpt":"Sorting Game 문제 링크   https://algospot.com/judge/problem/read/SORTGAME코드 분석 그래프화한 뒤 넓이 우선 탐색(BFS) 사용하기 1. 그래프로 바꾸기   각 배열을 정점으로 표현하고, 부분 구간을 뒤집어 한 배열에서 다른 배열을 만들 수 있을 때 두 정점을 간선으로 연결한다.  n원소가 있을 때 이들을 배열하는 방법은 n!이며, 최대 정점의 개수도 이와 같다.   위 그래프를 넓이 우선 탐색하면서 정렬된 상태를 나타내는 정점까지의 거리를 계산한다.  구현          그래프를 생성하는 과정은 생략하고, 입력 배열의 부분 구간을 뒤집으면서 그때 그때 그래프의 간선을 만들어 넓이 우선 탐색을 실행한다.      정점 큐의 각 원소를 정수 배열로 하며, 거리를 계산할 distance[]는 정수 배열을 키(key)로 갖는 map을 사용한다.      //perm을 정렬하기 위해 필요한 최소 뒤집기 연산의 수를 계산 후 반환한다.int bfs(const vector&lt;int&gt; &amp;perm) {\tint n = perm.size();\t//목표 정점을 미리 계산한다.(오름차순된 배열)\tvector&lt;int&gt; sorted = perm;\tsort(sorted.begin(), sorted.end());\t//방문 목록(큐)\tqueue&lt;vector&lt;int&gt;&gt; q;\t//시작점으로부터 각 정점까지의 거리(map)\tmap&lt;vector&lt;int&gt;, int&gt; distance;\t//시작점의 거리는 0\tdistance[perm] = 0;\t//시작점을 큐에 넣는다.\tq.push(perm);\twhile (!q.empty()) {\t\tvector&lt;int&gt; here = q.front();\t\tq.pop();\t\t//목표 정점을 발견했으면 곧장 종료한다.\t\tif (here == sorted) return distance[here];\t\tint cost = distance[here];\t\t//가능한 모든 부분 구간을 뒤집어 본다.\t\tfor (int i = 0; i &lt; n; ++i) {\t\t\t//reverse함수의 배열 범위에 주의한다.\t\t\tfor (int j = i + 1; j &lt;= n; ++j) {\t\t\t\treverse(here.begin() + i, here.begin() + j);\t\t\t\tif (distance.count(here) == 0) {\t\t\t\t\tdistance[here] = cost + 1;\t\t\t\t\tq.push(here);\t\t\t\t}\t\t\t\treverse(here.begin() + i, here.begin() + j);\t\t\t}\t\t}\t}\t//실행되지 않음\treturn -1;}2. 더 빠른 해결방법   위 방법은 최악의 경우 8! = 40320개의 정점을 탐색하며, map에 접근해야한다. 그리고 최대 1000개의 테스트 케이스가 있기 때문에 시간안에 해결하기 힘들다.  위 알고리즘을 최적화하기 위해 2가지를 알고 있어야 한다.          숫자들이 다르더라도 상대적인 크기가 같은 배열들에 대한 답은 같다.                  예를들어, 두 배열 {30, 40, 10, 20}과 {3, 4, 1, 2}는 모두 최소 연산수가 2이다.                    이 문제의 그래프는 양방향 그래프이기 때문에, 시작 정점에서 목표 정점으로 가는 최단 거리는 그 반대인 목표 정점에서 시작 정점으로 가는 최단 거리와 같다.                  한 배열을 정렬하는데 드는 연산의 수는 정렬된 배열을 원래 배열로 바꾸는데 드는 연산의 수와 같다.                      위 2가지 속성을 이용하면, 모든 n(최대 크기 8)에 대해 정렬된 배열 [0, 1, 2, …, n-1]에서 모든 상태를 미리 계산한다.  입력 배열을 [0, n-1] 범위의 값으로 상대적인 크기를 유지한 상태로 바꾸면 위에서 미리 계산된 연산의 수로 답을 바로 알 수 있다.3. 구현 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;map&lt;vector&lt;int&gt;, int&gt; toSort;//[0, ..., n-1]의 모든 순열에 대해 toSort[]를 계산해 저장한다.void precalc(int n) {\tvector&lt;int&gt; perm(n);\tfor (int i = 0; i &lt; n; ++i) perm[i] = i;\tqueue&lt;vector&lt;int&gt;&gt; q;\tq.push(perm);\ttoSort[perm] = 0;\twhile (!q.empty()) {\t\tvector&lt;int&gt; here = q.front();\t\tq.pop();\t\tint cost = toSort[here];\t\tfor (int i = 0; i &lt; n; ++i) {\t\t\tfor (int j = i + 1; j &lt;= n; ++j) {\t\t\t\treverse(here.begin() + i, here.begin() + j);\t\t\t\tif (toSort.count(here) == 0) {\t\t\t\t\ttoSort[here] = cost + 1;\t\t\t\t\tq.push(here);\t\t\t\t}\t\t\t\treverse(here.begin() + i, here.begin() + j);\t\t\t}\t\t}\t}}int solve(const vector&lt;int&gt; &amp;perm) {  //perm을 [0, ..., n-1]의 순열로 변환한다.\tint n = perm.size();\tvector&lt;int&gt; fixed(n);\tfor (int i = 0; i &lt; n; ++i) {\t\tint smaller = 0;\t\tfor (int j = 0; j &lt; n; ++j) {\t\t\tif (perm[j] &lt; perm[i])\t\t\t\tsmaller++;\t\t}\t\tfixed[i] = smaller;\t}\treturn toSort[fixed];}int main(){\tfor (int i = 1; i &lt;= 8; ++i)\t\tprecalc(i);\tint tc; scanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tint n; scanf(\"%d\", &amp;n);\t\tvector&lt;int&gt; in(n);\t\tfor (int i = 0; i &lt; n; ++i)\t\t\tscanf(\"%d\", &amp;in[i]);\t\tprintf(\"%d\\n\", solve(in));\t}\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/ALGOSPOT-SORTGAME/",
        "teaser":null},{
        "title": "[ALGOSPOT]STRJOIN",
        "excerpt":"문자열 합치기 문제 링크   https://algospot.com/judge/problem/read/STRJOIN코드 분석   그리디 알고리즘  문자열 길이가 가장 짧은 2개를 계속 더해나간다.          더한 값 역시 문자열 길이가 저장되어 있는 배열에 갱신해야 한다.        vector로 구현          vector의 멤버함수인 push_back과 pop_back을 사용하기 위해 내림차순으로 정렬하여 구현하였다.      시간 복잡도: 내림차순 정렬O(NlogN) + 문자열 길이 2개 더하고 vector 갱신하기O(N) = O(N^2 * logN)        우선순위 큐로 구현          시간복잡도: 우선순위 큐O(logN) + 문자열 길이 2개 더하고 큐 갱신O(N) = O(NlogN)      허프만 압축 알고리즘을 응용한다.      결과 코드   vector로 구현한 코드#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; len;//내림차순bool compare(const int a, const int b){ return a &gt; b; }int main(){\tint tc; scanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tint n; scanf(\"%d\", &amp;n);\t\tfor (int i = 0; i &lt; n; i++) {\t\t\tint num; scanf(\"%d\", &amp;num);\t\t\tlen.push_back(num);\t\t}\t\tint vlen = len.size();\t\t//내림차순 정렬\t\tsort(len.begin(), len.end(), compare);\t\t/*for (int i = 0; i &lt; vlen; i++)\t\t\tprintf(\"%d \", len[i]);*/\t\tint ans = 0, num1, num2, sum;\t\t//문자열 길이가 2개 이상이면 계속 더해나간다.\t\twhile (vlen &gt; 1) {\t\t\t//문자열 길이가 가장 짧은 2개를 뽑아서 더한다.\t\t\tnum1 = len[vlen - 1];\t\t\tnum2 = len[vlen - 2];\t\t\tlen.pop_back();\t\t\tlen.pop_back();\t\t\tsum = num1 + num2;\t\t\tans += sum;\t\t\t//더한 값 역시 vector에 추가한다.\t\t\tlen.push_back(sum);\t\t\t//vector 길이를 갱신한다.\t\t\tvlen = len.size();\t\t\t//다시 내림차순 정렬을 한다.\t\t\tsort(len.begin(), len.end(), compare);\t\t}\t\tprintf(\"%d\\n\", ans);\t\tlen.clear();\t}\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/ALGOSPOT-STRJOIN/",
        "teaser":null},{
        "title": "[ALGOSPOT]TRIANGLEPATH",
        "excerpt":"TRIANGLEPATH 문제 링크   https://algospot.com/judge/problem/read/TRIANGLEPATH코드 분석 Bottom-up   DP[y][x] = (y,x)일 때, 최대합  DP[0][0] = triangle[0][0]  DP[y][x] = triangle[y][x] + max(DP[y-1][x], DP[y-1][x-1])  시간복잡도: O(n^2), 부분 문제 수 n^2 * 부분 문제 계산 2Top-down + 메모이제이션   y, x는 재귀 호출이 풀어야 할 부분 문제를 지정한다. 즉, 이들은 앞으로 풀어야 할 조각들에 대한 정볼르 주는 입력들이다.  path(y,x)는 (y,x)에서 시작해서 맨 아래줄까지 내려가는 부분 경로의 최대합을 반환한다.  점화식: path(y,x) = trinangle[y][x] + max(path(y+1,x), path(y+1, x+1))  시간복잡도: O(n^2), 부분 문제수 n^2 * 부분 문제 계산 시간 M(상수)최적 부분 구조   동적 계획법의 중요한 요소로서, 어떤 문제와 분할 방식에 성립하는 조건이다.  각 부분 문제의 최적해만 있으면 전체 문제의 최적해를 쉽게 얻어낼 수 있는 경우이다.  대두분의 최적 부분 구조는 직관적으로 이해할 수 있지만, 그렇지 않은 경우는 대게 귀류법이나 대우를 이용해 증명할 수 있다.결과 코드   Bottom-up#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define N 101int dp[N][N];int tri[N][N];int mj[2] = { -1, 0 };int mi[2] = { -1, -1 };int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tmemset(dp, 0, sizeof(dp));\t\tmemset(tri, 0, sizeof(dp));\t\tint n;\t\tscanf(\"%d\", &amp;n);\t\tfor (int i = 0; i &lt; n; i++) {\t\t\tfor (int j = 0; j &lt; n; j++) {\t\t\t\tif (j &gt; i)\t\t\t\t\tbreak;\t\t\t\tscanf(\"%d\", &amp;tri[i][j]);\t\t\t}\t\t}\t\t//윗 줄부터 차례대로 내려가면서 최대합을 계산한다.\t\tdp[0][0] = tri[0][0];\t\tfor (int i = 1; i &lt; n; i++) {\t\t\tfor (int j = 0; j &lt; n; j++) {\t\t\t\tif (j &gt; i)\t\t\t\t\tbreak;\t\t\t\tfor (int f = 0; f &lt; 2; f++) {\t\t\t\t\tint fi = i + mi[f];\t\t\t\t\tint fj = j + mj[f];\t\t\t\t\tif (fj &gt;= 0 &amp;&amp; fj &lt; i)\t\t\t\t\t\tif (dp[i][j] &lt; (tri[i][j] + dp[fi][fj]))\t\t\t\t\t\t\tdp[i][j] = tri[i][j] + dp[fi][fj];\t\t\t\t}\t\t\t}\t\t}\t\t/*for (int i = 0; i &lt; n; i++) {\t\tfor (int j = 0; j &lt; n; j++)\t\tprintf(\"%d \", dp[i][j]);\t\tprintf(\"\\n\");\t\t}*/\t\tint max = 0;\t\tfor (int i = 0; i &lt; n; i++) {\t\t\tif (max &lt; dp[n - 1][i])\t\t\t\tmax = dp[n - 1][i];\t\t}\t\tprintf(\"%d\\n\", max);\t}\treturn 0;}  Top-down + 메모이제이션#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define N 100#define max(a,b) ((a)&gt;(b)?(a):(b))int n, triangle[N][N];int cache[N][N];//(y, x) 위치부터 맨 아래줄까지 내려가면서 얻을 수 있는 최대 경로의 합을 반환한다.int path(int y, int x){\t//기저 사례: 맨 아래 줄까지 도달했을 경우\tif (y == n - 1) return triangle[y][x];\t//메모이제이션\tint &amp; ret = cache[y][x];\tif (ret != -1) return ret;\treturn ret = max(path(y + 1, x), path(y + 1, x + 1))\t\t+ triangle[y][x];}int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tmemset(triangle, 0, sizeof(triangle));\t\tmemset(cache, -1, sizeof(cache));\t\tscanf(\"%d\", &amp;n);\t\tfor (int i = 0; i &lt; n; i++) {\t\t\tfor (int j = 0; j &lt; n; j++) {\t\t\t\tif (j &gt; i) break;\t\t\t\tscanf(\"%d\", &amp;triangle[i][j]);\t\t\t}\t\t}\t\tprintf(\"%d\\n\", path(0, 0));\t}\treturn 0;}결과 분석   Bottom-up          시간: 12ms        Top-down + 메모이제이션          시간: 8ms      ","categories": ["Algorithm"],
        "tags": ["Algorithm_Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/ALGOSPOT-TRIANCLEPATH/",
        "teaser":null},{
        "title": "[ALGOSPOT]WILDCARD",
        "excerpt":"WILDCARD 문제 링크   https://algospot.com/judge/problem/read/WILDCARD코드 분석 완전 탐색: 4가지 경우   s[pos]와 w[pos]가 대응되지 않는다.: 대응 실패  w 끝에 도달했다.: 패턴에 * 가 하나도 없는 경우, 패턴과 문자열의 길이가 정확히 같아야 대응 할 수 있다.  s 끝에 도달했다.: 패턴은 남아있지만 문자열은 끝난 경우, 남은 패턴이 모두 * 면 대응 가능하지만 아니면 대응 실패이다.  w[pos]가 * 인 경우: * 가 몇 글자에 대응될지 모르기 때문에, 0 글자부터 남은 문자열의 길이까지를 순회하며 모든 가능성을 검사해야한다.이때 w는 pos+1이후를 패턴 w’으로 하고, s의 pos + skip(현재 인덱스(pos) 이후 문자열 끝까지) 이후를 문자열 s’로 하여 match(w’, s’)로 재귀 호출했을 때 답이 하나라도 참이면 대응 가능하다.DP   w와 s는 각각 최대 101개이다.  match()가 101 * 101 = 10201번 이상 호출되었다면 비둘기집의 원리에 따라 어떤 부분 문제가 반드시 여러 번 계산되고 있다는 뜻이다.  중복되는 계산은 메모이제이션을 사용하여 해결 가능하다.  w는 항상 전체 패턴 W의 접미사이기 때문에 w의 길이가 결정되면 w 또한 결정된다. 이를 이용하여 101 X 101 크기의 배열에 모든 부분 문제를 저장할 수 있다.결과 코드   완전 탐색#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;#define N 1001vector&lt;string&gt; res;//와일드카드 패턴 w가 문자열 s에 대응되는지 여부를 반환한다.bool match(const string &amp;w, const string &amp;s){\t//w[pos]와 s[pos]를 맞춰나간다.\tint pos = 0;\twhile (pos &lt; (int)s.size() &amp;&amp; pos &lt; (int)w.size() &amp;&amp;\t\t(w[pos] == '?' || w[pos] == s[pos]))\t\t++pos;\t//더이상 대응할 수 없으면 왜 while문이 끝났는지 확인한다.\t//2. 패턴 끝에 도달해서 끝난 경우: 문자열도 끝났어야 대응됨\tif (pos == w.size())\t\treturn pos == s.size();\t//4. *를 만나서 끝난 경우: *에 몇 글자를 대응해야 할지 재귀 호출하면서 확인한다.\tif (w[pos] == '*')\t\tfor (int skip = 0; pos + skip &lt;= (int)s.size(); ++skip)\t\t\t//하나라도 대응되는 것이 있으면 TRUE 반환\t\t\tif (match(w.substr(pos + 1), s.substr(pos + skip)))\t\t\t\treturn true;\t//이 외의 경우에는 모두 대응되지 않는다.\treturn false;}int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tstring wild;\t\tcin &gt;&gt; wild;\t\tint n;\t\tscanf(\"%d\", &amp;n);\t\twhile (n--) {\t\t\tstring file;\t\t\tcin &gt;&gt; file;\t\t\tif (match(wild, file))\t\t\t\tres.push_back(file);\t\t}\t\tsort(res.begin(), res.end());\t\tfor (int i = 0; i &lt; (int)res.size(); i++)\t\t\tcout &lt;&lt; res[i] &lt;&lt; endl;\t\tres.clear();\t}\treturn 0;}  DP#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;#define N 101vector&lt;string&gt; res;//-1: 아직 답이 계산되지 않음//1: 해당 입력들이 서로 대응됨//0: 해당 입력들이 서로 대응되지 않음int cache[N][N];//패턴과 문자열string W, S;//와일드카드 패턴 W[w...]가 문자열 S[s...]에 대응되는지 여부를 반환int matchMemoized(int w, int s){\t//메모이제이션\tint &amp;ret = cache[w][s];\tif(ret != -1) return ret;\t//W[w]와 S[s]를 맞춰나간다.\twhile (s &lt; (int)S.size() &amp;&amp; w &lt; (int)W.size() &amp;&amp;\t\t(W[w] == '?' || W[w] == S[s])) {\t\t++w;\t\t++s;\t}\t//더이상 대응할 수 없으면 왜 while문이 끝났는지 확인한다.\t//2. 패턴 끝에 도달해서 끝난 경우: 문자열도 끝났어야 참이다.\tif (w == W.size()) return ret = (s == (int)S.size());\t//4. *를 만나서 끝난 경우: *에 몇 글자를 대응해야 할지 재귀 호출하면서 확인한다.\tif (W[w] == '*')\t\tfor (int skip = 0; skip + s &lt;= (int)S.size(); ++skip)\t\t\tif (matchMemoized(w + 1, s + skip))\t\t\t\treturn ret = 1;\t//3. 이 외의 경우에는 모두 대응되지 않는다.\treturn ret = 0;}int main(void){\tint tc;\tscanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tcin &gt;&gt; W;\t\tint n;\t\tscanf(\"%d\", &amp;n);\t\twhile (n--) {\t\t\tmemset(cache, -1, sizeof(cache));\t\t\tcin &gt;&gt; S;\t\t\tif (matchMemoized(0, 0))\t\t\t\tres.push_back(S);\t\t\tS.clear();\t\t}\t\tsort(res.begin(), res.end());\t\tfor (int i = 0; i &lt; (int)res.size(); i++)\t\t\tcout &lt;&lt; res[i] &lt;&lt; endl;\t\tres.clear();\t\tW.clear();\t}\treturn 0;}결과 분석   완전 탐색          소요 시간: 44ms        DP          소요 시간: 4ms      ","categories": ["Algorithm"],
        "tags": ["Algorithm_Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/ALGOSPOT-WILDCARD/",
        "teaser":null},{
        "title": "[ALGOSPOT]WORDCHAIN",
        "excerpt":"단어 제한 끝말잇기 문제 링크   https://algospot.com/judge/problem/read/WORDCHAIN코드 분석 1. 해밀토니안 경로(Hamiltonian path)   그래프의 모든 정점을 정확히 한 번씩 지나는 경로  해밀토니안 경로를 찾는 유일한 방법은 조합 탐색으로, 모든 정점의 배열을 하나하나 시도하며 이들이 경로가 되는지 확인하는 것이다.          시간 복잡도: 최악의 경우 O(N!)이다.      이 문제 최대 크기인 100인 경우 100!이므로, 시간안에 절대 해결할 수 없다.        예제 그림   구현 코드#define N 101bool check[N];int adj[N][N];vector&lt;string&gt; sv, ans;int n;//행의 마지막 글자가 열의 첫 번째 글자와 일치하면 1값을 넣어,//각각 단어를 이을 수 있는 지를 그래프로 표현한다.(인접 행렬)void makeAdj() {\tfor (int i = 0; i &lt; n; ++i)\t\tfor (int j = 0; j &lt; n; ++j)\t\t\tif (i != j) {\t\t\t\tchar iBackCh = sv[i][(int)sv[i].size() - 1];\t\t\t\tchar jFrontCh = sv[j][0];\t\t\t\tif (iBackCh == jFrontCh)\t\t\t\t\tadj[i][j] = 1;\t\t\t}}//단어 정점을 하나씩 방문하며 경로가 되는지 검사한다.(DFS)bool dfs(int here) {\tcheck[here] = true;\tans.push_back(sv[here]);\tbool flag = true;\tfor (int j = 0; j &lt; n; ++j)\t\tif (!check[j]) {\t\t\tflag = false;\t\t\tbreak;\t\t}\tif (flag) return true;\tfor (int there = 0; there &lt; n; ++there) {\t\tif (!check[there] &amp;&amp; adj[here][there]) {\t\t\tif (dfs(there)) return true;\t\t\tcheck[there] = false;\t\t}\t}\treturn false;}//모든 정점에서 경로를 만들 수 있는지 검사한다.bool dfsAll() {\tmakeAdj();\tfor (int i = 0; i &lt; n; ++i) {\t\tmemset(check, false, sizeof(check));\t\tans.clear();\t\tif (dfs(i))\t\t\treturn true;\t}\treturn false;}2. 오일러 트레일 혹은 서킷   입력으로 주어진 각 단어를 정점이 아닌 간선으로 갖는 방향 그래프를 만든다.  각 정점은 알파벳으로 이루어져 있고, 각 단어의 첫글자에서 마지막 글자로 가는 간선을 만든다.   위 그림에서와 같은 그래프에서 오일러 트레일 혹은 서킷을 활용하면, 답이 될 수 있는 것을 알 수 있다.  오일러 서킷 및 트레일의 자세한 내용은 링크: (추가 예정)  방향 그래프에서의 오일러 서킷          무향 그래프에서는 각 정점에서ㅓ 인접하나 간선이 짝수 개여야 하지만, 방향 그래프에서는 둘 중 한 방향만 쓸 수 있기 때문에 각 정점에 들어오는 간선의 수와 나가는 간선의 수가 같아야 한다.      방향 그래프에서 오일러 서킷을 통해 오일러 트레일(a에서 시작, b에 도착)을 찾는 방법                  간선 (b, a)를 추가 한다.          정점 a에서는 나가는 간선이 들어오는 간선보다 하나 많고, 정점 b는 들어오는 간선이 나가는 간선보다 하나 많아야 한다.          위 두 정점을 제외한 나머지 정점은 나가는 간선과 들어오는 간선의 수가 같아야 한다.                      구현 코드#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;/* 끝말잊기 문제의 입력을 그래프로 만들기*///그래프의 인점 행렬 표현, adj[i][j] = i와 j사이의 간선의 수vector&lt;vector&lt;int&gt;&gt; adj;//graph[i][j] = i로 시작해서 j로 끝나는 단어의 수vector&lt;string&gt; graph[26][26];//indegree[i] = i로 시작하는 단어의 수//outdegree[i] = i로 끝나는 단어의 수vector&lt;int&gt; indegree, outdegree;void makeGraph(const vector&lt;string&gt; &amp;words) {\t//전역 변수 초기화\tfor (int i = 0; i &lt; 26; ++i)\t\tfor (int j = 0; j &lt; 26; ++j)\t\t\tgraph[i][j].clear();\tadj = vector&lt;vector&lt;int&gt;&gt;(26, vector&lt;int&gt;(26, 0));\tindegree = outdegree = vector&lt;int&gt;(26, 0);\t//각 단어를 그래프에 추가한다.\tfor (int i = 0; i &lt; words.size(); ++i) {\t\tint a = words[i][0] - 'a';\t\tint b = words[i][words[i].size() - 1] - 'a';\t\tgraph[a][b].push_back(words[i]);\t\tadj[a][b]++;\t\toutdegree[a]++;\t\tindegree[b]++;\t}}/* 방향 그래프에서 오일러 서킷 혹은 트레일 찾아내기 *///유향 그래프의 인접 행렬 adj가 주어질 때 오일러 서킷 혹은 트레일을 계산한다.void getEulerCircuit(int here, vector&lt;int&gt; &amp;circuit) {\tfor (int there = 0; there &lt; adj.size(); ++there)\t\twhile (adj[here][there] &gt; 0) {\t\t\tadj[here][there]--;  //간선을 지운다\t\t\tgetEulerCircuit(there, circuit);\t\t}\tcircuit.push_back(here);}//현재 그래프의 오일러 트레일이나 서킷을 반환한다.vector&lt;int&gt; getEulerTrailOrCircuit() {\tvector&lt;int&gt; circuit;\t//우선 트레일을 찾아본다: 시작점이 존재하는 경우\tfor(int i = 0; i &lt; 26; ++i)\t\tif (outdegree[i] == indegree[i] + 1) {\t\t\tgetEulerCircuit(i, circuit);\t\t\treturn circuit;\t\t}\t//아니면 서킷이니, 간선에 인접한 아무 정점에서나 시간한다.\tfor(int i = 0; i &lt; 26; ++i)\t\tif (outdegree[i]) {\t\t\tgetEulerCircuit(i, circuit);\t\t\treturn circuit;\t\t}\t//모두 실패한 경우 빈 배열을 반환한다.\treturn circuit;}/* 끝말잇기 문제를 오일러 트레일 문제로 바꿔 해결하는 알고리즘 */string solve(const vector&lt;string&gt; &amp;words) {\tmakeGraph(words);\t//오일러 서킷이나 트레일으르 찾아낸다.\tvector&lt;int&gt; circuit = getEulerTrailOrCircuit();\t//모든 간선을 방문하지 못했으면 실패\tif (circuit.size() != words.size() + 1) return \"IMPOSSIBLE\";\t//아닌 경우 방문 순서를 뒤집은 뒤 간선들을 모아 문자열로 만들어 반환한다.\treverse(circuit.begin(), circuit.end());\tstring ret;\tfor (int i = 1; i &lt; circuit.size(); ++i) {\t\tint a = circuit[i - 1], b = circuit[i];\t\tif (ret.size()) ret += \" \";\t\tret += graph[a][b].back();\t\tgraph[a][b].pop_back();\t}\treturn ret;}int main(){\tint tc; scanf(\"%d\", &amp;tc);\twhile (tc--) {\t\tvector&lt;string&gt; sv;\t\tint n;  scanf(\"%d\", &amp;n);\t\tfor (int i = 0; i &lt; n; ++i) {\t\t\tstring str;\t\t\tcin &gt;&gt; str;\t\t\tsv.push_back(str);\t\t}\t\tcout &lt;&lt; solve(sv) &lt;&lt; endl;\t}\treturn 0;}예외 사항   위 오일러 서킷 및 트레일 코드에 예외 사항이 발생한다.          결과는 정답으로 나온다.        getEulerCircuit()함수에서 갈 수 없는 경로를 가는 경우가 발생하여 vector에 추가하지 못하는데, solve()함수에서 정답을 출력하려 하기 때문에 존재하지 않는 vector 인덱스에 접근하여 오류로 강제 종료된다.  예외 테스트 케이스15goddoggunnewnurse  나중에 수정 및 해결 해볼것…","categories": ["Algorithm"],
        "tags": ["Algorithm_Algospot"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/ALGOSPOT-WORDCHAIN/",
        "teaser":null},{
        "title": "[SW Expert Academy] 2117.홈 방범 서비스",
        "excerpt":"홈 방범 서비스 문제 링크   https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5V61LqAf8DFAWu해결 방법 완전 탐색   서비스 영역의 면적이 최대 크기 20 x 20을 모두 포함하려면 대략 k 값을 25로 정한다.  k 값 1 ~ 25 까지 포함되는 모든 좌표를 벡터에 저장한다.          원점 기준으로 하며, 이는 도시 정보의 한 칸 한 칸마다 서비스 영역을 적용하기 위해서이다.        도시 정보가 주어진 2차원 배열의 모든 좌표에서 위에서 저장한 서비스 영역을 적용하여 손해보지 않는 최대 집의 수를 구한다.시간 복잡도 서비스 영역 구하기   다음 서비스 영역을 구하는 방법으로 현재 서비스 영역에서 동서남북 방향으로 한 칸씩 늘리는 방법을 사용하였다.(중복 제외)  서비스 영역의 개수는 1, 5, 13, 25, 41, 61, ... 1201로 증가한다.  이를 바탕으로 최대 시간 복잡도는 대략25 * 4(동서남북) * 1200 * 1200 = 144,000,000으로 약 1초정도 걸릴 것으로 예상된다.최대 집의 개수 구하기   최대 시간 복잡도는 25(서비스 영역 크기) * 20(가로) * 20(세로) * 1200(최대 서비스 영역 좌표 개수) = 12,000,000이다.결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int my[4] = { -1, 0, 1, 0 };int mx[4] = { 0, 1, 0, -1 };//도시 입력int cmap[21][21];//kv[i] = k의 크기가 i일때 방범 서비스를 제공할 수 있는 모든 좌표의 집합vector&lt;pair&lt;int, int&gt;&gt; kv[25];//가로세로 최대 크기 20인 배열을 모두 방범 서비스를 제공할 k의 최대 크기는 대략 23 ~ 25이다.//미리 k의 크기에 따른 방범 서비스를 할 수 있는 좌표 집합을 만든다.void makeKSet() {\t//k = 1일때\tkv[0].push_back({ 0, 0 });\t//k = 2일때 부터 계산을 한다.\tfor (int i = 1; i &lt; 25; ++i) {\t\tint pre_ksize = kv[i - 1].size();\t\tkv[i] = kv[i - 1];\t\tfor (int j = 0; j &lt; pre_ksize; ++j) {\t\t\tfor (int k = 0; k &lt; 4; ++k) {\t\t\t\tint nexty = kv[i - 1][j].first + my[k];\t\t\t\tint nextx = kv[i - 1][j].second + mx[k];\t\t\t\tbool flag = false;\t\t\t\t//중복되는 좌표가 있는지 검사한다.\t\t\t\tfor(int l = 0; l &lt; kv[i].size(); ++l)\t\t\t\t\tif (kv[i][l].first == nexty &amp;&amp; kv[i][l].second == nextx) {\t\t\t\t\t\tflag = true;\t\t\t\t\t\tbreak;\t\t\t\t\t}\t\t\t\t//중복이 없으면 추가한다.\t\t\t\tif (!flag)\t\t\t\t\tkv[i].push_back({ nexty, nextx });\t\t\t}\t\t}\t}}//k에 따른 운영 비용을 반환한다.int calOperationFin(int k) {\treturn (k * k) + ((k - 1) * (k - 1));}int main(void){\tmakeKSet();\tint tc; scanf(\"%d\", &amp;tc);\tfor (int t = 1; t &lt;= tc; ++t) {\t\tmemset(cmap, 0, sizeof(cmap));\t\tint n, m; scanf(\"%d %d\", &amp;n, &amp;m);\t\tfor(int i=0; i&lt;n; ++i)\t\t\tfor(int j=0; j&lt;n; ++j)\t\t\t\tscanf(\"%d\", &amp;cmap[i][j]);\t\tint ans = 0;\t\t//k에 따라 방범 서비스를 받을 수 있는 최대 집의 개수를 계산한다.\t\tfor(int i = 0; i &lt; 25; ++i) {\t\t\t//현재 k에서 운영 비용\t\t\tint curOF = calOperationFin(i + 1);\t\t\t//현재 k에서 모든 좌표를 순회한다.\t\t\tfor (int y = 0; y &lt; n; ++y) {\t\t\t\tfor (int x = 0; x &lt; n; ++x) {\t\t\t\t\tint serviced = 0, curProfit;\t\t\t\t\t//현재 좌표에서 방범 서비스를 받을 수 있는 집의 개수 계산\t\t\t\t\tfor (int j = 0; j &lt; kv[i].size(); ++j) {\t\t\t\t\t\tint nexty = y + kv[i][j].first;\t\t\t\t\t\tint nextx = x + kv[i][j].second;\t\t\t\t\t\tif (nexty &gt;= 0 &amp;&amp; nexty &lt; n &amp;&amp; nextx &gt;= 0 &amp;&amp; nextx &lt; n)\t\t\t\t\t\t\tif (cmap[nexty][nextx])\t\t\t\t\t\t\t\tserviced++;\t\t\t\t\t}\t\t\t\t\tcurProfit = (serviced * m) - curOF;\t\t\t\t\t//비용 손해를 보지 않는다면 최대 집 개수를 갱신한다.\t\t\t\t\tif (curProfit &gt;= 0)\t\t\t\t\t\tans = ans &gt; serviced ? ans : serviced;\t\t\t\t\t\t}\t\t\t}\t\t}\t\tprintf(\"#%d %d\\n\", t, ans);\t}\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_FCT"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/SW-Expert-Academy-2117.%ED%99%88-%EB%B0%A9%EB%B2%94-%EC%84%9C%EB%B9%84%EC%8A%A4/",
        "teaser":null},{
        "title": "[SW Expert Academy] 2382.미생물 격리",
        "excerpt":"미생물 격리 문제 링크   https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV597vbqAH0DFAVl해결 방법 시뮬레이션   문제에서 제시된 시간에 따라 미생물의 움직임에 대한 경우의 수를 조건에 맞게 구현한다.  주의할 점은 임시로 사용할 배열을 반복문안에 선언하여 사용하면 시간이 훨씬 많이 걸린다.          전역으로 선언하여 초기화해주면서 사용하는 것이 효율적이다.      시간 복잡도   최대 시간 복잡도는 1000(시간) * 1000(군집 개수) * 4(겹쳐질 수 있는 군집의 개수) = 4,000,000이다.결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//상,하,좌,우int my[4] = { -1, 1, 0, 0 };int mx[4] = { 0, 0, -1, 1 };//미생물 군집 정보 클래스class state {public:\tint y, x;\tint microNum;\tint dir;};//방향 반전int reverseDir(int cur) {\t//상하 반전\tif (cur == 0)\t\treturn 1;\telse if (cur == 1)\t\treturn 0;\t//좌우 반전\telse if (cur == 2)\t\treturn 3;\telse if (cur == 3)\t\treturn 2;\treturn -1;}//모든 미생물 군집 정보를 저장할 벡터vector&lt;state&gt; mov;//미생물 군집이 존재하는 좌표에 군집 인덱스를 저장할 2차원 벡터vector&lt;int&gt; map[101][101];int main(void){\tint tc; scanf(\"%d\", &amp;tc);\tfor (int t = 1; t &lt;= tc; ++t) {\t\tmov.clear();\t\tint n, m, k; scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;k);\t\tfor (int i = 0; i &lt; k; ++i) {\t\t\tint y, x, mn, d;\t\t\tscanf(\"%d %d %d %d\", &amp;y, &amp;x, &amp;mn, &amp;d);\t\t\tmov.push_back({ y, x, mn, d - 1 });\t\t}\t\tint msize = mov.size();\t\t//시간 경과\t\tfor (int i = 0; i &lt; m; ++i) {\t\t\t//미생물 군집들이 이동한 결과를 갱신할 벡터\t\t\tvector&lt;state&gt; tmp;\t\t\t/*\t\t\t크기가 큰 저장공간을 계속해서 만들고 사용하는 것은 시간이 매우 오래걸린다.\t\t\t전역으로 선언 후 초기화하면서 사용하는 것이 시간 단축에 큰 도움이 된다.\t\t\t특히 이 문제에서는 map[y][x]을 한번 사용하면 바로 지워주기 때문에\t\t\t따로 초기화해줄 필요가 없어 전역으로 선언해서 사용하면 더욱 효율적이다.\t\t\t(map[y][x]를 중복해서 사용하는 것을 방지하기위해 사용하면 바로 지워준다.)\t\t\t*/\t\t\t//vector&lt;int&gt; map[101][101];\t\t\t//군집 이동\t\t\tfor (int j = 0; j &lt; msize; ++j) {\t\t\t\tint nexty = mov[j].y + my[mov[j].dir];\t\t\t\tint nextx = mov[j].x + mx[mov[j].dir];\t\t\t\tmov[j].y = nexty;\t\t\t\tmov[j].x = nextx;\t\t\t\t//이동한 좌표에 군집 인덱스 저장\t\t\t\tmap[nexty][nextx].push_back(j);\t\t\t}\t\t\t//군집 갱신\t\t\tfor (int j = 0; j &lt; msize; ++j) {\t\t\t\t//해당 좌표의 군집 개수가 1개인 경우\t\t\t\tif (map[mov[j].y][mov[j].x].size() == 1) {\t\t\t\t\t//약품이 칠해진 셀에 도착한 경우\t\t\t\t\tif (mov[j].y == 0 || mov[j].y == n - 1\t\t\t\t\t\t|| mov[j].x == 0 || mov[j].x == n - 1) {\t\t\t\t\t\tstate half;\t\t\t\t\t\thalf.dir = reverseDir(mov[j].dir);\t\t\t\t\t\thalf.y = mov[j].y;\t\t\t\t\t\thalf.x = mov[j].x;\t\t\t\t\t\thalf.microNum = mov[j].microNum / 2;\t\t\t\t\t\t//미생물 군집 크기가 0보다 큰 경우에만 갱신한다.\t\t\t\t\t\tif (half.microNum &gt; 0)\t\t\t\t\t\t\ttmp.push_back(half);\t\t\t\t\t\t//해당 좌표의 인덱스를 지운다.\t\t\t\t\t\tmap[mov[j].y][mov[j].x].clear();\t\t\t\t\t}\t\t\t\t\t//일반 셀인 경우\t\t\t\t\telse {\t\t\t\t\t\ttmp.push_back(mov[j]);\t\t\t\t\t\tmap[mov[j].y][mov[j].x].clear();\t\t\t\t\t}\t\t\t\t}\t\t\t\t//해당 좌표의 군집 개수가 1보다 많은 경우\t\t\t\telse if (map[mov[j].y][mov[j].x].size() &gt; 1) {\t\t\t\t\tint bigMicro = 0, bigIdx = 0, totalMicro = 0;\t\t\t\t\t//방향을 정할 가장 큰 군집 인덱스와 미생물의 총합을 구한다.\t\t\t\t\tfor (int k = 0; k &lt; map[mov[j].y][mov[j].x].size(); ++k) {\t\t\t\t\t\tif (bigMicro &lt; mov[map[mov[j].y][mov[j].x][k]].microNum) {\t\t\t\t\t\t\tbigMicro = mov[map[mov[j].y][mov[j].x][k]].microNum;\t\t\t\t\t\t\tbigIdx = map[mov[j].y][mov[j].x][k];\t\t\t\t\t\t}\t\t\t\t\t\ttotalMicro += mov[map[mov[j].y][mov[j].x][k]].microNum;\t\t\t\t\t}\t\t\t\t\tstate summ;\t\t\t\t\tsumm.dir = mov[bigIdx].dir;\t\t\t\t\tsumm.y = mov[bigIdx].y;\t\t\t\t\tsumm.x = mov[bigIdx].x;\t\t\t\t\tsumm.microNum = totalMicro;\t\t\t\t\ttmp.push_back(summ);\t\t\t\t\t//해당 좌표에는 여러 군집이 저장되어 있으므로 지우지 않으면 중복이 발생한다.(궁극적인 이유)\t\t\t\t\tmap[mov[j].y][mov[j].x].clear();\t\t\t\t}\t\t\t}\t\t\t//갱신한 임시 벡터를 원래 벡터에 저장해주고 크기를 다시 계산한다.\t\t\tmov = tmp;\t\t\tmsize = mov.size();\t\t}\t\t//남은 미생물 군집을 모두 더한다.\t\tint ans = 0;\t\tfor (int i = 0; i &lt; msize; ++i)\t\t\tans += mov[i].microNum;\t\tprintf(\"#%d %d\\n\", t, ans);\t}\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_FCT"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/SW-Expert-Academy-2382.%EB%AF%B8%EC%83%9D%EB%AC%BC-%EA%B2%A9%EB%A6%AC/",
        "teaser":null},{
        "title": "[SW Expert Academy] 2383.점심 식사시간",
        "excerpt":"점심 식사시간 문제 링크   https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5-BEE6AK0DFAVl해결 방법 조합 + 시뮬레이션   각 사람들이 2개의 계단을 이용하는 모든 경우의 수는 조합으로 풀 수 있다.  각 경우의 수마다 모든 사람이 계단을 내려가는 시뮬레이션을 통해 시간을 구하며, 그 중 최소값을 선택한다.시간 복잡도   최대 10명의 사람이 2개의 계단을 이용하는 모든 경우의 수: 10C2 = 45  시뮬레이션 최대 시간: 10(세로) * 10(가로) * 10(계단을 내려가는 최대 시간) * 10(사람수) = 10,000  45 * 10(사람수, 정보 저장) * 10,000 = 4,500,000Notice   SW Expert Academy 는 GCC컴파일러를 사용하는데 이때 sort SLT함수의 3번째 인자를 밑과 같이 사용하면 에러가 발생한다. 그러므로 일반적인 함수 오버로딩이나 연산자 오버로딩을 사용해야 할 것 같다.//에러sort(arriveState.begin(), arriveState.end(), [](state &amp;a, state &amp;b) {  return a.arriveTime &lt; b.arriveTime;});결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;queue&gt;using namespace std;const int INF = 987654321;//계단에 도착한 사람의 상태 클래스class state {public:\tint arriveTime;  //도착 시간\tint stairNum;    //계단 번호\tint personNum;   //사람 번호};//거리 계산int calDist(int py, int px, int sy, int sx) {\treturn abs(py - sy) + abs(px - sx);}//sort함수를 위한 연산자 오버로딩bool operator &lt;(const state &amp;a, const state &amp;b) {\treturn a.arriveTime &lt; b.arriveTime;}int main(void){\tint tc; scanf(\"%d\", &amp;tc);\tfor (int t = 1; t &lt;= tc; ++t) {\t\tint n; scanf(\"%d\", &amp;n);\t\t//사람의 위치를 저장하는 벡터\t\tvector&lt;pair&lt;int, int&gt;&gt; person;\t\t//계단의 위치를 저장하는 벡터\t\tvector&lt;pair&lt;int, int&gt;&gt; stair;\t\t//계단의 길이를 저장할 배열\t\tint sLen[2], cnt = 0;\t\tfor (int i = 0; i &lt; n; ++i)\t\t\tfor (int j = 0; j &lt; n; ++j) {\t\t\t\tint loc; scanf(\"%d\", &amp;loc);\t\t\t\tif (loc == 1)\t\t\t\t\tperson.push_back(make_pair(i, j));\t\t\t\telse if (loc &gt; 1) {\t\t\t\t\tstair.push_back(make_pair(i, j));\t\t\t\t\tsLen[cnt++] = loc;\t\t\t\t}\t\t\t}\t\tint ans = INF;\t\tint psize = person.size();\t\t//계단 2개를 이용하는 모든 경우의 수를 탐색 (조합 사용)\t\tfor (int i = 0; i &lt;= psize; ++i) {\t\t\tvector&lt;int&gt; flag;\t\t\tfor (int j = 0; j &lt; psize - i; ++j)\t\t\t\tflag.push_back(0);\t\t\tfor (int j = 0; j &lt; i; ++j)\t\t\t\tflag.push_back(1);\t\t\t//조합 계산\t\t\tdo {\t\t\t\t//각 사람에게 주어진 계단에 도착할 때의 정보를 저장하는 벡터        //{ 계단까지 거리, 계단 번호, 사람 번호 }\t\t\t\tvector&lt;state&gt; arriveState;\t\t\t\tfor (int j = 0; j &lt; psize; ++j) {\t\t\t\t\tif (!flag[j]) {\t\t\t\t\t\tarriveState.push_back({ calDist(person[j].first, person[j].second,\t\t\t\t\t\t\tstair[0].first, stair[0].second), 0, j });\t\t\t\t\t}\t\t\t\t\telse {\t\t\t\t\t\tarriveState.push_back({ calDist(person[j].first, person[j].second,\t\t\t\t\t\t\tstair[1].first, stair[1].second), 1, j });\t\t\t\t\t}\t\t\t\t}\t\t\t\t//계단에 도착하는 시간을 오름차순으로 정렬\t\t\t\tsort(arriveState.begin(), arriveState.end());\t\t\t\t//time: 시간, serviced: 계단을 모두 내려간 사람 수\t\t\t\tint time = 0, serviced = 0;        //계단의 상황을 통제하는 벡터 {계단 번호, 계단을 내려가는데 걸리는 시간 }\t\t\t\t//계단을 내려가는데 걸리는 시간이\t\t\t\t//-1: 계단을 모두 내려온 후로 계산에서 제외함\t\t\t\t//0: 현재 시간에 계단을 모두 내려옴\t\t\t\t//0보다 큰수: 계단을 내려거야할 시간\t\t\t\tvector&lt;pair&lt;int, int&gt;&gt; s1, s2;\t\t\t\t//시뮬레이션\t\t\t\twhile (true) {\t\t\t\t\t//기저 사례: 계단을 모두 내려간 사람 수와 전체 사람수가 같으면 종료\t\t\t\t\tif (serviced == psize) break;\t\t\t\t\tint vcnt = 0;\t\t\t\t\t//계단 1\t\t\t\t\tfor (int j = 0; j &lt; s1.size(); ++j) {\t\t\t\t\t\t//계단을 사용할 수 있는 최대 사람 수인 3명을 넘으면 빠져나간다.\t\t\t\t\t\tif (vcnt == 3) break;\t\t\t\t\t\tif (s1[j].second &gt; 0) {\t\t\t\t\t\t\ts1[j].second--;\t\t\t\t\t\t\tvcnt++;\t\t\t\t\t\t}\t\t\t\t\t\t//계단을 모두 내려갔다면 서비스완료 사람수를 늘리고 시간에 -1값을 넣는다.\t\t\t\t\t\telse if (s1[j].second == 0) {\t\t\t\t\t\t\tserviced++;\t\t\t\t\t\t\ts1[j].second = -1;\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t\tvcnt = 0;\t\t\t\t\t//계단 2\t\t\t\t\tfor (int j = 0; j &lt; s2.size(); ++j) {\t\t\t\t\t\tif (vcnt == 3) break;\t\t\t\t\t\tif (s2[j].second &gt; 0) {\t\t\t\t\t\t\ts2[j].second--;\t\t\t\t\t\t\tvcnt++;\t\t\t\t\t\t}\t\t\t\t\t\telse if (s2[j].second == 0) {\t\t\t\t\t\t\tserviced++;\t\t\t\t\t\t\ts2[j].second = -1;\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t\t//현재 시간에 계단에 도착하는 사람이 있는지 탐색한다.\t\t\t\t\tfor (int j = 0; j &lt; psize; ++j) {\t\t\t\t\t\tif (arriveState[j].arriveTime == time) {\t\t\t\t\t\t\tif (arriveState[j].stairNum == 0)\t\t\t\t\t\t\t\ts1.push_back({ arriveState[j].personNum, sLen[0] });\t\t\t\t\t\t\telse if(arriveState[j].stairNum == 1)\t\t\t\t\t\t\t\ts2.push_back({ arriveState[j].personNum, sLen[1] });\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t\t//시간 증가\t\t\t\t\ttime++;\t\t\t\t}\t\t\t\t//시간을 1증가하고 시뮬레이션이 종료되므로 시간을 1빼준다.\t\t\t\tans = ans &lt; (time - 1) ? ans : (time - 1);\t\t\t} while (next_permutation(flag.begin(), flag.end()));\t\t}\t\tprintf(\"#%d %d\\n\", t, ans);\t}\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_FCT"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/SW-Expert-Academy-2383.%EC%A0%90%EC%8B%AC-%EC%8B%9D%EC%82%AC%EC%8B%9C%EA%B0%84/",
        "teaser":null},{
        "title": "[SW Expert Academy] 2477.차량 정비소",
        "excerpt":"차량 정비소 문제 링크   https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV6c6bgaIuoDFAXy&amp;categoryId=AV6c6bgaIuoDFAXy&amp;categoryType=CODE해결 방법 시뮬레이션   문제가 제시하는 고객이 서비스 받는 순서를 그대로 시뮬레이션으로 구현한다.시간 복잡도   최대 시간: 1,000  최대 고객 수: 1,000  최대 창구 개수: 9 + 9 = 18  1,000 * 1,000(?) * 18 = 18,000,000  시뮬레이션 안의 고객 수는 현재 시간에 도착한 고객 수이기 때문에 0 ~ 1000로 시간마다 변한다.결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;queue&gt;using namespace std;//창구 정보를 저장하는 클래스class desk {public:\t\tbool use;          //현재 사용여부\t\tint usingPerson;   //현재 사용하고 있는 사람 번호\t\tint usingTime;     //현재까지 사용한 시간\t\t//클래스 초기화\t\tdesk() {\t\t\tuse = false;\t\t\tusingPerson = 0;\t\t\tusingTime = 0;\t\t}};int main(void){\tint tc; scanf(\"%d\", &amp;tc);\tfor (int t = 1; t &lt;= tc; ++t) {\t\tint n, m, k, a, b;\t\tscanf(\"%d %d %d %d %d\", &amp;n, &amp;m, &amp;k, &amp;a, &amp;b);\t\t//1번 인덱스부터 저장\t\tint at[10], bt[10];\t\tfor (int i = 0; i &lt; n; ++i)\t\t\tscanf(\"%d\", &amp;at[i + 1]);\t\tfor (int i = 0; i &lt; m; ++i)\t\t\tscanf(\"%d\", &amp;bt[i + 1]);\t\tint kt[1001];\t\tfor (int i = 0; i &lt; k; ++i)\t\t\tscanf(\"%d\", &amp;kt[i + 1]);\t\t//현재 시간\t\tint cur_time = 0;\t\t//서비스를 모두 받은 사람 수\t\tint servicedPerson = 0;\t\t//각 창구 정보를 저장하는 벡터(0번 인덱스부터 시작)\t\tvector&lt;desk&gt; aDesk(n);\t\tvector&lt;desk&gt; bDesk(m);\t\t//aq: 접수 창구를 기다리고 있는 대기열\t\t//bq: 정비 창구를 기다리고 있는 대기열\t\tqueue&lt;int&gt; aq, bq;\t\t//각각의 사람이 몇번 접수 창구(0) 몇번 정비 창구(1)를 사용했는지 저장하는 배열\t\tint usedDesk[2][1001];\t\t//시뮬레이션 시작\t\twhile (true) {\t\t\t//기저 사례: 모든 사람이 서비스를 받았다면 반복문을 종료한다.\t\t\tif (servicedPerson == k) break;\t\t\t//현재 시간에서 정비소에 온 사람을 접수 창구 대기열에 추가한다.\t\t\tfor (int i = 0; i &lt; k; ++i)\t\t\t\tif (kt[i + 1] == cur_time)\t\t\t\t\taq.push(i + 1);\t\t\t//접수 창구\t\t\tfor (int i = 0; i &lt; n; ++i) {\t\t\t\t//현재 접수 창구를 사용하지 않고 있으며, 대기열에 사람이 있는 경우\t\t\t\tif (!aDesk[i].use &amp;&amp; !aq.empty()) {\t\t\t\t\taDesk[i].use = true;\t\t\t\t\tint nextPerson = aq.front();\t\t\t\t\taq.pop();\t\t\t\t\tusedDesk[0][nextPerson] = i + 1;\t\t\t\t\taDesk[i].usingPerson = nextPerson;\t\t\t\t}\t\t\t\t//현재 접수 창구를 사용하고 있고, 서비스 시간이 끝난 경우\t\t\t\telse if (aDesk[i].use &amp;&amp; aDesk[i].usingTime == at[i + 1]) {\t\t\t\t\t//정비 창구 대기열에 추가해준다.\t\t\t\t\tbq.push(aDesk[i].usingPerson);\t\t\t\t\t//접수 창구 대기열에 사람이 있다면 추가한다.\t\t\t\t\tif (!aq.empty()) {\t\t\t\t\t\tint nextPerson = aq.front();\t\t\t\t\t\taq.pop();\t\t\t\t\t\tusedDesk[0][nextPerson] = i + 1;\t\t\t\t\t\taDesk[i].usingTime = 0;\t\t\t\t\t\taDesk[i].usingPerson = nextPerson;\t\t\t\t\t}\t\t\t\t\t//대기열이 없다면 초기화한다.\t\t\t\t\telse {\t\t\t\t\t\taDesk[i].use = false;\t\t\t\t\t\taDesk[i].usingPerson = 0;\t\t\t\t\t\taDesk[i].usingTime = 0;\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\t//정비 창구\t\t\tfor (int i = 0; i &lt; m; ++i) {\t\t\t\t//현재 정비 창구를 사용하지 않고 있으며, 대기열에 사람이 있는 경우\t\t\t\tif (!bDesk[i].use &amp;&amp; !bq.empty()) {\t\t\t\t\tbDesk[i].use = true;\t\t\t\t\tint nextPerson = bq.front();\t\t\t\t\tbq.pop();\t\t\t\t\tusedDesk[1][nextPerson] = i + 1;\t\t\t\t\tbDesk[i].usingPerson = nextPerson;\t\t\t\t\t//정비 창구까지 왔다면 모든 서비스를 받은 것으로 간주한다.\t\t\t\t\tservicedPerson++;\t\t\t\t}\t\t\t\t//현재 정비 창구를 사용하고 있고, 서비스 시간이 끝난 경우\t\t\t\telse if (bDesk[i].use &amp;&amp; bDesk[i].usingTime == bt[i + 1]) {\t\t\t\t\t//정비 창구 대기열에 사람이 있다면 추가한다.\t\t\t\t\tif (!bq.empty()) {\t\t\t\t\t\tint nextPerson = bq.front();\t\t\t\t\t\tbq.pop();\t\t\t\t\t\tusedDesk[1][nextPerson] = i + 1;\t\t\t\t\t\tbDesk[i].usingTime = 0;\t\t\t\t\t\tbDesk[i].usingPerson = nextPerson;\t\t\t\t\t\t//정비 창구까지 왔다면 모든 서비스를 받은 것으로 간주한다.\t\t\t\t\t\tservicedPerson++;\t\t\t\t\t}\t\t\t\t\t//대기열이 없다면 초기화한다.\t\t\t\t\telse {\t\t\t\t\t\tbDesk[i].use = false;\t\t\t\t\t\tbDesk[i].usingPerson = 0;\t\t\t\t\t\tbDesk[i].usingTime = 0;\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\t//현재 시간 및 창구에 서비스를 받고 있는 시간을 증가시킨다.\t\t\tcur_time++;\t\t\tfor (int i = 0; i &lt; n; ++i)\t\t\t\tif (aDesk[i].use)\t\t\t\t\taDesk[i].usingTime++;\t\t\tfor (int i = 0; i &lt; m; ++i)\t\t\t\tif (bDesk[i].use)\t\t\t\t\tbDesk[i].usingTime++;\t\t}\t\tint ans = 0;\t\tfor (int i = 0; i &lt; k; ++i) {\t\t\tif (usedDesk[0][i + 1] == a &amp;&amp; usedDesk[1][i + 1] == b)\t\t\t\tans += (i + 1);\t\t}\t\tprintf(\"#%d %d\\n\", t, ans == 0 ? -1 : ans);\t}\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_FCT"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/SW-Expert-Academy-2477.%EC%B0%A8%EB%9F%89-%EC%A0%95%EB%B9%84%EC%86%8C/",
        "teaser":null},{
        "title": "[SW Expert Academy] 4008.숫자 만들기",
        "excerpt":"숫자 만들기 문제 링크   https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWIeRZV6kBUDFAVH&amp;categoryId=AWIeRZV6kBUDFAVH&amp;categoryType=CODE해결 방법 순열 + 완전탐색   주어진 연산자들이 정해진 숫자 사이의 공간에 위치하는 모든 경우의 수를 순열로 계산하여 해결한다.          연산자의 종류는 4개이므로 4개보다 많은 연산자를 사용하면 반드시 중복이 생긴다.      중복이 m개 있는 수열 n에서 r개를 뽑는 순열은 nPr / m!이다.      시간 복잡도   최대 연산자 개수(n): 11  최대 주어진 공간(r): 11  11P11(= 11!) / m!Notice   음수가 나올 수 있으므로, 가장 작은 값을 설정할 때 0이 아닌 최대 음수값으로 설정해야 한다.결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;const int INF = 987654321;const int RINF = -987654321;int main(void){\tint tc; scanf(\"%d\", &amp;tc);\tfor (int t = 1; t &lt;= tc; ++t) {\t\tint n; scanf(\"%d\", &amp;n);\t\t// 0: +, 1: -, 2: *, 3: /\t\tint oper[4] = { 0, };\t\tvector&lt;int&gt; opv;\t\tfor (int i = 0; i &lt; 4; ++i) {\t\t\tscanf(\"%d\", &amp;oper[i]);\t\t\t//연산자별로 저장하기(조합 탐색을 위해)\t\t\tfor (int j = 0; j &lt; oper[i]; ++j)\t\t\t\topv.push_back(i);\t\t}\t\tint num[13] = { 0, };\t\tfor (int i = 0; i &lt; n; ++i)\t\t\tscanf(\"%d\", &amp;num[i]);\t\t//최대값은 음수를 포함한 범위안에서 가장 작은수\t\t//최소값은 가장 큰수로 초기화한다.\t\tint ans_max = RINF, ans_min = INF;\t\tdo {\t\t\tint cal_res = num[0];\t\t\tint cnt = 0;\t\t\tfor (int i = 1; i &lt; n; ++i) {\t\t\t\tswitch (opv[cnt++]) {\t\t\t\tcase 0: cal_res += num[i]; break;\t\t\t\tcase 1: cal_res -= num[i]; break;\t\t\t\tcase 2: cal_res *= num[i]; break;\t\t\t\tcase 3: cal_res /= num[i]; break;\t\t\t\tdefault: break;\t\t\t\t}\t\t\t}\t\t\tans_max = ans_max &gt; cal_res ? ans_max : cal_res;\t\t\tans_min = ans_min &lt; cal_res ? ans_min : cal_res;\t\t\t/* //연산자의 모든 경우의 수 출력해보기\t\t\tfor (int i = 1; i &lt; n; ++i) {\t\t\t\tswitch (opv[cnt++]) {\t\t\t\tcase 0: printf(\"+ \"); break;\t\t\t\tcase 1: printf(\"- \"); break;\t\t\t\tcase 2: printf(\"* \"); break;\t\t\t\tcase 3: printf(\"/ \"); break;\t\t\t\tdefault: break;\t\t\t\t}\t\t\t}\t\t\tprintf(\"\\n\");*/\t\t} while (next_permutation(opv.begin(), opv.end()));\t\tprintf(\"#%d %d\\n\", t, ans_max - ans_min);\t}\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_FCT"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/SW-Expert-Academy-4008.%EC%88%AB%EC%9E%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
        "teaser":null},{
        "title": "[SW Expert Academy] 4012.요리사",
        "excerpt":"요리사 문제 링크   https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWIeUtVakTMDFAVH&amp;categoryId=AWIeUtVakTMDFAVH&amp;categoryType=CODE해결 방법 조합 + 완전탐색   재료를 2가지로 나누므로 모든 재료를 2가지로 나누는 모든 경우의 수를 조합으로 계산한다.  재료의 시너지는 각각 2개의 재료의 시너지를 모두 더한 값이다.시간 복잡도   최대 식재료 개수: n = 16  재료 시너지의 총합: (n/2) * (n/2) = 8 * 8 = 64  16C2 * 64 = 7,680결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;const int INF = 987654321;int mat[17][17];int main(void){\tint tc; scanf(\"%d\", &amp;tc);\tfor (int t = 1; t &lt;= tc; ++t) {\t\tmemset(mat, 0, sizeof(mat));\t\tint n; scanf(\"%d\", &amp;n);\t\tfor (int i = 0; i &lt; n; ++i)\t\t\tfor (int j = 0; j &lt; n; ++j)\t\t\t\tscanf(\"%d\", &amp;mat[i][j]);\t\tint ans = INF;\t\t//전체 재료의 반을 선택하는 모든 경우의 수 계산(조합 사용)\t\tvector&lt;int&gt; flag;\t\tfor (int i = 0; i &lt; n - (n / 2); ++i)\t\t\tflag.push_back(0);\t\tfor (int i = 0; i &lt; n / 2; ++i)\t\t\tflag.push_back(1);\t\tdo {\t\t\tint matA[17], matB[17];\t\t\tint cntA = 0, cntB = 0;\t\t\t//1: A재료, 0: B재료 로 사용\t\t\tfor (int i = 0; i &lt; n; ++i)\t\t\t\tif (flag[i])\t\t\t\t\tmatA[cntA++] = i;\t\t\t\telse\t\t\t\t\tmatB[cntB++] = i;\t\t\t//두가지 재료마다 시너지를 모두 더한다.\t\t\tint foodA = 0, foodB = 0;\t\t\tfor (int i = 0; i &lt; n / 2; ++i)\t\t\t\tfor (int j =  i + 1; j &lt; n / 2; ++j) {\t\t\t\t\tfoodA += (mat[matA[i]][matA[j]] + mat[matA[j]][matA[i]]);\t\t\t\t\tfoodB += (mat[matB[i]][matB[j]] + mat[matB[j]][matB[i]]);\t\t\t\t}\t\t\t//맛 차이 구하기\t\t\tint sub = foodA - foodB;\t\t\tsub = sub &gt;= 0 ? sub : -sub;\t\t\tans = ans &lt; sub ? ans : sub;\t\t\t/*for (int i = 0; i &lt; n; ++i)\t\t\t\tif (flag[i])\t\t\t\t\tprintf(\"%d \", i);\t\t\tprintf(\"\\n\");*/\t\t} while (next_permutation(flag.begin(), flag.end()));\t\tprintf(\"#%d %d\\n\", t, ans);\t}\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_FCT"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/SW-Expert-Academy-4012.%EC%9A%94%EB%A6%AC%EC%82%AC/",
        "teaser":null},{
        "title": "[SW Expert Academy] 4013.특이한 자석",
        "excerpt":"특이한 자석 문제 링크   https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWIeV9sKkcoDFAVH&amp;categoryId=AWIeV9sKkcoDFAVH&amp;categoryType=CODE해결 방법 구현   문제에서 제시한 톱니바퀴가 도는 조건을 바탕으로, 특정 톱니바퀴를 한 번 회전 시킬 때 같이 회전해야할 톱니바퀴들을 계산하여 그에 맞게 회전 시켜 준다.결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;//자석을 회전하는 함수//dir = 1: 시계 방향//dir = -1: 반시계 방향void rotate(int *gear, int dir) {\tif (dir == 1) {\t\tint tmp = gear[7];\t\tfor (int i = 6; i &gt;= 0; --i)\t\t\tgear[i + 1] = gear[i];\t\tgear[0] = tmp;\t}\telse if (dir == -1) {\t\tint tmp = gear[0];\t\tfor (int i = 0; i &lt; 7; ++i)\t\t\tgear[i] = gear[i + 1];\t\tgear[7] = tmp;\t}}int main(void){\tint tc; scanf(\"%d\", &amp;tc);\tfor (int t = 1; t &lt;= tc; ++t) {\t\t//4개 자석\t\tint gear[4][8];\t\tint k; scanf(\"%d\", &amp;k);\t\tfor (int i = 0; i &lt; 4; ++i)\t\t\tfor (int j = 0; j &lt; 8; ++j)\t\t\t\tscanf(\"%d\", &amp;gear[i][j]);\t\t//회전\t\tfor (int i = 0; i &lt; k; ++i) {\t\t\tint n, d; scanf(\"%d %d\", &amp;n, &amp;d);\t\t\t//하나의 톱니바퀴가 회전할 때, 각 자석에 적용해야할 회전 방향\t\t\tint rotRes[4];\t\t\t//1번 자석이 회전하는 경우\t\t\tif (n == 1) {\t\t\t\trotRes[0] = d;\t\t\t\tif (gear[0][2] == gear[1][6]) {\t\t\t\t\trotRes[1] = 0;\t\t\t\t\trotRes[2] = 0;\t\t\t\t\trotRes[3] = 0;\t\t\t\t}\t\t\t\telse {\t\t\t\t\trotRes[1] = -d;\t\t\t\t\tif (gear[1][2] == gear[2][6]) {\t\t\t\t\t\trotRes[2] = 0;\t\t\t\t\t\trotRes[3] = 0;\t\t\t\t\t}\t\t\t\t\telse {\t\t\t\t\t\trotRes[2] = d;\t\t\t\t\t\tif (gear[2][2] == gear[3][6])\t\t\t\t\t\t\trotRes[3] = 0;\t\t\t\t\t\telse\t\t\t\t\t\t\trotRes[3] = -d;\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\t//2번 자석이 회전하는 경우\t\t\telse if (n == 2) {\t\t\t\trotRes[1] = d;\t\t\t\tif (gear[1][2] == gear[2][6]) {\t\t\t\t\trotRes[2] = 0;\t\t\t\t\trotRes[3] = 0;\t\t\t\t}\t\t\t\telse {\t\t\t\t\trotRes[2] = -d;\t\t\t\t\tif (gear[2][2] == gear[3][6])\t\t\t\t\t\trotRes[3] = 0;\t\t\t\t\telse\t\t\t\t\t\trotRes[3] = d;\t\t\t\t}\t\t\t\tif (gear[0][2] == gear[1][6])\t\t\t\t\trotRes[0] = 0;\t\t\t\telse\t\t\t\t\trotRes[0] = -d;\t\t\t}\t\t\t//3번 자석이 회전하는 경우\t\t\telse if (n == 3) {\t\t\t\trotRes[2] = d;\t\t\t\tif (gear[2][2] == gear[3][6])\t\t\t\t\trotRes[3] = 0;\t\t\t\telse\t\t\t\t\trotRes[3] = -d;\t\t\t\tif (gear[1][2] == gear[2][6]) {\t\t\t\t\trotRes[1] = 0;\t\t\t\t\trotRes[0] = 0;\t\t\t\t}\t\t\t\telse {\t\t\t\t\trotRes[1] = -d;\t\t\t\t\tif (gear[0][2] == gear[1][6])\t\t\t\t\t\trotRes[0] = 0;\t\t\t\t\telse\t\t\t\t\t\trotRes[0] = d;\t\t\t\t}\t\t\t}\t\t\t//4번 자석이 회전하는 경우\t\t\telse if (n == 4) {\t\t\t\trotRes[3] = d;\t\t\t\tif (gear[2][2] == gear[3][6]) {\t\t\t\t\trotRes[2] = 0;\t\t\t\t\trotRes[1] = 0;\t\t\t\t\trotRes[0] = 0;\t\t\t\t}\t\t\t\telse {\t\t\t\t\trotRes[2] = -d;\t\t\t\t\tif (gear[1][2] == gear[2][6]) {\t\t\t\t\t\trotRes[1] = 0;\t\t\t\t\t\trotRes[0] = 0;\t\t\t\t\t}\t\t\t\t\telse {\t\t\t\t\t\trotRes[1] = d;\t\t\t\t\t\tif (gear[0][2] == gear[1][6])\t\t\t\t\t\t\trotRes[0] = 0;\t\t\t\t\t\telse\t\t\t\t\t\t\trotRes[0] = -d;\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\t//회전 적용 (0이면 회전하지 않음)\t\t\tfor (int j = 0; j &lt; 4; ++j)\t\t\t\tif (rotRes[j] != 0)\t\t\t\t\trotate(gear[j], rotRes[j]);\t\t}\t\t//점수 계산\t\tprintf(\"#%d %d\\n\", t, gear[0][0] * 1 + gear[1][0] * 2 +\t\t\tgear[2][0] * 4 + gear[3][0] * 8);\t}\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_FCT"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/SW-Expert-Academy-4013.%ED%8A%B9%EC%9D%B4%ED%95%9C-%EC%9E%90%EC%84%9D/",
        "teaser":null},{
        "title": "[SW Expert Academy] 4014.활주로 건설",
        "excerpt":"활주로 건설 문제 링크   https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWIeW7FakkUDFAVH&amp;categoryId=AWIeW7FakkUDFAVH&amp;categoryType=CODE해결 방법 구현   활주로를 만드는 경우의 수를 총 4가지로 구분하였다.          경사가 모두 같은 경우      경사 차이가 1보다 큰 경우(활주로를 지을 수 없음)      오르막 설치      내리막 설치                  구현 능력에 따라 코드 길이를 대폭 줄일 수 있는 것 같다. 나는 실력이 부족해서 안되는 경우가 있으면 다시 추가 추가하면서 구현하였다.                     결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;#define N 21//입력 배열int map[N][N];int main(void){\tint tc; scanf(\"%d\", &amp;tc);\tfor (int t = 1; t &lt;= tc; ++t) {\t\tmemset(map, 0, sizeof(map));\t\tint n, x; scanf(\"%d %d\", &amp;n, &amp;x);\t\tfor (int i = 0; i &lt; n; ++i)\t\t\tfor (int j = 0; j &lt; n; ++j)\t\t\t\tscanf(\"%d\", &amp;map[i][j]);\t\t//활주로 개수\t\tint ans = 0;\t\t//활주로를 건설할 수 있는지 검사\t\tbool buildPos = false;\t\t//가로 방향\t\tfor (int i = 0; i &lt; n; ++i) {\t\t\t//한 활주로에서 경사로를 지을수 있는지 없는지 검사하는 배열\t\t\tbool check[N] = { false, };\t\t\tbuildPos = false;\t\t\t//높이가 같은 인덱스를 한 그룹으로 묶는다.\t\t\t//preIdx: 이전 그룹의 가장 마지막 인덱스(0으로 초기화)\t\t\t//curIdx: 현재 그룹의 가장 마지막 인덱스\t\t\tint preIdx = 0;\t\t\tfor (int j = 0; j &lt; n; ++j) {\t\t\t\t//높이 같은 인덱스 개수\t\t\t\tint sameCnt = 1;\t\t\t\tint curIdx;\t\t\t\t//높이가 같은 인덱스 개수 계산\t\t\t\tfor (curIdx = j + 1; curIdx &lt; n; ++curIdx) {\t\t\t\t\tif (map[i][j] == map[i][curIdx])\t\t\t\t\t\tsameCnt++;\t\t\t\t\telse\t\t\t\t\t\tbreak;\t\t\t\t}\t\t\t\t//현재 인덱스를 현재 그룹 가장 마지막 인덱스에 맞춘다.\t\t\t\tcurIdx -= 1;\t\t\t\t//주어진 x길이보다 크거나 같다면 해당 그룹을 모두 true값을 넣어준다.\t\t\t\tif (sameCnt &gt;= x) {\t\t\t\t\t//preIdx를 0으로 초기화 하였기 때문에 처음 그룹이 인덱스 0을 포함한다면 0도 true값을 넣어준다.\t\t\t\t\tif (!preIdx) check[0] = true;\t\t\t\t\tfor (int k = preIdx + 1; k &lt;= curIdx; ++k)\t\t\t\t\t\tcheck[k] = true;\t\t\t\t}\t\t\t\t// 1) preIdx가 0이고, preIdx와 curIdx의 높이가 같다면 이 그룹은 같은 그룹이며 모두 높이가 같다.\t\t\t\tif (preIdx == 0 &amp;&amp; map[i][preIdx] - map[i][curIdx] == 0)\t\t\t\t\tbuildPos = true;\t\t\t\t// 2) 이전 그룹보다 현재 그룹의 높이가 1 작은 경우,\t\t\t\t// 현재 그룹의 처음부터 x개의 경사로를 만들 수 있어야 한다.\t\t\t\telse if (map[i][preIdx] - map[i][curIdx] == 1 &amp;&amp; (preIdx + x) &lt; n\t\t\t\t\t&amp;&amp; check[preIdx + x]) {\t\t\t\t\tbuildPos = true;\t\t\t\t\t//x개의 경사로를 만들었으므로, 해당 인덱스에서 중복으로 경사로를 지을 수 없다.\t\t\t\t\tfor (int k = preIdx + 1; k &lt;= preIdx + x; ++k)\t\t\t\t\t\tcheck[k] = false;\t\t\t\t}\t\t\t\t// 3) 이전 그룹보다 현재 그룹의 높이가 1 큰 경우,\t\t\t\t// 이전 그룹의 마지막부터 x개의 경사로를 만들 수 있어야 한다.\t\t\t\telse if (map[i][preIdx] - map[i][curIdx] == -1 &amp;&amp; (preIdx - x + 1) &gt;= 0\t\t\t\t\t&amp;&amp; check[preIdx - x + 1]) {\t\t\t\t\tbuildPos = true;\t\t\t\t\tfor (int k = preIdx - x + 1; k &lt;= preIdx; ++k)\t\t\t\t\t\tcheck[k] = false;\t\t\t\t}\t\t\t\t// 4) 높이차이가 1보다 크거나, 경사로를 지을 수 없는 경우\t\t\t\telse {\t\t\t\t\tbuildPos = false;\t\t\t\t\tbreak;\t\t\t\t}\t\t\t\t//현재 인덱스를 이전 인덱스에 삽입한다.\t\t\t\tpreIdx = curIdx;\t\t\t\tj = curIdx;\t\t\t}\t\t\t//활주로를 지을 수 있다면 개수를 증가한다.\t\t\tif (buildPos) ans++;\t\t}\t\t//세로 방향\t\t//가로 방향 알고리즘에서 map배열의 인덱스를 서로 바꿔준다.\t\tfor (int i = 0; i &lt; n; ++i) {\t\t\tbool check[N] = { false, };\t\t\tbuildPos = false;\t\t\tint preIdx = 0;\t\t\tfor (int j = 0; j &lt; n; ++j) {\t\t\t\tint sameCnt = 1;\t\t\t\tint curIdx;\t\t\t\tfor (curIdx = j + 1; curIdx &lt; n; ++curIdx) {\t\t\t\t\tif (map[j][i] == map[curIdx][i])\t\t\t\t\t\tsameCnt++;\t\t\t\t\telse\t\t\t\t\t\tbreak;\t\t\t\t}\t\t\t\tcurIdx -= 1;\t\t\t\tif (sameCnt &gt;= x) {\t\t\t\t\tif (!preIdx) check[0] = true;\t\t\t\t\tfor (int k = preIdx + 1; k &lt;= curIdx; ++k)\t\t\t\t\t\tcheck[k] = true;\t\t\t\t}\t\t\t\tif (preIdx == 0 &amp;&amp; map[preIdx][i] - map[curIdx][i] == 0)\t\t\t\t\tbuildPos = true;\t\t\t\telse if (map[preIdx][i] - map[curIdx][i] == 1 &amp;&amp; (preIdx + x) &lt; n\t\t\t\t\t&amp;&amp; check[preIdx + x]) {\t\t\t\t\tbuildPos = true;\t\t\t\t\tfor (int k = preIdx + 1; k &lt;= preIdx + x; ++k)\t\t\t\t\t\tcheck[k] = false;\t\t\t\t}\t\t\t\telse if (map[preIdx][i] - map[curIdx][i] == -1 &amp;&amp; (preIdx - x + 1) &gt;= 0\t\t\t\t\t&amp;&amp; check[preIdx - x + 1]) {\t\t\t\t\tbuildPos = true;\t\t\t\t\tfor (int k = preIdx - x + 1; k &lt;= preIdx; ++k)\t\t\t\t\t\tcheck[k] = false;\t\t\t\t}\t\t\t\telse {\t\t\t\t\tbuildPos = false;\t\t\t\t\tbreak;\t\t\t\t}\t\t\t\tpreIdx = curIdx;\t\t\t\tj = curIdx;\t\t\t}\t\t\tif (buildPos) ans++;\t\t}\t\tprintf(\"#%d %d\\n\", t, ans);\t}\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_FCT"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/SW-Expert-Academy-4014.%ED%99%9C%EC%A3%BC%EB%A1%9C-%EA%B1%B4%EC%84%A4/",
        "teaser":null},{
        "title": "[SW Expert Academy] 5644.무선 충전",
        "excerpt":"무선 충전 문제 링크   https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRDL1aeugDFAUo&amp;categoryId=AWXRDL1aeugDFAUo&amp;categoryType=CODE&amp;&amp;&amp;해결 방법 시뮬레이션   2차원 배열에 주어진 배터리 범위들을 저장한다.  두 사용자의 시작점부터 한 칸씩 이동할 때마다 배터리 범위에 포함되어 있는지 검사한다.  두 사용자가 배터리 범위에 있을 경우의 수는 총 3가지가 있다.          A사용자가 배터리 범위에 있고 B사용자는 배터리 범위에 있지 않을 경우                  A사용자가 속한 배터리 범위 중 가장 큰 충전량을 선택한다.                    A사용자가 배터리 범위에 없고 B사용자는 배터리 범위에 있는 경우                  B사용자가 속한 배터리 범위 중 가장 큰 충전량을 선택한다.                    A사용자, B사용자 둘 다 배터리 범위에 있는 경우                  A, B사용자가 같은 배터리 범위에 있을 때의 충전량과 다른 배터리 범위에 있을 때 충전량 중 큰 값을 선택한다.                    결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//이동하지 않음, 상, 우, 하, 좌int my[5] = { 0, -1, 0, 1, 0 };int mx[5] = { 0, 0, 1, 0, -1 };//배터리 정보class APInfo {public:\tint y, x;  //배터리 좌표\tint c;     //범위\tint p;     //충전량};//범위 크기에 따라 계산할 좌표 벡터(인덱스 0이 문제에서 범위 1를 나타낸다.)vector&lt;pair&lt;int, int&gt;&gt; covSet[5];//배터리 정보를 저장할 벡터vector&lt;APInfo&gt; apv;//사용자 A, B의 움직임을 저장할 벡터vector&lt;int&gt; amove, bmove;//지도에서 해당 좌표에 어떤 BC번호가 있는지 저장할 벡터(하나의 좌표에 여러 BC가 있을 수 있음)vector&lt;int&gt; board[11][11];//범위 크기에 따라 계산할 좌표 벡터를 만든다.void makeCoverage() {\t//범위가 1인 경우\tcovSet[0].push_back({ 0, 0 });\tcovSet[0].push_back({ -1, 0 });\tcovSet[0].push_back({ 0, 1 });\tcovSet[0].push_back({ 1, 0 });\tcovSet[0].push_back({ 0, -1 });\t//중복을 방지할 플래그\tbool flag;\t//문제 기준 범위 크기 5까지 만든다.\t//이전 범위에서 상하좌우를 각각 추가해준다.(중복 제외)\tfor (int i = 1; i &lt; 5; ++i) {\t\tcovSet[i] = covSet[i - 1];\t\t//이전 범위에서 좌표 개수\t\tint preSize = covSet[i - 1].size();\t\t//현재 범위에서 좌표 개수\t\tint curSize = covSet[i].size();\t\tfor (int j = 0; j &lt; preSize; ++j) {\t\t\t//상하좌우 추가\t\t\tfor (int k = 1; k &lt; 5; ++k) {\t\t\t\tflag = false;\t\t\t\tint nexty = covSet[i][j].first + my[k];\t\t\t\tint nextx = covSet[i][j].second + mx[k];\t\t\t\t//현재 범위 좌표 벡터에 중복이 있는지 검사한다.\t\t\t\tfor (int l = 0; l &lt; curSize; ++l)\t\t\t\t\tif (covSet[i][l].first == nexty &amp;&amp; covSet[i][l].second == nextx) {\t\t\t\t\t\tflag = true;\t\t\t\t\t\tbreak;\t\t\t\t\t}\t\t\t\t//중복이 없으면 추가한다.\t\t\t\tif (!flag) {\t\t\t\t\tcovSet[i].push_back({ nexty, nextx });\t\t\t\t\tcurSize++;\t\t\t\t}\t\t\t}\t\t}\t}}int main(void){\tmakeCoverage();\tint tc; scanf(\"%d\", &amp;tc);\tfor (int t = 1; t &lt;= tc; ++t) {\t\t//지도 초기화\t\tfor (int i = 0; i &lt; 11; ++i)\t\t\tfor (int j = 0; j &lt; 11; ++j)\t\t\t\tboard[i][j].clear();\t\tint m, a; scanf(\"%d %d\", &amp;m, &amp;a);\t\t//이동하지 않을 때도 충전을 검사해야하기 때문에 가장 처음에 이동하지 않는 경우를 추가한다.\t\t//입력 벡터 초기화\t\tamove = vector&lt;int&gt;(m + 1, 0);\t\tbmove = vector&lt;int&gt;(m + 1, 0);\t\tapv = vector&lt;APInfo&gt;(a);\t\t//이동하지 않은 경우\t\tamove[0] = 0;\t\tbmove[0] = 0;\t\t//시간에 따른 이동 정보 저장\t\tfor (int i = 0; i &lt; m; ++i)\t\t\tscanf(\"%d\", &amp;amove[i + 1]);\t\tfor (int i = 0; i &lt; m; ++i)\t\t\tscanf(\"%d\", &amp;bmove[i + 1]);\t\t//BC정보 입력\t\tfor (int i = 0; i &lt; a; ++i) {\t\t\t//입력은 x좌표부터인 것에 유의한다.\t\t\tscanf(\"%d %d %d %d\", &amp;apv[i].x, &amp;apv[i].y, &amp;apv[i].c, &amp;apv[i].p);\t\t\t//문제에서는 (1, 1)부터 시작이므로 각각 1을 빼준다.\t\t\tapv[i].y -= 1;\t\t\tapv[i].x -= 1;\t\t\t//현재 범위 좌표 벡터의 크기\t\t\tint csize = covSet[apv[i].c - 1].size();\t\t\t//BC범위를 지도에 표시한다.\t\t\tfor (int j = 0; j &lt; csize; ++j) {\t\t\t\tint nexty = apv[i].y + covSet[apv[i].c - 1][j].first;\t\t\t\tint nextx = apv[i].x + covSet[apv[i].c - 1][j].second;\t\t\t\t//범위 내에 있는 경우\t\t\t\tif (nexty &gt;= 0 &amp;&amp; nexty &lt; 10 &amp;&amp; nextx &gt;= 0 &amp;&amp; nextx &lt; 10)\t\t\t\t\tboard[nexty][nextx].push_back(i);\t\t\t}\t\t}\t\tint ans = 0;\t\t//현재 사용자 A, B의 위치 좌표\t\tpair&lt;int, int&gt; cusA, cusB;\t\t//사용자 A의 처음 위치\t\tcusA = make_pair(0, 0);\t\t//사용자 B의 처음 위치\t\tcusB = make_pair(9, 9);\t\t//시뮬레이션(이동하지 않는 경우 포함)\t\tfor (int i = 0; i &lt;= m; ++i) {\t\t\t//사용자 A의 다음 위치\t\t\tcusA.first += my[amove[i]];\t\t\tcusA.second += mx[amove[i]];\t\t\t//사용자 B의 다음 위치\t\t\tcusB.first += my[bmove[i]];\t\t\tcusB.second += mx[bmove[i]];\t\t\t//현재 사용자A, B의 좌표에서 어떤 BC가 있는지 모두 저장할 벡터\t\t\tvector&lt;int&gt; covA, covB;\t\t\t//사용자 A 위치 좌표에서 BC 개수\t\t\tint asize = board[cusA.first][cusA.second].size();\t\t\t//사용자 B 위치 좌표에서 BC 개수\t\t\tint bsize = board[cusB.first][cusB.second].size();\t\t\t//BC 추가\t\t\tfor (int j = 0; j &lt; asize; ++j)\t\t\t\tcovA.push_back(board[cusA.first][cusA.second][j]);\t\t\tfor (int j = 0; j &lt; bsize; ++j)\t\t\t\tcovB.push_back(board[cusB.first][cusB.second][j]);\t\t\tint curChargeA = 0, curChargeB = 0, sumCharge = 0;\t\t\t//현재 좌표에서 최대 충전량을 구할 경우의 수는 총 3가지가 있다.\t\t\t// 1) 사용자 A 좌표에서 BC가 있고 사용자 B 좌표에서 BC가 없는 경우\t\t\tif (asize &gt; 0 &amp;&amp; bsize == 0) {\t\t\t\tfor (int j = 0; j &lt; asize; ++j)\t\t\t\t\tcurChargeA = curChargeA &gt; apv[covA[j]].p ? curChargeA : apv[covA[j]].p;\t\t\t\tsumCharge = curChargeA;\t\t\t}\t\t\t// 2) 사용자 A 좌표에서 BC가 없고 사용자 B 좌표에서 BC가 있는 경우\t\t\telse if (asize == 0 &amp;&amp; bsize &gt; 0) {\t\t\t\tfor (int j = 0; j &lt; bsize; ++j)\t\t\t\t\tcurChargeB = curChargeB &gt; apv[covB[j]].p ? curChargeB : apv[covB[j]].p;\t\t\t\tsumCharge = curChargeB;\t\t\t}\t\t\t// 3) 사용자 A, B 좌표에 BC가 모두 있는 경우\t\t\telse {\t\t\t\tfor (int j = 0; j &lt; asize; ++j) {\t\t\t\t\tfor (int k = 0; k &lt; bsize; ++k) {\t\t\t\t\t\tif (covA[j] == covB[k]) {\t\t\t\t\t\t\tcurChargeA = apv[covA[j]].p / 2;\t\t\t\t\t\t\tcurChargeB = apv[covB[k]].p / 2;\t\t\t\t\t\t}\t\t\t\t\t\telse {\t\t\t\t\t\t\tcurChargeA = apv[covA[j]].p;\t\t\t\t\t\t\tcurChargeB = apv[covB[k]].p;\t\t\t\t\t\t}\t\t\t\t\t\tint tmpSum = curChargeA + curChargeB;\t\t\t\t\t\tsumCharge = sumCharge &gt; tmpSum ? sumCharge : tmpSum;\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tans += sumCharge;\t\t}\t\tprintf(\"#%d %d\\n\", t, ans);\t}\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_FCT"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/SW-Expert-Academy-5644.%EB%AC%B4%EC%84%A0-%EC%B6%A9%EC%A0%84/",
        "teaser":null},{
        "title": "[SW Expert Academy] 5653.줄기세포배양",
        "excerpt":"줄기세포배양 문제 링크   https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRJ8EKe48DFAUo&amp;categoryId=AWXRJ8EKe48DFAUo&amp;categoryType=CODE해결 방법 시뮬레이션   문제에서 세포 최대 크기가 주어지지 않았지만 초기 상태의 최대 크기가 가로/세로 50이며 최대 배양 시간이 300이므로 최대 크기는 가로/세로 350으로 예상할 수 있다.  세포 배양은 문제에서 주어진 대로 구현하며, 두 개 이상의 줄기 세포가 하나의 그리드 셀에 동시 번식하는 경우는 현재 시간에서 배양할 수 있는 모든 세포를 미리 번식시킨 뒤 생명력 수치를 기준으로 내림차순 정렬하여 수치가 가장 큰 세포가 번식하면 그 아래는 무시한다.결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//상방향부터 시계 방향int my[4] = { -1, 0, 1, 0 };int mx[4] = { 0, 1, 0, -1 };//해당 좌표에 세포가 있는지 검사하는 2차원 배열//문제에서 최대 한방향으로 350만큼 갈 수 있다.bool visited[800][800];//세포 정보class cellInfo {public:\tint y, x;      //세포 좌표\tint lifetime;  //생명력 수치\tint timeCnt;   //시간에 따른 생명력 수치 변화\t               //0 &gt; timeCnt: 비활성 상태\t               //timeCnt == 0: 활성 상태 + 번식할 수 있는 상태                   //0 &gt; timeCnt &gt; -lifetime: 활성 상태\t               //-lifetime &gt;= timeCnt: 죽은 상태};//cv: 해당 시간에 존재하는 세포들의 정보를 저장한 벡터//add: 해당 시간에 추가해야할 세포들의 정보를 저장한 벡터vector&lt;cellInfo&gt; cv, add;//생명력 수치를 내림차순으로 정렬한다.bool comp(const cellInfo &amp;a, const cellInfo &amp;b) {\treturn a.lifetime &gt; b.lifetime;}int main(void){\tint tc; scanf(\"%d\", &amp;tc);\tfor (int t = 1; t &lt;= tc; ++t) {\t\t//초기화\t\tmemset(visited, false, sizeof(visited));\t\tcv.clear();\t\tint n, m, k; scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;k);\t\tfor (int i = 0; i &lt; n; ++i)\t\t\tfor (int j = 0; j &lt; m; ++j) {\t\t\t\tint life; scanf(\"%d\", &amp;life);\t\t\t\t//생명력 수치가 0보다 큰 경우\t\t\t\tif (life &gt; 0) {\t\t\t\t\tcv.push_back({ i, j, life, life });\t\t\t\t\t//좌표를 모두 양수로 만들기 위해 각각 400을 더한다.\t\t\t\t\tvisited[i + 400][j + 400] = true;\t\t\t\t}\t\t\t}\t\tfor (int i = 0; i &lt; k; ++i) {\t\t\tadd.clear();\t\t\tint cvSize = cv.size();\t\t\t//세포가 활성화 상태 + 번식 가능 상태일 때 번식할 세포의 정보를 임시 벡터에 저장한다.\t\t\tfor (int j = 0; j &lt; cvSize; ++j) {\t\t\t\t//상태 검사\t\t\t\tif (cv[j].timeCnt == 0) {\t\t\t\t\tfor (int l = 0; l &lt; 4; ++l) {\t\t\t\t\t\tint nexty = cv[j].y + my[l];\t\t\t\t\t\tint nextx = cv[j].x + mx[l];\t\t\t\t\t\t//이미 해당 좌표에 세포가 있으면 넘어간다.\t\t\t\t\t\tif (visited[nexty + 400][nextx + 400]) continue;\t\t\t\t\t\t//번식할 수 있는 모든 세포를 추가한다.(중복 좌표 포함)\t\t\t\t\t\tadd.push_back({ nexty, nextx, cv[j].lifetime, cv[j].lifetime });\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\t//번식한 세포를 제외한 모든 세포의 시간을 1 감소시킨다.\t\t\tfor (int j = 0; j &lt; cvSize; ++j)\t\t\t\tcv[j].timeCnt--;\t\t\t//번식한 세포들을 생명력 수치를 기준으로 내림차순으로 정렬한다.\t\t\t//해당 좌표에서 가장 큰 생명력 수치를 저장하고 그 이후는 무시하기 위함이다.\t\t\tsort(add.begin(), add.end(), comp);\t\t\tfor (int j = 0; j &lt; add.size(); ++j) {\t\t\t\t//해당 좌표에 세포가 없다면 세포를 추가한다.\t\t\t\tif (!visited[add[j].y + 400][add[j].x + 400]) {\t\t\t\t\tcv.push_back(add[j]);\t\t\t\t\tvisited[add[j].y + 400][add[j].x + 400] = true;\t\t\t\t}\t\t\t}\t\t}\t\tint ans = 0;\t\t//활성 상태와 비활성 상태의 세포의 수를 센다.\t\tfor (int i = 0; i &lt; cv.size(); ++i)\t\t\tif (cv[i].timeCnt &gt; -cv[i].lifetime)\t\t\t\tans++;\t\tprintf(\"#%d %d\\n\", t, ans);\t}\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_FCT"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/SW-Expert-Academy-5653.%EC%A4%84%EA%B8%B0%EC%84%B8%ED%8F%AC%EB%B0%B0%EC%96%91/",
        "teaser":null},{
        "title": "[SW Expert Academy] 5658.보물상자 비밀번호",
        "excerpt":"보물상자 비밀번호 문제 링크   https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRUN9KfZ8DFAUo&amp;categoryId=AWXRUN9KfZ8DFAUo&amp;categoryType=CODE해결 방법 구현   수열을 string으로 입력받는다.  string을 4개로 나눈다.(사각형의 각 변)  생성된 수 문자열(16진수)를 중복없이 저장한다.  3번 회전한 후, 생성된 모든 수 문자열을 10진수 int형으로 변환한다.  이를 내림차순으로 정렬한 후 k번째를 반환한다.결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;//16진수 한자리 문자를 10진수 정수형으로 변환하여 반환한다.int hexToDec(char h) {\tswitch (h) {\tcase 'A': return 10;\tcase 'B': return 11;\tcase 'C': return 12;\tcase 'D': return 13;\tcase 'E': return 14;\tcase 'F': return 15;\tdefault: return h - '0';\t}}//16진수 숫자 문자열을 10진수 정수형으로 변환하여 반환한다.int changeDec(string hex) {\tint hsize = hex.size();\tint res = 0;\tint mult = hsize - 1;\tfor (int i = 0; i &lt; hsize; ++i) {\t\tint num = hexToDec(hex[i]);\t\tfor (int j = 0; j &lt; mult; ++j)\t\t\tnum *= 16;\t\tmult--;\t\tres += num;\t}\treturn res;}//내림차순bool comp(const int a, const int b) {\treturn a &gt; b;}//회전하여 나타날 수 있는 모든 변의 숫자를 내림차순하여 k번째 숫자를 반환한다.int solution(string number, int k) {\tint ans = 0;\tint size = number.size();\t//변은 총 4개이므로 현재 숫자 길이에서\t//회전할 수 있는 횟수를 계산한다.\tint numOfRot = size / 4;\t//각 변의 숫자 문자열을 저장하는 벡터\tvector&lt;string&gt; n;\t//현재 숫자 문자열\tstring cur;\tcur = number;\tchar tmp[30];\tfor (int i = 0; i &lt; numOfRot; ++i) {\t\t//각 변의 숫자만을 파싱하기 위해 사용할 인덱스(다음 파싱할 문자열의 시작 인덱스)\t\tint nIdx = 0;\t\t//총 4개의 변에서 나타날 수 있는 숫자 문자열을 만든다.\t\tfor (int j = 0; j &lt; 4; ++j) {\t\t\tint cnt = 0;\t\t\tfor (int k = 0; k &lt; numOfRot; ++k)\t\t\t\ttmp[cnt++] = cur[nIdx + k];\t\t\tnIdx += numOfRot;\t\t\ttmp[cnt] = '\\0';\t\t\t//중복을 피하기 위해 사용될 스트링\t\t\tstring check = tmp;\t\t\tbool flag = false;\t\t\t//중복이 있는지 검사\t\t\tfor (int k = 0; k &lt; n.size(); ++k)\t\t\t\tif (check == n[k]) {\t\t\t\t\tflag = true;\t\t\t\t\tbreak;\t\t\t\t}\t\t\t//중복이 없다면 벡터에 추가한다.\t\t\tif (!flag)\t\t\t\tn.push_back(check);\t\t}\t\t//회전\t\t//현재 문자열의 마지막 문자를 임시로 저장한다.\t\tchar first = cur.at(size - 1);\t\t//회전이 끝난 문자열을 저장할 스트링\t\tstring next;\t\t//현재 문자열의 마지막 문자를 회전 후의 문자열 첫번째 인덱스에 위치한다.\t\tnext.push_back(first);\t\t//현재 문자열의 마지막 문자를 제외한 문자열을 순서대로 회전 후의 문자열에 삽입한다.\t\tfor (int j = 0; j &lt; size - 1; ++j)\t\t\tnext.push_back(cur[j]);\t\t//현재 문자열을 갱신한다.\t\tcur = next;\t\t/*cout &lt;&lt; cur &lt;&lt; endl;\t\tfor (int j = 0; j &lt; n.size(); ++j)\t\t\tcout &lt;&lt; n[j] &lt;&lt; \" \";\t\tprintf(\"\\n\");*/\t}\t//문자열을 십진수 숫자로 변환 후 저장할 벡터\tvector&lt;int&gt; num;\t//문자열을 십진수 숫자로 변환\tfor (int i = 0; i &lt; n.size(); ++i)\t\tnum.push_back(changeDec(n[i]));\t//내림차순 정렬\tsort(num.begin(), num.end(), comp);\t//k번째 숫자 저장\tans = num[k - 1];\treturn ans;}int main(void){\tint tc; scanf(\"%d\", &amp;tc);\tfor (int t = 1; t &lt;= tc; ++t) {\t\tint n, k; scanf(\"%d %d\", &amp;n, &amp;k);\t\tstring number;\t\tcin &gt;&gt; number;\t\tprintf(\"#%d %d\\n\", t, solution(number, k));\t}\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_FCT"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/SW-Expert-Academy-5658.%EB%B3%B4%EB%AC%BC%EC%83%81%EC%9E%90-%EB%B9%84%EB%B0%80%EB%B2%88%ED%98%B8/",
        "teaser":null},{
        "title": "[Algorithm]너비 우선 탐색(BFS)",
        "excerpt":"너비 우선 탐색(BFS)과 최단 거리 알고리즘 너비 우선 탐색으로 최단 거리 구하기   가중치가 없는 그래프에 대해 주로 사용할 수 있다.  최단 경로를 구성하는 정점들의 목록을 구할 수 있다.넓이 우선 탐색으로 최단거리 구하는 과정   간선(u, v)를 통해 정점 v를 처음 발견하여 큐에 넣었다.  시작점으로부터 정점 v까지 최단 거리 distance[v]는 시작적으로부터 정점 u까지 최단 거리 distance[u]에 1을 더한 것이다.  너비 우선 탐색 스패닝 트리를 보면 시작점으로부터 각 정점이 모두 실제 그래프상 최단 경로임을 알 수 있다. 구현   bfs(): 각 정점까지의 최단 거리를 계산하고, 너비 우선 탐색 스패닝 트리를 만든다.  shortestPath(): 너비 우선 탐색 스패닝 트리와 정점을 입력받아, 루트로부터 해당 입력된 정점까지의 최단 경로를 반환한다.          루트로부터 입력 정점까지 경로와 입력 정점으로부터 루트까지 경로가 같은 것을 이용한다.      BFS 스패닝 트리에서 각 정점의 부모 정점을 저장한 배열을 이용하여 계산한다.(parent[])      vector&lt;vector&lt;int&gt;&gt; adj;//start에서 시작해 그래프를 너비 우선 탐색하고 시작점부터 각 정점까지의//최단 거리와 너비 우선 탐색 스패닝 트리를 계산한다.//distance[i] = start부터 i까지의 최단 거리//parent[i] = 너비 우선 탐색 스패닝 트리에서 i의 부모 번호(루트인 경우 자신의 번호)void bfs(int start, vector&lt;int&gt; &amp;distance, vector&lt;int&gt; &amp;parent) {\tdistance = vector&lt;int&gt;(adj.size(), -1);\tparent = vector&lt;int&gt;(adj.size(), -1);\t//방문할 정점 목록을 유지하는 큐\tqueue&lt;int&gt; q;\tdistance[start] = 0;\tparent[start] = start;\tq.push(start);\twhile (!q.empty()) {\t\tint here = q.front();\t\tq.pop();\t\t//here의 모든 인접한 정점을 검사한다.\t\tfor (int i = 0; i &lt; adj[here].size(); ++i) {\t\t\tint there = adj[here][i];\t\t\t//처음 보는 정점이면 방문 목록에 집어넣는다.\t\t\tif(distance[there] == -1) {\t\t\t\tq.push(there);\t\t\t\tdistance[there] = distance[here] + 1;\t\t\t\tparent[there] = here;\t\t\t}\t\t}\t}}//v로부터 시작점까지의 최단 경로를 계산한다.vector&lt;int&gt; shortestPath(int v, const vector&lt;int&gt; &amp;parent) {\tvector&lt;int&gt; path(1, v);\twhile (parent[v] != v) {\t\tv = parent[v];\t\tpath.push_back(v);\t}\treverse(path.begin(), path.end());\treturn path;}상태 객체와 너비 우선 탐색을 사용하여 최단 경로 구하기 예제: 15-퍼즐   4 X 4 격자에 끼워진 15개의 임의의 순서의 숫자 타일이 주어졌을 때, 순서에 맞게 맞추는 퍼즐 문제이다.  게임판의 상태를 정점으로 표현하여 그래프를 만든 후, 문제를 해결할 수 있다.          상태를 정점으로 하는 그래프를 상태 공간(state space)라고 부른다.        게임판에 총 15개의 숫자와 1개의 빈칸이 있으므로, 상태 공간은 총 16!개의 정점을 갖는다.  한 번의 움직임으로 한 상태를 다른 상태로 바꿀 수 있을 때, 두 정점을 간선으로 연결한다.          각 정점마다 최대 4개의 이웃 정점이 있을 수 있다.(위, 아래, 오른쪽, 왼쪽으로 옮길 수 있기 때문)        15-퍼즐 구현               게임판의 상태를 State라는 별도의 객체로 표현한다.          15-퍼즐에 관련된 부분을 전부 State 객체 내에 구현함으로서 bfs()함수와 독립적이다.      State만 바꾸면 다른 문제에서도 활용할 수 있다.        State가 가질 수 있는 값의 종류가 너무 많기 때문에 배열 대신 map을 사용한다.  아직 덜구현된듯 문제에 맞게 구현해서 예제 넣어 풀어보기(State 클래스 구현)//게임판의 상태를 표현한다.class State {\t//인접한 상태들의 목록을 반환한다.\tvector&lt;State&gt; getAdjacent() const;\t//map에 State를 넣기 위한 비교 연산자\tbool operator &lt; (const State &amp;rhs) const;\t//종료 상태와 비교하기 위한 연산자\tbool operator == (const State &amp;rhs) const;};typedef map&lt;State, int&gt; stateMap;//start에서 finish까지 가는 최단 경로의 길이를 반환한다.int bfs(State start, State finish) {\t//예외: start == finish인 경우\tif (start == finish) return 0;\t//각 정점까지의 최단 경로의 길이를 저장한다.\tstateMap c;\t//앞으로 방문할 정점들을 저장한다.\tqueue&lt;State&gt; q;\tq.push(start);\tc[start] = 0;\t//너비 우선 탐색\twhile (!q.empty()) {\t\tState here = q.front();\t\tq.pop();\t\tint cost = c[here];\t\t//인접한 정점들의 번호를 얻어낸다.\t\tvector&lt;State&gt; adjacent = here.getAdjacent();\t\tfor (int i = 0; i &lt; adjacent.size(); ++i) {\t\t\tif (c.count(adjacent[i]) == 0) {\t\t\t\t//답을 찾았나?\t\t\t\tif (adjacent[i] == finish) return cost + 1;\t\t\t\tc[adjacent[i]] = cost + 1;\t\t\t\tq.push(adjacent[i]);\t\t\t}\t\t}\t}\t//답을 찾지 못한 경우\treturn -1;}시간 복잡도 분석   이 문제는 답을 찾는 대로 탐색을 종료하기 때문에, 일반적인 너비 우선 탐색의 시간복잡도 O(|V| + |E|)와 다르다.  너비 우선 탐색이 방문하는 정점의 개수에 비례한다.  이 문제에서 너비 우선 탐색이 방문하는 정점의 개수에 직접적인 영향을 주는 요소는 시작 정점에서 목표 정점까지의 최단 거리 d와 탐색의 분기 수(branching factor) b이다.          분기 수는 경로의 길이가 하나 늘어날 때마다 닿을 수 있는 정점의 개수를 말한다.      이 문제에서 분기 수는 최대 4개 이지만, 이 중에는 돌아가는 정점이나 중복된 정점이 있기 때문에 2나 3으로 계산할 수 있다.        이를 바탕으로, 시간 복잡도는 대략 O(b^d)가 된다.너비 우선 탐색보다 더 효율적인 최단 경로 알고리즘   양방향 탐색  점점 깊어지는 탐색(Iteratively Deeping Search, IDS)탐색 방법 선택하기   상태 공간에서의 최단 경로를 찾는 경우, 너비 우선 탐색을 최우선적으로 고려한다.          탐색의 깊이 한계가 정해져 있지 않거나 너무 깊어서 메모리 사용량이 너무 크지 않은지 확인해야 한다.        탐색의 최대 깊이가 정해져 있고 너비 우선 탐색을 하기에는 메모리와 시간이 부족한 경우 양방향 탐색을 고려한다.  위의 두 탐색이 모두 메모리나 시간이 초과될 경우, 점점 깊어지는 탐색을 사용한다.참고 문헌   프로그래밍 대회에서 배우는 알고리즘 문제해결전략, 인사이트, 구종만 지음","categories": ["Algorithm"],
        "tags": ["Algorithm_DataStructure"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-BFS%EC%99%80-%EC%B5%9C%EB%8B%A8%EA%B1%B0%EB%A6%AC/",
        "teaser":null},{
        "title": "[Algorithm]깊이 우선 탐색(DFS)의 간선 분류",
        "excerpt":"깊이 우선 탐색(DFS)과 간선의 분류   어떤 그래프를 깊이 우선 탐색을 했을 때, 탐색이 따라가는 간선들만을 모아 보면 트리 형태를 띤다.  예제 그래프   위 그래프를 0번 정점부터 깊이 우선 탐색했을 때 탐색이 따라가는 간선들을 굵은 실선으로 표시하면 아래의 그림과 같다.   굵은 실선이 0번 정점을 루트로 하는 트리 형태를 띠는 것을 볼 수 있다.  이와 같은 트리를 주어진 트리의 깊이 우선 탐색 스패닝 트리 혹은 DFS 스패닝 트리(Spanning Tree)라고 부른다.  DFS 스패닝 트리는 4가지의 간선으로 분류된다.          트리 간선(tree edge): 스패닝 트리에 포함된 간선을 의미한다. (위 그래프의 굵은 선으로 표시된 간선)      순방향 간선(forward edge): 스패닝 트리의 선조에서 자손으로 연결되지만 트리 간선이 아닌 간선을 의미한다. (위 그래프의 (0, 6)간선이 그 예이다.)      역방향 간선(back edge): 스패닝 트리의 자손에서 선조로 연결되는 간선이다. (위 그래프의 (2, 0)간선이 그 예이다.)      교차 간선(cross edge): 위 세 간선을 제외한 나머지 간선을 의미하며, 트리에서 선조와 자손 관계가 아닌 정점들 간에 연결된 간선이다. (위 그래프의 (6, 3)간선이 그 예이다.)        같은 그래프에서도 깊이 우선 탐색이 어느 순서대로 정점을 방문하느냐에 따라 서로 다른 트리가 만들어질 수 있다. (아래 그래프 예제)   무향 그래프에서 간선의 분류          모든 간선은 양방향으로 통행 가능하므로, 교차 간선이 없다.      순방향 간선과 역방향 간선의 구분이 없다.      참고 문헌   프로그래밍 대회에서 배우는 알고리즘 문제해결전략, 인사이트, 구종만 지음","categories": ["Algorithm"],
        "tags": ["Algorithm_DataStructure"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-DFS%EC%99%80-%EA%B0%84%EC%84%A0%EC%9D%98-%EB%B6%84%EB%A5%98/",
        "teaser":null},{
        "title": "[Algorithm]깊이 우선 탐색(DFS) 사이클",
        "excerpt":"깊이 우선 탐색(DFS)로 사이클 존재 여부 확인하기 개요   미리 알아야 할 내용: DFS와 간선의 분류 링크 해주기  간선의 분류를 이용하면 방향 그래프에서 사이클이 존재하는지 쉽게 알 수 있다.          사이클의 존재 여부는 역방향 간선의 존재 여부와 동치이다.        탐색 과정          어떤 그래프에서 깊이 우선 탐색 중 만나는 한 정점을 u라고 하자.      dfs(u)는 u에서 갈 수 있는 모든 정점들을 방문한 후에 종료된다.      따라서, u이전에 있는 한 정점이 dfs(u)가 종료되기 전에 u정점을 방문을 한다면, 해당 정점은 u로 가는 역방향 간선이 된다.      결과적으로, 이 그래프는 사이클이 존재하는 그래프가 된다.      간선 구분하기   깊이 우선 탐색을 하면서 간선의 종류를 구분하기 위해서는 기존의 저장해야하라 정보보다 더 많은 정보가 필요하다.1. 해당 정점이 몇 번째로 방문 되었는지에 대한 정보(방문 순서 정보)   기존의 깊이 우선 탐색에서 필요한 정보였던 해당 정점이 방문되었는지에 대한 정보를 대체한다.  이 정보로 (u, v)간선이 있을 때, 두 정점의 관계가 선조인지, 자손인지, 아무관계가 없는지를 알 수 있다.  (u, v)간선이 순방향 간선인지 알 수 있다.(역방향 간선과 교차 간선은 구분하지 못함)          (u, v)가 순방향 간선이면 v는 u의 자손이므로, v는 u보다 더 늦게 발견된다.      (u, v)가 역방향 간선이면 v는 u의 선조이므로, v는 u보다 더 일찍 발견된다.      (u, v)가 교차 간선이면 dfs(v)가 종료된 후에 dfs(u)가 호출되므로, v는 u보다 더 일찍 발견된다.        discovered[]배열2. 해당 정점의 dfs()함수가 종료되었는지에 대한 정보   이 정보로 (u v)간선이 역방향 간선인지 교차 간선인지 구분할 수 있다.  (u, v)에서 dfs(v)가 아직 종료되지 않았다면 v는 u의 선조이니 역방향 간선이 되고, 종료되었다면 교차 간선이 된다.  finished[]배열구현 //그래프으이 인접 리스트 표현vector&lt;vector&lt;int&gt;&gt; adj;//discovered[i] = i번 정점의 발견 순서, -1로 초기화//finished[i] = dfs(i)가 종료했으면 1, 아니면 0vector&lt;int&gt; discovered, finished;//지금까지 발견한 정점의 수int counter;void classifyEdgeDfs(int here) {  discovered[here] = counter++;  //모든 인접 정점을 순회하면서  for(int i =0; i &lt; adj[here].size(); ++i) {    int there = adj[here][i];    cout &lt;&lt; \"(\" &lt;&lt; here &lt;&lt; \",\" &lt;&lt; there &lt;&lt; \") is a \";    //아직 방문한 적이 없다면 방문한다. (트리 간선)    if (discovered[there] == -1) {      cout &lt;&lt; \"tree edge\" &lt;&lt; endl;      classifyEdgeDfs(there);    }    //만약 there가 here보다 늦게 발견됐으면 there은 here의 후손이다. (순방향 간선)    else if (discovered[here] &lt; discovered[there])      cout &lt;&lt; \"forward edge\" &lt;&lt; endl;    //만약 classifyEdgeDfs(there)가 아직 종료되지 않았으면 there은 here의 선조이다. (역방향 간선 = 사이클 존재)    else if (finished[there] == 0)      cout &lt;&lt; \"back edge\" &lt;&lt; endl;    //이 외의 모든 경우는 교차 간선    else      cout &lt;&lt; \"cross edge\" &lt;&lt; endl;  }  finished[here] = 1;}참고 문헌   프로그래밍 대회에서 배우는 알고리즘 문제해결전략, 인사이트, 구종만 지음","categories": ["Algorithm"],
        "tags": ["Algorithm_DataStructure"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-DFS%EC%99%80-%EC%82%AC%EC%9D%B4%ED%81%B4/",
        "teaser":null},{
        "title": "[Algorithm]다익스트라 알고리즘",
        "excerpt":"다익스트라(Dijkstra) 최단 경로 알고리즘   다익스트라 알고리즘은 단일 시작점 최단 경로 알고리즘으로, 시작 정점 s에서부터 다른 정점들까지의 최단거리를 계산한다.  다익스트라 알고리즘은 음수 간선이 있는 그래프(특히, 음수 사이클)에 대해서는 정답을 계산하지 못한다.          음수 간선이 사이클을 이루지 않는다면, 계산을 할 수 있는 경우가 있지만 시간복잡도는 지수적으로 증가한다.      우선순위 큐를 사용하는 너비 우선 탐색으로 구현   다익스트라 알고리즘은 너비 우선 탐색처럼 시작점에서 가까운 순서대로 정점을 방문한다.  다익스트라 알고리즘은 가중치가 있는 그래프에 적용하기 때문에 너비 우선 탐색을 그대로 사용할 수는 없다.          가중치 그래프에서 너비 우선 탐색으로 최단 거리를 차지 못하는 예                   위 그림에서 최단 경로는 s-a-b-c이다.      하지만, 너비 우선 탐색을 사용하면 각 정점을 순서대로 방문해야 하기 때문에 위와 같은 최단 경로를 찾을 수 없다.                  b정점을 늦게 발견하더라도 먼저 방문할 수 있어야 한다.                      위의 문제를 해결하기 위해 우선순위 큐를 활용하여 너비 우선 탐색을 사용한다.구현   dist[]: 시작점에서 각 정점까지의 최단 거리를 저장하는 배열  간선(u, v)에서 정점 v가 아직 발견되지 않은 상태라면, v까지 최단 거리는 dist[v] = dist[u] + w(u, v)가 되고, 우선 순위 큐에 (v, dist[v])형태로 삽입한다.          아직 방문하지 않는 간선 중에 정점 v가 포함되어 있고, 위의 dist[v]보다 더 짧다면 갱신될 수 있다.        위와 같이 한 정점이 중복된다면, 우선 순위 큐에 역시 같은 정점이 여러개 존재할 수 있다.          간단한 구현을 위해, 중복된 정점을 우선 순위 큐에 삽입 하되 나중에 큐에서 꺼내질 때 해당 정점의 현재 최단 거리보다 길다면 무시한다.        C++ STL에 포함된 우선 순위 큐를 사용할 때 주의할 점은 기본적으로 가장 큰 값을 가장 먼저 나오도록 구현되어 있으므로 거리(dist[])의 부호를 바꿔서 큐에 삽입하도록 하여 간단하게 구현한다.          부호가 마이너스인 숫자는 절대값이 큰 값이 더 작은 값이 되기 때문이다.      큐에서 꺼낼때 역시 부호를 바꿔서 양의 숫자로 바꿔주어야 한다.      구현 코드 //정점의 개수int V;//그래프의 인접 리스트 (연결된 정점 번호, 간선 가중치) 쌍을 담는다.vector&lt;pair&lt;int, int&gt;&gt; adj[MAX_V];//다익스트라, 최단 거리 배열을 반환한다.vector&lt;int&gt; dijkstra(int src) {\t//INF: 매우 큰 값\tvector&lt;int&gt; dist(V, INF);\tdist[src] = 0;\t//(해당 정점까지 최단 거리, 해당 정점)쌍  \t//STL내부에서 pair의 첫번째 원소부터 크기 비교를 하기 때문에, 거리값을 첫 원소로 해야 한다.\tpriority_queue&lt;pair&lt;int, int&gt;&gt; pq;\tpq.push(make_pair(0, src));\twhile (!pq.empty()) {    \t\tint here = pq.top().second;\t\tint cost = -pq.top().first;\t\tpq.pop();\t\t//만약 지금 꺼낸 것보다 더 짧은 경로를 알고 있다면 지금 꺼낸 것을 무시한다.\t\tif (dist[here] &lt; cost) continue;\t\t//인접한 정점들을 모두 검사한다.\t\tfor (int i = 0; i &lt; adj[here].size(); ++i) {\t\t\tint there = adj[here][i].first;\t\t\tint nextDist = cost + adj[here][i].second;\t\t\t//더 짧은 경로를 발견하면, dist[]를 갱신하고 우선순위 큐에 넣는다.\t\t\tif (dist[there] &gt; nextDist) {\t\t\t\tdist[there] = nextDist;\t\t\t\tpq.push(make_pair(-nextDist, there));\t\t\t}\t\t}\t}  return dist;}시간 복잡도   각 정점마다 인접한 간선들을 모두 검사하는 작업: O(|E|)  우선순위 큐에 원소를 넣고 삭제하는 작업          너비 우선 탐색에서는 각 정점을 한번 씩만 방문하지만, 다익스트라는 각 간선을 한번 씩 방문하기 때문에 정점을 중복해서 방문한다.      최대 원소의 수: O(|E|)      추가 및 삭제 연산: O(log|E|)      전체 시간 복잡도: O(|E|log|E|)                                    대부분의 그래프에서 간선의 개수          E          는 |V|^2보다 작기 때문에, O(log|E|) == O(log|V|)라고 할 수 있다.                      따라서, 우선순위 큐 다익스트라 알고리즘의 전체 시간 복잡도는 O(|E|log|V|)이다.실제 경로 찾기   너비 우선 탐색에서 경로를 찾는 것과 유사하게, 스패닝 트리를 계산한 후, 스패닝 트리를 거슬러 올라가며 경로를 찾을 수 있다.O(|V|log|V|) 다익스트라 알고리즘   중복 원소를 우선순위 큐에 넣지 않도록 수정하면 O(|V|log|V|)의 시간복잡도를 가질 수 있다.  피보나치 힙이나 이진 검색 트리를 이용해 우선순위 큐를 사용하면 중복 원소를 제거할 수 있지만, 구현이 복잡하고 실제로 시간이 더 오래 걸리는 경우가 많다.참고 문헌   프로그래밍 대회에서 배우는 알고리즘 문제해결전략, 인사이트, 구종만 지음","categories": ["Algorithm"],
        "tags": ["Algorithm_Algorithm"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/",
        "teaser":null},{
        "title": "[Algorithm]벨만-포드 알고리즘",
        "excerpt":"벨만-포드(Bellman-Ford)의 최단 경로 알고리즘   다익스트라 알고리즘과 똑같은 단일 시작점 최단 경로 알고리즘이지만, 음수 간선이 있는 그래프에서도 최단 경로를 찾을 수 있다.  그래프에서 음수 사이클이 있어서 최단 경로를 찾을 수 없는 경우에도 이를 알려줄 수 있다.벨만-포드의 동작 과정   벨만-포드 알고리즘은 시작점에서 각 정점까지 가는 최단 거리의 상한을 적당히 예측한 뒤, 예측 값과 실제 최단 거리 사이의 오차를 반복적으로 줄여가는 방식으로 동작한다.  upper[]: 각 정점까지의 최단 거리의 상한을 담은 배열  시작점 s의 upper[s] = 0으로 초기화하고, 나머지 원소들은 모두 아주 큰 수로 초기화 한다.  이 배열의 예측 값을 실체 최단 거리에 더 가깝게 갱신하기 위해 다음과 같은 최단 거리의 특성을 이용한다.          dist[v] &lt;= dist[u] + w(u, v)        위 속성을 이용하여 upper[u] + w(u, v) &lt; upper[v]인 상황을 예를 들어 보자.          u까지 가는 최단 거리는 항상 upper[u]이거나 그보다 짧다.      그 뒤에 (u, v)를 붙인 경로의 길이는 최대 upper[u] + w(u, v)이다.      따라서, upper[v]를 upper[u] + w(u, v)로 줄일 수 있다.      위 과정을 통해 upper[v]를 감소하는 작업을 (u, v)를 따라 완화(relax)한다고 한다.        벨만-포드 알고리즘은 위와 같은 완화 과정을 모든 간선에 대해 반복적으로 실시한다.                                                      음수 사이클이 없는 그래프에서 최단 경로가 한 정점을 두 번 지나는 일이 없으므로, V개의 정점 그래프에서 최단 경로를 나타내는 간선의 개수는              V              - 1개 이다.                                                                                      따라서, 모든 간선에 대한 완화 과정은 전체              V              - 1번 수행하면 된다는 것을 알 수 있다.                                          음수 사이클만 없다면 음수 간선이 있더라도, 최단 경로를 찾을 수 있다.      음수 사이클 판정   음수 사이클이 존재하는 그래프에서는 최단 거리를 구할 수 없으므로, 벨만-포드 알고리즘 역시 의미없는 값을 반환한다.                              위에서 말했듯이, 벨만-포드의 동작은 음수 사이클이 없는 그래프에서          V          - 1번만 수행하면 되며 그 이후의 완화는 모두 실패한다.                                                  하지만, 음수 사이클이 있는 그래프에서는          V          - 1번의 수행 이후에도 완화가 계속 성공적으로 이루어 진다.                            음수 사이클을 지날 때는 계속해서 거리 값이 작아지므로, 이를 쉽게 알 수 있다.                                    결과적으로 음수 사이클을 판정하기 위해서는          V          번 동작에서 완화가 성공하는지, 실패하는지로 알 수 있다.                    구현                               해당 구현에서 벨만=포드 알고리즘은          V          번 반복하며, 마지막          V          번째의 완화가 성공하면 음수 사이클이 있는 것으로 판단하고 빈 배열을 반환한다.                      시간 복잡도                                                      V              번 반복과 모든 간선 순회하므로 O(|E|)이다.                                          따라서, 전체 시간 복잡도는 O(|V||E|)가 된다.      //정점의 개수int V;//그래프의 인접 리스트, (연결된 정점 번호, 간선 가중치)쌍을 담는다.vector&lt;pair&lt;int, int&gt;&gt; adj[MAX_V];//음수 사이클이 있을 경우 텅 빈 배열을 반환한다.vector&lt;int&gt; bellmanFord(int src) {\t//시작점을 제외한 모든 정점까지의 거리 상한을 INF로 초기화한다.\tvector&lt;int&gt; upper(V, INF);\tupper[src] = 0;\tbool updated;\t//V번 순회한다.\tfor (int iter = 0; iter &lt; V; ++iter) {\t\tupdated = false;\t\tfor (int here = 0; here &lt; V; ++here) {\t\t\tfor (int i = 0; i &lt; adj[here].size(); ++i) {\t\t\t\tint there = adj[here][i].first;\t\t\t\tint cost = adj[here][i].second;\t\t\t\t//(here, there)간선을 따라 완화를 시도한다.\t\t\t\tif (upper[there] &gt; upper[here] + cost) {\t\t\t\t\t//성공\t\t\t\t\tupper[there] = upper[here] + cost;\t\t\t\t\tupdated = true;\t\t\t\t}\t\t\t}\t\t}\t\t//모든 간선에 대해 완화가 실패했을 경우 V-1번도 수행할 필요 없이 곧장 종료한다.\t\tif (!updated) break;\t}\t//V번째 순회에서도 완화가 성공했다면 음수 사이클이 있다.\tif (updated) upper.clear();\treturn upper;}","categories": ["Algorithm"],
        "tags": ["Algorithm_Algorithm"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-%EB%B2%A8%EB%A7%8C-%ED%8F%AC%EB%93%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/",
        "teaser":null},{
        "title": "[Algorithm]절단점 찾기 알고리즘",
        "excerpt":"깊이 우선 탐색(DFS)를 활용한 절단점 관련 알고리즘 절단점이란?   절단점(cut vertex): 어떤 무향 그래프의 절단점이란 이 점과 인접한 간선들을 모두 지웠을 때 해당 컴포넌트가 2개 이상으로 나뉘어지는 정점을 말한다.   위 그래프에서 1, 3, 5 정점이 각각 절단점이다.절단점 찾기 알고리즘   무향 그래프에서 한 번의 깊이 우선 탐색으로 그래프의 모든 절단점으르 찾을 수 있다.  무향 그래프에서 절단점을 포함하지 않는 서브그래프를 이중 결합 컴포넌트(biconnected component)라고 부른다.          이중 결합 컴포넌트에서 임의의 한 정점을 지우더라도 정정 간의 연결 관계는 유지된다.        탐색 과정               임의의 정점에서부터 깊이 우선 탐색을 수행하여 DFS 스패닝 트리를 만든다.  무향 그래프에서 어떤 정점 u는 연결된 모든 정점들은 u의 선조 아니면 자손 관계에 있다.          무향 그래프에서는 교차 간선이 없기 때문이다.      따라서, u의 자손들을 루트로 하는 서브트리들은 서로 연결되어 있지 않다.        위의 조건을 이용하면 u가 지워졌을 때, 그래프가 쪼개지지 않는 유일한 경우는 u의 선조와 자손들이 서로 전부 역방향 간선으로 연결되어 있는 경우이다.   u의 자손들이 전부 역방향 간선을 통해 u의 선조로 갈 수 있다면, u는 절단점이 아니다.  u가 스패닝 트리의 루트라서 선조가 없는 경우는 둘 이상의 자손을 가질때만 절단점이 될 수 있다.          u의 선조가 없다고 무조건 절단점이 되는 것은 아니다.      u의 자손이 하나도 없거나 하나만 있을 경우, u정점이 지워져도 그래프는 쪼개지지 않는다.      구현   u정점의 조상들이 항상 u보다 먼저 발견되어야 한다는 점을 활용하여, 깊이 우선 탐색이 해당 정점을 루트로 하는 서브트리에서 역방향 간선을 통해 닿는 정점들의 최소 발견순서를 반환한다.//그래프의 인접 리스트 표현vector&lt;vector&lt;int&gt;&gt; adj;//각 정점의 발견 순서, -1로 초기화vector&lt;int&gt; discovered;//각 정점이 절단점인지 여부를 저장한다. false로 초기화vector&lt;bool&gt; isCutVertex;int counter = 0;//here를 루트로 하는 서브트리에 있는 절단점들을 찾는다.//반환 값은 해당 서브트리에서 역방향 간선으로 갈 수 있는 정점 중 가장 일찍 발견된 정점의 발견 시점.//처음 호출은 isRoot = true이다.int findCutVertex(int here, bool isRoot) {  //발견 순서를 기록한다.  discovered[here] = counter++;  int ret = discovered[here];  //루트인 경우의 절단점 판정을 위해 자손 서브트리의 개수를 센다.  int children = 0;  for(int i = 0; i &lt; adj[here].size(); ++i) {    int there = adj[here][i];    if (discovered[there] == -1) {      ++children;      //이 서브트리에서 갈 수 있는 가장 높은 정점의 번호      int subtree = findCutVertex(there, false);      //그 번호가 자기 자신 이하라면 현재 위치는 절단점!      if (!isRoot &amp;&amp; subtree &gt;= discovered[here])        isCutVertex[here] = true;      ret = min(ret, subtree);    }    else      ret = min(ret, discovered[there]);  }  //루트인 경우 절단점 판정은 서브트리의 개수로 한다.  if(isRoot) isCutVertex[here] = (children &gt;= 2);  return ret;}강결합 컴포넌트 (Strongly Connected Components, SCC) 분리   방향 그래프에서는 무향 그래프의 절단점 정의를 그대로 사용할 수 없으므로, 이중 결합 컴포넌트를 정의할 수 없다.  방향 그래프에서는 이중 결합 컴포넌트와 유사한 강결합 컴포넌트가 있다.          방향 그래프 상에서 두 정점 u, v에 대해 양 방향으로 가는 경로가 모두 있을 때, 두 정점은 같은 SCC에 속해 있다고 말한다.         위 그림은 한 그래프의 각 SCC들을 짙은 색 배경으로 구분한 모습이다.  SCC 특징          위 그래프에서도 볼 수 있듯이, SCC 사이를 연결하는 간선들을 모으면 각 SCC들을 정점으로 하는 DAG를 만들 수 있다.                  원 그래프의 정점들을 SCC별로 분리하고 각 SCC를 표현하는 정점들을 갖는 새로운 그래프를 만드는 과정을 그래프 압축(condensation)이라 부른다.                    한 사이클에 포함된 정점들은 항상 같은 SCC에 속한다.      반대로 한 SCC에 속한 두 정점 사이를 잇는 양방향 경로를 합치면 두 정점을 포함하는 사이클이 된다.      강결합 컴포넌트 분리를 위한 타잔(Tarjan)의 알고리즘   타잔 알고리즘은 한 번의 깊이 우선 탐색으로 강결합 컴포넌트를 분리할 수 있다.1. 알고리즘 과정   임의의 정점에서부터 깊이 우선 탐색을 수행하여 DFS 스패닝 트리를 만든다.   위 그림은 예제 그래프의 가장 왼쪽 정점에서 깊이 우선 탐색을 해서 얻은 스패닝 트리이다.          스패닝 트리를 적절히 자르기만 하면 정점들을 SCC로 분리할 수 있다는 것을 알 수 있다.        동심원으로 표현된 정점들을 각 SCC의 루트라고 하자.  이때 SCC를 분리하기 위해 끊어야할 간선들은 모두 SCC의 루트로 내려가는 트리 간선임을 알 수 있다.          스패닝 트리에서 인접한 두 정점이 서로 다른 SCC에 속한다면, 그 중 자손 정점은 자신이 속한 SCC의 루트여야만 한다.        한 정점이 해당 SCC의 루트에 속하는지 알기 위해서는 절단점 찾기 알고리즘을 응용하여 판단할 수 있다.          어떤 정점 u가 SCC의 루트라면, u의 선조와 u가 서로 다른 SCC에 속한다는 의미이다.      위의 조건을 만족하려면, u에서 그 선조로 가는 경로가 없어야하는데 이 경로를 탐색 없이 확인하는 방법은 절단점 찾기 알고리즘을 응용해야 한다.        u를 루트로 하는 서브 트리 깊이 우선 탐색하면서 만나는 모든 역방향 간선을 이용해 닿을 수 있는 가장 상위 정점을 찾는다.  이 정점이 u의 선조거나 그보다 높이 있다면 이 역방향 간선을 이용해 u에서 그 선조로 갈 수 있으며, 따라서 u는 SCC의 루트가 아니다.  방향 그래프에서는 교차 간선이 존재하므로, 이를 유의해야 한다.          어떤 정점이 SCC의 루트인데, 자손 중 하나가 교차 간선을 통해 다른 정점에 연결되어 있다면 판정이 잘못 될 수 있다.       - 위 그림에서 u에서 깊이 우선 탐색을 시작하여 왼쪽의 SCC를 먼저 탐색한 뒤 v로 왔다고 한다면, w에서 왼쪽으로 가는 교차 간선을 v의 선조로 가는 역방향 간선이라고 판단하여 v가 SCC의 루트가 아니라고 잘못된 판단을 내린다.- 해결 방법은 그래프의 모든 교차 간선은 무시한다.2. 구현   현재 위치를 루트로 하는 서브트리에 남아 있는 정점들을 모두 찾는 방법을 스택을 이용하여 구현한다.          scc()함수는 깊이 우선 탐색 과정에서 지금까지 방문한 정점 중 아직 SCC로 묶이지 않은 모든 정점들을 스택에 담는다.      각 정점을 처음 방문할 때마다 스택에 넣기 때문에, here가 SCC의 루트라는 것을 확인하면 스택에서 here 위에 있는 정점들은 모두 here의 후손이다.      따라서, here를 만날 때까지 계속 스택에서 정점을 꺼내는 방식으로 쉽게 구현이 가능하다.        시간 복잡도: O(|V| + |E|)  SCC의 위상 정렬          아래의 코드에서 새 SCC가 생성되는 시점은 항상 scc()함수가 종료하기 직전이다.      위와 같은 속성때문에, 각 SCC는 위상 정렬의 역순으로 번호가 매겨진다. (dfs()가 늦게 종료하는 정점부터 배열하면 위상 정렬 결과가 나온다)      그래프의 압축을 바로 사용할 수 있다.        구현 코드 및 예제구현 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; adj;//각 정점의 컴포넌트 번호, 컴포넌트 번호는 0부터 시작하며,//같은 강결합 컴포넌트에 속한 정점들의 컴포넌트 번호가 같다.vector&lt;int&gt; sccId, discovered, finished;stack&lt;int&gt; st;  //정점의 번호를 담는 스택int sccCounter, vertexCounter;//here를 루트로 하는 서브트리에서 역방향 간선으로 닿을 수 있는 최소의 발견 순서를 반환한다.int scc(int here) {\tint ret = discovered[here] = vertexCounter++;\t//스택에 here를 넣는다. here의 후손들은 모두 스택에서 here 후에 들어간다.\tst.push(here);\tfor (int i = 0; i &lt; adj[here].size(); ++i) {\t\tint there = adj[here][i];\t\t//(here, there)가 트리 간선\t\tif (discovered[there] == -1)\t\t\tret = min(ret, scc(there));\t\t//(here, there)가 역행 간선인 경우 선조 정점의 발견 순서를 확인한다.\t\telse if (discovered[there] &lt; discovered[here] &amp;&amp; finished[there] == -1)\t\t\tret = min(ret, discovered[there]);\t}\t//here가 강결합 컴포넌트의 루트인지 확인한다.\tif (ret == discovered[here]) {\t\t//here를 루트로 하는 서브트리에 남아 있는 정점들을 전부 하나의 컴포넌트로 묶는다.\t\twhile (true) {\t\t\tint t = st.top();\t\t\tst.pop();\t\t\tsccId[t] = sccCounter;\t\t\tif (t == here) break;\t\t}\t\t++sccCounter;\t}\tfinished[here] = 1;\treturn ret;}//tarjan의 SCC알고리즘vector&lt;int&gt; tarjanSCC() {\t//배열과 카운터 초기화\tsccId = discovered = finished = vector&lt;int&gt;(adj.size(), -1);\tsccCounter = vertexCounter = 0;\t//모든 정점에 대해 scc()호출\tfor (int i = 0; i &lt; adj.size(); ++i)\t\tif (discovered[i] == -1) scc(i);\treturn sccId;}int main(){\t//n: 정점의 개수, m: 간선의 개수\tint n, m; scanf(\"%d %d\", &amp;n, &amp;m);\tadj = vector&lt;vector&lt;int&gt;&gt;(n);\tfor (int i = 0; i &lt; m; i++) {\t\tint s, e; scanf(\"%d %d\", &amp;s, &amp;e);\t\tadj[s].push_back(e);\t}\tvector&lt;int&gt; ans;\tans = tarjanSCC();\tfor (int i = 0; i &lt; n; ++i)\t\tprintf(\"%d \", ans[i]);\treturn 0;}  예제 그래프(위의 예제 그래프에 정점 번호 부여)   예제 입력    11 150 10 71 22 02 33 43 64 55 37 87 98 68 99 1010 8        예제 결과    4 4 4 1 1 1 0 3 2 2 2                  정점 번호      0      1      2      3      4      5      6      7      8      9      10                  SCC 번호      4      4      4      1      1      1      0      3      2      2      2      참고 문헌   프로그래밍 대회에서 배우는 알고리즘 문제해결전략, 인사이트, 구종만 지음","categories": ["Algorithm"],
        "tags": ["Algorithm_Algorithm"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-%EC%A0%88%EB%8B%A8%EC%A0%90-%EC%B0%BE%EA%B8%B0-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/",
        "teaser":null},{
        "title": "[Algorithm]플로이드 알고리즘",
        "excerpt":"플로이드(Floyd)의 모든 쌍 최단 거리 알고리즘 플로이드 알고리즘의 특징   모든 쌍의 최단 거리를 구할 수 있다.          알고리즘이 간단하기 때문에, 모든 정점에서 다익스트라나 벨만-포드 알고리즘을 수행하는 것보다 훨씬 효율적이다.        실제 경로를 계산할 수 있다.  가중치없는 그래프에서 각 정점 간의 도달 가능성 여부를 계산할 수 있다.          너비 우선 탐색보다 구현이 간단하여 자주 사용한다.      경유점   두 정점 u, v를 잇는 어떤 경로가 있을 때, 이 경로는 u, v외에도 다른 정점을 경유해서 가는 경로가 더 짧을 수도 있다.  위와 같이 경로가 거쳐가는 정점들을 경유점이라고 한다.   위의 그림에서 볼 수 있듯이, 정점 u에서 v까지 가장 짧은 경로는 u -&gt; a -&gt; b -&gt; v인 것을 볼 수 있다.          여기서 경유점은 정점 a, b이다.        플로이드 알고리즘은 시작 정점과 도착 정점 사이의 모든 경로점을 고려하는 것을 시각적으로 이해하기 쉽고 간단하게 구현된 알고리즘이다.플로이드 알고리즘 최적화 과정 1. 시간 복잡도: O(|V|^3), 공간 복잡도: O(|V|^3)   어떤 정점 집합 S에 포함된 정점만을 경유점으로 사용해 u에서 v로 가는 최단 경로를 계산한다고 가정하자.  어떤 정점 x에 대해 2가지를 생각할 수 있다.          경로가 x를 경유하지 않는다: 이 경로는 S - {x} 에 포함된 정점들만을 경유점으로 사용한다.      경로가 x를 경유한다.: 이 경로는 u에서 x의 구간과 x에서 v로 가는 구간으로 나눌 수 있다. 이 두개의 부분 경로는 각각 최단 경로임이 확실하며 x를 경유하지 않는다. 따라서 위와 같이 S - {x}에 포함된 정점들만을 경유점으로 사용한다.        이를 활용하여, S = { 0, 1, 2, ..., k }라 하고 C_k(u, v)는 정점 0번 부터 k번 정점까지만을 경유점을 썼을 때 u에서 v까지 가는 최단 경로의 길이라고 두면 다음과 같은 재귀적인 식이 만들 수 있다.    C_k(u, v) = min(C_k-1(u, k) + C_k-1(k, v), C_k-1(u, v))        C_k는 C_k-1에만 의존하기 때문에, 동적 계획법으로 구현할 수 있다. (C[k][u][v]배열로 메모이제이션)2. 시간 복잡도: O(|V|^3), 공간 복잡도: O(|V|^2)   1번 알고리즘의 문제는 시간 복잡도보다 공간 복잡도이다.          정점의 개수가 1000개라고 가정하면, 시간은 10초가량 소요되지만, 배열 용량은 4GB가 정도가 필요하다.        공간 복잡도를 줄이기 위해서는 위에서 세운 식의 문제점을 파악하면 쉽게 해결가능하다.          C_k-1(u, k) = 시작점으로부터 k-1번 정점까지를 경유점으로 이용해 u에서 k로 가는 최단 경로의 길이      C_k(u, k) = 시작점으로부터 k번 정점까지를 경유점으로 이용해 u에서 k로 가는 최단 경로의 길이      위의 두 식을 보면, 출발점이나 도착점이 k번 정점일 때, 사용가능한 경유점의 목록에 k가 추가되는 것은 아무런 의미가 없다.      즉, 1번에서 C배열의 k가 전혀 필요하지 않다는 것이다.        구현          별도의 배열 C를 만들지 않고, 인접 행렬adj에 직접 최단 거리를 계산한다.      //정점의 개수int V;//그래프의 인접 행렬 표현//adj[u][v] = u에서 v로 가는 가선의 가중치, 간선이 없으면 아주 큰 값으로 초기화int adj[MAX_V][MAX_V];//플로이드의 모든 쌍 최단 거리 알고리즘void floyd() {\tfor (int i = 0; i &lt; V; ++i) adj[i][i] = 0;\tfor (int k = 0; k &lt; V; ++k)\t\tfor (int i = 0; i &lt; V; ++i)\t\t\tfor (int j = 0; j &lt; V; ++j)\t\t\t\tadj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j]);}3. 시간 복잡도 최적화   플로이드 알고리즘의 3중 for문 중 2번째 for문 바로 다음에 i에서 k로 가는 경로가 실제 있는지를 확인한다.  i에서 k로 가는 경로가 없다면 j에 대한 for문은 수행할 필요가 없다.  이는 실제로 그래프에 간선이 적을수록 효과가 좋으며, 경우에 따라 10% ~ 20% 정도의 수행 시간으르 단축시킬 수 있다.실제 경로 계산하기   플로이드 알고리즘에서 실제 경로를 계산하기 위해서는 adj[u][v]를 갱신했을 때 사용했던 k의 값을 저장해두면 된다.          u에서 v로 가는 최단 거리를 정점 w일 때 갱신되었다면, u에서 w로 가는 최단 거리 경로점을 찾고 w에서 v로 가는 최단 거리를 경로점을 찾아 둘을 합치면 최종적으로 u에서 v로 가는 최단 경로를 찾을 수 있다.        구현//정점의 개수int V;//그래프의 인접 행렬 표현//adj[u][v] = u에서 v로 가는 가선의 가중치, 간선이 없으면 아주 큰 값으로 초기화int adj[MAX_V][MAX_V];//via[u][v] = u에서 v까지 가는 최단 경로가 경유하는 점 중 가장 번호가 큰 정점//-1로 초기화한다.int via[MAX_V][MAX_V];//플로이드의 모든 쌍 최단 거리 알고리즘void floyd() {\tfor (int i = 0; i &lt; V; ++i) adj[i][i] = 0;\t//via배열 초기화\tmemset(via, -1, sizeof(via));\tfor (int k = 0; k &lt; V; ++k)\t\tfor (int i = 0; i &lt; V; ++i)\t\t\tfor (int j = 0; j &lt; V; ++j)\t\t\t\tif (adj[i][j] &gt; adj[i][k] + adj[k][j]) {\t\t\t\t\tvia[i][j] = k;\t\t\t\t\tadj[i][j] = adj[i][k] + adj[k][j];\t\t\t\t}}//u에서 v로 가는 최단 경로를 계산해 path에 저장한다.void reconstruct(int u, int v, vector&lt;int&gt; &amp;path) {\t//기저 사례\tif (via[u][v] == -1) {\t\tpath.push_back(u);\t\tif (u != v) path.push_back(v);\t}\telse {\t\tint w = via[u][v];\t\treconstruct(u, w, path);\t\tpath.pop_back(); //w가 중복으로 들어가므로 지워준다.\t\treconstruct(w, v, path);\t}}도달 가능성 확인하기   C_k(u, v): 0번부터 k번 정점까지를 경유점으로 사용한다.  u에서 v로 가는 경로가 있는지 여부를 나타내는 식은 다음과 같다.    C_k(u, v) = C_k-1(u, v) || (C_k-1(u ,k) &amp;&amp; C_k-1(k, v))      ","categories": ["Algorithm"],
        "tags": ["Algorithm_Algorithm"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/",
        "teaser":null},{
        "title": "[Algorithm]소수 구하기",
        "excerpt":"소수 에라토스테네스의 체 정의   제일 작은 소수 2부터 N-1까지 수 중에서 2의 배수를 모두 체로 거르고, 남은 수중에서 3의 배수를 거르는 과정을 반복하여 루트N 까지 걸러서 남은 수들이 이 범위안의 소수이다.구현 //에라토스테네스의 체prime[0] = prime[1] = 1;  //0,1은 소수 판별에서 제외되는 숫자이기 때문for (int i = 2; i &lt; N; i++) {\tif (prime[i] == 0) {\t       for (int j = i + i; j &lt; N; j += i)\t                prime[j] = 1;\t}}  //prime 배열의 값이 0인 인덱스가 소수이다.  일정 범위 내의 수에서 모든 소수를 구하는 문제에 주로 사용된다.","categories": ["Algorithm"],
        "tags": ["Algorithm_Algorithm"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-%EC%86%8C%EC%88%98-%EA%B5%AC%ED%95%98%EA%B8%B0/",
        "teaser":null},{
        "title": "[Algorithm]순열과 조합",
        "excerpt":"순열과 조합 경우의 수   합의 법칙: 분류          분류의 조건                  동시에 일어나지 않음.          하나도 빠짐없이 포함되어 있어야함.                      곱의 법칙: 동시에 일어나는 일 = 함께 일어나는 일  예제자연수 999이하의 수 중에서 숫자 5가 포함된 수의 개수를 구하라.1. 합의 법칙 = 분류1) 5가 1개 있는 경우의 수 (곱의 법칙)- 5xx = 9 * 9 = 81 * 1- x5x = 9 * 9 = 81 * 1- xx5 = 9 * 9 = 81 * 12) 5가 2개 있는 경우의 수 (곱의 법칙)- 55x = 9 * 2 = 18- 5x5 = 9 * 2 = 18- x55 = 9 * 2 = 183) 5가 3개 있는 경우의 수 (곱의 법칙)- 555 = 1 * 3=&gt; (81 + 81 + 81) + (18 + 18 + 18) + 3 = 300순열(Permutation)   순서 있는 나열  nPr: n개 중에서 r개를 뽑아서 일렬로 나열하는 경우의 수  nPr = n! / (n-r)!STL함수 next_permutation을 활용한 순열 구현(C++)   기본적으로 next_permutation은 nPn을 구하는 함수이다.  nPr을 next_permutation을 활용하여 구할려면 nPn을 구한 상태에서 r크기까지만 저장한다.          하지만, nPn과 시간복잡도가 같다는 단점이 있다.      구현 코드 /*순열은 초기화가 필요하다.for (int i = 0; i &lt; n; ++i)\t\tset.push_back(i);*/void permutationSTL(vector&lt;int&gt; set, int n, int r) {\tdo {\t\tfor (int i = 0; i &lt; r; ++i)\t\t\tprintf(\"%d \", set[i]);\t\tprintf(\"\\n\");\t} while (next_permutation(set.begin(), set.end()));}재귀 함수를 활용한 순열 구현(C++) void swapSet(vector&lt;int&gt; &amp;num, int a, int b) {\tint tmp = num[a];\tnum[a] = num[b];\tnum[b] = tmp;}void permutation(vector&lt;int&gt; set, int setSize, int n, int r) {\t//종료 조건\tif (setSize == r) {\t\tfor (int i = 0; i &lt; setSize; ++i)\t\t\tprintf(\"%d \", set[i]);\t\tprintf(\"\\n\");\t\treturn;\t}\t//분기 조건\tfor (int i = setSize; i &lt; n; ++i) {\t\tswapSet(set, i, setSize);\t\tpermutation(set, setSize + 1, n, r);\t\tswapSet(set, i, setSize);\t}}중복 순열(Repeated permutation)   중복 원소를 포함하는 순서있는 나열void repeatedPerm(vector&lt;int&gt; set, int setSize, int n, int r) {\t//종료 조건\tif (setSize == r) {\t\tfor (int i = 0; i &lt; setSize; ++i)\t\t\tprintf(\"%d \", set[i]);\t\tprintf(\"\\n\");\t\treturn;\t}\t//분기 조건\tfor (int i = 0; i &lt; n; ++i) {\t\tset[setSize] = i;\t\trepeatedPerm(set, setSize + 1, n, r);\t}}조합(Combination)   순서를 고려하지 않고 선택하는 방법의 수  nCr: n개 중에서 r개를 순서에 상관없이 선택하는 방법의 수  nCr = nPr / r! = n! / (n-r)!r!STL함수 next_permutation을 활용한 조합 구현(C++)   n 크기의 배열에서 r 개수만큼의 1을 배열 뒤에서 부터 삽입하고 나머지는 0으로 채운다.  위의 배열을 이용하여 next_permutation 함수를 사용하여 순열을 구한 후 1에 해당하는 인덱스를 뽑는다.구현 코드 void combinationSTL(vector&lt;int&gt; set, int n, int r) {\tfor (int j = 0; j &lt; n - r; ++j)\t\tset.push_back(0);\tfor (int j = 0; j &lt; r; ++j)\t\tset.push_back(1);\tdo {\t\tfor (int j = 0; j &lt; n; ++j)\t\t\tif (set[j])\t\t\t\tprintf(\"%d \", j);\t\tprintf(\"\\n\");\t} while (next_permutation(set.begin(), set.end()));}재귀 함수를 활용한 조합 구현(C++) //set = vector&lt;int&gt;(n);void repeatedComb(vector&lt;int&gt; set, int setSize, int n, int r, int idx) {\t//종료 조건\tif (setSize == r) {\t\tfor (int i = 0; i &lt; setSize; ++i)\t\t\tprintf(\"%d \", set[i]);\t\tprintf(\"\\n\");\t\treturn;\t}\tif (n == idx) return;\t//분기 조건\tset[setSize] = idx;\trepeatedComb(set, setSize + 1, n, r, idx + 1);\trepeatedComb(set, setSize, n, r, idx + 1);}중복 조합(Repeated combination)   중복 원소를 포함하여 선택하는 방법의 수void repeatedComb(vector&lt;int&gt; set, int setSize, int n, int r, int idx) {\t//종료 조건\tif (setSize == r) {\t\tfor (int i = 0; i &lt; setSize; ++i)\t\t\tprintf(\"%d \", set[i]);\t\tprintf(\"\\n\");\t\treturn;\t}\tif (n == idx) return;\t//분기 조건\tset[setSize] = idx;\trepeatedComb(set, setSize + 1, n, r, idx);  //idx 중복 가능\trepeatedComb(set, setSize, n, r, idx + 1);}결과 main 함수 int main(){\tint n = 3;\tint r = 2;\tvector&lt;int&gt; set;\t//초기화\tfor (int i = 0; i &lt; n; ++i)\t\tset.push_back(i);\tprintf(\"permutationSTL(%d, %d)\\n\", n, r);\tpermutationSTL(set, n, r);\tprintf(\"============================\\n\");\tprintf(\"permutation(%d, %d)\\n\", n, r);\tpermutation(set, 0, n, r);\tprintf(\"============================\\n\");\tprintf(\"repeatedPerm(%d, %d)\\n\", n, r);\trepeatedPerm(set, 0, n, r);\tprintf(\"============================\\n\");\tset.clear();\tprintf(\"combinationSTL(%d, %d)\\n\", n, r);\tcombinationSTL(set, n, r);\tprintf(\"============================\\n\");\tset = vector&lt;int&gt;(n);\tprintf(\"combination(%d, %d)\\n\", n, r);\tcombination(set, 0, n, r, 0);\tprintf(\"============================\\n\");\tprintf(\"repeatedComb(%d, %d)\\n\", n, r);\trepeatedComb(set, 0, n, r, 0);\treturn 0;}결과 화면 permutationSTL(3, 2)0 10 21 01 22 02 1============================permutation(3, 2)0 10 21 01 22 12 0============================repeatedPerm(3, 2)0 00 10 21 01 11 22 02 12 2============================combinationSTL(3, 2)1 20 20 1============================combination(3, 2)0 10 21 2============================repeatedComb(3, 2)0 00 10 21 11 22 2","categories": ["Algorithm"],
        "tags": ["Algorithm_Algorithm"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-%EC%88%9C%EC%97%B4%EA%B3%BC-%EC%A1%B0%ED%95%A9/",
        "teaser":null},{
        "title": "[Algorithm]KMP 알고리즘",
        "excerpt":"KMP 알고리즘   풀네임은 커누스-모리스-프랫(Knuth-Morris-Pratt) 알고리즘으로, 문자열 검색 알고리즘이다.미리 알아 둘점   문자열 S의 길이는 |S|로 표기  문자열 S의 i번부터 j번까지 구성된 부분 문자열을 S[i...j]로 표기  문자열 S의 0번부터 a번까지 구성된 부분 문자열을 접두사(prefix)라 부르고, S[...a]로 표기  문자열 S의 b번부터 끝까지 구성된 부분 문자열을 접미사(suffix)라 부르고, S[b...]로 표기기본 개념   기본적인 검색 알고리즘은 한 문자열의 시작점을 하나씩 옮겨가면서 찾을 문자열을 검색하는 것이다.  KMP 알고리즘은 시작점을 하나씩 옮기는 것이 아니라 최적화 과정을 거쳐 옮길 칸 수를 정한다.  예를 들어, N = “aabaabac”를 찾는 경우가 있다.          H 문자열의 해당 부분 문자열인 H[i...i + 6]이 “aabaaba”까지 일치한다.      그렇다면, i + 1에서 시작하는 N은 H와 일치할 수 없다는 것을 알 수 있다.      가능성이 있는 위치는 i + 3, i + 6 이라는 것을 아래의 그림을 보면 알 수 있다.       다음 시작 위치 찾기   다음 시작 위치를 어떻게 찾는지 예제 그림을 보며, 알아보자   위 그림에서 시작 위치 i일때, H와 N을 맞춰보면 matched글자가 일치하고 다음 글자가 불일치하는 상황을 볼 수 있다.  matched글자가 일치했기 때문에, N의 접두사 N[...matced - 1]가  H[i...i + matched - 1]와 일치했음을 알 수 있다.(회색으로 칠해진 부분)  시작 위치 i + k가 답이 될려면, B와 C가 서로 같아야 하며, 결과적으로 A와 C도 같아야 한다.(굵은 선 네모 부분)          A = C는 N[...matced - 1]의 접두사이기도 하고 접미사이기도 한다.      시작 위치 i + k가 답을 찾을 수 있기 위해서는 N[...matced - 1]의 길이 matched - k인 접두사와 접미사가 같아야 한다.        정리하면, 답이 될 수 있는 바로 다음 위치를 찾기 위해서는 N의 각 접두사에 대해 접두사도 되고 접미사도 되는 문자열의 최대 길이를 계산해야 한다.          위의 예제 “aabaaba”에서 접두사도 되고 접미사도 되는 문자열은 “aaba”와 “a” 두가지 있다.      여기서 최대 길이 문자열은 “aaba”이기 때문에, 시작 위치를 3만큼 옮겨주었던 것이다.      KMP 알고리즘 구현   다음 시작 위치를 찾는 배열을 다음과 같이 정의한다.          pi[i] = N[...i]의 접두사도 되고 접미사도 되는 문자열의 최대 길이        pi[]는 어디까지 일치했는지가 주어질 때 다음 시작 위치를 알려주기 때문에, 이를 흔히 부분 일치 테이블(partial match table) 또는 실패 함수(faulure function)이라 부른다.          찾는 문자열 “aabaabac”의 각 접두사에 대한 부분 일치 테이블은 밑에와 같이 계산된다.                                i          N[…i]          접두사이면서 접미사인 최대 문자열          pi[i]                                      0          a          (없음)          0                          1          aa          a          1                          2          aab          (없음)          0                          3          aaba          a          1                          4          aabaa          aa          2                          5          aabaab          aab          3                          6          aabaaba          aaba          4                          7          aabaabac          (없음)          0                      KMP 알고리즘 동작 과정          초기에는 단순한 알고리즘과 같이 시작 위치 0부터 시작한다.      만약 matched글자가 일치한 후 불일치가 발생한다면, 위 그림의 A의 길이는 pi[matched - 1]이다.      시작 위치를 matched - pi[matched - 1]만큼 증가 시킨다.                  위와 같이 동작하면, 시작 위치를 움직인 이후 첫 글자부터 다시 대응시켜 나갈 필요가 없다는 것이 중요한 관점이다.          새로운 위치에서 비교를 시작하더라도 N의 첫 pi[matched - 1]글자는 대응되는 H의 글자와 일치하기 때문이다.(위 그림에서 B와 C가 서로 같기 때문이다.)                    matched를 pi[matched - 1]로 변경하고 비교를 계속한다.      답을 찾은 경우에는 현재 시작 위치를 답의 목록에 추가해주고, 불일치가 발생한 경우와 같이 다음 시작 위치에서부터 다시 검색을 한다.      matched = 0이면 한 글자도 일치하지 않았다는 의미이므로, 바로 다음 시작 위치에서 처음부터 검색을 시작한다.        구현 코드          참고사항으로, 부분 일치 테이블의 구현과 관련된 점은 아래에서 설명한다.      //'짚더미' H의 부분 문자열로 '바늘' N이 출현하는 시작 위치들을 모두 반환한다.vector&lt;int&gt; kmpSearch(const string &amp;H, const string &amp;N) {\tint n = H.size(), m = N.size();\tvector&lt;int&gt; ret;\t//pi[i] = N[...i]의 접미사도 되고 접두사도 되는 문자열의 최대 길이\tvector&lt;int&gt; pi = getPartialMatch(N);\t//begin = matched = 0 에서부터 시작\tint begin = 0, matched = 0;\twhile (begin &lt;= n - m) {\t\t//만약 짚더미의 해당 글자가 바늘의 해당 글자와 같다면\t\tif (matched &lt; m &amp;&amp; H[begin + matched] == N[matched]) {\t\t\t++matched;\t\t\t//결과적으로 m글자가 모두 일치했다면 답에 추가한다.\t\t\tif (matched == m) ret.push_back(begin);\t\t}\t\telse {\t\t\t//예외: matched가 0인 경우에는 다음 칸에서부터 계속\t\t\tif (matched == 0)\t\t\t\t++begin;\t\t\telse {\t\t\t\tbegin += matched - pi[matched - 1];\t\t\t\t//begin을 옮겼다고 처음부터 다시 비교할 필요가 없다.\t\t\t\t//옮긴 후에도 pi[matched - 1]만큼은 항상 일치하기 때문이다.\t\t\t\tmatched = pi[matched - 1];\t\t\t}\t\t}\t}\treturn ret;}  시간 복잡도          getPartialMatch() 시간 복잡도는 아직 고려하지 않는다.      while문에서 begin + matched 는 절대 감소하지 않는다.                  matched가 감소하면 그만큼 begin이 증가하기 때문이다.                    따라서, 최대 시간 복잡도는 O(|H|)입니다.      부분 일치 테이블 생성하기 1. 간단한 알고리즘   N의 각 접두사에 대해 가능한 모든 답을 시도한다.  길이 p인 접두사 N[...p - 1]이 주어졌을때, 길이 p - 1, p - 2, ...들을 순회하며 이들이 N[... p - 1]의 접미사가 되는지 확인한다.  모든 접두사에 대해 한꺼번에 계산한다면, 시간 복잡도는 O(|N|^2)이다.  구현 코드    //N에서 자기 자신을 찾으면서 나타나는 부분 일치를 이용해 pi[]를 계산한다.//pi[i] = N[...i]의 접미사도 되고 접두사도 되는 문자열의 최대 길이vector&lt;int&gt; getPartialMatchNaive(const string &amp;N) {  int m = N.size();  vector&lt;int&gt; pi(m, 0);  //단순한 문자열 검색 알고리즘을 구현한다.  for (int begin = 1; begin &lt; m; ++begin) {      for (int i = 0; i &lt; m; ++i) {          if (N[begin + i] != N[i]) break;          //i + 1글자가 서로 대응되었다.          pi[begin + i] = max(pi[begin + i], i + 1);      }  }  return pi;}      2. KMP 알고리즘 활용   고려 사항          begin을 옮길 때 이전에 계산한 pi[] 값을 사용한다.                  현재 matched글자가 일치했다면 pi[matched - 1]는 항상 계산된 뒤임을 증명할 수 있기 때문이다.                    pi[]의 각 원소는 최대 한 번만 변경되기 때문에 위의 간단한 알고리즘에서 처럼 max()연산을 해줄 필요가 없다.        구현 코드vector&lt;int&gt; getPartialMatch(const string &amp;N) {\tint m = N.size();\tvector&lt;int&gt; pi(m, 0);\t//KMP로 자기 자신을 찾는다.\t//N을 N에서 찾는다. begin = 0이면 자기 자신을 찾아버리니까 안됨!\tint begin = 1, matched = 0;\t//비교할 문자가 N의 끝에 도달할 때까지 찾으면서 부분 일치를 모두 기록한다.\twhile (begin + matched &lt; m) {\t\tif (N[begin + matched] == N[matched]) {\t\t\t++matched;\t\t\tpi[begin + matched - 1] = matched;\t\t}\t\telse {\t\t\tif (matched == 0)\t\t\t\t++begin;\t\t\telse {\t\t\t\tbegin += matched - pi[matched - 1];\t\t\t\tmatched = pi[matched - 1];\t\t\t}\t\t}\t}\treturn pi;}  시간 복잡도: O(|N|)","categories": ["Algorithm"],
        "tags": ["Algorithm_Algorithm"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-KMP%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/",
        "teaser":null},{
        "title": "[Algorithm]LCS 알고리즘",
        "excerpt":"Longest Common Subsequence(LCS) 알고리즘 개요   최장 공통 부분 문자열  예제 그림 관련 문제 문제 링크   LCS 길이 구하기          https://www.acmicpc.net/problem/9251        LCS 길이 + LCS 문자열 구하기          https://www.acmicpc.net/problem/9252      추가 테스트 케이스   입력AKAKAAK  출력4AAK코드 분석 LCS 길이 구하기   동적 계획법  str1[]: 입력 배열1, str2[]: 입력 배열2  dp[x][y]: str1[x], str2[y] 일때, LCS 길이          점화식 계산을 위해 인덱스 0일 때, 모든 값을 0으로 채워준다.(즉 str1, str2길이가 n일 때, dp[n+1][n+1]이어야 한다.)        점화식: for문 i: 1 ~ str1 문자열 길이, j: 1 ~ str2 문자열 길이str1[i - 1] == str2[j - 1] =&gt; dp[i][j] = dp[i - 1][j - 1] + 1str1[i - 1] != str2[j - 1] =&gt; MAX(dp[i - 1][j], dp[i][j - 1])  예제 배열 최종 결과 그림   시간 복잡도: str1, str2 중 최대 문자열 길이를 N이라 할때, O(N^2)LCS 문자열 구하기   check[x][y]: str1[x] == str2[y]일때 LCS 길이, 아니면 0값이다.          위의 LCS 길이를 구하는 점화식에서 두 문자열이 같을 때의 dp배열값을 같은 인덱스 위치 check배열에 삽입한다.        maxLen: LCS 길이 값  슈도 코드for( i: str1 문자열길이 ~ 1)  for( j: str2 문자열길이 ~ 1)    if(check[i][j] == maxLen)      정답 배열[maxLen - 1] = str1[i - 1] or str2[j - 1]      maxLen--      break  예제 배열 그림   시간복잡도: O(N^2)결과 코드   LCS 길이 + LCS 문자열 구하기#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define max(a,b) ((a) &gt; (b) ? (a) : (b))#define N 1002//str1, str2: 입력 배열char str1[N], str2[N];//dp: LCS 길이를 계산할 배열, check: LCS 문자열을 계산할 배열int dp[N][N], check[N][N];//ans: LCS 문자열을 저장할 배열char ans[N];int main(){\tscanf(\"%s %s\", str1, str2);\tint len1 = strlen(str1);\tint len2 = strlen(str2);\t//LCS 길이 계산\tfor (int i = 1; i &lt; len1 + 1; i++) {\t\tfor (int j = 1; j &lt; len2 + 1; j++) {\t\t\tif (str1[i - 1] == str2[j - 1]) {\t\t\t\tdp[i][j] = dp[i - 1][j - 1] + 1;\t\t\t\tcheck[i][j] = dp[i][j];\t\t\t}\t\t\telse\t\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\t\t}\t}\tprintf(\"%d\\n\", dp[len1][len2]);\t//LCS 문자열 계산\tint maxlen = dp[len1][len2];\tfor (int i = len1; i &gt;= 1; i--) {\t\tif (!maxlen) break;\t\tfor (int j = len2; j &gt;= 1; j--) {\t\t\tif (check[i][j] == maxlen) {\t\t\t\tans[maxlen - 1] = str1[i - 1];\t\t\t\tmaxlen--;\t\t\t\tbreak;\t\t\t}\t\t}\t}\tprintf(\"%s\\n\", ans);\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_Algorithm"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-LCS%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/",
        "teaser":null},{
        "title": "[Algorithm]LCS 알고리즘",
        "excerpt":"Longest Increasing Subsequence(LIS) 알고리즘 개요   가장 긴 증가하는 부분 수열  예제 그림   두번째 줄의 노란색 박스 부분이 LIS를 나타내는 모습이다.구현 1. 동적 계획법   알고스팟 LIS 문제 분석          Top-down, Bottom-up 방식        시간복잡도: O(N^2)2. Lower-bound   알고리즘 과정          num[]: 입력 수열, lis[]: LIS를 만들기 위해 비어있는 수열                  lis배열에 아무 값이 없다면(초기화), num배열의 가장 첫번째 값을 삽입한다.          lis배열에서 가장 큰 값(= 가장 오른쪽에 있는 값)보다 현재 보고 있는 num[i]값이 크다면 lis배열에 num[i]값을 추가한다.          작다면 lower_bound(주어진 집합의 어떤 원소보다 작거나 같은 원소)를 이용하여 해당 위치에 num[i]값을 삽입한다.                      시간복잡도: O(NlogN)구현 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define N 1001int num[N], lis[N];int _lower_bound(int start, int end, int target){\tint mid;\twhile (start &lt; end) {\t\tmid = (start + end) / 2;\t\tif (lis[mid] &lt; target)\t\t\tstart = mid + 1;\t\telse\t\t\tend = mid;\t}\treturn end;}int main(){\tint n; scanf(\"%d\", &amp;n);\tfor (int i = 0; i &lt; n; i++)\t\tscanf(\"%d\", &amp;num[i]);\tint idx = 0;\tlis[idx] = num[0];\tfor (int i = 1; i &lt; n; i++) {\t\tif (lis[idx] &lt; num[i])\t\t\tlis[++idx] = num[i];\t\telse {\t\t\tint next = _lower_bound(0, idx, num[i]);\t\t\tlis[next] = num[i];\t\t}\t}\tprintf(\"%d\\n\", idx + 1);\treturn 0;}관련 문제   https://www.acmicpc.net/problem/11053  https://algospot.com/judge/problem/read/LIS  이외에 LIS알고리즘을 응용하는 다양한 문제들이 있다.","categories": ["Algorithm"],
        "tags": ["Algorithm_Algorithm"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-LIS%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/",
        "teaser":null},{
        "title": "[Algorithm]이분 탐색",
        "excerpt":"Binary Search / Lower Bound / Upper Bound 개요   Binary Search: 원하는 값 K를 찾는 과정  Lower Bound: 원하는 값 K 이상인 값 이 처음 나오는 위치를 찾는 과정  Upper Bound: 원하는 값 K 초과인 값 이 처음 나오는 위치를 찾는 과정Lower Bound 알고리즘 과정   arr[] = { 1, 3, 5, 7, 9, 11 }, target = 8 일때, Louwer Bound를 구하라.   시작 인덱스 = 0, 끝 인덱스 = 5, 중간 인덱스 = 2 이다.          중간 인덱스 2의 값은 5이고, 이 값은 타겟인 8보다 작기 때문에 시작 인덱스 = 중간 인덱스 + 1로 설정하고 다음 반복문으로 간다.         시작 인덱스 = 3, 끝 인덱스 = 5, 중간 인덱스 = 4 이다.          9는 타겟인 8보다 크기 때문에 끝 인덱스 = 중간 인덱스로 설정하고 다음 반복문으로 간다.         시작 인덱스 = 3, 끝 인덱스 = 4, 중간 인덱스 = 3 이다.          7은 타겟 8보다 작기 때문에 시작 인덱스 = 중간 인덱스 + 1로 설정한다.         시작 인덱스 = 4, 끝 인덱스 = 4, 중간 인덱스 = 4 이다.          시작 인덱스와 끝 인덱스가 같기 때문에 반복문에 들어가지 않으며, 끝 인덱스를 Lower Bound가 찾는 인덱스로 반환한다.        Bound의 반환 값은 인덱스가 0부터 시작하므로 +1을 해서 몇 번째인지 바로 반환할 수도 있고, 반환받은 값에서 +1을해도 상관없다.구현 코드   Binary Search예제 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int binarySearch(int *arr, int size, int target){\tint first = 0;\tint last = size - 1;\tint mid;\twhile (first &lt;= last) {\t\tmid = (first + last) / 2;\t\tif (arr[mid] == target)\t\t\treturn mid;\t\tif (mid &gt; target)\t\t\tlast = mid - 1;\t\telse\t\t\tfirst = mid + 1;\t}\treturn -1;}int main(){\tint arr[6] = { 1, 3, 5, 7, 9, 11 };\tint target = 8;\tint find;\t//Binary Search\tfind = binarySearch(arr, sizeof(arr), target);\tprintf(\"Binary Search, target: 8 =&gt; INDEX: %d, VALUE: %d\\n\", find, find == -1 ? -1 : arr[find]);\treturn 0;}결과 Binary Search, target: 8 =&gt; INDEX: -1, VALUE: -1  Lower Bound예제 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int lowerBound(int *arr, int size, int target){\tint start = 0;\tint end = size - 1;\tint mid;\twhile (start &lt; end) {\t\tmid = (start + end) / 2;\t\tif (arr[mid] &lt; target)\t\t\tstart = mid + 1;\t\telse\t\t\tend = mid;\t}\treturn end;}int main(){\tint arr[6] = { 1, 3, 5, 7, 9, 11 };\tint target = 8;\tint find;\t//Lower Bound\tfind = lowerBound(arr, sizeof(arr), target);\tprintf(\"Lower Bound, target: 8 =&gt; INDEX: %d, VALUE: %d\\n\", find, arr[find]);\treturn 0;}결과 Lower Bound, target: 8 =&gt; INDEX: 4, VALUE: 9  Upper Bound예제 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int upperBound(int *arr, int size, int target){\tint start = 0;\tint end = size - 1;\tint mid;\twhile (start &lt; end) {\t\tmid = (start + end) / 2;\t\tif (arr[mid] &lt;= target)\t\t\tstart = mid + 1;\t\telse\t\t\tend = mid;\t}\treturn end;}int main(){\tint arr[6] = { 1, 3, 5, 7, 9, 11 };\tint target = 8;\tint find;\t//Upper Bound\tfind = upperBound(arr, sizeof(arr), target);\tprintf(\"Upper Bound, target: 8 =&gt; INDEX: %d, VALUE: %d\\n\", find, arr[find]);\treturn 0;}결과 Upper Bound, target: 8 =&gt; INDEX: 4, VALUE: 9","categories": ["Algorithm"],
        "tags": ["Algorithm_DataStructure"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/",
        "teaser":null},{
        "title": "[DataStructure]N^2 정렬 알고리즘",
        "excerpt":"O(N^2) 정렬 알고리즘 버블 정렬(Bubble Sort)   버블 정렬은 인접한 두 원소를 검사하여 정렬하는 방법이다.  버블 정렬 알고리즘 순서(오름차순)          주어진 배열 범위 중에서 첫 번째 위치와 두 번재 위치 크기를 비교하여 크기가 큰 수를 두 번째 위치에 둔다.      첫 번째 위치를 한 칸 뒤로 옮겨 과정 1을 반복한다.                  두 번째 위치가 주어진 배열 범위의 끝에 도달하면 마지막 위치를 제외하여 배열 범위를 설정하고 과정 1로 돌아간다.  (첫 번째 과정이 끝나면 가장 큰 원소가 가장 끝에 위치한다.)                      총 비교 횟수: (n-1) + (n-2) + (n-3) ... + 1   구현 코드(C언어)//오름차순//arr[]: 입력 배열, n: arr배열 크기void BubbleSort(int arr[], int n) {\tint i, j;\tint temp;\tfor(i = 0; i &lt; n - 1; i++)\t\tfor(j = 0; j &lt; (n - i) - 1; j++)\t\t\tif(arr[j] &gt; arr[j + 1]) {\t\t\t\ttemp = arr[j];\t\t\t\tarr[j] = arr[j + 1];\t\t\t\tarr[j + 1] = temp;\t\t\t}}선택 정렬(Selection Sort)   선택 정렬 알고리즘 순서(오름차순)          주어진 배열 범위 중에서 최소값을 찾는다.      해당 값을 가장 앞에 위치한 값과 교환한다.      가장 앞에 위치한 값을 제외하여 배열 범위를 설정하고 과정 1로 돌아간다.         구현 코드(C언어)//오름차순//arr[]: 입력 배열, n: arr배열 크기void SelectionSort(int arr[], int n) {\tint i, j;\tint maxIdx;\tint temp;\tfor(i = 0; i &lt; n - 1; i++) {\t\tmaxIdx = i;    // 정렬 순서상 가장 앞서는 데이터의 index    // 최소값 탐색\t\tfor(j = i + 1; j &lt; n; j++) {\t\t\tif(arr[j] &lt; arr[maxIdx])\t\t\t\tmaxIdx = j;\t\t}\t\t/* 교환 */\t\ttemp = arr[i];\t\tarr[i] = arr[maxIdx];\t\tarr[maxIdx] = temp;\t}}삽입 정렬(Insertion Sort)   삽입 정렬 알고리즘 순서(오름차순)          배열의 두 번째 위치부터 시작한다.      현재 위치보다 앞선 위치를 차례대로 순회하며 현재 값보다 작은 값을 찾는다.      작은 값을 찾으면, 그 바로 다음 위치로 옮기고 현재 위치 바로 다음 위치에서 과정 1을 반복한다.         구현 코드(C언어)//오름차순//arr[]: 입력 배열, n: arr배열 크기void InserSort(int arr[], int n) {\tint i, j;\tint insData;  //두 번째 위치부터 시작\tfor(i = 1; i &lt; n; i++) {\t\tinsData = arr[i];          // 정렬 대상을 insData에 저장\t\tfor(j = i - 1; j &gt;= 0 ; j--) {\t\t\tif(arr[j] &gt; insData)\t\t\t\tarr[j + 1] = arr[j];   // 비교 대상 한 칸 뒤로 밀기\t\t\telse\t\t\t\tbreak;                 // 삽입 위치 찾았으니 탈출!\t\t}\t\tarr[j + 1] = insData;        // 찾은 위치에 정렬 대상 삽입!\t}}","categories": ["Algorithm"],
        "tags": ["Algorithm_DataStructure"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/DataStructure-N-2-%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/",
        "teaser":null},{
        "title": "[DataStructure]NlogN 정렬 알고리즘",
        "excerpt":"O(NlogN) 정렬 알고리즘 합병 정렬(Merge Sort)   합병 정렬은 분할 정복(Divide and conquer)방식으로 설계한 알고리즘이다.  합병 정렬 알고리즘 순서(오름차순)          분할 과정                  주어진 배열 범위를 반으로 분할한다.          반으로 분할된 배열의 크기가 0 또는 1일때 까지 반복한다.                    합병 과정                  두 배열 A, B를 합병한다고 가정하자.          두 배열 A, B를 합친 크기의 배열 C를 만든다.          배열 A부터 시작하는 인덱스와 배열 B부터 시작하는 인덱스를 설정하여 순서대로 서로 비교하여 작은 값부터 배열 C에 차례대로 삽입한다. (배열A, B는 반복된 위의 과정으로 오름차순으로 정렬되어 있다.)          배열 C가 원래 주어진 배열의 크기와 같을때까지 반복한다.                       구현 코드(C언어)void MergeTwoArea(int arr[], int left, int mid, int right) {\tint fIdx = left;\tint rIdx = mid+1;\tint i;  //두 배열을 합친 크기의 임의의 배열\tint * sortArr = (int*)malloc(sizeof(int)*(right+1));\tint sIdx = left;\twhile(fIdx &lt;= mid &amp;&amp; rIdx &lt;= right) {\t\tif(arr[fIdx] &lt;= arr[rIdx])\t\t\tsortArr[sIdx] = arr[fIdx++];\t\telse\t\t\tsortArr[sIdx] = arr[rIdx++];\t\tsIdx++;\t}\tif(fIdx &gt; mid) {\t\tfor(i = rIdx; i &lt;= right; i++, sIdx++)\t\t\tsortArr[sIdx] = arr[i];\t}\telse {\t\tfor(i = fIdx; i &lt;= mid; i++, sIdx++)\t\t\tsortArr[sIdx] = arr[i];\t}  //기존 배열의 원래 위치에 정렬된 배열을 삽입한다.\tfor(i = left; i &lt;= right; i++)\t\tarr[i] = sortArr[i];\tfree(sortArr);}//오름차순//arr[]: 입력 배열, left: arr배열의 가장 왼쪽 인덱스, right: arr배열의 가장 오른쪽 인덱스void MergeSort(int arr[], int left, int right) {\tint mid;\tif(left &lt; right) {\t\t// 중간 지점을 계산한다.\t\tmid = (left + right) / 2;\t\t// 둘로 나눠서 각각을 정렬한다.\t\tMergeSort(arr, left, mid);\t\tMergeSort(arr, mid + 1, right);\t\t// 정렬된 두 배열을 병합한다.\t\tMergeTwoArea(arr, left, mid, right);\t}}퀵 정렬(Quick Sort)   퀵 정렬은 분할 정복(Divide and conquer)방식으로 설계한 알고리즘이다.  퀵 정렬 알고리즘 순서(오름차순)          pivot을 설정한다.                  pivot을 설정하는 방법은 배열의 특정 위치나 배열 원소의 값 중 중간값, 랜덤값 n번째 값으로 설정한다.                    현재 주어진 배열에서 pivot 위치를 찾아서 그 위치로 교환한다.                  pivot보다 작은 값들은 모두 pivot 앞에 위치하고 큰 값은 모두 뒤에 위치해야한다.                    pivot을 기준으로 둘도 분할한 뒤 과정 1을 반복한다.      퀵 정렬 특징   퀵 정렬의 최악의 시간 복잡도는 O(N^2)이다.          pivot의 위치가 지속적으로 주어진 배열의 가장 왼쪽 또는 오른쪽에 위치하여 2개로 분할하지 못하는 경우이다.        하지만, 퀵 정렬은 평균적으로 정렬 알고리즘 중에서 가장 빠르다.          최초 pivot을 설정하는 방법 중에서 주어진 배열을 2개로 분할할 수 있는 효율적인 방법들이 존재한다.      퀵 정렬의 내부 루프는 대부분의 컴퓨터 아키텍처에서 효율적으로 동작하도록 설계되어 있다.                  메모리 참조가 지역화되어 있으므로 CPU의 cache 히트률이 높기 때문이다.                       구현 코드(C언어)void Swap(int arr[], int idx1, int idx2) {\tint temp = arr[idx1];\tarr[idx1] = arr[idx2];\tarr[idx2] = temp;}// pivot의 위치를 반환한다.int Partition(int arr[], int left, int right) {\tint pivot = arr[left];    // 피벗의 위치는 가장 왼쪽!\tint low = left+1;\tint high = right;  // 교차되지 않을 때까지 반복\twhile(low &lt;= high) {\t\twhile(pivot &gt;= arr[low] &amp;&amp; low &lt;= right)\t\t\tlow++;\t\twhile(pivot &lt;= arr[high] &amp;&amp; high &gt;= (left + 1))\t\t\thigh--;    // 교차되지 않은 상태라면 Swap 실행\t\tif(low &lt;= high)\t\t\tSwap(arr, low, high);\t}  //현재 high의 위치가 pivot이 있어야할 위치이다.\tSwap(arr, left, high);    \treturn high;}//오름차순//arr[]: 입력 배열, left: arr배열의 가장 왼쪽 인덱스, right: arr배열의 가장 오른쪽 인덱스void QuickSort(int arr[], int left, int right) {\tif(left &lt;= right) {\t\tint pivot = Partition(arr, left, right);    // pivot 설정 후 위치를 찾는다.\t\tQuickSort(arr, left, pivot-1);              // 왼쪽 영역을 정렬\t\tQuickSort(arr, pivot+1, right);             // 오른쪽 영역을 정렬\t}}","categories": ["Algorithm"],
        "tags": ["Algorithm_DataStructure"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/DataStructure-NlogN-%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/",
        "teaser":null},{
        "title": "[DataStructure]배열과 리스트",
        "excerpt":"선형 자료 구조 동적 배열(dynamic array)   동적 배열은 일반 배열을 이용해 만든 별도의 자료구조이다.          대부분 언어의 표준 라이브러리에 포함되어 있다.        일반 배열의 특징(동적 배열 포함)          원소들은 메모리의 연속된 위치에 저장된다.      주어진 위치의 원소를 반환하거나 변경하는 동작을 O(1)에 할 수 있다.        동적 배열만의 특징          배열의 크기를 변경하는 reaize() 연산이 가능하다.                  이 동작을 수행하는데 배열의 크기 N에 비례하는 시간이 소요된다.                    주어진 원소를 배열의 맨 끝에 추가함으로써 크기를 1 늘리는 append() 연산을 지원한다.                  이 동작을 수행하는데 상수 시간 1이 소요된다.                      append() 연산의 원리          append()연산이 상수 시간이 걸리는 이유                  메모리를 할당받을 때 배열의 크기가 커질때를 대비해서 여유분의 메모리를 미리 할당받아 둔다.                    capacity: 이미 할당받은 메모리의 크기(배열의 용량)      size:  실제 원소 개수(배열의 크기), 프로그램이 실제 인식하는 배열의 크기                   미리 할당해둔 메모리가 꽉 찼을 때, append()연산을 할 경우 재할당이 필요하다.                  일반적인 재할당 코드의 시간 복잡도는 O(N + M)으로 선형 시간이 소요된다.(M: 추가할 메모리 크기)          하지만, 재할당을 할때 정해진 개수(M)로 추가하는 것이 아니라 현재 가진 원소의 개수에 비례해서 여유분을 확보하면 평균적으로 O(1)의 시간 복잡도로 append()연산을 수행할 수 있다.                    append()를 여러 번 수행할 때, 배열의 최종 크기를 미리 알 수 있다면, 동적 배열의 용량(capacity)를 미리 늘려둠으로써 재할당에 드는 비용을 없애는것이 좋다.                  동적 배열을 사용했을 때 느려지는 대부분의 이유이다.                      동적 배열은 c++의 vector, C#과 Java에서 ArrayList로 표준 라이브러리에서 제공한다.연결 리스트(linked list)   연결 리스트는 배열과 달리 원소들이 메모리 여기저기 흩어져 있고, 각 원소들이 이전과 다음 원소를 가르키는 포인터(양방향 리스트) 방식으로 구현된다.  일반적인 노드(node) 구조체struct ListNode {  int element;            //담고 있는 원소  ListNode *prev, *next;  //이전 노드, 다음 노드의 포인터}  연결 리스트는 첫 번째 노드와 마지막 노드에 대한 포인트를 가지는데, 이들을 각각 머리(head)와 꼬리(tail)이라고 부른다.          머리와 꼬리를 포인터가 아니라 값이 정의되지 않는 텅 빈 노드(더미 노드)로 두면, 항상 이전 노드와 다음 노드가 존재한다고 가정할 수 있기 때문에 구현이 더욱 간단해진다.        연결 리스트의 특징          노드들이 메모리 여기저기에 흩어져 있기 때문에 특정 위치 값을 찾기 힘들다.                  리스트의 머리부터 꼬리까지 포인터를 따라 가며 탐색해야 하기 때문에 선형 시간이 소요된다.                    노드의 삽입, 삭제가 간단하다.                  삽입, 삭제될 해당 노드의 이전 노드와 다음 노드의 포인트만 바꿔주면 된다.                      연결 리스트 응용 연산들          잘라 붙이기 연산(splicing): 두 개의 서로 다른 리스트에서 각각의 일부 리스트를 서로 잘라서 붙이는 연산이다.                  시간 복잡도는 리스트의 길이인 선형 시간에 비례하며, 잘라 붙였을 때의 크기를 알 수 없어 불안정하다.                    삭제했던 원소 돌려놓기(undo)      두 연산은 대부분 표준 라이브러리에서 제공하지 않는다.        연결 리스트는 C++의 list, C#과 java의 LinkedList로 표준 라이브러리에서 제공한다.동적 배열과 연결 리스트 비교   동적 배열          임의의 원소에 빠르게 접근 가능하다.      원소들이 메모리에 연속해 배치되어 있어 CPU 캐시의 효율을 높여준다.      삽입과 삭제가 거의 없고, 끝에 추가만 하면 될 경우에 활용하기 좋다.        연결 리스트          삽입과 삭제가 빠르다.      삽입과 삭제가 많이 수행하는 작업에 활용하기 좋다.                                작업          동적 배열          연결 리스트                                      이전 원소/다음 원소 찾기          O(1)          O(1)                          맨 뒤에 원소 추가/삭제하기          O(1)          O(1)                          맨 뒤 이외의 위치에 원소 추가/삭제하기          O(N)          O(1)                          임의의 위치의 원소 찾기          O(1)          O(N)                          크기 구하기          O(1)          O(N), 구현에 따라 O(1)가능                    ","categories": ["Algorithm"],
        "tags": ["Algorithm_DataStructure"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/DataStructure-%EB%B0%B0%EC%97%B4%EA%B3%BC%EB%A6%AC%EC%8A%A4%ED%8A%B8/",
        "teaser":null},{
        "title": "[DataStructure]정렬 알고리즘 비교",
        "excerpt":"정렬 알고리즘 비교 정렬 알고리즘 비교 표             Sort      Best      Worst      Stable      Memory                  버블 정렬      N      N^2      TRUE      1              선택 정렬      N^2      N^2      FALSE      1              삽입 정렬      N      N^2      TRUE      1              셸 정렬      NlogN      Nlog^2N      FALSE      1              합병 정렬      NlogN      NlogN      TRUE      N              퀵 정렬      NlogN      N^2      FALSE      logN ~ N      추천 링크   정렬 시뮬레이션: https://www.toptal.com/developers/sorting-algorithms","categories": ["Algorithm"],
        "tags": ["Algorithm_DataStructure"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/DataStructure-%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B9%84%EA%B5%90/",
        "teaser":null},{
        "title": "[Database]SQL 개념 정리",
        "excerpt":"SQL(Structed Query Language) SQL에서 지원하는 기본 데이터 타입   정수(Integer): INT(4Byte), SMALLINT(2Byte)  실수(Float): FLOAT, REAL, DOUBLE PRECISION  형식화된 숫자: DEC(i, j) (i = 전체 자릿수, j = 소수부 자릿수)  고정길이 문자: CHAR(n) (n = 문자수)  가변길이 문자: VARCHAR(n) (n = 최대 문자 수)  고정길이 비트 열(Bit String): BIT(n)  가변길이 비트 열: VARBIT(n)  날짜: DATE  시간: TIMEDDL(Data Define Language)   DDL로 정의된 내용은 메타데이터가 되며, 시스템카탈로그에 저장한다.  CREATE, ALTER, DROP 명령문이 존재한다.    CREATE     스키마, 도메인 테이블, 뷰 인덱스를 정의한다.    CREATE SCHEMA     스키마를 정의하는 명령문  스키마는 하나의 응용(사용자)에 속하는 테이블과 기타 구성 요소등을 그룹짓기 위함이다.CREATE SCHEMA 스키마명 AUTHORIZATION 사용자ID;예제   ID가 홍길동인 사용자의 스키마 ‘대학교’를 정의하는 SQL문CREATE SCHEMA 대학교 AUTHORIZATION 홍길동;CREATE DOMAIN   도메인을 정의하는 명령문  도메인은 하나의 속성이 취할 수 있는 동일한 타입의 원자값들의 집합이다.CREATE DOMAIN 도메인명 데이터타입  [DEFAULT 기본값]  [CONSTRAINT 제약조건명 CHECK (범위값)];  데이터타입: SQL에서 지원하는 데이터 타입  기본값: 데이터를 입력하지 않았을 때 자동으로 입력되는 값예제   성별을 ‘남’ 또는 ‘여’와 같은 정해진 1개의 문자로 표현되는 도메인 SEX를 정의하는 SQL문CREATE DOMAIN SEX CHAR(1)  DEFAULT '남'  CONSTRAINT VALID-SEX CHECK (VALUE IN('남', '여'));CREATE TABLE   테이블을 정의하는 명령문CREATE TABLE 테이블명  (속성명 데이터타입[NOT NULL], ...  [, PRIMARY KEY (기본키 속성명, ...)]  [, UNIQUE (대채키 속성명, ...)]  [, FOREIGN KEY (외래키 속성명, ...)    REFERENCES 참조테이블(기본키 속성명, ...)]    [ON DELETE 옵션]    [ON UPDATE 옵션]  [, CONSTRAINT 제약조건명][CHECK (조건식)]);  옵션 종류          NO ACTION: 참조 테이블에 변화가 있어도 기본 테이블에는 아무런 조취를 취하지 않는다.      CASCADE: 참조 테이블의 튜플이 삭제되거나 속성이 변경되면 그에 해당하는 기본 테이블의 모든 튜플이 그에 맞게 갱신된다.      SET NULL: 참조 테이블에 변화가 생기면 기본 테이블의 관련 튜플의 속성 값을 NULL로 변경한다.      SET DEFAULT: 참조 테이블에 변화가 있으면 기본 테이블의 관련 튜플의 속성 값을 기본값으로 변경한다.        CONSTRAINT: 제약  조건의 이름을 지정하며, 반드시 지정할 필요는 없다.예제   이름, 학번, 전공, 성별, 생년월일로 구성된  테이블을 정의하는 SQL문          이름은 NULL이 올 수 없고, 학번은 기본키이다.      전공은  테이블의 학과코드를 참조하는 외래키로 사용된다.               테이블에서 삭제가 일어나면 관련된 튜플들의 전공 값을 NULL로 만든다.                     테이블에서 학과코드가 변경되면 전공 값도 같은 값으로 변경된다.            생년월일은 1980-01-01 이후의 데이터만 저장할 수 있다.      제약 조건의 이름은 ‘생년월일제약’으로 한다.      각 속성의 데이터형은 적당하게 지정한다. 단 성별은 도메인 ‘SEX’를 사용한다.      CREATE TABLE 학생  (이름 VARCHAR(15) NOT NULL,  학번 CHAR(8),  전공 CHAR(5),  성별 SEX,  생년월일 DATE,  PRIMARY KEY(학번),  FOREIGN KEY(전공) REFERENCES 학과(학과코드)    ON DELETE SET NULL    ON UPDATE CASCADE,  CONSTRAINT 생년월일제약 CHECK(생년월일 &gt;= '1980-01-01'));CREATE VIEW   뷰를 정의하는 명령문  뷰(View)는 하나 이상의 기본 테이블로부터 유도되는 이름을 갖는 가상 테이블이다.CREATE VIEW 뷰명[(속성명[, 속성명, ...])]AS SELECT문;  SELECT문을 서브 쿼리로 사용하여 SELECT문의 결과로서 뷰를 생성한다.예제        테이블에서 주소가 '안산시'인 고객들의 성명과 전화번호를 '안산고객'이라는 뷰로 정의한다.  CREATE VIEW 안산고객(성명, 전화번호)AS SELECT 성명, 전화번호FROM 고객WHERE 주소='안산시';CREATE INDEX   인덱스를 정의하는 명령문  인덱스는 검색을 빠르게 하기 위해 만든 보조적인 데이터 구조이다.CREATE [UNIQUE] INDEX &lt;인덱스명&gt;  ON 테이블명({속성명 [ASC | DESC] [,속성명 [ASC | DESC]]})  [CLUSTER];  UNIQUE          사용된 경우: 중복 값이 없는 속성으로 인덱스를 생성한다.      생략된 경우: 중복 값을 허용하는 속성으로 인덱스를 생성한다.        정렬 여부 지정          ASC: 오름차순 정렬      DESC: 내림차순 정렬      생략된 경우: 오름차순으로 정렬된다.        CLUSTER: 지정된 키에 따라 튜플들으르 그룹으로 지정하기 위해 사용된다.예시        테이블에서 UNIQUE한 특성을 갖는 고객번호 속성에 대해 내림차순으로 정렬하여 '고객번호_idx'라는 이름으로 인덱스를 정의한다.  CREATE UNIQUE INDEX 고객번호_idx  ON 고객(고객번호 DESC);ALTER ALTER TABLE   테이블에 대한 정의를 변경하는 명령문ALTER TABLE 테이블명 ADD 속성명 데이터타입 [DEFAULT '기본값'];ALTER TABLE 테이블명 ALTER 속성명 [SET DEFAULT '기본값'];ALTER TABLE 테이블명 DROP COLUMN 속성명 [CASCADE];  ADD: 새로운 속성을 추가한다.  ALTER:  속성의 기본값을 변경한다.  DROP COLUMN: 속성을 제거한다.예시        테이블에 최대 3문자로 구성되는 학년 속성을 추가하는 SQL문  ALTER TABLE 학생 ADD 학년 VARCHAR(3);DROP   스키마, 도메인, 테이블, 뷰, 인덱스, 트리거를 제거하는 명령문DROP SCHEMA 스키마명 [CASCADE | RESTRICT];DROP DOMAIN 도메인명 [CASCADE | RESTRICT];DROP TABLE 테이블명 [CASCADE | RESTRICT];DROP VIEW 뷰명 [CASCADE | RESTRICT];DROP INDEX 인덱스명 [CASCADE | RESTRICT];DROP TRIGGER 트리거명 [CASCADE | RESTRICT];DROP CONSTRAINT 제약조건명;  CASCADE: 제거할 개체를 참조하는 다른 모든 개체를 함께 제거한다. 즉, 주 테이블의 데이터 제거 시, 각각의 외래키와 관계를 맺고 있는 모든 데이터를 함께 제거한다.(참조 무결성 제약 조건을 위함)  RESTRICT: 다른 개체가 제거할 개체를 참조중일 경우 제거가 취소된다.SELECT   테이블을 구성하는 튜플들 중에서 전체 또는 조건을 만족하는 튜플을 검색하여 주기억장치에 임시 테이블로 구성하는 명령문이다.SELECT [PREDICATE] [테이블명.]속성명[ AS 별칭][, [테이블명.]속성명, ...]FROM 테이블명[, 테이블명, ...][WHERE 조건][GROUP BY 속성명[, 속성명, ...]][HAVING 조건][ORDER BY 속성명 [ASC | DESC][, 속성명 [ASC | DESC], ...]];  PREDICATE: 검색할 튜플을 제한할 목적으로 사용되는 조건이다.          ALL: 모든 튜플들을 검삭할 때 사용되며, 기본값이다.      DISTINCT: 중복된 튜플들을 제거할 때 사용된다.      DISTINCTROW: 중복된 튜플을 제거하지만, 선택된 속성의 값이 아닌 튜플의 전체 값을 대상으로 사용된다.        AS: 속성 및 연산의 이름을 다른 제목으로 표시하기 위해 사용된다.  FROM절: 검색할 데이터가 들어 있는 테이블명을 기술한다.  WHERE절: 검색할 조건을 기술한다.  GROUP BY절: 특정 속성을 기준으로 그룹화하여 검색할 때 사용된다. 일반적으로 그룹 함수와 함께 사용한다.  HAVING절: 그룹에 대한 조건을 기술한다.  ORDER BY절: 특정 속성을 기분으로 정렬하여 검색할 때 사용된다.    하위 질의          테이블에서 취미가 '나이트댄스'인 사원에 대해  테이블에서 해당 사원의 이름과 주소를 검색하는 SQL문  SELECT 이름, 주소FROM 사원WHERE 이름 IN(SELECT 이름 FROM 여가활동 WHERE 취미='나이트댄스');복수 테이블 검색   경력이 10년 이상인 사원의 이름, 부서, 취미, 경력을 검색하는 SQL문SELECT 사원.이름, 사원.부서, 여가활동.취미, 여가활동.경력FROM 사원, 여가활동WHERE 여가활동.경력 &gt;= 10 AND 사원.이름 = 여가활동.이름;통합(UNION) 질의   UNION은 일반 집합 이론에서의 합집합과 같다.  두 테이블을 합치면 두 테이블에 모두 속해 있는 튜플은 중복이 제거되어 1개만 표시된다.  사원들의 명단이  테이블과  테이블에 저장되어 있다. 두 테이블을 통합하는 SQL문(중복 제거)SELECT *FROM 임원UNION SELECT * 직원;JOIN   조인은 2개의 테이블에 대해 연관된 튜플들을 결합하여, 하나의 새로운 릴레이션을 반환한다.  조인은 크게 INNER JOIN과 OUTER JOIN으로 구분된다.    INNER JOIN     INNER JOIN은 일반적으로 EQUI JOIN과 NON-EQUI JOIN으로 구분된다.    EQUI JOIN     EQUI JOIN은 JOIN 대상 테이블에서 공통 속성을 기준으로 ‘=’(equal)비교에 의해 같은 값을 가지는 행을 연결하여 결과를 생성하는 방법이다.  중복된 속성을 제거하여 같은 속성을 한 번만 표기하는 방법을 NATURAL JOIN이라 한다.  WHERE절을 이용한 EQUI JOINSELECT [테이블명1.]속성명, [테이블명2.]속성명, ...FROM 테이블명1, 테이블명2, ...WHERE 테이블명1.속성명 = 테이블명2.속성명;  NATURAL JOIN을 이용한 EQUI JOINSELECT [테이블명1.]속성명, [테이블명2.]속성명, ...FROM 테이블명1 NATURAL JOIN 테이블명2;  JOIN ~ USING절을 이용한 EQUI JOINSELECT [테이블명1.]속성명, [테이블명2.]속성명, ...FROM 테이블명1 JOIN 테이블명2 USING(속성명);예제        테이블과  테이블에서 학과코드 값이 같은 튜플을 JOIN하여 학번, 이름, 학과코드, 학과명을 출력하는 SQL문  SELECT 학번, 이름, 학생.학과코드, 학과명FROM 학생, 학과WHERE 학생.학과코드 = 학과.학과코드;SELECT 학번, 이름, 학생.학과코드, 학과명FROM 학생 NATURAL JOIN 학과;SELECT 학번, 이름, 학생.학과코드, 학과명FROM 학생 JOIN 학과 USING(학과코드);NON-EQUI JOIN   NON-EQUI JOIN은 JOIN조건에 ‘=’ 조건이 아닌 나머지 비교 연산자인 ‘&gt;’, ‘&lt;’, ‘&lt;=’, ‘&gt;=’ 연산자를 사용하는 방법이다.예제        테이블과  테이블을 JOIN하여 각 학생의 학번, 이름, 성적, 등급을 출력하는 SQL문  SELECT 학번, 이름, 성적, 등급FROM 학생, 성적등급WHERE 학생.성적 BETWEEN 성적등급.최저 AND 성적등급.최고;OUTER JOIN   OUTER JOIN은 릴레이션에서 JOIN조건에 만족하지 않는 튜플도 결과로 출력하기 위한 JOIN 방법이다.    LEFT OUTER JOIN     INNER JOIN의 결과를 구한 후, 우측 항 릴레이션과 맞지 않는 좌측 항 릴레이션의 튜플에 NULL값을 대입한다.  좌측 릴레이션은 모두 출력된다.SELECT [테이블명1.]속성명, [테이블명2.]속성명, ...FROM 테이블명1 LEFT OUTER JOIN 테이블명2ON 테이블명1.속성명 = 테이블명2.속성명;SELECT [테이블명1.]속성명, [테이블명2.]속성명, ...FROM 테이블명1, 테이블명2WHERE 테이블명1.속성명 = 테이블명2.속성명(+);RIGHT OUTER JOIN   INNER JOIN의 결과를 구한 후, 좌측 항 릴레이션과 맞지 않는 우측 항 릴레이션의 튜플에 NULL값을 대입한다.  우측 릴레이션은 모두 출력된다.SELECT [테이블명1.]속성명, [테이블명2.]속성명, ...FROM 테이블명1 RIGHT OUTER JOIN 테이블명2ON 테이블명1.속성명 = 테이블명2.속성명;SELECT [테이블명1.]속성명, [테이블명2.]속성명, ...FROM 테이블명1, 테이블명2WHERE 테이블명1.속성명(+) = 테이블명2.속성명;FULL OUTER JOIN   LEFT OUTER JOIN과 RIGHT OUTER JOIN을 합쳐 놓은 것이다.  양쪽 릴레이션이 모두 출력된다.SELECT [테이블명1.]속성명, [테이블명2.]속성명, ...FROM 테이블명1 FULL OUTER JOIN 테이블명2ON 테이블명1.속성명 = 테이블명2.속성명;SELF JOIN   SELF JOIN은 같은 테이블에서 2개의 속성을 연결하여 EQUI JOIN을 하는 방법이다.SELECT [별칭1.]속성명, [별칭2.]속성명, ...FROM 테이블명1 [AS] 별칭1 JOIN 테이블명1 [AS] 별칭2ON 별칭1.속성명 = 별칭2.속성명;SELECT [별칭1.]속성명, [별칭2.]속성명, ...FROM 테이블명1 [AS] 별칭1, 테이블명1 [AS] 별칭2WHERE 별칭1.속성명 = 별칭2.속성명;DML(Date Manipulation Language)   DML은 데이터베이스 사용자가 응용 프로그램이나 질의어를 통해 저장된 데이터를 실질적으로 관리하는데 사용되는 언어이다.  DML은 데이터베이스 사용자와 데이터베이스 관리 시스템 간의 인터페이스를 제공한다.  INSERT, DELETE, UPDATE 명령문이 있다.    INSERT문     테이블에 새로운 튜플을 삽입할 때 사용하는 명령문이다.INSERT INTO 테이블명[(속성명1, 속성명2, ...)]VALUES (데이터1, 데이터2, ...);예시        테이블에 이름이 \"이순신\"이고, 부서가 \"기획\"인 사원을 삽입하는 SQL문  INSERT INTO 사원(이름, 부서) VALUES ('이순신', '기획');       테이블에 있는 편집 부서의 모든 튜플을 &lt;편집부원(이름, 생일, 주소, 기본급)&gt; 테이블에 삽입하는 SQL문  INSERT INTO 편집부원(이름, 생일, 주소, 기본급)SELECT 이름, 생일, 주소, 기본급 FROM 사원 WHERE 부서='편집';DELETE문   테이블에 있는 튜플들 중에서 특정 튜플을 삭제할 때 사용하는 명령문이다.DELETE FROM 테이블명 WHERE 조건;예시        테이블에서 이름이 \"임꺽정\"인 튜플을 삭제하는 SQL문  DELETE FROM 사원 WHERE 이름='임꺽정';       테이블의 모든 튜플을 삭제하는 SQL문  DELETE FROM 사원;UPDATE문   테이블에 있는 튜플들 중에서 특정 튜플의 내용을 갱신할 때 사용하는 명령문이다.UPDATE 테이블명SET 속성명=데이터[, 속성명=데이터, ...]WHERE 조건;예시        테이블에서 홍길동의 주소를 \"퇴계동\"으로 갱신하는 SQL문  UPDATE 사원 SET 주소='퇴계동' WHERE 이름='홍길동';       테이블에서 황진이의 부서를 \"기획\"으로 변경하고 기본급을 5 인상하는 SQL문  UPDATE 사원 SET 부서='기획', 기본급=기본급+5 WHERE 이름='황진이';DCL(Data Control Language)   DCL은 데이터의 보안, 무결성, 회복, 병행 제어 등을 정의하는데 사용하는 언어이다.  DCL은 데이터베이스 관리자(DBA)가 데이터 관리를 목적으로 사용한다.  COMMIT, ROLLBACK, GRANT, REVOKE 명령문이 있다.    COMMIT     트랜잭션의 모든 변경 내용들을 영구적으로 데이터베이스에 반영하는 명령어이다.    ROLLBACK     변경된 모든 내용들을 취소하고 데이터베이스를 이전 상태로 되돌리는 명령어이다.  트랜잭션의 일부를 성공적으로 끝내지 못하면 데이터베이스가 비일관성인 상태를 가질 수 있으므로 모든 내용들을 취소해야한다.    GRANT     데이터베이스 관리자가 데이터베이스 사용자에게 권한을 부여하기 위한 명령어이다.  사용자등급 지정GRANT 사용자등급 TO 사용자ID리스트[IDENTIFIED BY 암호];  사용자 등급: DBA(데이터베이스 관리자), RESOURCE(데이터베이스 및 테이블 생성 가능자), CONNECT(단순 사용자)  테이블 및 속성에 대한 권한 부여GRANT 권한리스트 ON 개체 TO 사용자 [WITH GRANT OPTION];REVOKE   권한 취소를 위한 명령어이다.  사용자등급 해제REVOKE 사용자등급 FROM 사용자ID리스트;  테이블 및 속성에 대한 권한 취소REVOKE [GRANT OPTION FOR] 권한리스트 ON 개채 FROM 사용자 [CASCADE];","categories": ["Study"],
        "tags": ["Study_Database"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/Database-SQL-%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC/",
        "teaser":null},{
        "title": "[Database]개념 정리",
        "excerpt":"데이터베이스(Database) 데이터베이스 개념 정의   특정 조직의 업무를 수행하는데 있어서 필요한 상호 관련된 데이터들의 모임  통합 데이터(Integrated Data): 검색의 효율성을 위해 중복을 최소화한 데이터  저장 데이터(Stored Data): 컴퓨터가 접근 가능한 저장 매체에 저장된 데이터  운영 데이터(Operational Data): 조직의 목표를 위해 존재 가치가 확실하고 반드시 필요한 데이터  공유 데이터(Shared Data): 여러 프로그램들이 공동으로 사용하는 데이터특징   실시간 접근성(Real Time Accessibility): 사용자의 질의(query)에 대해 즉시 처리하여 응답한다.  계속적인 진화(Continuous Evolution): 항상 최근의 정확한 데이터를 동적으로 유지한다.  동시 공유(Concurrent Sharing): 여러 사용자가 동시에 원하는 데이터를 사용가능하다.  내용에 의한 참조(Content Reference): 데이터를 참조할 때 내용으로 참조한다.(물리적 주소값이 아님)  독립성(Independence)          논리적 독립성(응용프로그램과 데이터베이스와의 관계): 데이터의 논리적 구조를 변경하더라도 응용프로그램에는 영향을 주지 않는다.      물리적 독립성(응용프로그램과 보조기억장치와의 관계): 새로운 저장장치의 추가에도 응용프로그램에는 영향을 주지 않는다.        무결성(Integrity): 데이터베이스에 저장된 데이터 값과 실제 값이 일치하는 정확성          무결성 제약 조건: 정확하지 않은 데이터가 데이터베이스내에 저장되는 것을 방지하기 위한 제약 조건                  널 무결성(NULL Integrity): 특정 속성(attribute)값이 NULL일 수 없다.          고유 무결성(Unique Integrity): 특정 속성에 대해 각 튜플들은 서로 다른 값이어야 한다.          키 무결성(Key Integrity): 하나의 릴레이션에는 적어도 하나의 key가 있어야 한다.          도메인 무결성(Domain Integrity): 특정 속성값이 해당 속성이 정의된 도메인에 속한 값이어야 한다.          관계 무결성(Relationship Integrity): 릴레이션에서 튜플의 삽입 가능 여부와 서로 다른 릴레이션의 튜플들 사이의 관계가 적절해야 한다.          참조 무결성(Referential Integrity): Foreign key는 NULL값이거나 참조 릴레이션의 primary key와 동일해야한다.          개체 무결성(Entity Integrity): Primary key를 구성하는 속성은 NULL일 수 없다.                      보안성  일관성  데이터 중복 최소Data Language   데이터베이스의 구축과 사용을 위해 DBMS와의 통신 수단이다.  종류          DDL(Data Definition Language): 데이터베이스의 구조, 형식, 접근방식 등을 구축하거나 변경한다.      DML(Data Manipulation Language): 데이터 처리를 위한 연산의 집합(검색, 삽입, 삭제, 갱신)이다.      DCL(Data Control Language): 보안 및 권한제어, 무결성, 회복, 벙행제어를 수행한다.      데이터베이스 사용자   DBA(DataBase Administrator, 데이터베이스 관리자): 데이터베이스를 정의하고 제어하는 사람 또는 그룹  DA(Data Administrator, 데이터 관리자): 조직내에서 데이터에 대한 정의, 체계화, 감독 및 보안 업무를 수행한다.  DA(Data Architect, 데이터 설계자): 데이터의 구조를 체계적으로 정의한다.시스템 카탈로그(System Catalog)   DBA의 도구로써, 데이터베이스에 저장되어 있는 모든 데이터 개체들에 대한 정의와 명세와 같은 정보들이 저장되어 있는 테이블이다.  데이터 사전(Data Dictionary) 라고도 불린다.  시스템 카탈로그에 저장된 내용을 메타 데이터(Meta Data)라고 한다.  시스템 카탈로그는 DBMS에 의해 생성되고 유지되며, 사용자가 SQL문으로 수정할 수 없다.(DBMS와 사용자가 접근 가능하다.)DBMS(Database Management System)   다수의 사용자들이 데이터베이스 내의 데이터를 접근할 수 있도록 해주는 소프트웨어 도구의 집합이다.  주어진 설정에 따라 데이터베이스 스키마를 생성하고, 생성된 스키마를 참조하여 명령을 수행한다.  DDL 컴파일러와 트랜잭션 관리자로 구성되어 있다.기능   사용자 또는 다른 프로그램의 요구를 처리하고 적절히 응답하여 데이터를 사용할 수 있도록 도와준다.  정의: 데이터에 대한 형식, 구조, 제약조건들을 명세하는 기능(데이터베이스에 대한 정의 및 설명은 카탈로그나 사전의 형태로 저장된다.)  구축: DBMS가 관리하는 기억 장치에 데이터를 저장하는 기능  조작: 특정한 데이터를 검색하기 위한 질의, 데이터베이스의 갱신, 보고서 생성 기능 등  공유: 여러 사용자와 프로그램이 데이터베이스에 동시에 접근하도록 하는 기능  보호: 하드웨어나 소프트웨어의 오동작 또는 권한이 없는 악의적인 접근으로부터 시스템을 보호  유지보수: 시간이 지남에 따라 변화하는 요구사항을 반영할 수 있도록 하는 기능장점   데이터의 통합성 향상  데이터의 접근성 용이  데이터 통제 강화  애플리케이션 프로그램들을 쉽게 개발 및 관리가 가능  보안 강화스키마(Schema)   데이터베이스에서 데이터의 구조, 표현 방법, 관계를 형식 언어로 정의한 구조이다.  외부 스키마(External Schema): 프로그래머나 사용자의 입장에서 데이터베이스 모습을 정의한다.  개념 스키마(Conceptual Schema): 모든 응용 시스템과 사용자들의 관점에서 데이터베이스 구조를 논리적으로 정의한다.  내부 스키마(Internal Schema): 전체 데이터베이스의 물리적 저장 형태를 기술한다.데이터베이스 설계 1. 요구 조건 분석 2. 개념적 설계   개념 스키마 모델링: ER Model과 같은 추상화 기법을 통해 개념 스키마를 만든다.  트랜잭션 모델링3. 논리적 설계   논리 스키마를 설계한다.  관계형 DBMS의 경우 ER Model을 relation schema로 변환한다.(정규화 수행)  트랜잭션의 전체적인 구조를 설계하고 인터페이스를 정의한다.4. 물리적 설계   물리 스키마를 설계한다.  데이터베이스 파일에 대한 저장 구조와 접근 경로를 설정한다.5. 데이터베이스 구현   DBMS의 DDL을 사용하여 데이터베이스를 구축한다.Model Relationship Data Model   대표적인 논리적 데이터 모델로서, 테이블(Table) 또는 릴레이션(Relation)의 구조로 표현한다.  테이블 그림 삽입  Relation: 데이터를 표현하는 2차원 테이블          Relation Schema: Relation의 이름, 각 attribute에 대한 정의      Relation Instance: Relation에 들어있는 tuple들의 집합        Attribute(속성): Relation의 columns  Tuple(튜플): Relation의 rows  Domain: 하나의 attribute가 가질 수 있는 같은 타입의 값들의 집합  Degree: Relation의 attribute의 개수  Cardinality: Relation의 tuple의 개수ER Model(Entity - Relationship Model)   대표적인 개념적 데이터 모델로서, Entity, Relationship, Attribute 를 도형화하여 표현한 것이다.  위를 ERD(ER Diagram)이라고 부른다.  그림 삽입key             Key      특징      유일성      최소성                  Super Key(슈퍼키)      한 릴레이션 내에 있는 속성들의 집합      O      X              Candidate Key(후보키)      한 릴레이션에서 튜플을 유일하게 식별할 수 있는 속성      O      O              Primary Key(기본키)      후보키 중 특별히 선정된 키(중복된 값과 NULL을 가질 수 없음)      O      O              Alternate Key(대체키)      후보키중 기본키를 제외한 나머지 속성들      O      O              Foreign Key(외래키)      다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합(중복된 값과 NULL을 가질 수 없음)      O      O      관계대수와 관계해석   관계대수로 표현한 식은 관계해석으로도 표현 가능하다.  관계해석과 관계대수는 관계형 데이터베이스를 처리하는 기능과 능력면에서는 동등하다.    관계대수(Relation Algebra)     관계형 데이터베이스에서 원하는 정보를 검색하기 위해서 어떻게 유도할지를 기술한 절차적 언어로 연산자와 연산규칙을 제공한다.  질의에 대한 해를 구하기 위해 수행해야할 연산의 순서를 명시한다.(절차적 성격)  순수 관계 연산자          표 그림 삽입        일반 집합 연산자          표 그림 삽입        관계해석(Relation Calculus)               E.F.Codd박사가 제안한 것으로 수학의 술어해석에 기반을 둔다.  원하는 정보가 무엇이라는 것만 정의하는 비절차적 특징을 갖는다.  SQL문과 같은 질의어를 사용하며 튜플 관계해석과 도메인 해석으로 구성된다.정규화(Normalization)   테이블 속성들 사이의 종속적인 관계를 이용하여 테이블을 손실없이 분해하는 과정이다.  이러한 분해를 통해, 중복을 최대한 제거하고 이상(anomaly)의 발생 가능성을 줄인다.    이상(Anomaly)     테이블 일부 속성들이 종속으로인해 중복이 발생하여 테이블 조작에 문제가 발생하는 현상이다.  종류          삽입 이상(Insert Anomaly): 원하지 않는 데이터가 삽입되거나 삽입하는데 데이터가 부족하여 삽입이 되지 않는 문제점을 말한다.      삭제 이상(Delete Anomaly): 하나의 데이터만을 삭제하는 동작에서 해당 데이터가 포함된 튜플 전체가 삭제됨과 같은 원하지 않는 정보 손실이 발생하는 문제점을 말한다.      갱신 이상(Update Anomaly): 튜플에 있는 속성값을 갱신하는 동작에서 일부 튜플 정보만 갱신되어 정보에 불일치성이 생기는 문제점을 말한다.        원인: 여러가지 종류의 값들을 하나의 릴레이션에 표현하기 때문이다.  해결 방안: 속성들간의 종속성을 분석하여 하나의 종속성은 하나의 릴레이션에 표현되도록 분해한다.(정규화)    함수적 종속(Functional Dependency)     임의의 테이블 R에서 X와 Y를 각각 R의 속성 집합의 부분 집합이라고 할때, X의 값이 Y의 값을 유일하게(unique) 결정한다면 “X는 Y를 함수적으로 결정한다”라고 한다.  이를 X -&gt; Y로 표기하며, X를 결정자(Determinant), Y를 종속자(Dependent)라고 부른다.  완전 함수적 종속(Full Functional Dependency): X -&gt; Y일때, X의 임의의 애트리뷰트를 제거하면 더 이상 함수적 종속성이 성립하지 않는 경우를 말한다.  부분 함수적 종속(Partial Functional Dependency): X -&gt; Y일때, X의 임의이 애트리뷰트를 제거하더라도 함수적 종속성을 성립하는 경우를 말한다.  이행 함수적 종속(Transitive Functional Dependency): X -&gt; Y, Y -&gt; Z의 경우에서 추론될 수 있는 X -&gt; Z가 성립하는 경우를 말한다.  다치종속(Multi-Valued Dependency, MVD): X, Y -&gt; Z와 X -&gt; Z가 성립하는 경우이다.  조인 종속: 테이블 R과 R의 프로젝션들을 모두 조인한 결과가 동일한 경우를 말한다.    정규화 과정     제 1 정규형(1NF)     애트리뷰트의 도메인이 오직 원자값 만을 포함하고, 튜플의 모든 애트리뷰트가 도메인에 속하는 하나의 값을 가져야 한다.  복합 애트리뷰트, 다중값 애트리뷰트, 중첩 릴레이션 등 비원자적인 애트리뷰트를 혀용하지 않는 릴레이션 형태이다.    제 2 정규형(2NF)     모든 비주요 애트리뷰트들이 주요 애트리뷰트에 대해서 완전 함수적 종속 이면 제 2 정규형을 만족한다.  기본키가 아닌 모든 애트리뷰트들이 기본키에 완전 함수적 종속이 되는 릴레이션 형태이다.    제 3 정규형(3NF)     모든 비주요 애트리뷰트들이 기본키에 대해서 이행 함수적 종속이 성립하지 않으면 제 3 정규형을 만족한다.  비주요 애트리뷰트가 비주요 애트리뷰트에 의해 종속되는 경우가 없는 릴레이션 형태를 말한다.    BCNF(Boyce-Codd) 정규형     여러 후보키가 존재하는 릴레이션에 해당하는 정규화이다.  모든 종속의 결정자가 후보키가 되면 BCNF 정규형을 만족한다.    제 4 정규형(4NF)     다치종속관계 가 성립되는 경우를 모두 제거한 형태를 말한다.    제 5 정규형(5NF)     조인종속 이 후보키를 통해서만 성립되는 형태를 말한다.인덱스(Index)   DBMS가 데이터베이스 테이블의 데이터를 빠르게 검색하기 위해서 &lt;데이터, 데이터가 저장된 주소&gt; 쌍으로 구성되는 데이터 구조이다.  DBMS의 인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 탐색하는것은 빠르지만 새로운 값을 추가, 삭제, 수정하는 경우에는 느리다.  즉, 인덱스는 데이터의 저장 성능을 희생하는 대신 데이터의 읽기 속도를 높이는 역할을 한다.    인덱스 종류     기본 인덱스          기본키를 위한 인덱스      관계형 DBMS에서는 모든 기본키에 자동적으로 기본 인덱스를 생성한다.        보조 인덱스: 기본 인덱스가 아닌 나머지 인덱스  클러스터드(Clustered) 인덱스          인덱스 테이블의 키 값 순서와 튜플의 물리적 순서를 동일하게 유지하는 인덱스(물리적으로 인접한 장소에 저장되어 있는 데이터들)      클러스터드 인덱스는 기본키에 대해서만 적용되며, 기본키가 비슷한 레코드끼리 묶어서 저장한 것이다.      기본키값에 따라 레코드의 저장 위치가 결졍되므로 기본키값이 변경되면 해당 레코드의 물리적인 저장 위치 역시 변경되어야 한다.      클러스터드 인덱스는 테이블당 기본키와 같이 한 개만 생성할 수 있다.(Non-clustered 인덱스는 한 테이블당 여러개를 생성할 수 있다.)        인덱스 자료구조         B+-Tree 인덱스 알고리즘               일반적으로 사용되는 인덱스 알고리즘은 B+-Tree 알고리즘이다.  B+-Tree 인덱스는 칼럼의 값을 변형하지 않고(사실, 값의 일부분만 잘라서 관리함), 원래의 값을 이용해 인덱싱하는 알고리즘이다.    Hash 인덱스 알고리즘     칼럼 값을 해시 값으로 계산해서 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원한다.  값을 변형해서 인덱싱하므로, 특정 문자로 시작하는 검색인 전방 일치 검색과 같이 값의 일부만으로 검색하고자 할 때는 사용할 수 없다.  주로 메모리 기반의 데이터베이스에 사용된다.    왜 index를 생성하는데 주로 B-Tree를 사용하는가?     데이터에 접근하는 시간복잡도가 O(1)인 hash table이 더 효율적일 것 같지만, SELECT질의의 조건에는 부등호(&lt; &gt;)연산도 포함이 되는데 이는 hash table에서 사용할 수 없다.  동등 연산(=)에 특화된 hash table은 데이터베이서의 자료구조에 적합하지 않다.    인덱스 성능     인덱스를 사용하면 SELECT 쿼리의 성능을 크게 상향시킬 수 있다.  그에 반해 INSERT, DELETE, UPDATE 쿼리를 실행할 때 별도의 과정이 추가적으로 발생하기 때문에 오히려 전체적인 성능은 떨어진다.          INSERT는 인덱스에 대한 데이터도 따로 추가해한다.      DELETE는 인덱스에 존재하는 값은 삭제하지 않고 사용을 안한다는 표시로만 남는다.(즉, row의 수는 그대로이다.)        결과적으로, 인덱스는 꼭 필요한 컬럼에만 적용해야 한다.트랜잭션(Transaction)   트랜잭션은 작업의 완전성 을 보장해준다.  논리적인 작업 셋을 모두 완벽하게 처리한다. 만약 처리하지 못할 경우에는 원래 상태로 복구해서 작업의 일부만 적용되는 현상을 막아주는 기능을 한다.  사용자의 입장에서는 작업의 논리적 단위로 볼 수 있고, 시스템의 입장에서는 데이터들을 접근 또는 변경하는 프로그램의 단위가 된다.  COMMIT: 하나의 트랜잭션이 정상적으로 종료될 경우 수행되는 연산  ROLLBACK: 하나의 트랜잭션이 비정상적으로 종료될 경우 수행되는 연산    특징     ACID    원자성(Atomicity)     만약 트랜잭션 중간에 어떤 문제가 발생했다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행해되어서는 안된다. 즉, 아무런 문제가 발생하지 않았을 경우에만 모든 작업이 수행된다.    일관성(Consistency)     트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.    고립성(Isolation)     각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.    지속성(Durability)     트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.    상태     그림 삽입  Active: 트랜잭션의 활동 상태, 트랜잭션이 실행중이며 동작중인 상태를 말한다.  Failed: 트랜잭션 실패 상태, 트랜잭션이 더이상 정상적으로 진행할 수 없는 상태를 말한다.  Partial Committed: 트랜잭션의 Commit 명령어가 도착한 상태, 트랜잭션의 commit 이전의 sql 문이 수행되고 commit 만 남은 상태를 말한다.  Committed: 트랜잭션 완료 상태, 트랜잭션이 정상적으로 완료된 상태를 말한다.  Aborted: 트랜잭션 취소 상태, 트랜잭션이 취소되고 트랜잭션 실행 이전 데이터로 돌아간 상태를 말한다.    Partial Committed 와 Committed 의 차이     Commit 요청이 들어오면 트랜잭션의 상태는 Partial Committed 상태가 된다. 이후 commit 을 문제없이 수행할 수 있으면 Committed 상태로 전이되고, 만약 오류가 발생하면 Failed 상태가 된다. 즉, Partial Committed 는 commit 요청이 들어왔을때를 말하며, Committed 는 commit 을 정상적으로 완료한 상태를 말한다.    병행제어(Concurrency Control)     병행제어란 다중 프로그램의 이점을 활용하여 동시에 여러개의 트랜잭션을 병행 수행할 때, 동시에 실행되는 트랜잭션들이 데이터베이스의 일관성을 파괴하지 않도록 트랜잭션 간의 상호작용을 제어하는 것이다.    목적     데이터베이스의 공유를 최대화한다.  시스템의 활용도를 최대화한다.  데이터베이스의 일관성을 유지한다.  사용자에 대한 응답시간을 최소화한다.    문제점     갱신 분실(Lost Update): 두 개 이상의 트랜잭션이 같은 자료를 공유하여 갱신할 때 갱신 결과의 일부가 없어지는 현상이다.  비완료 의존성(Uncommitted Dependency): 하나의 트랜잭션 수행이 실패한 후 이를 회복하기 전에 다른 트랜잭션이 그 실패한 갱신 결과를 참조하는 현상이며, 임시 갱신이라고도 한다.  모순성(Inconsistency): 두 개의 트랜잭션이 병행수행될 때 원치 않는 자료를 이용함으로써 발생하는 문제이며, 불일치 분석이라고도 한다.  연쇄 복귀(Cascading Rollback): 병행수행하는 트랜잭션들 중 어느 하나에 문제가 발생하여 Rollback 하는 경우 다른 트랜잭션도 함께 Rollback 되는 현상이다.    병행제어 기법의 종류           로킹(Locking, 잠금)        로킹은 주요 데이터의 접근을 상호 배타적으로 하는 것이다.  트랜잭션들이 어떤 로킹 단위를 접근하기 전에 Lock(잠금)을 요청하여 접근을 허용해주어야만 그 로킹 단위에 접근할 수 있는 기법이다.  데이터 갱신 과정: 잠금(Lock) -&gt; 실행(Excute) -&gt; 해제(Unlock)  잠금 단위          병행제어에서 한 번에 잠금할 수 있는 단위는 데이터베이스, 테이블, 레코드, 필드 등이 있다.      단위가 커지면 Locking Overhead는 감소하지만 공유성이 낮아진다.      단위가 작아지면 Locking Overhead는 증가하지만 공유성은 높아진다.        종류: 공유 잠금, 배타 잠금, 의도 잠금, 의도 공유 잠금, 배타 의도 잠금, 공유 의도 독점 잠금  2단계 잠금 규약(Two-Phase Lock Protocol)          각 트랜잭션의 잠금 요청과 해제 요청을 2단계로 실시한다.      직렬성을 보장하는 대표적인 잠금 규약이다.      확장 단계: 새로운 Lock은 수행할 수 있지만, Unlock은 수행할 수 없다.      축소 단계: 새로운 Unlick은 수행할 수 있지만, Lock은 수행할 수 없다.      직렬성을 보장하지만, 교착상태를 예방할 수 없다.    2. 타임 스탬프 순서(Time Stamp Ordering)        직렬성 순서를 결정하기 위해 트랜잭션 간의 처리 순서를 선택하는 기법 중 가장 보편적인 방법이다.  트랜잭션과 트랜잭션이 읽거나 갱신한 데이터에 대해 트랜잭션이 실행을 시작하기 전에 시간표(Time Stamp)를 만들어 정해진 시간에 따라 작업을 수행하는 기법이다.  교착상태가 발생하지 않는다.          최적 병행 수행(검증 기법, 확인 기법, 낙관적 기법)        병행수행하고자 하는 트랜잭션의 대부분이 읽기 전용(Read only) 트랜잭션일 경우, 트랜잭션 간의 충돌방생률이 매우 낮으므로 병행제어 기법을 사용하지 않아도 시스템의 일관성을 유지할 수 있다는 점을 이용하는 기법이다.          다중 버전 기법        타임 스탬프의 개념을 이용하는 기법으로, 다중 버전 타임 스탬프 기법이라고도 한다.  타임 스탬프 기법은 트랜잭션 및 데이터들의 이용 시간을 시간표로 관리하지만, 다중 버전 기법은 갱신될 때마다의 버전을 만들어 관리한다.    회복(Recovery)     데이터베이스 운영 도중 예기치 못한 장애(Failure)가 발생한 경우, 데이터베이스를 장애 발생 이전의 일관된 상태(Consistent State)로 복원시키는 것이다.  데이터베이스 관리 시스템에 회복 기능이 없을 경우, 데이터베이스에 저장된 내용을 신뢰할 수 없으므로 핵심적인 역할을 담당하는 회복 관리기(Recovery Manager)가 필요하다.    장애(Failure) 유형     실행 장애(Action Failure): 사용자의 실수나 무결성 규칙 위반 등 질의 실행이 실패한 경우.  트랜잭션 장애(Transaction Failure): 내부적인 오류나 Deadlock과 같은 오류로 정상적으로 트랜잭션을 실행할 수 없는 경우.  시스템 장애(System Failure): 전원, 하드웨어, 소프트웨어 등의 고장으로 모든 트랜잭션을 사용할 수 없는 경우.  미디어 장애(Media Failure): 저장장치의 손상이나 오류로 데이터베이스의 일부 또는 전체가 물리적으로 손상되는 경우.    회복 관리기(Recovery Manager)     Log, Memory Dump 등을 이용하여 회복을 수행하는 DBMS의 핵심 구성요소이다.  트랜잭션이 성공적으로 완료되지 않았을 때, Log를 이용하여 트랜잭션이 데이터베이스의 모든 변화를 취소(Undo)하여 회복한다.  트랜잭션이 성공적으로 완료되었으나 저장장치에 반영되지 않았을 때, Log를 이용하여 재작업(Redo)를 수행한다.    회복 기법     연기 갱신(Differed Update)          트랜잭션이 성공적으로 종료될 때까지 데이터베이스에 대한 실질적인 갱신을 연기한다.      실행되는 동안 변경된 내용은 Log에 보관하며 부분완료 시점에 Log에 저장된 내용을 데이터베이스에 반영한다.      내용을 Log에 저장하고 데이터베이스에 적용을 하지 않기 때문에 장애가 발생하면 Redo 작업만을 수행하면 된다.        즉각 갱신(Immediate Update)          트랜잭션이 데이터를 변경하면 트랜잭션이 부분 완료가 되기 전이라도 데이터베이스에 바로 반영한다.      장애를 대비하여 모든 변경 내용을 Log에 저장한다.      Undo, Redo 모두 수행한다.        그림자 페이지(Shadow Paging)          갱신 이전의 데이터베이스를 페이지단위로 구성하여 복사해놓고, 실제 페이지를 대상으로 트랜잭션에 대한 변경 작업을 반영한다.      장애가 발생하여 Rollback을 할 때, 해당 페이지만 복구한다.      Log와 Undo, Redo 모두 수행할 필요가 없다.        검사점(Check Point)          Undo, Redo를 수행할 때 Log 전체를 조사해야하는 것을 피하기 위한 기법이다.      트랜잭션 실행 중 주기적으로 변경 내용과 검사점을 같이 Log에 저장한다.      장애가 발생할 때, 전체 Log를 조회하지 않고 가장 최근 검사점을 기준으로 회복 작업을 수행한다.        미디어 회복(Media Recovery)          데이터베이스의 내용을 주기적으로 안전한 저장소에 덤프한다.      장애가 발생하면 가장 최근의 덤프를 디스크에 적재하고, Log를 조회하여 최근의 트랜잭션에 대하여 Redo를 수행한다.      고급 데이터베이스 분산 데이터베이스(Distributed Database)   논리적으로 같은 시스템에 속하지만, 물리적으로 분산되어있는 데이터베이스    분산 데이터베이스 시스템 구성요소     분산 처리기: 지리적으로 분산되어있는 컴퓨터 시스템, 자체 처리 능력을 가진다.  분산 데이터베이스: 지리적으로 분산되어있는 데이터베이스  통신 네트워크: 분산 처리기들을 통신망으로 연결해 하나의 시스템처럼 작동할 수 있는 네트워크    목표     위치 투명성(Location Transparency): 접근하려는 데이터베이스의 실제 위치를 알 필요는 없다.  중복 투명성(Replication Transparency): 동일한 데이터가 여러 곳에 중복되어도 하나의 데이터만 존재하는 것처럼 사용할 수 있다.  병행 투명성(Concurrency Transparency): 다수의 트랜잭션들이 동시에 수행되어도 서로 영향을 주지 않는다.  장애 투명성(Failure Transparency): 각종 장애에도 불구하고 트랜잭션은 정확히 수행된다.    멀티미디어 데이터베이스(Multimedia Database)     텍스트, 그래픽, 정지화상, 동영상, 음성 등이 복합적으로 구성된 데이터베이스    주기억장치 데이터베이스(Main Memory Database)     데이터베이스 전체를 주기억장치에 저장한 후, 데이터베이스 연산을 수행하는 시스템  디스크 I/O가 발생하지 않는다.    데이터 웨어하우스(Data Warehouse)     다량의 데이터를 효과적으로 분석하여 정보화하고, 이를 계층의 사용자가 효율적으로 사용하도록 하는 데이터베이스  다양한 원본 데이터베이스로부터 정제되어 추출된 데이터만을 저장하고 필요한 인덱스를 생성한다.  빠르고 정확한 의사결정을 도와준다.    데이터 마트(Data Mart)     전사적으로 구축된 데이터 웨어하우스로부터, 특정 주제나 부서 중심으로 구성된 단일 주제의 데이터 웨어하우스    데이터 마이닝(Data Mining)     데이터 웨어하우스에 저장된 데이터 집합에서 사용자의 요구에 따라 유용하고 가능성 있는 정보를 발견하기 위한 기법    기법 종류     연관, 연속, 분류, 클러스터링, 특성화, 패턴 분석, 경향 분석 등    OLAP(Online Analytical Processing)     다차원으로 이루어진 데이터로부터, 통계적인 요약 정보를 분석하여 의사결정에 활용하는 방식  데이터 웨어하우스, 데이터 마트 같은 시스템과 상호 연관되는 시스템  데이터 웨어하우스의 데이터를 전략적인 정보로 변환시키는 역할  중간 매개체 없이 이용자들이 직접 컴퓨터를 이용해 데이터에 접근하는데 있어서 필수적인 시스템    OLAP 연산     Roll-up: 더 요약된 정보보기  Drill-down: 더 구체적인 정보보기  Pivoting: 보고서의 행/열/페이지 차원을 바꾸어 보는 기능  Slicing: 다차원 데이터 항목들을 다양한 각도에서 조회하고 자유롭게 비교하는 기능  Dicing: Slicing을 더 세분화하는 기능    OLAP 종류     ROLAP(Relational-OLAP): 관계형 데이터베이스와 관계형 질의어를 사용하여 다차원 데이터를 저장하고 분석한다.  MOLAP(Multi-dimension OLAP)          다차원 데이터를 저장하기 위해 특수한 구조의 다차원 데이터베이스를 사용한다.      검색 속도를 위해 큐브 캐시(Cube Cache)라고 하는 주기억장치 속에 데이터 큐브를 저장한다.      데이터 큐브(Data Cube): 특정 목적의 OLAP에서 사용하기 위한 큐브형태의 다차원 논리적 구조        HOLAP(Hybrid OLAP)          ROLAP와 MOLAP의 특성을 모두 가지고 있다.      빠른 검색을 필요할 때는 요약을 메모리에 저장하고 다른 요약들은 관계형 데이터베이스에 저장한다.        OLTP(Online Transaction Processing)               온라인 업무 처리 형태의 하나로 네트워크 상에서 다수의 유저가 데이터베이스의 데이터를 갱신, 검색하는 등의 트랜잭션을 처리하는 방식이다.  OLTP 시스템은 일반적으로 빠른 응답 시간을 요구하며, 개개의 레코드를 효율적으로 조회하고 수정할 수 있도록 정규화 되어 있다.    OLTP와 OLAP 비교     |        구분        \t|                OLTP                \t|                OALP                \t||:——————:\t|:———————————-:\t|:———————————-:\t||    데이터의 구조   \t|    복잡(운영시스템 계산에 적합)    \t|       단순(사업 분석에 적합)       \t||    데이터의 갱신   \t|             순간적/동적            \t|             주기적/정적            \t||      응답 시간     \t|         2,3초 ~ 몇 초 이내         \t|            수 초 ~ 몇 분           \t||    데이터의 범위   \t|          과거 30일 ~ 90일          \t|           과거 5년 ~ 10년          \t||     데이터 성격    \t| 정규/핵심 업무 데이터, 변경 어려움 \t| 비정규/일기 전용 데이터, 변경 용이 \t||    데이터의 크기   \t|            수 Giga Byte            \t|            수 Tera Byte            \t||    데이터의 내용   \t|             상세 데이터            \t|    기록 보관된 요약/계산 데이터    \t||     데이터 특성    \t|      트랜잭션 중심, 중복 배제      \t|    주제(subject) 중심, 중복 허용   \t|| 데이터 액세스 빈도 \t|                높음                \t|           보통 혹은 낮음           \t||   데이터의 사용법  \t|      고도로 구조화된 연속 처리     \t|     고도로 비구조화된 분석 처리    \t||     쿼리의 성격    \t|          예언 가능, 주기적         \t|       예측하기 어려움, 특수함      \t|     ODBC(Open Database Connectivity)     프로그램과 데이터베이스의 종류에 관계업이 자유롭게 사용할 수 있도록 MS에서 만든 API  구조상 데이터베이스 바로 위에 ODBC가 위치한다.    구조     Application: ODBC API를 이용해 데이터베이스에 접근한다.  Driver Manager: 애플리케이션과 ODBC Driver 간의 통신을 관리하는 라이브러리  DSN(Domain Service Name): 서버에 연결할 때 필요한 드라이버와 데이터베이스 정보를 저장한다.  ODBC Driver: ODBC API가 지원하는 함수를 구현하는 라이브러리  데이터베이스: ODBC Driver에서 요청한 SQL에 대한 결과를 반환한다.","categories": ["Study"],
        "tags": ["Study_Database"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/Database-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC/",
        "teaser":null},{
        "title": "[HowToInstall]텐서플로우 우분투에 설치하기",
        "excerpt":"Ubuntu16.04에서 Tensorflow 설치 설치 환경   Linux Ubuntu 16.04  GTX 1060 3GB (CUDA)  python 3.5  Virtualenv설치 순서 1) CUDA 설치 (CUDA 9.0)2) cuDNN 설치 (cuDNN 7.1)3) Virtualenv(python 가상 환경) 설치4) Tensorflow 설치 CUDA 설치 NVIDIA 드라이버 설치 확인 $ nvidia-smi주의 사항   현재 설치하는 tensorflow 버전은 1.8이며, 이 버전은 CUDA 9.0과 호환된다. (CUDA 버전이 9.0이 아닐시 밑과 같은 오류 메시지가 뜬다.)   CUDA 이전 버전 삭제하기 (CUDA 8.0)$ sudo apt-get --purge remove 'cuda*'$ sudo apt-get autoremove --purge 'cuda*'  $ sudo rm -rf /usr/local/cuda-8.0$ sudo rm -rf /usr/local/cuda CUDA 9.0 Toolkit 설치   https://developer.nvidia.com/cuda-90-download-archive (Nvidia, 설치 파일)  위 사이트에 들어가서 아래와 같이 다운받는다.  Patch 파일은 가장 최신인 Patch 2만 설치하면 된다.    Base Installer$ cd Download(다운로드)$ sudo dpkg -i cuda-repo-ubuntu1604-9-0-local_9.0.176-1_amd64.deb$ sudo apt-key add /var/cuda-repo-9-0-local/7fa2af80.pub$ sudo apt-get update$ sudo apt-get install cuda  Patch 2 (Released Mar 5, 2018)$ cd Download$ sudo dpkg -i cuda-repo-ubuntu1604-9-0-local-cublas-performance-update-2_1.0-1_amd64.deb$ sudo apt-get update$ sudo apt-get upgrade cuda   cuDNN 설치 cuDNN 7.1.4 설치   https://developer.nvidia.com/rdp/cudnn-download (Nvidia, 설치 파일)  로그인을 해야 설치 파일을 다운 받을 수 있다.      아래 그림에서 cuDNN v7.1.4 Library for Linux 를 다운 받는다.     압축 풀기$ cd Download$ tar xvzf cudnn*  cuDNN 라이브러리를 CUDA가 설치된 곳에 복사하기$ sudo cp cuda/include/cudnn.h /usr/local/cuda/include$ sudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64$ sudo chmod a+r /usr/local/cuda/include/cudnn.h /usr/local/cuda/lib64/libcudnn*$ sudo mv ~/Download/cuda/* /usr/local/cuda-9.0  cuDNN 라이브러리를 /usr/lib/x86_64-linux-gnu 폴더에 복사하면 R 언어에서 정상적으로 사용가능하다.$ sudo cp cuda/lib64/libcudnn* /usr/lib/x86_64-linux-gnu Virtualenv 가상환경 설치 Virtualenv 를 사용하는 이유   https://www.tensorflow.org/install/install_linux  위의 tensorflow 공식 홈페이지에 따르면, Virtualenv 가상환경이 tensorflow를 설치하기 간단하여 추천하고 있다.Virtualenv 설치   python 3.5 버전, GPU 환경에 맞춰서 설치한다.  다른 환경 설치와 자세한 사항은 참고 문헌 부분을 참고하길 바란다.  pip와 virtualenv 패키지 설치$ sudo apt-get install python3-pip python3-dev python-virtualenv  Virtualenv 환경 생성$ virtualenv --system-site-packages -p python3 targetDirectory  가상 환경 활성화$ source ~/tensorflow/bin/activate # bash, sh, ksh, or zsh$ source ~/tensorflow/bin/activate.csh # csh or tcsh  위의 명령어를 실행하면 가상 환경이 밑에와 같이 활성화되는 모습을 볼 수 있다.(tensorflow)$  원활한 진행을 위해 pip 8.1버전 이상이 설치되어 있어야 한다. 만약을 위해 pip 업그레이드를 한다.$ easy_install -U pip    Tensorflow 설치(tensorflow)$ pip3 install --upgrade tensorflow-gpu   Virtualenv 가상 환경 비활성화(tensorflow)$ deactivateTensorflow 테스트 $ source ~/tensorflow/bin/activate(tensorflow)$ pythonimport tensorflow as tfhello = tf.constant('Hello, Tensorflow!')sess = tf.Session()print(sess.run(hello))(tensorflow)$ deactivate$ Tensorflow 버전 확인 (tensorflow)$ pythonimport tensorflow as tftf.__version__ 참고 문헌   CUDA 8.0 지우고 CUDA 9.0 설치하기          https://park-ju-hyeong.github.io/2018/04/05/CUDA-8.0-to-9.0/        cuDNN 설치          http://igotit.tistory.com/entry/cuDNN-Ubuntu-%EC%97%90-%EC%84%A4%EC%B9%98        Virtualenv를 활용한 tensorflow 설치          http://webnautes.tistory.com/1046  - https://www.tensorflow.org/install/install_linux (tensorflow 공식 홈페이지)      ","categories": ["HowToInstall"],
        "tags": ["Tensorflow"],
        "url": "https://codemcd.github.io/pages/CODEMCD/howtoinstall/HowToInstall-Tensorflow_Ubuntu/",
        "teaser":null},{
        "title": "[Java]1. 클래스와 객체",
        "excerpt":"1. 클래스와 객체 정의와 용도   클래스의 정의: 클래스란 객체를 정의해 놓은 것이다.  클래스의 용도: 클래스는 객체를 생성하는데 사용된다.  객체의 정의: 실제로 존재하는것, 사물 또는 개념  객체의 용도: 객체가 가지고 있는 기능과 속성에 따라 다르다.          유형의 객체: 책상, 의자, 자동차, TV와 같은 사물      무형의 객체: 수학공식, 프로그램 에러와 같은 논리나 개념        객체를 사용한다. = 객체가 가지고 있는 속성과 기능을 사용한다.  프로그래밍적인 관점에서의 클래스          자료형의 종류와 상관없이 서로 관계가 깊은 변수와 함수들을 하나로 묶은 집합                  변수: 하나의 데이터를 저장할 수 있는 공간          배열: 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간          구조체: 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집으로 저장할 수 있는 공간          클래스: 데이터와 함수의 결합(구조체 + 함수)                    프로그래밍언어에서 제공하는 기본 자료형외에 프로그래머가 새로운 타입을 추가할 수 있는 사용자정의 타입(user-defined type)이다.      객체와 인스턴스   인스턴스화(Instantiate): 클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화라고 한다.  인스턴스(Instance): 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다.  인스턴스와 객체는 같은 의미이지만 문맥상으로 구분하여 사용하는 것이 좋다.          ‘책상은 객체다.’      ‘책상은 책상 클래스의 인스턴스다.’      객체의 구성요소 - 속성과 기능   클래스로부터 객체를 생성하면, 클래스에 정의된 속성과 기능을 가진 객체가 만들어진다.  속성(Property) = 멤버변수 (member variable), 특성(attribute), 필드(field), 상태(state)  기능(Function) = 메서드 (method), 함수(function), 행위(behavior)인스턴스의 생성과 사용   인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야한다.클래스명 변수명;참조 변수명 = new 클래스명();","categories": ["Study"],
        "tags": ["Study_Java"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/Java-1.-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EA%B0%9D%EC%B2%B4/",
        "teaser":null},{
        "title": "[Java]10. 오버라이딩(Overriding)",
        "excerpt":"10. 오버라이딩(Overriding) 정의   조상 래스로부터 상속받은 메서드의 내용을 변경하는 것을 오버라이딩이라고 한다.  예제예제 코드 class Point {\tint x;\tint y;\tString getLocation() {\t\treturn \"x: \" + x + \", y: \" + y;\t}}class Point3D extends Point {\tint z;\tString getLocation() {\t\treturn \"x: \" + x + \", y: \" + y + \", z: \" + z;\t}}조건   자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 매서드와          이름이 같아야 한다.      매개변수가 같아야 한다.      반환타입이 같아야 한다.                  JDK1.5부터 ‘공변 반환타입(covariant return type)’이 추가되어, 반환타입을 자손 클래스의 타입으로 변경 가능하게 완화되었다.                      조상 클래스의 메서드를 자손 클래스에서 오버라이딩할 때          접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.                  범위 순서(넓은 순): public &gt; protected &gt; (default) &gt; private                    예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.      인스턴스메서드를 static메서드로 또는 그 반대로 변경할 수 없다.      오버로딩 vs 오버라이딩   오버로딩(overloading): 기존에 없는 새로운 메서드를 정의하는 것  오버라이딩(overriding): 상속받은 메서드의 내용을 변경하는 것  예제예제 코드 class Parent {\tvoid parentMethod() { }}class Child extends Parent {\tvoid parentMethod() { }       //오버라이딩\tvoid parentMethod(int i) { }  //오버로딩\tvoid childMethod() { }\tvoid childMethod(int i) { }   //오버라이딩\tvoid childMethod() { }        //중복정의 에러('already defined in Child')}super 1. 정의   자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는 참조변수이다.2. 특징   super대신 this를 사용할 수 있으며, 조상 클래스 멤버와 자손 클래스 멤버가 중복 정의되어 서로 구별을 해야 하는 경우에만 super를 사용한다.          위의 기능을 제외하고는 super와 this는 근본적으로 같다.        static메서드에서는 사용할 수 없고, 오직 인스턴스메서드에서만 사용가능하다.  예제1: super멤버변수예제 코드 class SuperTest {\tpublic static void main(String args[]) {\t\tChild c = new Child();\t\tc.method();\t}}class Parent {\tint x = 10;}//super == this 경우class Child extents Parent {\tvoid method() {\t\tSystem.out.println(\"x = \" + x);\t\tSystem.out.println(\"this.x = \" + this.x);\t\tSystem.out.println(\"super.x = \" + super.x);\t}}//super != this 경우class Child extents Parent {\tint x = 20;\tvoid method() {\t\tSystem.out.println(\"x = \" + x);\t\tSystem.out.println(\"this.x = \" + this.x);\t\tSystem.out.println(\"super.x = \" + super.x);\t}}실행 결과 //super == thisx = 10this.x = 10super.x = 10//super != thisx = 20this.x = 20super.x = 10  예제2: super메서드예제 코드 class Point {\tint x;\tint y;\tString getLocation() {\t\treturn \"x: \" + x + \", y: \" + y;\t}}class Point3D extends Point {\tint z;\tString getLocation() {\t\t//return \"x: \" + x + \", y: \" + y + \", z: \" + z;\t\treturn super.getLocation() + \", z: \" + z;\t}}super() - 조상 클래스의 생성자   this()와 마찬가지로 super()도 생성자이다.  자손 클래스의 인스턴스를 생성하면, 자손의 멤버와 조상의 멤버가 모두 합쳐진 하나의 인스턴스가 생성된다.  자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수 있으므로 메서드 첫 줄에 super() 생성자를 선언해주어야 한다.          그렇지 않으면 컴파일러가 자동적으로 ‘super()’를 생성자의 첫 줄에 삽입한다.        예제예제 코드 class PointTest {\tpublic static void main(String args[]) {\t\tPoint3D p3 = new Point3D();\t\tSystem.out.println(\"p3.x = \" + p3.x);\t\tSystem.out.println(\"p3.y = \" + p3.y);\t\tSystem.out.println(\"p3.z = \" + p3.z);\t}}class Point {\tint x;\tint y;\tPoint(int x, int y) {\t\t//super()(=Object())를 컴파일러가 자동으로 추가한다.\t\tthis.x = x;\t\tthis.y = y;\t}\tString getLocation() {\t\treturn \"x: \" + x + \", y: \" + y;\t}}class Point3D extends Point {\tint z;\tPoint3D() {\t\tthis(100, 200, 300);    //Point3D(int x, int y, int z) 호출\t}\tPoint3D(int x, int y, int z) {\t\tsuper(x,y);    //Point(int x, int y) 호출\t\tthis.z = z;\t}}실행 결과 p3.x = 100p3.y = 200p3.z = 300  Point3D p3 = new Point3D(); 인스턴스 생성시, 생성자 호출 순서          Point3D()      Point3D(int x, int y, int z)      Point(int x, int y)      Object()      ","categories": ["Study"],
        "tags": ["Study_Java"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/Java-10.-%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%94%A9/",
        "teaser":null},{
        "title": "[Java]11. package와 import",
        "excerpt":"11. package와 import 패키지(package) 1. 정의   패키지란, 클래스의 묶음으로서, 서로 관련된 클래스 및 인터페이스들끼리 그룹 단위로 묶는것을 의미한다.  클래스의 실제 이름(full name)은 패키지명을 포함한 것이다.  클래스가 물리적으로 하나의 클래스 파일(.class)인 것과 같이 패키지는 물리적으로 하나의 디렉토리이다.2. 특징   같은 이름의 클래스 일지라도 서로 다른 패키지에 존재하는 것이 가능하다.          자신만의 패키지 체계를 유지할 수 있으며, 다른 개발자가 개발한 클래스 라이브러리의 클래스와 이름이 충돌하는 것을 피할 수 있다.        하나의 소스파일에는 첫 번째 문장으로 단 한 번의 패키지 선언만을 허용한다.  모든 클래스는 반드시 하나의 패키지에 속해야 한다.  패키지는 점(.)을 구분자로 하여 계층구조로 구성할 수 있다.          예를들어, String클래스의 실제 이름은 java.lang.String이다.        패키지는 물리적으로 클래스 파일(.class)을 포합하는 하나의 디렉토리이다.패키지 선언 1. 선언 방법 pachage 패키지명;2. 특징   패키지 선언문은 클래스나 인터페이스의 소스파일(.java)에서 반드시 주석과 공배을 제외한 첫 번째 문장에 선언해야 한다.  하나의 소스파일에 단 한번만 선언될 수 있다.  해당 소스파일에 포함된 모든 클래스나 인터페이스는 선언된 패키지에 속하게 된다.  패키지명은 대소문자를 모두 허용한다.          클래스명과 구분하기 위해 일반적으로 소문자로 하는 것을 원칙으로 한다.        모든 클래스는 반드시 하나의 패키지에 포함되어야 한다.          패키지를 선언하지 않는다면 ‘이름없는 패키지(unnamed package)’에 속하게 된다.      3. 새로운 패키지 생성 순서   패키지 예제예제 코드 package com.javachobo.book;class PackageTest {\tpublic static void main(String args[]) {\t\tSystem.out.println(\"Hello World!\");\t}}  컴파일: C:\\Program Files\\Java\\jdk1.8.0_171\\work&gt;javac -d . PackageTest.java          ‘-d’ 옵션                  소스파일에 지정된 경로를 통해 패키지의 위치를 찾아서 클래스 파일을 생성한다. (일치하는 디렉토리가 없다면 자동생성)          ‘-d’옵션 뒤에는 해당 패키지의 루트(root)디렉토리의 경로를 적어준다.          ‘-d’옵션을 사용하지 않으면, 프로그래머가 직접 계층구조를 만들어야 한다.                      해당 패키지의 루트 디렉토리를 클래스패스(classpath)에 포함시킨다.          클래스패스는 컴파일러(javac.exe)나 JVM 등이 클래스의 위치를 찾는데 사용되는 경로이다.      com.javachobo.book 패키지의 루트 디렉토리는 ‘com’의 상위 디렉토리인 ‘C:\\Program Files\\Java\\jdk1.8.0_171\\work’이다.      ‘제어판 - 시스템 - 고급 시스템 설정 - 환경변수 - 새로 만들기’를 하면 ‘새 시스템 변수’ 팝업창이 뜬다.                  변수 이름: CLASSPATH          변수 값: .;C:\\Program Files\\Java\\jdk1.8.0_171\\work;                    클래스패스를 지정해주지 않으면 기본적으로 현재 디렉토리(.)로 지정되지만, 클래스패스를 따로 지정해주는 경우에는 직접 추가해주어야 한다.      클래스패스 확인 명령어: C:...&gt;echo %classpath%        실행 결과C:/...&gt;java com.javachobo.book.PackageTestHello World!  위의 방법으로 클래스패스를 이용하면, 클래스패스를 따로 설정하지 않아도 된다.          새로 추가하고자 하는 클래스는 ‘JDK설치디렉토리\\jre\\classes’디렉토리에 추가한다.                  classes디렉토리는 사용자가 직접 생성해야한다.                    jar파일은 ‘JDK설치디렉토리\\jre\\lib\\ext’디렉토리에 추가한다.        ‘-cp’옵션을 이용해서 일시적으로 클래스패스르르 지정할 수도 있다. C:...&gt;java -cp C:\\Program Files\\Java\\jdk1.8.0_171\\work com.javachobo.book.PackageTestimport문 1. 정의   컴파일러에게 소스파일에 사용된 클래스의 패키지에 대한 정보를 제공한다.2. 특징   클래스를 사용하기 전, 클래스의 패키지를 import문으로 미리 명시해주면 소스코드에 사용되는 클래스이름에서 패키지명을 생략할 수 있다.  컴파일시, import문을 통해 소스파일에 사용된 클래스들의 패키지를 알아낸 다음, 모든 클래스 이름 앞에 패키지명을 붙여 준다.          import문은 프로그램의 성능에 전혀 영향을 미치지 않으며, 컴파일 시간이 아무 조금 더 걸릴 뿐이다.      3. 선언   import문은 모든 소스파일(.java)에서 package문 다음, 클래스 선언문 이전에 위치해야 한다.          일반적인 소스파일(.java) 구성: package문, import문, 클래스 선언 순        한 소스파일에서 여러 번 선언할 수 있다.  선언 방식import 패키지명.클래스명;import 패키지명.*;  .*를 사용할 때 주의할 점은 하위 패키지의 클래스까지 포함하는 것은 아니라는 것이다.import java.util.*;import java.text.*;//import java.*;로 대신할 수 없다!  import문을 선언하지 않아도 묵시적으로 import java.lang.*;가 선언되어 있기 때문에 String과 같은 클래스를 사용할 수 있다.4. static import문   static멤버를 호출할 때 클래스 이름을 생략할 수 있다.import static java.lang.Integer.*;     //Integer클래스의 모든 static 메서드import static java.lang.Math.random;   //Math.random()만 . 괄호 안붙임import static java.lang.System.out;    //System.out을 out만으로 참조가능  위와 같이 선언하였다면 System.out.println(Math.random());을 out.println(random());로 선언가능하다.","categories": ["Study"],
        "tags": ["Study_Java"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/Java-11.-package%EC%99%80-import/",
        "teaser":null},{
        "title": "[Java]12. 제어자(Modifier)",
        "excerpt":"12. 제어자(Modifier) 정의   클래스, 변수, 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다.종류   접근 제어자: public, protected, default, private  그 외: static, final, abstract, native, transient, synchronized, volatile, strictfp특징   하나의 대상에 대해서 여러 제어자를 조합하여 사용하는 것이 가능하지만, 접근 제어자는 하나만 사용할 수 있다.  제어자들간의 순서는 관계없지만 주로 접근 제어자를 제일 왼쪽에 선언한다.static - 클래스의, 공통적인   static은 ‘클래스의’, ‘공통적인’의 의미를 가지고 있다.  클래스변수(static멤버변수)는 모든 인스턴스가 하나의 변수를 공유하기 때문에 인스턴스와 관계없이 같은 값을 갖는다.  static은 멤버변수, 클래스, 초기화 블럭에 사용될 수 있으며, 인스턴스를 생성하지 않고도 사용할 수 있다.            제어자      대상      의미                  static      멤버변수      - 모든 인스턴스에 공통적으로 사용되는 클래스변수가 된다.&lt;/br&gt; - 클래스 변수는 인스턴스를 생성하지 않고도 사용 가능하다.&lt;/br&gt; - 클래스가 메모리에 로드될 때 생성된다.              static      메서드      - 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다.&lt;/br&gt; - static 메서드 내에서는 인스턴스 멤버들을 직접 사용할 수 없다.              static      초기화 블럭      - 클래스가 메모리에 로드될 때 단 한번만 수행된다.&lt;/br&gt; - 주로 클래스변수를 초기화 하는데 사용된다.      final - 마지막의, 변경될 수 없는   final은 ‘마지막의’, ‘변경될 수 없는’의 의미를 가진다.  클래스, 메서드, 멤버변수, 지역변수에 사용가능하다.            제어자      대상      의미                  final      클래스      변경될 수 없는 클래스, 확장될 수 없는 클래스가 되며, final 클래스는 다른 클래스의 조상이 될 수 없다.              final      메서드      변경될 수 없는 메섣, final 메서드는 오버라이딩을 통해 재정의 될 수 없다.              final      멤버변수      변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다.              final      지역변수      변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다.        일반적으로 final이 붙은 변수는 선언과 동시에 초기화를 하지만, 인스턴스 변수의 경우에는 생성자에서 초기화가 가능하다.          각 인스턴스마다 final이 붙은 멤버변수가 각각 다른 값을 갖도록 하는 것이 가능하다.      abstract - 추상의, 미완성의   abstract는 ‘미완성’의 의미를 가진다.  클래스, 메서드에 사용가능하다.            제어자      대상      의미                  abstract      클래스      클래스 내에 추상 메서드가 선언되어 있음을 의미한다.(추상 클래스)              abstraact      메서드      선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알린다.      abstract class AbstractTest {     // 추상 클래스(추상 메서드를 포함한 클래스)\tabstract void move();     // 추상 메서드(구현부가 없는 메서드)}  추상 클래스는 미완성이므로, 인스턴스를 생성할 수 없다.  완성된 클래스도 abstract를 선언하여 추상 클래스로 만드는 경우가 있다.          메서드들에 아무 내용이 없어 인스턴스 자체를 생성하지 못하게 하기 위함이다.      이 경우, 주로 원하는 메서드만 오버라이딩을 해서 쓰기 위해 사용된다.      접근 제어자(access modifier) 1. 정의와 특징   접근 제어자는 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.  클래스, 멤버변수, 메서드, 생성자에 사용된다.  O: 접근 가능, X: 접근 불가능            제어자      같은 클래스      같은 패키지      자손 클래스      전 체                  public      O      O      O      O              protected      O      O      O      X              (default)      O      O      X      X              private      O      X      X      X        default는 접근 제어자를 선언하지 않으면 자동으로 지정된다.  protected는 패키지에 관계없이 상속관계에 있는 자손클래스와 같은 패키지내에 있는 모든 클래스에서 접근 가능하다.            대 상      사용가능한 접근 제어자                  클래스      public, (default)              메서드      public, protected, (default), private              멤버변수      public, protected, (default), private              지역변수      없 음      2. 접근 제어자를 이용한 캡슐화   접근 제어자를 사용하는 이유 = 캡슐화(encapsulation)를 하는 이유          외부로부터 데이터를 보호하기 위해(data hiding)                  데이터가 유효한 값을 유지하며, 외부로부터 함부로 변경하는 것을 막는다.                    외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서                  복잡성을 줄이고, 접근 범위를 최소화한다.          에러 테스트 상황에서 public은 모든 범위, default는 패키지 내부, private는 클래스 내부만 확인하면 된다.                      올바른 사용 예제          상속을 통해 확장될 것이 예상된다면, 멤버 변수 접근 제어자를 protected로 하며, 그렇지 않다면 private로 한다.      멤버변수의 값을 읽는 메서드의 이름은 ‘get멤버변수이름’ 값을 변경하는 메서드의 이름은 ‘set멤버변수이름’을 주로 사용한다.      예제 코드 public class Time {\t// 접근 제어자를 private로 하여 외부에서 직접 접근하지 못하도록 한다.\tprivate int hour;\tprivate int minute;\tprivate int second;\t//getter\tpublic int getHour() { return hour; }\tpublic int getMinute() { return minute; }\tpublic int getSecond() { return second; }\t//setter\tpublic void setHour(int hour) {\t\tif (hour &lt; 0 || hour &gt; 23) return;\t\tthis.hour = hour;\t}\tpublic void setMinute(int minute) {\t\tif (minute &lt; 0 || minute &gt; 59) return;\t\tthis.minute = minute;\t}\tpublic void setSecond(int second) {\t\tif (second &lt; 0 || second &gt; 23) return;\t\tthis.second = second;\t}}  하나의 소스파일(.java)에는 public클래스가 단 하나만 존재할 수 있으며, 소스파일 이름은 반드시 public클래스의 이름과 같아야 한다.3. 생성자의 접근 제어자   생성자에 접근 제어자를 사용하여 인스턴스의 생성을 제한할 수 있다.  사용 예제          생성자의 접근 제어자를 private(또는 protected)로 지정하여, 클래스 내부에서 인스턴스를 생성한다. (인스턴스 개수 제한)      인스턴스를 생성해서 반환해주는 메서드의 접근 제어자는 public으로 해야하며, 동시에 static이어야 한다.                  인스턴스를 생성하지 않고도 호출할 수 있어야 하기 때문에 static을 사용한다.                    예제 코드 class Singleton {\t// getInstance()에서 사용될 수 있도록 인스턴스가 미리 생성되어야 하므로 static을 사용한다.\tprivate static Singleton s = new Singleton();\tprivate Singleton() {\t\t...\t}\t// 인스턴스를 생성하지 않고도 호출할 수 있어야 하기 때문에 static을 사용한다.\tpublic static Singleton getInstance() {\t\treturn s;\t}\t...}제어자의 조합             대 상      사용가능한 제어자                  클래스      public, (default), final, abstract              메서드      public, protected, (default), private, final, abstract, static              멤버변수      public, protected, (default), private, final, static              지역변수      final        제어자 조합시 주의사항          메서드에 static과 abstract를 동시에 사용할 수 없다.                  static메서드는 몸통이 있는 메서드에만 사용할 수 있기 때문이다.                    클래스에 abstract와 final을 동시에 사용할 수 없다.                  final 클래스는 확장할 수 없다는 의미이고, abstract는 상속을 통해서 완성되어야 하는 의미이므로 서로 모순된다.                    abstract 메서드의 접근 제어자가 private일 수 없다.                  abstract 메서드는 자손클래스에서 구현해주어야 하는데 접근 제어자가 private이면, 자손클래스에서 접근할 수 없다.                    메서드에 private와 final을 같이 사용할 수 없다.                  접근 제어자가 private인 메서드는 오버라이딩될 수 없기 때문에, 이 둘 중 하나만 사용하면 된다.                    ","categories": ["Study"],
        "tags": ["Study_Java"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/Java-12.-%EC%A0%9C%EC%96%B4%EC%9E%90/",
        "teaser":null},{
        "title": "[Java]13. 다형성(Polymorphism)",
        "excerpt":"13. 다형성(Polymorphism) 다형성의 정의   객체지향개념에서 다형성이란 ‘여러 가지 형태를 가질 수 있는 능력’이다.          자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 하여 다형성을 구현하였다.        조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있다.          참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 항상 같거나 적어야 한다.      위의 이유 때문에, 자손타입의 참조변수로 조상타입의 인스턴스는 참조할 수 없다.        예제예제 코드 class Tv {\tboolean power;\tint channel;\tvoid power() { power != power; }\tvoid channelUp() { ++channel; }\tvoid channelDown() { --channel; }}class CaptionTv extends Tv {\tString text;\tvoid caption() { ... }}  위의 코드를 바탕으로, 다형성에 의해 아래와 같은 초기화가 가능하다.CaptionTv c = new CaptionTv();Tv t = new CaptionTv();  하지만, Tv타입의 참조변수로 CaptionTv인스턴스를 생성한 변수 t는 Tv클래스에 정의되지 않은 멤버인 text와 caption()은 사용할 수 없다.          같은 타입의 인스턴스라도 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라진다.      참조변수의 형변환   참조변수는 서로 상속관계 에 있는 클래스 사이에서만 서로 형변환이 가능하다.          조상의 조상으로도 형변환이 가능하기 때문에, 상속관계에만 있다면 서로 형변환이 가능하다.      클래스 A, B, C가 있을 때, A &lt;- C, A &lt;- B의 상속관계가 있다고 가정하자. 이 때, B, C는 서로 형변환이 불가능하다.(B,C는 서로 아무 관계가 없음)        기본형 변수 형변환과 유사하다.          작은 자료형에서 큰 자료형의 형변환이 생략이 가능하듯이, 자손타입의 참조변수를 조상타입의 참조변수로 형변환활 경우에는 생략이 가능하다.      참조변수의 형변환에도 캐스트연산자 ‘()’를 사용한다.        자손타입 -&gt; 조상타입 (Up-casting): 형변환 생략가능  자손타입 &lt;- 조상타입 (Down-casting): 형변환 생략불가  참조변수의 형변환은 인스턴스에 아무런 영향을 미치지 않는다.  참조변수의 형변환을 통해서 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위(개수)를 조절할 수 있다.  주의할 예제예제 코드 class CastingTest {\tpublic static void main(String args[]) {\t\tCar car = new Car();\t\tCar Car2 = null;\t\tFireEngine fe = null;\t\tcar.drive();\t\tfe = (FireEngine)car;  // 8번째 줄, 컴파일은 가능하지만 실행 시 에러가 발생한다.\t\tfe.drive();\t\tcar2 = fe;\t\tcar2.drive();\t}}실행 결과 drive, ...java.lang.ClassCastException: Car at CastingTest.main(CastingTest.java:8)  컴파일 시에는 참조변수간의 타입만 체크하고 인스턴스의 타입에 대해서는 알지 못하므로, 컴파일 시에는 에러가 발생하지 않는다.  참조변수가 참조하고 있는 인스턴스의 자손타입으로 형변환하는 것은 허용되지 않는다.          Car car = new Car(); -&gt; Car car = new FireEngine();으로 변경하면 실행 가능하다.      instanceof 연산자   instanceof 연산자는 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용한다.  형태는 참조변수 incstanceof 타입(클래스명)이며, 반환값은 true, false이다.          true: 참조변수가 검사한 타입으로 형변환이 가능하다는 의미이다.      값이 null인 참조변수는 항상 false를 반환한다.      참조변수와 인스턴스의 연결   조상타입의 참조변수로 자손 인스턴스를 참조하는 경우와 자손타입의 참조변수로 자손 인스턴스를 참조하는 경우는 다른 결과를 얻는다.          메서드의 경우는 참조변수의 타입에 관계없이 오버라이딩에 따라 다르게 호출된다. (인스턴스 메서드)                  static 메서드는 참조변수의 타입에 영향을 받기 때문에, 반드시 ‘클래스이름.메서드()’로 호출해야한다.                    멤버변수의 경우 참조변수의 타입에 따라 달라진다.                  멤버변수가 조상과 자손클래스에 중복 정의된 경우, 조상타입의 참조변수를 사용했을 때는 조상 클래스에 선언된 멤버변수가 사용되고, 자손타입의 참조변수를 사용했을 때는 자손 클래스에 선언된 멤버변수가 사용된다.                    매개변수의 다형성   메서드의 매개변수에도 다형성은 적용된다.  예제예제 코드 class Product {\tint price;        // 제품 가격\tint bonusPoint;   // 제품구매시 제공하는 보너스 점수}class Tv extends Product {}class Computer extends Product {}class Audio extends Product {}class Buyer {                 // 고객\tint money = 1000;     // 소유금액\tint bonusPoint = 0;   // 보너스 점수}  물건을 구입하는 메서드          다형성 적용하기 전      void buy(Tv t) { ... }void buy(Computer c) { ... }void buy(Audio a) { ... }  다형성 적용void buy(Product p) { ... }여러 종류의 객체를 배열로 다루기   참조변수를 배열로 처리할 수 있다.  예제          배열 사용하기 전      Product p1 = new Tv();Product p2 = new Computer();Product p3 = new Audio();  배열Product p[] = new Product[3];p[0] = new Tv();p[1] = new Computer();p[2] = new Audio();  동적 크기 배열인 Vector 클래스 역시 사용가능하다.  Vector 클래스의 주요 메서드            메서드 / 생성자      설 명                  Vector()      10개의 객체를 저장할 수 있는 Vector인스턴스를 생성한다. 10개이상의 인스턴스가 저장되면, 자동적으로 크기가 증가한다.              boolean add(Object o)      Vector에 객체를 추가한다. 추가에 성공하면 true, 실패하면 false를 반환한다.              boolean remove(Object o)      Vector에 저장되어 있는 객체를 제거한다. 제거에 성공하면 true, 실패하면 false를 반환한다.              boolean isEmpty()      Vector가 비어있는지 검사한다. 비어있으면 true, 비어있지 않으면 false를 반환한다.              Object get(int index)      지정된 위치(index)의 객체를 반환한다. 반환타입이 Object타입이므로 적절한 타입으로의 형변환이 필요하다.              int size()      Vector에 저장된 객체의 개수를 반환한다.      ","categories": ["Study"],
        "tags": ["Study_Java"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/Java-13.-%EB%8B%A4%ED%98%95%EC%84%B1/",
        "teaser":null},{
        "title": "[Java]2. 추상클래스(abstract class)",
        "excerpt":"2. 추상클래스(abstract class) 정의와 특징   추상클래스는 미완성 메서드(추상메서드)를 포함하고 있는 클래스이다.  추상클래스로는 인스턴스를 생성할 수 없으며, 오직 상속을 통해서 자손클래스에 의해서만 완성될 수 있다.  새로운 클래스를 작성하는데 있어 바탕이 되는 조상클래스로서의 중요한 의미를 갖는다.          새로운 클래스에서 아무것도 없는 상태에서 시작하는 것보다 어느 정도 틀을 갖춘상태에서 시작하는 것이 더 효율적이다.        추상클래스는 추상메서드를 포함하고 있다는 것을 제외하고는 일반 클래스와 같다.          생성자, 멤버변수, 메서드 모두 가질 수 있다.        추상클래스는 클래스 앞에 키워드 ‘abstract’를 붙이기만 하면 된다.abstract class 클래스이름 {  ...}  추상메서드가 없더라고 ‘abstract’를 붙여 추상클래스로 지정할 수도 있다.추상메서드(abstract method)   추상메서드는 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 것이다.  추상메서드를 사용하는 이유는 메서드의 내용이 상속받는 클래스에 따라 달라질 수 있기 때문이다.          추상클래스를 상속받는 자손클래스는 오버라이딩을 통해 조상의 추상메서드를 상황에 맞게 적절히 구현해주어야 한다.      만약 자손클래스에서도 추상메서드를 구현하지 않는다면 자손클래스에서 역시 추상메서드로 지정해야 한다.        추상메서드 형태/* 주석을 통해 어떤 기능을 수행할 목적으로 작성하였는지 설명한다. */abstract 리턴타입 메서드이름 ();추상클래스 작성   추상: 낱낱의 구체적 표상이나 개념에서 공통된 성질을 뽑아 이를 일반적인 개념으로 파악하는 정신 작용  상속은 조상클래스를 사용하여 자손클래스를 만드는 것이지만, 추상화는 반대로 자손클래스를 이용해 공통부분을 뽑아내서 조상클래스를 만드는 것이다.  추상화: 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업  구체화: 상속을 통해 클래스를 구현 및 확장하는 작업  추상메서드는 일반메서드에서 내용없는 빈 몸통만 만들어 놓은 것과 같지만, 굳이 사용하는 이유는 자손클래스에서 오버라이딩을 강제하기 위해서이다.  예제일반 클래스 코드 class Marine {    // 보병  int x, y;       // 현재 위치  void move(int x, int y) { /* 지정된 위치로 이동 */ }  void stop()             { /* 현재 위치에 정지 */ }  void stimPack()         { /* 스팀팩을 사용한다. */ }}class Tank {      // 탱크  int x, y;       // 현재 위치  void move(int x, int y) { /* 지정된 위치로 이동 */ }  void stop()             { /* 현재 위치에 정지 */ }  void changeMode()       { /* 공격모드를 변환한다. */ }}class Dropship {  // 수송선  int x, y;       // 현재 위치  void move(int x, int y) { /* 지정된 위치로 이동 */ }  void stop()             { /* 현재 위치에 정지 */ }  void load()             { /* 선택된 대상을 태운다. */ }  void unload()           { /* 선택된 대상을 내린다. */ }}추상 클래스 코드 abstract class Unit {  int x, y;  /* 각 유닛마다 고유의 이동방식을 구현한다. */  abstract void move(int x, int y);  void stop() { /* 현재 위치에 정지 */ }}class Marine extends Unit {  void move(int x, int y) { /* 지정된 위치로 이동 */ }  void stimPack()         { /* 스팀팩을 사용한다. */ }}class Tank extends Unit {  void move(int x, int y) { /* 지정된 위치로 이동 */ }  void changeMode()       { /* 공격모드를 변환한다. */ }}class Dropship extends Unit {  void move(int x, int y) { /* 지정된 위치로 이동 */ }  void load()             { /* 선택된 대상을 태운다. */ }  void unload()           { /* 선택된 대상을 내린다. */ }}","categories": ["Study"],
        "tags": ["Study_Java"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/Java-2.-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4/",
        "teaser":null},{
        "title": "[Java]3. 인터페이스(interface)",
        "excerpt":"3. 인터페이스(interface) 정의 및 특징   인터페이스는 일종의 추상 클래스이다.  추상클래스보다 추상화 정도가 높다.          일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다.      추상메서드와 상수만을 멤버로 가질 수 있다.      인터페이스 작성   인터페이스를 작성하는 것은 클래스를 작성하는 것과 같다          키워드 ‘class’ 대신 ‘interface’를 사용해야 한다.      접근제어자를 사용할 수 있다.      interface 인터페이스이름 {  public static final 타입 상수이름 = 값;  public abstract 메서드이름(매개변수목록);}  인터페이스 멤버들의 제약사항          모든 멤버변수는 public static final 이어야 하며, 이를 생략할 수 있다.      모든 메서드는 public abstract 이어야 하며, 이를 생략할 수 있다.      JDK1.8부터 static메서드와 디폴트 메서드를 사용할 수 있다.        인터페이스에 정의된 모든 멤버에게 적용되기 때문에 생략될 수 있으며, 컴파일 시에 자동으로 추가해준다.인터페이스 상속   인터페이스는 인터페이스로부터만 상속이 가능하다.  클래스와 달리 다중상속이 가능하다.  인터페이스는 Object클래스와 같은 최고 조상이 없다.  예제예제 코드 interface Movable {  /** 지정된 위치 (x,y)로 이동하는 기능의 메서드 */  void move(int x, int y);}interfave Attackable {  /** 지정된 대상 (u)를 공격하는 기능의 메서드 */  void attack(Unit u);}interface Fightable extends Movable, Attackable { }인터페이스 구현   인터페이스도 추상클래스와 같이 그 자체로는 인스턴스를 생성하지 못한다.          인터페이스 자신을 상속받는 클래스를 선언하여 메서드의 몸통을 오버라이딩을 통해 만들어주어야한다.        인터페이스를 상속할 때는 키워드 ‘extends’(확장하다) 대신 ‘implements’(구현하다)를 사용해야 한다.class 클래스이름 implements 인터페이스이름 {  // 인터페이스에 정의된 추상메서드를 구현해야 한다.}class Fighter implements Fightable {  public void move(int x, int y) { ... }  public void attack(Unit u) { ... }}  만일 구현하는 인터페이스의 메서드 중 일부만 구현한다면, ‘abstract’를 붙여 추상클래스로 선언해야 한다.abstract class Fighter implements Fightable {  public void move(int x, int y) { ... }}  상속과 구현을 동시에 할 수 있다.class Fighter extends Unit implements Fightable {  ...}  인터페이스의 이름에는 주로 ‘~able’(할 수 있는) 이라는 키워드를 붙인다.          반드시 붙는 것은 아니기 때문에 위의 키워드가 붙었다면 인터페이스라고 추측만 할 수 있다.        예제예제 코드 class FighterTest {\tpublic static void main(String[] args) {\t\tFighter f = new Fighter();\t\tif(f instanceof Unit) {\t\t\tSystem.out.println(\"f는 Unit클래스의 자손입니다.\");\t\t}\t\tif(f instanceof Fightable) {\t\t\tSystem.out.println(\"f는 Fightable인터페이스를 구현했습니다.\");\t\t}\t\tif(f instanceof Movable) {\t\t\tSystem.out.println(\"f는 Movable인터페이스를 구현했습니다.\");\t\t}\t\tif(f instanceof Attackable) {\t\t\tSystem.out.println(\"f는 Attackable인터페이스를 구현했습니다.\");\t\t}\t\tif(f instanceof Object) {\t\t\tSystem.out.println(\"f는 Object클래스의 자손입니다.\");\t\t}\t}}class Fighter extends Unit implements Fightable {\tpublic void move(int x, int y) { /*내용 생략*/ }\tpublic void attack(Unit u) { /*내용 생략*/ }}class Unit {\tint currentHP;  //유닛의 체력\tint x;          //유닛의 x좌표\tint y;          //유닛의 y좌표}interface Fightable extends Movable, Attackable { }interface Movable { void move(int x, int y); }interface Attackable { void attack(Unit u); }결과 f는 Unit클래스의 자손입니다.f는 Fightable인터페이스를 구현했습니다.f는 Movable인터페이스를 구현했습니다.f는 Attackable인터페이스를 구현했습니다.f는 Object클래스의 자손입니다.  클래스와 인터페이스간의 관계도   Moavable인터페이스에서 move메서드의 접근 제어자는 ‘public abstract’가 생략되었다.          Fighter클래스에서 move메서드의 접근 제어자가 public인 이유이다.      인터페이스를 이용한 다중상속   자바에서는 일반적으로 다중상속의 단점이 더 크다고 판단되어 허용하지 않는다.  C++에서는 다중상속이 가능하므로 자바에서는 인터페이스를 이용하여 다중상속이 가능하도록 만들었다.          하지만 인터페이스가 다중상속을 위한 것이 아니고 여전히 단점이 크므로 다중상속으로 구현하는 경우는 거의 없다.      인터페이스를 이용한 다형성   인터페이스 역시 클래스와 같이 다형성을 제공한다.          인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있다.      인터페이스 타입으로 형변환이 가능하다.                  인터페이스의 타입을 매개변수 타입으로 사용할 수 있다.          메서드의 리턴타입으로 인터페이스의 타입을 지정할 수 있다.                          리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인터페이스를 반환한다는 것을 의미한다.                                            예제예제 코드 interface Parseable {\t//구문 분석작업을 수행한다.\tpublic abstract void parse(String fileName);}class ParserManager {\t//리턴타입이 Parseable인터페이스이다.\tpublic static Parseable getParser(String type) {\t\tif(type.equals(\"XML\")) {\t\t\t/*\t\t\tParseable p = new XMLParser();\t\t\treturn p;\t\t\t*/\t\t\treturn new XMLParser();\t\t}\t\telse {\t\t\t/*\t\t\tParseable p = new HTMLParser();\t\t\treturn p;\t\t\t*/\t\t\treturn new HTMLParser();\t\t}\t}}class XMLParser implements Parseable {\tpublic void parse(String fileName) {\t\t/* 구문 분석작업을 수행하는 코드를 적는다. */\t\tSystem.out.println(fileName + \" - XML parsing completed.\");\t}}class HTMLParser implements Parseable {\tpublic void parse(String fileName) {\t\t/* 구문 분석작업을 수행하는 코드를 적는다. */\t\tSystem.out.println(fileName + \" - HTML parsing completed.\");\t}}class ParserTest {\tpublic static void main(String args[]) {\t\tParseable parser = ParserManager.getParser(\"XML\");\t\tparser.parse(\"document.xml\");\t\tparser = ParserManager.getParser(\"HTML\");\t\tparser.parse(\"document2.html\");\t}}출력 결과 document.xml - XML parsing completed.document2.html - HTMLparsing completed.  밑의 예제코드를 통해 분산환경 프로그래밍에서 큰 장점을 가진다.          사용자 컴퓨터에 설치된 프로그램을 변경하지 않고 서버측의 변경만으로도 사용자가 새로 개정된 프로그램을 사용할 수 있다.      예를들어, ParserManager클래스의 getParser메서드에서 ‘return new XMLParser(); 대신 ‘return new NEWXMLParser();’로 변경하기만 하면 된다.      인터페이스의 장점   개발시간을 단축시킬 수 있다.          인터페이스가 작성되면, 이를 사용해서 프로그램을 작성하는 것이 가능하다. 메서드를 호출하는 쪽에서는 메서드의 내용에 관계없이 선언부만 알면되기 때문이다.      동시에 다른 한 쪽에서는 인터페이스를 구현하는 클래스를 작성하도록 하여, 인터페이스를 구현하는 클래스가 작성할 때까지 기다리지 않고 양쪽에서 동시에 개발이 가능하다.        표준화가 가능하다.          프로젝트에 사용되는 기본 틀을 인터페이스로 작성한 다음, 개발자들에게 인터페이스를 구현하여 프로그램을 작성하도록 함으로써 보다 일관되고 정형화된 프로그램 개발이 가능하다.        서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.          서로 상속관계에 있지 않고, 같은 조상클래스를 가지고 있지 않은 서로 아무런 관계가 없느느 클래스들에게 하나의 인터페이스를 공통으로 구현하도록 하여 관계를 맺어 줄 수 있다.        독립적인 프로그래밍이 가능하다.          인터페이스를 이용하면 클래스의 선언과 구현을 분리시킬 수 있어 독립적인 프로그램을 작성할 수 있다.      클래스간의 직접적인 관계를 인터페이스를 이용해서 간접적인 관계로 변경하면, 한 클래스의 변경이 관련된 다른 클래스에 영향을 미치지 않는다.      인터페이스의 의해   클래스를 사용하는 쪽(User)과 클래스를 제공하는 쪽(Provider)이 있다.  메서드를 사용(호출)하는 쪽(User)에서는 사용하려는 메서드(Provider)의 선언부만 알면 된다.  예제예제 코드 class A {\tpublic void methodA(B b) {\t\tb.methodB();\t}}class B {\tpublic void methodB() {\t\tSystem.out.println(\"methodB()\");\t}}class InterfaceTest {\tpublic static void main(Sting args[]) {\t\tA a = new A();\t\ta.methodA(new B());\t}}출력 결과 methodB()  위 예제 코드의 클래스간의 관계는 A(User) -&gt; B(Provider)와 같이 서로 직접적인 관계에 있다.          이 경우, 클래스 A를 작성하기 위해서는 클래스 B가 이미 작성되어 있어야 한다.      클래스 B의 methodB()의 선언부가 변경되면, 이를 사용하는 클래스 A도 변경되어야 한다.        위의 단점을 개선하기 위해 2가지를 생각해보자.          Provider 클래스는 인터페이스를 활용하여 구현한다.                  클래스 A를 작성하는데 클래스 B가 관련되지 않는다.                    클래스 A가 매개변수를 통해서 인터페이스를 구현한 클래스의 인스턴스를 동적으로 생성하는 것보다 제 3의 클래스를 활용한다.                  나중에 다른 클래스의 인스턴스로 변경되어도 클래스 A는 변경할 필요가 없다.                    예제 코드 class InterfaceTest {\tpublic static void main(String args[]) {\t\tA a = new A();\t\ta.methodA();\t}}class A {\tvoid methodA() {\t\t//제 3의 클래스의 메서드를 통해서 인터페이스 I를 구현한 클래스의 인스턴스를 얻어온다.\t\tI i = InstanceManager.getInstance();\t\ti.methodB();\t\t//인터페이스 I 타입의 참조변수 i로도 Object클래스에 정의된 메서드들을 호출 가능하다.\t\tSystem.out.println(i.toString());\t}}interface I {\tpublic abstract void mathodB();}class B implements I {\tpublic void methodB() {\t\tSystem.out.println(\"methodB int B class\");\t}\tpublic String toString() { return \"class B\"; }}class InstanceManager {\tpublic static I getInstance() {\t\treturn new B();\t}}출력 결과 methodB in B classclass B디폴트 메서드와 static 메서드   JDK1.8부터 인터페이스에 디폴트 메서드와 static 메서드도 추가할 수 있게 되었다.  디폴트 메서드: 추상 메서드의 기본적인 구현을 제공하는 메서드          추상 메서드가 아니기 때문에, 새로 추가되어도 해당 인터페이스를 구현한 클래스를 변경하지 않아도 된다.      메서드 앞에 키워드 ‘default’를 붙이며, 일반 메서드처럼 몸통 {}이 있어야 한다.      접근 제어자는 ‘public’이며, 생략할 수 있다.        새로 추가된 디폴트 메서드는 기존의 메서드와 이름이 중복되어 충돌하는 경우가 생긴다.          여러 인터페이스의 디폴트 메서드 간의 충돌                  인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩해야 한다.                    디폴트 메서드와 조상 클래스의 메서드 간의 충돌                  조상 클래스의 메서드가 상속되고, 디폴트 메서드는 무시된다.                    ","categories": ["Study"],
        "tags": ["Study_Java"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/Java-3.-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/",
        "teaser":null},{
        "title": "[Java]4. 내부 클래스(inner class)",
        "excerpt":"4. 내부 클래스(inner class) 내부 클래스란?   내부클래스: 클래스 내에 선언된 클래스  장점          내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.      코드의 복잡성을 줄일 수 있다.(캡슐화)        주로 AWT나 Swing과 같은 GUI어플리케이션의 이벤트처리 이외에는 잘 사용하지 않는다.class A { //외부 클래스  //...  class B { //내부 클래스    //...  }  //...}내부 클래스의 종류와 특징             내부 클래스      특 징                  인스턴스 클래스 (instance class)      - 외부 클래스의 멤버변수 선언위치에 선언한다. &lt;/br&gt;- 외부 클래스의 인스턴스멤버처럼 다루어진다.&lt;/br&gt; - 주로 외부 클래스의 인스턴스멤버들과 관련된 작업에 사용된다.              스태틱 클래스 (static class)      - 외부 클래스의 멤버변수 선언 위치에 선언한다.&lt;/br&gt; - 외부 클래스의 static 멤버처럼 다루어진다.&lt;/br&gt; - 주로 외부 클래스의 static멤버, static메서드에서 사용된다.              지역 클래스 (local class)      - 외부 클래스의 메서드나 초기화 블럭 안에 선언한다.&lt;/br&gt; - 선언된 영역 내부에서만 사용가능하다.              익명 클래스 (anonymous class)      클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스(일회용)      내부 클래스 선언   내부 클래스는 변수와 마찬가지로 선언된 위치에 따라 유효범위(scope)와 접근성(accessibility)을 갖는다.class Outer {  class InstanceInner { }  static class StaticInner { }  void Mymethod() {    class LocalInner { }  }}익명 클래스(anonymous class)   익명 클래스는 다른 내부 클래스들과는 달리 이름이 없다.  클래스의 선언과 객체의 생성을 동시에 하기 때문에 단 한번만 사용될 수 있고, 오직 하나의 객체만을 생성할 수 있다.  이름이 없기 때문에 생성자를 가질 수 없다.  오로지 단 하나의 클래스를 상속받거나 단 하나의 인터페이스만을 구현할 수 있다.new 조상클래스이름() {  //멤버 선언}new 구현인터페이스이름() {  //멤버 선언}예제 코드 class anonymousTest {  Object iv = new Object() { void method() {} };          //익명클래스  static Object cv = new Object() { void method() {} };   //익명클래스  void myMethod() {    Object lv = new Object() { void method() {} };        //익명클래스  }}  위의 예제를 컴파일 하면 다음과 같은 4개의 클래스파일을 생성한다.          ‘외부 클래스명$숫자.class’      anonymousTest.classanonymousTest$1.classanonymousTest$2.classanonymousTest$3.class","categories": ["Study"],
        "tags": ["Study_Java"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/Java-4.-%EB%82%B4%EB%B6%80%ED%81%B4%EB%9E%98%EC%8A%A4/",
        "teaser":null},{
        "title": "[Java]5. 변수와 메서드",
        "excerpt":"5. 변수와 메서드 선언위치에 따른 변수의 종류   인스턴스 변수(instance variable)          클래스 영역에 선언되며, 클래스의 인스턴스를 생성할 때 만들어진다.      인스턴스 변수를 사용하기 위해서는 먼저 인스턴스를 생성해야한다.      독립적인 저장공간을 가지기 때문에 각각의 인스턴스마다 서로 다른 값을 가질 수 있다.      인스턴스마다 고유한 상태를 유지해야하는 속성의 경우, 인스턴스 변수를 사용해야한다.        클래스 변수(class variable)          클래스 변수는 인스턴스 변수 앞에 static을 붙인 형태이다.      모든 인스턴스가 공통된 저장공간(변수)으르 공유한다.      한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야하는 속성의 경우, 클래스 변수를 사용해야한다.      인스턴스 변수와 달리 인스턴스를 생성하지 않고도 언제든지 사용가능하다.      사용 형식은 ‘클래스이름.클래스변수’를 사용하는 것을 권장하며, 이는 인스턴스 변수 사용과 구분하기 위함이다.        지역 변수(local variable)          메서드 내에 선언되어 메서드 내에서만 사용가능하며, 메서드가 종료되면 소멸된다.      for문, while문의 {}블럭내에 선언된 변수도 지역 변수이다.      생성자와 초기화 블럭은 내부적으로 메서드로 취급한다.                  변수의 종류      선언위치      생성시기                  클래스변수      클래스 영역      클래스가 메모리에 올라갈 때              인스턴스변수      클래스 영역      인스턴스가 생성되었을 때              지역변수      클래스 영역 이외의 영역 (메서드, 생성자, 초기화 블럭 내부)      변수 선언문이 수행되었을 때        인스턴스 변수와 클래스 변수 사용 예제&lt;/br&gt;예제 코드 class CardTest {\tpublic static void main(String args[]) {\t\tSystem.out.println(\"Card.width = \" + Card.width);\t\tSystem.out.println(\"Card.height +\" + Card.height);\t\tCard c1 = new Card();  //인스턴스 생성\t\tc1.kind = \"Heart\";     //인스턴스 변수 값 설정\t\tc1.number = 7;         //인스턴스 변수 값 설정   \t\tCard c2 = new Card();  //인스턴스 생성\t\tc2.kind = \"Spade\";     //인스턴스 변수 값 설정\t\tc2.number = 4;         //인스턴스 변수 값 설정\t\tSystem.out.println(\"c1은 \" + c1.kind + \", \" + c1.number + \"이며, 크기는 (\" + c1.width + \", \" + c1.height + \")\");\t\tSystem.out.println(\"c2은 \" + c2.kind + \", \" + c2.number + \"이며, 크기는 (\" + c2.width + \", \" + c2.height + \")\");\t\tSystem.out.println(\"c1의 width와 height를 각각 50, 80으로 변경한다.\");\t\tc1.width = 50;   //클래스 변수 변경\t\tc1.height = 80;\t\t/* 밑과 같이 사용하는 것을 권장한다.\t\tCard.width = 50;  \t\tCard.height = 80;\t\t*/\t\tSystem.out.println(\"c1은 \" + c1.kind + \", \" + c1.number + \"이며, 크기는 (\" + c1.width + \", \" + c1.height + \")\");\t\tSystem.out.println(\"c2은 \" + c2.kind + \", \" + c2.number + \"이며, 크기는 (\" + c2.width + \", \" + c2.height + \")\");\t}}class Card {\tString kind;              //카드의 무늬 - 인스턴스 변수\tint number;               //카드의 숫자 - 인스턴스 변수\tstatic int width = 100;   //카드의 폭   - 클래스 변수\tstatic int height = 250;  //카드의 높이 - 클래스 변수}실행 결과 Card.width = 100Card.height = 250c1은 Heart, 7이며, 크기는 (100, 250)c2은 Spade, 4이며, 크기는 (100, 250)c1의 width와 height를 각각 50, 80으로 변경한다.c1은 Heart, 7이며, 크기는 (50, 80)c2은 Spade, 4이며, 크기는 (50, 80)메서드   메서드는 C/C++에서 사용하는 함수와 동일하다.  메서드의 3가지 특징          높은 재사용성(reusability)      중복된 코드의 제거      프로그램의 구조화      JVM의 메모리구조    메서드 영역(method area)          프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(.class)을 읽어서 분석하여 클래스에 대한 정보(클래스 데이터)를 이곳에 저장한다. 이 때, 그 클래스의 클래스 변수도 이 영역에 함께 생성된다.        힙(heap)          인스턴스가 생성되는 공간으로서, 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다. 즉 인스턴스변수들이 생성되는 공간이다.        호출스택(call back or execution stack)          메서드의 작업에 필요한 메모리 공간을 제공한다. 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당된다.                  이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용된다.                    메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거된다.      첫 번째로 호출된 메서드를 위한 메모리가 호출스택의 맨 밑에 생성되고, 그 다음은 차례로 그 위로 쌓인다.(스택)                  아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.                    호출스택의 제일 상위에 위치한 메서드가 현재 실행 중인 메서드이며, 나머지는 대기상태에 있게 된다.      반환타입이 있는 메서드는 종료되면서 결과값을 자신을 호출한 메서드(caller)에게 반환한다.      매개변수 및 반환   매개변수          기본형 매개변수: 변수의 값을 읽기만 할 수 있다. (read only)      참조형 매개변수: 변수의 값을 읽고 변경할 수 있다. (read &amp; write)        참조형 반환타입: 메서드가 ‘객체의 주소’를 반환한다.  참조형 매개변수 및 반환타입 예제          C/C++의 call by address와 유사하다.&lt;/br&gt;      예제코드 class Data { int x; }class ReferenceReturnEx {\tpublic static void main(String args[]) {\t\tData d = new Data();\t\td.x = 10;\t\tData d2 = copy(d);  //참조형 매개변수, 참조형 타입을 매개변수로 사용한다.\t\tSystem.out.println(\"d.x = \" + d.x);\t\tSystem.out.println(\"d2.x = \" + d2.x);\t}\tstatic Data copy(Data d) {\t\tData tmp = new Data();  //새로운 객체 tmp를 생성한다.\t\ttmp.x = d.x;            //d.x의 값을 tmp.x에 복사한다.\t\treturn tmp;  //참조형 반환타입, 복사한 객체의 주소를 반환한다.\t}}실행결과 d.x = 10d2.x = 10  재귀호출 역시 C/C++과 동일하게 사용가능하다.클래스 메서드(static 메서드)와 인스턴스 메서드   클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통적으로 사용해야하는 것에 static을 붙인다.          생성된 각 인스턴스는 서로 독립적이기 때문에 각 인스턴스 변수(iv)는 서로 다른 값을 유지한다. 그러나 모든 인스턴스에서 같은 값이 유지되어야 하는 변수는 static을 붙여서 클래스변수로 정의해야 한다.        클래스 변수(static 변수)는 인스턴스를 생성하지 않아도 사용할 수 있다.          static이 붙은 변수(클래스 변수)는 클래스가 메모리에 올라갈 때 이미 자동적으로 생성되기 때문이다.        클래스 메서드(static 메서드)는 인스턴스 변수를 사용할 수 없다.          인스턴스 변수는 인스턴스가 반드시 존재해야만 사용할 수 있는데, 클래스 메서드는 인스턴스 생성 없이 호출이 가능하므로 클래스 메서드가 호출되엇었을 때 인스턴스가 존재하지 않을 수도 있다. 반면에 인스턴스 변수나 메서드는 클래스 변수나 메서드를 언제나 사용가능하다.        메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.          클래스 메서드를 사용하면 메서드 호출시간이 짧아지므로 성능이 향상된다. 인스턴스 메서드는 실행 시 호출되어야할 메서드를 찾는 과정이 추가적으로 필요하기 때문에 시간이 더 걸린다.        예제예제코드 class MyMath {\tlong a, b;\t//인스턴스변수 a, b만을 이용해서 작업하므로 매개변수가 필요없다.\tlong add()      { return a + b; }  //a, b는 인스턴스변수\tlong subtract() { return a - b; }\tlong multiply() { return a * b; }\tdouble divide() { return a / b; }\t//인스턴스변수와 관계없이 매개변수만으로 작업이 가능하다.\tstatic long add(long a, long b)          { return a + b; }  //a, b는 지역변수\tstatic long subtract(long a, long b)     { return a - b; }\tstatic long multiply(long a, long b)     { return a * b; }\tstatic double divide(double a, double b) { return a / b; }}class MyMathTest {\tpublic static void main(String args[]) {\t\t//클래스 메서드 호출, 인스턴스 생성없이 호출가능\t\tSystem.out.println(MyMath.add(200L, 100L));\t\tSystem.out.println(MyMath.subtract(200L, 100L));\t\tSystem.out.println(MyMath.multiply(200L, 100L));\t\tSystem.out.println(MyMath.divide(200.0, 100.0));\t\tMyMath mm = new MyMath();  //인스턴스 생성\t\tmm.a = 200L;\t\tmm.b = 100L;\t\t//인스턴스 메서드는 객체생성 후에만 호출이 가능함.\t\tSystem.out.println(mm.add());\t\tSystem.out.println(mm.subtract());\t\tSystem.out.println(mm.multiply());\t\tSystem.out.println(mm.divide());\t}}실행결과 300100200002.0300100200002.0클래스 멤버와 인스턴스 멤버간의 참조와 호출   같은 클래스에 속한 멤버들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조 또는 호출이 가능하다. 하지만, 클래스 멤버가 인스턴스 멤버를 참조 또는 호출하고자하는 경우에는 인스턴스를 생성해야한다.          클래스 멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수도 있기 때문이다.        인스턴스 멤버는 클래스 멤버를 포함하여 언제나 참조 및 호출이 가능하다.","categories": ["Study"],
        "tags": ["Study_Java"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/Java-5.-%EB%B3%80%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C/",
        "teaser":null},{
        "title": "[Java]6. 오버로딩(Overloading)",
        "excerpt":"6. 오버로딩(Overloading) 정의   한 클래스내에 같은 이름의 메서드를 여러 개 정의하는 것을 말한다.          이름이 같지만 매개변수의 개수 또는 타입으로 구분한다.        메서드 오버로딩(method overloading)을 간단히 줄여서 오버로딩이라고 한다.조건   메서드 이름이 같아야 한다.  매개변수의 개수 또는 타입이 달라야 한다.          컴파일러는 같은 이름의 메서드라면 오직 매개변수로만 구분하며, 타입은 영향을 끼치지 않는다.      메서드 이름과 매개변수가 같다면 컴파일러는 중복 정의로 간주하여 에러를 발생시킨다.      예제   잘못된 예제          매개변수의 이름만 다른 경우              컴파일할 경우, ‘add(int, int) is already defined’라는 에러 메시지가 나타난다.      int add(int a, int b) { return a + b; }int add(int x, int y) { return x + y; }  리턴 타입만 다른 경우int add(int a, int b) { return a + b; }long add(int  a, int b) {return (long)(a + b); }  올바른 예제          타입이 다른 두 매개변수의 순서만 다른 경우              이는 사용할 때 순서가 헷갈릴 수 있어 추천하는 방법은 아니다.      long add(int a, long b) { return a + b; }long add(long a, int b) { return a + b; }  추천하는 방식int add(int a, int b) { return a + b; }long add(long a, long b) { return a + b; }long add(int[] a} {\tlong result = 0;\tfor(int i=0; i &lt; a.length; i++) {\t\tresult += a[i];\t}\treturn result;}  대표적인 사용 예제(println)void println()void println(boolean x)void println(char x)void println(char[] x)void println(double x)void println(float x)void println(int x)void println(long x)void println(object x)void println(String x)장점   하나의 메서드로 여러 기능을 사용할 수 있으므로, 기억하기 쉽고 오류를 줄일 수 있다.  메서드의 이름을 절약할 수 있다.가변인자(varargs)와 오버로딩   가변인자: 메서드의 매개변수 개수를 동적으로 지정하는 인자          ‘타입… 변수명’ 형식      가변인자는 매개변수 중 가장 마지막에 선언되어야 한다. (그렇지 않으면 컴파일 에러)      public PrintStream printf(String format, Object... args) {...}  장점          매개변수의 개수를 다르게 사용하기위해 간단히 선언할 수 있다.      인자가 아예 없어도 되고, 배열도 인자가 될 수 있다.                  매개변수를 배열로 할 시 인자를 무조건 지정해주어야 하는 단점이 있다.(길이가 0인 배열(JAVA에서만 가능), null을 사용해야함)                    String concatenate(String... str) {...}System.out.println(concatenate());System.out.println(concatenate(\"a\"));System.out.println(concatenate(\"a\", \"b\"));System.out.println(concatenate(new String[] {\"A\", \"B\"}));  단점          가변인자는 내부적으로 배열을 이용하기 때문에 서언된 메서드를 호출할 때마다 배열이 새로 생성되므로 비효율적이다.      가변인자를 선언한 메서드를 오버로딩하면, 메서드를 호출했을 때 구분하지 못하는 경우가 쉽게 발생하므로 오버로딩을 사용하지 않는 것이 좋다.                  매개변수를 다르게 선언한다 해도 에러가 발생할 확률이 높다.                    ","categories": ["Study"],
        "tags": ["Study_Java"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/Java-6.-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9/",
        "teaser":null},{
        "title": "[Java]7. 생성자(Constructor)",
        "excerpt":"7. 생성자(Constructor) 정의   인스턴스가 생성될 때 호출되는 ‘인스턴스 초기화 메서드’이다.  조건          메서드와 같이 클래스 내부에 선언된다.      생성자의 이름은 클래스의 이름과 같아야 한다.      생성자는 리턴 값이 없다.                  void도 사용하지 않으며, 아무것도 적지 않는다.                      오버로딩이 가능하다.  주의할 점은 연산자 new가 인스턴스를 생성하는 것이며, 생성자는 단지 인스턴스를 초기화하는 것이다.  예제class Card {\tCard() {    //매개변수가 없는 생성자\t\t...\t}\tCard(String k, int num) {    //매개변수가 있는 생성자(오버로딩)\t\t...\t}}  클래스 변수명 = new 클래스(); 동작 과정          연산자 new에 의해 메모리(heap)에 클래스의 인스턴스가 생성된다.      생성자 클래스() 가 호출되어 수행된다.      연산자 new의 결과로, 생성된 클래스 인스턴스의 주소가 반환되어 참조변수 변수명에 저장된다.      기본 생성자(default constructor)   모든 클래스에는 반드시 하나 이상의 생성자가 정의되어 있어야 하지만, 만약 정의되어 있지 않다면 컴파일러가 기본 생성자를 제공한다.  기본 생성자의 형태는 클래스이름() { }이며, 매개변수와 내용은 아무것도 정의되지 않는다.  클래스의 접근 제어자가 ‘public’인 경우의 기본생성자는 public 클래스이름() { }이다.  클래스 내부에 생성자가 하나라도 선언되어 있다면, 기본생성자는 생성되지 않는다.생성자에서 다른 생성자 호출하기 - this(), this   조건          생성자의 이름으로 클래스이름 대신 this를 사용한다.      한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.        잘못된 예제Car(String color) {\tdoor = 5;              //첫 번째 줄\tCar(color, \"auto\", 4); //에러1: 생성자의 두 번째 줄에서 다른 생성자 호출\t                       //에러2: this(color, \"auto\", 4);로 해야함}  특징          밑의 예제에서 1)생성자와 같이 this()를 사용하면, 간략히 표현이 가능하고 유지보수가 쉬운 코드를 만들 수 있다.      3)생성자에서 매개변수(지역변수) 이름과 인스턴스변수가 이름이 같은데 이를 구분하기 위해 참조변수 this를 사용한다.(this를 붙히지 않으면 둘 다 지역변수로 사용된다.)      참조변수 this                  인스턴스 자신을 가리키는 참조변수(인스턴스 주소가 저장되어 있음.)          모든 인스턴스 메서드에 지역변수로 줌겨진 채로 존재한다.          static 메서드(클래스 메서드)에서는 사용할 수 없다.                    생성자 this(), this(매개변수)                  생성자로서, 같은 클래스의 다른 생성자를 호출할 때 사용한다.                    현재 사용하고 있는 인스턴스와 같은 상태를 갖는 인스턴스를 하나 더 만들고자 할 때 생성자의 매개변수에 클래스의 참조변수를 사용할 수 있다.  (밑의 예제 4) 참고)                  같은 내용의 서로 독립적인 인스턴스를 만들 수 있다.&lt;/br&gt;                    예제 코드 class Car {\tString color;\tString gearType;\tint door;\t// 1)\tCar() {\t\tthis(\"White\", \"auto\", 4);  //Car(String color, String gearType, int door) 호출\t}\t// 2)\tCar(String color) {\t\tthis(color, \"auto\", 4);\t}\t// 3)\tCar(String color, String gearType, int door) {\t\tthis.color = color;\t\tthis.gearType = gearType;\t\tthis.door = door;\t}\t// 4) 인스턴스의 복사를 위한 생성자\tCar(Car c) {\t\tcolor = c.color;\t\tgearType = c.gearType;\t\tdoor = c.door;\t\t//this(c.color, c.gearType, c.door); // 더 바람직한 방법\t}}class CarTest {\tpublic static void main(String[] args) {\t\tCar c1 = new Car();\t\tCar c2 = new Car(\"Blue\");\t\tCar c3 = new Car(c1);\t\tSystem.out.println(\"c1 color: \" + c1.color + \", gearType: \" + c1.gearType + \", door: \" + c1.door);\t\tSystem.out.println(\"c2 color: \" + c2.color + \", gearType: \" + c2.gearType + \", door: \" + c2.door);\t\tSystem.out.println(\"c3 color: \" + c3.color + \", gearType: \" + c3.gearType + \", door: \" + c3.door);\t}}실행 결과 c1 color: While, gearType: auto, door: 4c2 color: Blue, gearType: auto, door: 4c3 color: While, gearType: auto, door: 4","categories": ["Study"],
        "tags": ["Study_Java"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/Java-7.-%EC%83%9D%EC%84%B1%EC%9E%90/",
        "teaser":null},{
        "title": "[Java]8. 변수의 초기화",
        "excerpt":"8. 변수의 초기화   멤버변수(클래스 변수와 인스턴스 변수)는 초기화하지 않아도 자동적으로 자료형에 맞는 기본값으로 초기화한다.  지역변수는 사용하기 전에 반드시 초기화해야 한다.  각 타입의 기본값(default value)            자료형      기본값                  boolean      false              char      ‘\\u000’              byte, short, int      0              long      0L              float      0.0f              double      0.0d or 0.0              참조형 변수      null      멤버변수 초기화 방법   명시적 초기화(explicit initialization)  생성자(constructor)  초기화 블럭(initialization block)  명시적 초기화          변수를 선언과 동시에 초기화하는 것을 말한다.      가장 우선시되는 초기화 방법      classs Car {\tint door = 4;              //기본형 변수의 초기화\tEngine e = new Engine();   //참조형 변수의 초기화}  초기화 블럭          클래스 초기화 블럭: 클래스변수의 복잡한 초기화에 사용된다.                  클래스내에 블럭 static { }만들고 그 안에 코드를 작성한다.          클래스가 메모리에 처음 로딩될 때 한 번 수행된다.                    인스턴스 초기화 블럭: 인스턴스변수의 복잡한 초기화에 사용된다.                  클래스 내에 블럭 { } 만들고 그 안에 코드를 작성한다.          생성자와 같이 인스턴스를 생성할 때 마다 수행된다. (생성자보다 인스턴스 초기화 블럭이 먼저 수행된다.)          생성자는 주로 인스턴스 변수의 초기화에 사용되고, 초기화 블럭은 모든 생성자에 공통적으로 수행되어야할 코드를 삽입한다.                    초기화 블럭 내에서 조건문, 반복문, 예외처리구문 등을 사용할 수 있다.&lt;/      예제 코드 class BlockTest {\t//클래스 초기화 블럭\tstatic {\t\tSystem.out.println(\"static { }, 클래스 초기화 블럭\");\t}\t//인스턴스 초기화 블럭\t{\t\tSystem.out.println(\"{ }, 인스턴스 초기화 블럭\");\t}\t//생성자\tpublic BlockTest() {\t\tSystem.out.println(\"생성자\");\t}\tpublic static void main(String[] args) {\t\tSystem.out.println(\"bt1 인스턴스 생성 전\");\t\tBlockTest bt1 = new BlockTest();\t\tSystem.out.println(\"bt1 인스턴스 생성 후\");\t\tSystem.out.println(\"bt2 인스턴스 생성 전\");\t\tBlockTest bt2 = new BlockTest();\t\tSystem.out.println(\"bt2 인스턴스 생성 후\");\t}}실행 결과 static { }, 클래스 초기화 블럭bt1 인스턴스 생성 전{ } 인스턴스 초기화 블럭생성자bt1 인스턴스 생성 후bt2 인스턴스 생성 전{ } 인스턴스 초기화 블럭생성자bt2 인스턴스 생성 후  멤버변수 초기화 시기와 순서          클래스변수의 초기화 시점: 클래스가 처음 로딩될 때 단 한 번 초기화 된다.      클래스변수의 초기화 순서: 기본값 -&gt; 명시적 초기화 -&gt; 클래스 초기화 블럭      인스턴스변수의 초기화 시점: 인스턴스가 생성될 때마다 각 인스턴스별로 초기화가 이루어진다.      인스턴스변수의 초기화 순서: 기본값 -&gt; 명시적 초기화 -&gt; 인스턴스 초기화 블럭 -&gt; 생성자      ","categories": ["Study"],
        "tags": ["Study_Java"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/Java-8.-%EB%B3%80%EC%88%98%EC%9D%98-%EC%B4%88%EA%B8%B0%ED%99%94/",
        "teaser":null},{
        "title": "[Java]9. 상속(Inhertance)",
        "excerpt":"9. 상속(Inhertance) 상속의 정의와 장점 1. 정의   상속: 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다.2. 장점   코드의 재사용성          보다 적은 양의 코드로 새로운 클래스를 작성할 수 있다.        프로그램의 생상성 향상과 유지보수가 간단함          코드를 공통적으로 관리할 수 있기 때문에 코드의 추가 및 변경이 매우 용이하다.      3. 특징   상속의 구현 방법          클래스의 이름 뒤에 상속받고자 하는 클래스의 이름을 키워드 ‘extends‘와 함께 작성하면 된다.      class Child extends Parent {  ... }  용어          조상 클래스: 부모(parent)클래스, 상위(super)클래스, 기반(base)클래스      자손 클래스: 자식(child)클래스, 하위(sub)클래스, 파생된(derived)클래스        상속계층도(class hierarchy)class Parent P { ... }class Child extends Parent { ... }   자손 클래스는 조상 클래스의 모든 멤버를 상속 받으므로 항상 조상 클래스보다 같거나 많은 멤버를 갖는다.          접근 제어자가 private 또는 default인 멤버들은 상속은 받지만 자손 클래스로부터의 접근이 제한된다.        생성자와 초기화 블럭은 상속되지 않는다.  클래스간 관계에서는 형제 관계는 존재하지 않고 오직 상속 관계만 존재한다.4. 예제 예제 코드 class Tv {\tboolean power;  //전원상태(on/off)\tint channel;    //채널\tvoid power() { power = !power; }\tvoid channelUp() { ++channel; }\tvoid channelDown() { --channel; }}class CaptionTv extends Tv {\tboolean caption;   //캡션상태(on/ofF)\tvoid displayCaption(String text) {\t\tif(caption) {    //캡션상태가 true면 해당 text를 출력한다.\t\t\tSystem.out.println(text);\t\t}\t}}class CaptionTvTest {\tpublic static void main(String[] args) {\t\tCaptionTv ctv = new CaptionTv();\t\tctv.channel = 10;                    //조상 클래스로부터 상속받은 멤버\t\tctv.channelUp();                     //조상 클래스로부터 상속받은 멤버\t\tSystem.out.println(ctv.channel);\t\tctv.displayCaption(\"Hello World\");\t\tctv.caption = true;\t\tctv.displayCaption(\"Hello World\");\t}}실행 결과 11Hello World  상속계층도   벤다이어그램   자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다.클래스간의 관계 - 포함(Composite)관계   상속이외에 클래스를 재사용하는 방법으로서, 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것이다.class Point {  int x;   // x좌표  int y;   // y좌표}class Circle {  Point c = new Point();  // 원점 (x, y) 좌표, 포함관계  int r;   // 반지름}클래스간의 관계 결정하기   상속 관계: ‘~은 ~이다. (is-a)’  포함 관계: ‘~은 ~을 가지고 있다. (has-a)’  예제          원(Circle)은 점(Point)를 가지고 있다. =&gt; 포함 관계 (‘원은 점이다’는 어색하다.)      스포츠카(SportsCar)는 차(Car)이다. =&gt; 상속 관계      단일 상속(Single inheritance)   JAVA에서는 단일 상속만을 허용한다.          C++에서는 다중 상속을 허용한다.        단일 상속 특징          클래스 간의 관계가 명확하다.      코드의 신뢰성을 높인다.        다중 상속 특징          여러 클래스로부터 상속을 받을 수 있기 때문에 복합적인 기능을 가지는 클래스를 쉽게 작성할 수 있다.      서로 다른 클래스로부터 상속받은 멤버간의 이름이 같은 경우 구별할 수 있는 방법이 없다. (큰 단점)      Object 클래스 - 모든 클래스의 조상   모든 클래스의 상속계층도의 최상위에는 Object 클래스가 있다.  상속을 명시하지 않는 클래스는 컴파일러가 자동으로 ‘extends Object’를 추가한다.          상속이 명시되어 있다면 추가하지 않는다. (다중 상속이 안되기 때문)      ","categories": ["Study"],
        "tags": ["Study_Java"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/Java-9.-%EC%83%81%EC%86%8D/",
        "teaser":null},{
        "title": "[Java]JAVA 변수와 자료형",
        "excerpt":"JAVA 변수와 자료형 변수와 자료형 정의   변수: 단 하나의 값(data)을 저장할 수 있는 메모리 공간  자료형: 변수에 저장할 값의 유형변수의 명명규칙   대소문자가 구분되며 길이에 제한이 없다.          True와 true는 서로 다른 것으로 간주된다.        예약어를 사용해서는 안 된다.          true는 예약어라서 사용할 수 없지만, True는 가능하다.        숫자로 시작해서는 안 된다.          top10은 허용되지만, 7up은 혀용되지 않는다.        특수문자는 ‘_ ‘ 와 ‘$’ 만을 허용한다.  그 외 프로그래머들간의 규칙          이는 필수는 아니지만 코드의 가독성을 위해 프로그래머들간의 약속이다.      클래스 이름의 첫 글자는 항상 대문자로 한다.                  클래스 이름은 ASCII코드로 하는 것이 좋다.(일부 운영체제에서 유니코드를 인식하지 못한다.)                    변수와 메서드의 이름의 첫 글자는 항상 소문자로 한다.      여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 한다.      상수의 이름은 모두 대문자로 한다.      여러 단어로 이루어진 경우 ‘_ ‘로 구분한다.      상수와 리터럴(constant &amp; literal)   상수: 선언과 동시에 초기화하며, 이 초기화된 값은 변경할 수 없다.(변수 앞에 final 기호를 붙임)  리터럴: 그 자체로 값을 의미하는 것이다.int year = 2014;final int MAX_VALUE = 100;//변수: year//상수: MAX_VALUE//리터럴: 2014, 100기본형(Primitive type)   기본형에는 모두 8개의 자료형이 있으며, 크게 논리형, 문자형, 정수형, 실수형으로 구분된다.논리형   true와 false 중 하나를 값으로 갖으며, 조건식과 논리적 계산에 사용된다.  기본값(default)은 false이다.  두 가지 값만을 사용하므로 1bit만으로 충분하지만 자바의 최소단위가 1byte이기 때문에 논리형의 크기는 1byte이다.            자료형      저장 가능한 값의 범위      bit      byte                  boolean      false, true      8      1      문자형   문자를 저장하기 위한 변수를 선언할 때 사용한다.  자료형은 char 하나이며, 크기는 2byte 이다.            자료형      저장 가능한 값의 범위      bit      byte                  char      0 ~ 2^16 -1,(0 ~ 65535)      16      2        특수 문자            특수 문자      문자 리터럴                         tab      \\t                     backspace      \\b                     form feed      \\f                     new line      \\n                     carriage return      \\r                     역슬래쉬()      \\      ㅅ              작은따옴표      '                     큰따옴표      \"                     유니코드(16진수)문자      \\u유니코드(ex, char a = ‘\\u0041’)             정수형   정수값을 저장하는데 사용된다.  자료형은 byte 크기순으로 byte(1), short(2), int(4), long(8) 이 있다.            자료형      저장 가능한 값의 범위      bit      byte      설명                  byte      -2^7 ~ 2^7-1 (-128 ~ 127)      8      1      성능보다 저장공간을 절약하는 것이 중요할 때 사용된다.              short      -2^15 ~ 2^15-1 (-32,768 ~ 32,767)      16      2      byte타입과 같은 이유로 사용된다.              int      -2^31 ~ 2^31-1 (약 +/-20억)      32      4      JVM의 피연산자 스택은 4byte단위로 저장하기 때문에 같은 크기를 사용하는 int 타입이 가장 효율적이다.              long      -2^63 ~ 2^63-1      64      8      int타입의 범위를 넘어사는 수를 저장할 때 사용된다.(리터럴에 접미사 ‘L’을 붙임)        오버플로우: 연산과정에서 타입이 표현할 수 있는 값의 범위를 넘어서는 것을 말하며, 에러가 발생하지는 않지만 예상할 수 없는 값을 얻게 된다.실수형   실수값을 저장하는데 사용된다.  실수형의 타입은 float와 double 이 있으며, 다른 자료형과 달리 소수점을 표현하기 때문에 정밀도가 존재한다.  해당 리터럴에 접미사 ‘f’, ‘d’ 를 붙여야 한다.  실수형은 큰 값을 표현하는 것과 얼마나 ‘0’에 가깝게 표현할 수 있는가도 중요하다.            자료형      저장 가능한 값의 범위(양수)      정밀도      bit      byte                  float      1.4 * 10^-45 ~ 3.4 * 10^38      7자리      32      4              double      4.9 * 10^-324 ~ 1.8 * 10^308      15자리      64      8        오버플로우: 실수형에서 오버플로우가 발생하면 해당 변수의 값은 무한대가 된다.  언더플로우: 실수형으로 표현할 수 없는 아주 작은 값의 경우 해당 변수의 값은 ‘0’이 된다.  실수형의 저장형식          flaot: 1 + 8 + 23 = 32(4byte)      | S(1) |      E(8)     |         M(23)         ||:—-:|:————-:|:———————:|   double: 1 + 11 + 52 = 64(8byte)| S(1) |        E(11)       |              M(52)              ||:—-:|:——————:|:——————————-:|             기호      의미      설명                  S      부호(Sign bit)      크기: 1 bit, 0이면 양수, 1이면 음수              E      지수(Exponent)      부호있는 정수, 지수의 범위는 float: -127 ~ 128, double: -1023 ~ 1024              M      가수(Mantissa)      실제 값을 저장하는 부분, float: 10진수로 7자리, double: 15자리 정밀도로 저장가능      출력 - printf()   기본 출력            지시자      자료형      설명                  %b      boolean                     %d      int      10진수              %o      int      8진수              %x, %X      int      16진수              %f      float      10진수              %e, %E             지수형태표현              %c      char      문자              %s      string      문자열        특수 출력System.out.printf(\"[%s]%n\", url);      //문자열의 길이만큼 출력공간을 확보한다.System.out.printf(\"[%20s]%n\", url);    //최소 20글자 출력공간 확보(우측정렬)System.out.printf(\"[%-20s]%n\", url);   //최소 20글자 출력공간 확보(좌측정렬)System.out.printf(\"[%.8s]%n\", url);    //왼쪽에서 8글자만 출력int finger = 10;System.out.printf(\"finger = [%5d]%n\", finger);    //finger = [   10]System.out.printf(\"finger = [%-5d]%n\", finger);   //finger = [10   ]System.out.printf(\"finger = [%05d]%n\", finger);   //finger = [00010]","categories": ["Study"],
        "tags": ["Study_Java"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/Java-%EB%B3%80%EC%88%98%EC%99%80%EC%9E%90%EB%A3%8C%ED%98%95/",
        "teaser":null},{
        "title": "[Java]예외처리(exception handing)",
        "excerpt":"예외처리(exception handing) 프로그램 오류   컴파일 에러(compile-time error): 컴파일 시에 발생하는 에러  런타임 에러(runtime error): 실행 시에 발생하는 에러  논리적 에러(logical error): 실행은 되지만, 의도와는 다르게 동작하는 것  자바에서는 실행 시(runtime)에 발생할 수 있는 프로그램 오류를 두 가지로 구분한다.          에러(error): 프로그램 코드에 의해서 수습될 수 없는 심각한 오류를 말한다.                  예를들어, 메모리 부족(OutOfMemoryError)나 스택오버플로우(StackOverflowError)가 있다.                    예외(exception): 프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류를 말한다.      예외 클래스의 계층구조   Exception과 Error클래스 역시 Object클래스의 자손들이다.  밑의 그림은 예외클래스 계층도를 주요 클래스들만을 나열한 모습이다.   Exception클래스는 두 개의 그룹으로 구분할 수 있다.          RuntimeException클래스와 그 자손클래스들                  자손클래스는 ArithmeticException, ClassCastException, NullPointerException, …, IndexOutOfBoundException 클래스 등이 있다.          해당 클래스들은 주로 프로그래머의 실수에 의해 발생될 수 있는 예외들로 자바의 프로그래밍 요소들과 관계가 깊다.          IndexOutOfBoundException: 배열의 범위를 벗어난 경우          NullPointerException: null인 참조변수의 멤버를 호출한 경우          ClassCastException: 클래스의 형변환이 잘못된 경우          ArithmeticException: 정수를 0으로 나누려고하는 경우                    Exception클래스와 그 자손클래스들(RuntimeException과 자손들 제외)                  자손클래스는 IOException, ClassNotFoundException 클래스 등이 있다.          프로그램의 사용자의 실수와 같은 외적인 요인에 의해 발생하는 예외이다.          FileNotFoundException: 존재하지 않은 파일의 이름을 입력한 경우          ClassNotFoundException: 실수로 클래스의 이름을 잘못된 경우          DataFormatException: 입력한 데이터 형식이 잘못된 경우                    예외처리하기 1. try-catch문   예외처리: 프로그램 실행 시 발생할 수 있는 예기치 못한 예외의 발생에 대비한 코드를 작성하는 것이다.  예외처리의 목적은 예외의 발생으로 인한 프로그램의 비정상적인 종료를 막고, 정상적인 실행상태를 유지하는 것이다.  예외를 처리하지 못하면, 프로그램은 비정상적으로 종료되며, JVM의 예외처리기(UncaughtExceptionHandler)에서 처리하지 못한 예외(uncaught exception)를 받아서 그 원인을 출력한다.  try-catch문의 구조try {  //예외가 발생할 가능성이 있는 문장들을 넣는다.} catch(Exception e1) {  //Exception1이 발생했을 경우, 이를 처리하기 위한 문장을 적는다.} catch(Exception e2) {  //Exception2이 발생했을 경우, 이를 처리하기 위한 문장을 적는다.}... catch(Exception eN) {  //ExceptionN이 발생했을 경우, 이를 처리하기 위한 문장을 적는다.}  여러 개의 catch블럭이 올 수 있지만, 이 중 발생한 예외의 종류와 일치하는 단 하나의 catch블럭만 실행된다.  if문과 같은 문법과 달리, 괄호({ })를 절대 생략할 수 없다.  try-catch문은 여러개 반복해서 사용할 수 있고, try-catch문 안에 또 다른 try-catch문의 선언도 가능하다.          중첩된 try-catch문을 사용할 때 같은 이름의 참조변수를 사용해서는 안된다.      2. try-catch문 흐름   try블럭 내에서 예외가 발생한 경우          발생한 예외와 일치하는 catch블럭이 있는지 확인한다.      일치하는 catch블럭을 찾으면, 그 catch블럭 내의 문장들을 수행하고 전체 try-catch문을 빠져나가서 그 다음 문장을 계속해서 수행한다.(try블럭 내의 예외 발생 시점 밑의 코드들은 수행하지 않는다.)      일치하는 catch블럭을 찾지 못하면, 예외는 처리되지 못한다.        tyr블럭 내에서 예외가 발생하지 않은 경우          catch블럭을 거치지 않고 전체 try-catch문을 빠져나가서 계속해서 수행한다.      3. catch블럭   예외가 발생했을 때, 생성되는 예외 클래스의 인스턴스에는 발생한 예외에 대한 정보가 담겨져 있으며, getMessage()와 printStackTrace()를 통해서 이 정보에 접근가능하다.  printStackTrace(): 예외발생 당시의 호출스택(Call Stack)에 있었던 메서드의 정보와 예외 메시지를 화면에 출력한다.          printStackTrace(PrintStream s)나 printStackTrace(PrintWriter s)를 통해 예외에 대한 정보를 파일에 저장할 수도 있다.        getMessage(): 발생한 예외클래스의 인스턴스에 저장된 메시지를 얻을 수 있다.                              멀티 catch블럭: JDK1.7부터 여러 catch블럭을 ‘          ‘기호를 이용해서 하나의 catch블럭으로 합칠 수 있다.                            조상과 자손 관계를 연결 시킬수는 없다.      예외 클래스들의 공통 분모인 조상 예외 클래스에 선언된 멤버만을 사용할 수 있고, 참조변수는 ‘e’로 고정된다.        기존 catch 블럭 코드     try {  ...} catch (ExceptionA e) {  e.printStackTrace();} catch (ExceptionB e2) {  e2.printStackTrace();}        멀티 catch 블럭 코드     try {  ...} catch (ExceptionA | ExceptionB e) {  e.printStackTrace();}      예외 발생시키기   키워드 ‘throw’를 사용해서 프로그래머가 고의로 예외를 발생시킬 수 있다.  사용 방법          연산자 new를 이용해서 발생시키려는 예외 클래스의 객체를 만든다. Exception e = new Exception(\"고의로 발생시킴\");      키워드 throw를 이용해서 예외를 발생시킨다. throw e;        예외를 고의로 발생시켰다면, 반드시 그 예외에 대한 처리를 해주어야 한다.(try-catch문)          Exception 클래스(checked 예외)의 경우, 처리를 해주지 않으면 컴파일 단계에서 오류가 발생한다.      RuntimeException 클래스(unchecked 예외)의 경우, 컴파일에는 성공하지만 비정상적으로 종료된다.      메서드에 예외 선언하기   try-catch문 외에, 메서드의 선언부에 키워드 ‘throws’를 사용해서 메서드 내에서 발생할 수 있는 예외를 선언해주면 된다.          예외가 여러개일 경우, 쉼표(,)로 구분하고, 키워드 ‘throw’와 구분해야 한다.      void method() throws Exception1, Exception2, ... ExceptionN {  //메서드 내용}  메서드의 선언부에 예외를 선언함으로써, 메서드를 사용하려는 사람이 해당 메서드를 사용하기 위해 어떠한 예외들을 처리해야 하는지 알려 줄 수 있다.          예외 발생 가능성을 예측해야 하는 프로그래머들의 수고를 덜어주고, 보다 견고한 프로그램 코드를 작성할 수 있다.      특히, JAVA API 작성된 메서드를 사용할때 보다 정확히 사용할 수 있다.        대부분 RuntimeException클래스는 적어 주지 않고, 반드시 처리해주어야 하는 예외들만 선언한다.  예외가 발생한 메서드에서 예외처리를 해주지 않으면, 그 메서드를 호출한 메서드에게 예외를 넘겨준다.          예외가 발생하면, 해당 메서드나 호출한 메서드 둘 중 한 곳에서는 예외 처리를 해주어야 한다.      finally 블럭   finally블럭은 try-catch문과 함께 예외의 발생여부에 상관없이 실행되어야할 코드를 포함 시킬 목적으로 사용한다.try {  //예외가 발생할 가능성이 있는 문장들} catch(Exception1 e1) {  //예외처리를 위한 문장} finally {  //예외의 발생여부에 관계없이 항상 수행되어야하는 문장들}  finally블럭은 try-catch문의 맨 마지막에 위치해야 한다.  실행 순서는 다음과 같다.          예외 발생: try -&gt; catch -&gt; finally      그 외: try -&gt; finally        try블럭에 return문이 있은 경우에도, finally블럭을 실행한 후에 return문이 실행된다.자동 자원 반환 - try-with-resourced문   JDK1.7부터 try-with-resourced문이라는 try-catch문 번형이 새로 추가되었다.  주로 입출력(I/O)과 관련된 클래스를 사용할 때 주로 사용된다.          입출력이 끝난 자원을 반환할 때, finally문을 사용한다고 해도 여기서 오류가 발생하면 처리해줄 수 없기 때문에 try-with-resourced문을 사용한다.        예제try(fis = new FileInputStream(\"score.dat\");    dis = new DataInputStream(fis)) {  while(true) {    score = dis.readInt();    System.out.println(score);    sum += score;  }} catch(EOFException e) {  System.out.println(\"점수의 총합은 \", + sum + \"입니다.\");} catch(IOException ie) {  ie.printStackTrace();}  try-with-resourced문dml 괄호()안에 객체를 생성하는 문장을 넣으면, 이 객체는 따로 close()를 호출하지 않아도 try블럭을 벗어나는 순간 자동으로 close()가 호출된다.          그 다음에 catch블럭 또는 finally블럭이 수행된다.        괄호()안에 두 문장 이상을 넣을 경우 세미콜론(;)으로 구분해주고, 변수 선언도 가능하다.          선언된 변수는 try블럭안에서만 사용가능하다.      사용자 정의 예외   프로그래머가 직접 Exception클래스로부터 상속을 받아 클래스를 만들거나, 필요에 따라 새로운 예외 클래스를 만들 수 있다.          기존 예외 클래스를 상속받아 만드는 것을 추천한다.        예제class MyException extends Exception {  privatee final int ERR_CODE;  //생성자  MyException(String msg, int errCode) {    super(mag);            //조상인 Excepton클래스의 생성자를 호출한다.    ERR_CODE = errCode;  }  //생성자  MyException(String msg) {    this(msg, 100);        //ERR_CODE를 100을 기본값으로 초기화한다.  }  //에러 코드를 얻을 수 있는 메서드  public int getErrCode() {    return ERR_CODE;  }}예외 되던지기(exception re-throwin)   하나의 예외에 대해서 예외가 발생한 메서드와 호출한 메서드 양쪽에서 처리하고자 할때, 예외 되던지기 방법을 사용한다.  예외 되던지기는 예외를 처리한 후에 인위적으로 다시 발생시키는 것을 말한다.  예외가 발생한 메서드에서는 try-catch문으로 예외를 처리해줌과 동시에 메서드의 선언부에 발생할 예외를 throws에 지정해줘야 한다.  예제class ExceptionEX {  public static void main(String[] args) {    try {      method1();    } catch(Exception e) {      System.out.println(\"main메서드에서 예외가 처리되었습니다.\");    }  }  static void method1() throws Exception {    try {      throw new Exception();    } catch(Exception e) {      System.out.println(\"method1메서드에서 예외가 처리되었습니다.\");      throw e;   //다시 예외를 발생시킨다.    }  }}결과 화면 method1메서드에서 예외가 처리되었습니다.main메서드에서 예외가 처리되었습니다.연결된 예외(chained exception)   한 예외가 다른 예외를 발생시킬 수 있다.          예를 들어, A가 예외 B를 발생시켰다면, A를 B의 ‘원인 예외(cause exception)’라고 한다.      Throwable initCause(Throwable cause)   //지정한 예외를 원인 예외로 등록Throwable getCause()                   //원인 예외를 반환  연결된 예외를 사용하는 이유          여러가지 예외를 하나의 큰 분류의 예외로 묶어서 다루기 위함이다.      checked예외를 unchecked예외로 바꾸기 위함이다.      ","categories": ["Study"],
        "tags": ["Study_Java"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/Java-%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC/",
        "teaser":null},{
        "title": "[Kotlin]1. 코틀린이란?",
        "excerpt":"코틀린(Kotlin)이란? 코틀린 소개   코틀린은 인텔리제이(IntelliJ IDEA)라는 제품으로 유명한 JetBrains에서 만든 언어로, 2011년 최초로 공개된 후 오랜 시간 개발을 거쳐 2016년 2월1.0 정식 버전이 출시되었다.  코틀린의 목표는 간결한 문법, 풍부한 기능, 높은 안정성을 토대로 높은 생산성을 보장하는 것이다.  코틀린은 자바와 100% 호환되기 때문에, 한 프로젝트에 혼합해서 사용할 수 있다.  구글 I/O 2017에서 안드로이드 공식 지원 언어로 채택되었다.코틀린 특징 1. 간결한 문법   코틀린 문법은 자바에 비해 더 간결한 형태를 추구한다.  자바와 주요 차이점          문장 끝에 세미콜론(;)을 넣지 않아도 된다.      new 키워드를 쓰지 않고 객체를 생성한다.      타입 추론을 지원하므로 일반적인 경우 타입을 적지 않아도 된다.        예제자바 코드 String name = \"John Smith\"Person person = new Person(name);코틀린 코드 val nmae = \"John Smith\"val person = Person(name)2. 널 안정성   객체 타입의 변수에서 널(null) 값의 허용 여부를 구분하지 않던 자바와 달리, 코틀린은 이를 명확히 구분한다.  널 값의 허용 여부를 컴파일 단계에서 검사하므로 런타임에서 발생하는 오류를 대폭 줄일 수 있다.  예제// 널 값을 허용하는 문자열 타입(String?)val foo: String? = null// 널 값을 허용하지 않는 문자열 타입(String)val bar: String  = \"bar\"3. 가변/불변 구분   코틀린에서는 변수 및 변수 내 할당된 값의 불변 여부를 구분한다.          불변 여부: 최초 생성 시 할당된 값을 이후에도 변경할 수 있는지 여부        키워드 ‘val’: 값을 한번 할당하고 나면 그후에 변경할 수 없다.          자바의 키워드 ‘final’과 유사하다.        키워드 ‘var’: 할당된 값을 자유자재로 변경할 수 있다.  변수와 마찬가지로 컬렉션 자료형에 대해서도 불변 여부를 구분한다.4. 람다 표현식 지원   코틀린에서는 람다 표현식을 기본으로 지원한다.5. 스트림 API 지원   코틀린에서는 컬렉션 내 자료를 다루는데 유용한 스트림(stream) API를 표준 라이브러리에서 제공한다.6. 완벽한 자바 호환성   코틀린에서 자바를 사용하는 것과 자바에서 코틀린을 사용하는 것이 모두 가능하다.  자바 라이브러리와도 모두 호환된다.  혼용 시 유의해야 하거나 사용 방법이 약간 다른 부분이 있으니 주의해야한다.","categories": ["Study"],
        "tags": ["Study_Kotlin"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/Kotlin-1.%EC%BD%94%ED%8B%80%EB%A6%B0%EC%9D%B4%EB%9E%80_/",
        "teaser":null},{
        "title": "[Kotlin]2. 기본 자료형",
        "excerpt":"기본 자료형 특징   자바의 자료형은 원시 타입과 참조 타입 두 가지로 나뉜다.          원시 타입(primitive type; int, double 등): 값 자체를 저장함.      참조 타입(reference type; String 등): 객체의 참조 값을 저장함.        코틀린은 모든 타입을 객체로 표현한다.          원시 타입과 래퍼(wrapper; Integer, Double 등)클래스를 구분하지 않는다.                  wrapper class: 기본 자료형을 객체로 사용하기 위해 기본 자료형 값을 객체로 포장해주는 클래스                    자바의 원시 타입 및 래퍼 클래스를 코틀린에서 사용하는 자료형으로 처리한다.        코틀린 코드를 작성하는 시점에서는 원시 타입과 래퍼를 구분하지 않지만, 컴파일 단계를 거치면서 가장 효율적인 타입으로 변환된다.          값이나 변수 타입으로 사용되는 경우: 원시 타입으로 변환      컬렉션의 타입 인자로 사용되는 경우: 래퍼로 변환      컴파일 단계는 intelliJ 플랫폼에서 디컴파일 하는 기능으로 컴파일 단계의 자바코드를 확인할 수 있다.                  Java(원시 타입)      Java(래퍼)      Kotlin                  byte      java.lang.Byte      kotlin.Byte              short      java.lang.Short      kotlin.Short              int      java.lang.Integer      kotlin.Int              long      java.lang.Long      kotlin.Long              char      java.lang.Character      kotlin.Char              float      java.lang.Float      kotlin.Float              double      java.lang.Double      kotlin.Double              boolean      java.lang.Boolean      kotlin.Boolean      숫자   숫자를 표현하는 모든 자료형은 Number 클래스를 상속합니다.  자료형 변환          코틀린은 작은 타입이 큰 타입으로 대입될 때, 자동으로 형변환을 해주지 않는다.(무조건 명시적 변환을 해주어야 함)                  java.lang.Number      kotlin.Number                  byte byteValue()      fun toByte(): Byte              없음      fun toChar(): Char              double doubleValue()      fun toDouble(): Double              float floatValue()      fun toFloat(): Float              int intValue()      fun toInt(): Int              long longValue()      fun toLong(): Long              short shortValue()      fun toShort(): Short        리터럴(Literal) 표기법          Long 타입은 대문자 ‘L’을 사용하는 것 외에는 자바와 모두 동일하다.      val dec: Int = 100val hex: Int = 0x100val binary: Int = 0b100val longValue: Long = 100Lval doubleValue: Double = 100.1 //(= 1.001e2)val flaotValue: Float = 100.0f  숫자 연산에 사용하는 사칙연산(+, -, *, /)은 자바와 동일하지만, 비트 연산자의 이름은 좀더 직관적으로 바뀌었다.            Java      Kotlin      의미                         &amp;      and      비트 연산 AND                                   or      비트 연산 OR              ^      xor      비트 연산 XOR                     ~      inv      비트 연산 NOT                     «      shl      왼쪽으로 시프트(부호 비트 유지)                     »      shr      오른쪽으로 시프트(부호 비트 유지)                     »&gt;      ushr      오른쪽으로 시프트(부호 비트 무시)             문자   코틀리은 자바와 달리 문자 자료형에 숫자의 형태로 대입할 경우 컴파일 에러가 발생한다.          해당 문자의 아스키 코드 값을 알고 싶을 때, toChar()를 사용하여 위 문제를 해결할 수 있다.      논리   논리 연산자는 자바와 동일하다. (Boolean 사용)문자열   String 클래스로 표현하며, 자바와 거의 동일하다.  get() 메서드 혹은 대괄호([])와 인덱스를 통해 특정 문자에 접근 가능하다.  문자열 리터럴          escaped string(“ “): 전통 적인 방식으로 자바와 거의 동일하다.      raw string(“”” “””): 개행이나 어떠한 문자열도 사용가능하다.        val espstr = \"Hello, kotlin!\"val rawstr = \"\"\"\"Hello, kotlin.I'm John.\"\"\"\"      배열   자바에서는 배열 타입이 별도로 존재하지만, 코틀린에서의 배열은 타입 인자를 갖는 Array클래스로 표현한다.  get(), set(), [], size 등 다양한 기능을 제공한다.  예제val words: Array&lt;String&gt; = arrayOf(\"Lorem\", \"ipsum\", \"dolor\", \"sit\")val intArr: IntArray = intArrayOf(1, 2, 3, 4, 5)            Java      Kotlin                  byte[]      kotlin.ByteArray              double[]      kotlin.DoubleArray              float[]      kotlin.FloatArray              int[]      kotlin.IntArray              long[]      kotlin.LongArray              short[]      kotlin.ShortArray      ","categories": ["Study"],
        "tags": ["Study_Kotlin"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/Kotlin-2.%EA%B8%B0%EB%B3%B8%EC%9E%90%EB%A3%8C%ED%98%95/",
        "teaser":null},{
        "title": "[Kotlin]3. 컬렉션(collection)",
        "excerpt":"컬렉션(collection) 개요   코틀린에서 컬렉션은 자바에서 제공하는 클래스들을 그대로 사용합니다.  코틀린의 컬렉션은 타입 별칭(type alias)을 사용하여 컬럭션 내 다른 클래스와의 일관성을 유지한다.  컬렉션 내 자료의 수정 가능 여부에 따라 컬렉션의 종류를 구분한다.          이는 새로운 타입을 선언하는 것이 아닌, 인터페이스를 통해 사용 가능한 함수를 제한하는 방식으로 구현된다.        자바의 List 인터페이스 상속 관계도   코틀린의 List 인터페이스 상속 관계도          컬렉션 내 자료를 수정 할 수 있는 가변 타입(mutable)과 수정이 불가능한 불변 타입(immutable)로 구분된다.         코틀린은 가변/불변 타입의 컬렉션이 있지만, 자바에서는 모두 가변 타입의 컬렉션이다. 그러므로 혼용 시에 이를 주의 해야 한다.          코틀린의 불변 타입 컬렉션을 자바로 변경 시 가변 타입의 컬렉션이 된다.        컬렉션은 배열과 마찬가지로 표준 라이브러리에서 쉽게 생성하는 함수를 제공한다.          일부 타입은 타입 별칭을 사용하므로 실제 반환되는 타입이 따로 존재한다.                  함수명      자료 수정가능 여부      반환 타입(실제 타입)                  listOf()      X      kotlin.collections.List              arrayListOf()      O      kltlin.collections.ArrayList(java.util.ArraryLsit)              setOf()      X      kltlin.collections.Set              hashSetOf()      O      kltlin.collections.HashSet(java.util.HashSet)              linkedSetOf()      O      kltlin.collections.LinkedHashSet(java.util.LinkedHashSet)              sortedSetOf()      O      kltlin.collections.TreeSet(java.util.TreeSet)              mapOf()      X      kltlin.collections.Map              hashMapOf()      O      kltlin.collections.HashMap(java.util.HashMap)              linkedMapOf()      O      kltlin.collections.LinkedHashMar(java.util.LinkedHashMap)              sortedMapOf()      O      kltlin.collections.SortedMap(java.util.SortedMap)        예제예제 코드 //자료를 수정할 수 없는 리스트 생성val immutableList: List&lt;String&gt; = listOf(\"Lorem\", \"ipsum\", \"dolor\", \"sit\")//컴파일 에러: 자료 수정을 위한 함수를 지원하지 않음immutableList.add(\"amet\")//자료를 수정할 수 있는 리스트 생성val mutableList: MutableList&lt;String&gt; = arrayListOf(\"Lorem\", \"ipsum\", \"dolor\", \"sit\")//자료 수정 가능mutableList.add(\"amet\")//자료를 수정하지 않는 자료형으로 재할당val immutableList2: List&lt;String&gt; = mutatbleList//컴파일 에러: 자료 수정을 위한 함수를 지원하지 않음immutableList2.add(\"amet\")","categories": ["Study"],
        "tags": ["Study_Kotlin"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/Kotlin-3.%EC%BB%AC%EB%A0%89%EC%85%98/",
        "teaser":null},{
        "title": "[Kotlin]4. 클래스 및 인터페이스",
        "excerpt":"클래스 및 인터페이스 클래스와 인터페이스의 선언 및 인스턴스 생성 1. 클래스   클래스를 선언하는 방법은 자바와 거의 동일하다.  예제예제 코드 //패키지 foo.bar에 포함된 클래스 Baz선언package foo.barclass Baz {  ---}//클래스 본체 없이 클래스를 선언할 수 있다.class Foo  코틀린에서 접근 제한자를 지정하지 않는 경우 public으로 간주한다.  코틀린에서는 키워드 ‘new’없이 인스턴스 생성이 가능하다.  예제예제 코드 val foo: Foo = Foo()//인자 하나를 받는 생성자로 인스턴스 생성val bar: Bar = Bar(1);2. 인터페이스   인터페이스의 생성은 자바와 비슷하지만, 인터페이스의 인스턴스 생성은 조금 다르다.  예제예제 코드 //인터페이스 선언interface Bar {  fun baz()}//인터페이스의 인스턴스 생성//object: [인터페이스 이름] 형태val bar = object: Bar {  override fun baz() {    //함수 구현  }}추상 클래스(abstract class)   추상 클래스의 선언 방법은 자바와 동일하지만, 인스턴스 생성은 다르며, 코틀린의 인터페이스의 인스턴스 생성과 유사하다.  추상 클래스에서는 인스턴스 생성 시 생성자를 사용하지만, 생성자가 없는 인스턴스는 인스턴스 이름만 사용한다.  예제예제 코드 //추상 클래스 선언abstract class Foo {  abstract fun bar()}//추상 클래스의 인스턴스 생성//object: [생성자] 형태val foo = object: Foo() {  override fun bar() {    //함수 구현  }}프로퍼티(property)   프로퍼티는 자료를 저장할 수 있는 필드(field)와 이에 상응하는 Getter/Setter 메서드를 함께 제공하며, 자바의 필드와 유사한 형태로 선안한다.          자바는 클래스내의 멤버함수에 접근하기 위해 Getter/Setter 메서드를 직접 추가해주어야 하기 때문에 코드의 양이 불필요하게 늘어난다.        프로퍼티 역시 ‘val’와 ‘var’ 중 하나로 선언해야 한다.          val: Getter 메서드만 존재한다.      var: Getter/Setter 메서드 모두 존재한다.        프로퍼티는 초기값을 명시적으로 지정해야 하며, 그렇지 않은 경우 컴파일 에러가 발생한다.  프로퍼티 선언 시점이나 생성자 호출 시점에 값을 할당하지 않을 경우 ‘lateinit’ 키워드를 사용하여 초기 할당없이 사용할 수 있다.          키워드 ‘lateinit’은 프로퍼티 값을 나중에 할당할 것이라고는 것을 명시하는 것으로서, ‘var’ 프로퍼티에만 사용가능하다.        프로퍼티 역시 타입 추론이 가능하기 때문에 타입 선언을 생략할 수 있다.  예제예제 코드 class Person {  //기본 예제  val name: String? = null  var address: String? = null  //lateinit  lateinit var adderss: String?  //타입 추론  var name = \"No Name\"  var address: String? = null  //null만으로는 타입을 추론할 수 없기 때문에 타입 선언이 필요하다.}접근 제한자   접근 제한자는 자바와 거의 동일하다.          제한자가 없으면 자동으로 public으로 간주한다.        자바와 다르게 ‘internal’ 접근 제한자가 존재한다.          자바에서 public의 접근 범위는 동일한 패키지 안이다. 하지만 외부 모듈이라도 패키지 이름이 같다면 접근이 가능하다.      위를 보완하기 위해 코틀린에서는 internal 접근 제한자를 제공한다.        ‘internal’ 접근 제한자의 범위는 동일한 모듈 내이다.          IntelliJ IDEA 모듈      Maven/Gradle 프로젝트      하나의 Ant 태스크 내에서 함께 컴파일되는 파일들      생성자 1. 기본 생성자   코틀린의 기본 생성자는 자바보다 더욱 직관적으로 정의한다.          init {} 사용        예제_ 예제 코드_ class Foo {  init {    //생성자에서 수행할 작업들...  }}2. 주 생성자(primary constructor)   생성자에 인자가 필요한 경우 주 생성자를 활용한다.  주 생성자로 클래스 내부의 프로퍼티를 대신해서 사용할 수 있으므로, 프로퍼티를 생략할 수 있다.  예제예제 코드 //기본 생성자에서 주 생성자의 인자를 사용할 수 있다.class Foo(a: Int) {  init {    Log.d(\"Foo\", \"Number: $a\")  }}//프로퍼티 대신 주 생성자를 사용할 수 있다.class Foo(val a: Int, var b: Char)3. 추가 생성자   주 생성자 외에 다른 형태의 생성자가 필요한 경우 ‘constructor’ 키워드를 사용하여 추가 생성자를 선언할 수 있다.  추가 생성자를 정의하는 경우 주 생성자를 반드시 호출해야 한다.  추가 생성자에서는 인자와 프로퍼티를 함께 선언할 수 없다.          프로퍼티 선언이 필요한 인자인 경우 반드시 주 생성자에서 이를 처리해야 한다.      예제        예제 코드     class Foo(val a: Int, var b: Char) {  //a값만 인자로 받는 추가 생성자  constructor(a: Int) : this(a, 0)  //두 인자의 값을 모두 0으로 지정하는 생성자  constructor() : this(0, 0)}      4. 생상자의 접근 제한자   생성자의 가시성을 변경하려면 constructor 키워드 앞에 접근 제한자를 추가하면 된다.  주 생성자는 생략하였던 constructor 키워드를 추가하고 그 앞에 접근 제한자를 추가해야 한다.  예제예제 코드 class Foo internal constructor(val a: Int, var b: Char) {  private constructor(a: Int) this(a, 0)  // 접근 제한자를 지정하지 않았으므로 public  constructor(): this(0, 0)}함수(function)   코틀린은 자바의 클래스 내 메서드를 함수로 표현한다.  함수에서 특별한 값을 반환하지 않는다면 ‘함수 자체’를 의미하는 Unit 타입을 반환하며, 이는 생략 할 수 있다.  예제예제 코드 class Foo {  //아무 값도 반환하지 않는 함수, 생략 가능  fun foo(): Unit { }  //정수 값을 반환하는 함수  private fun bar(): Int {    return 0  }}상속 및 인터페이스 구현   코틀린에서 상속 및 인터페이스는 키워드로 구분하는 자바와 달리 콜론(:) 뒤에 상속한 클래스나 구현한 인터페이스를 표기한다.  클래스를 상속하는 경우 반드시 부모 클래스의 생성자를 호출해야 한다.          부모 클래스의 생성자가 여러 개일 경우, 클래스의 선언부가 아닌 내부에서 호출할 수도 있다.        코틀린에서 부모 클래스의 메서드 재정의, 인터페이스 구현한 메서드는 앞에 ‘override’ 키워드를 반드시 붙여야 한다.          자바에서 이를 ‘@Override’ 어노테이션으로 구분하는데, 이는 선택 사항이다.        코틀린에서는 ‘open’ 키워드를 붙인 클래스나 함수만이 상속이나 재정의를 할 수 있다.          자바에서는 ‘final’ 키워드로 더 이상 상속이나 재정의를 할 수 없도록 한다.        예제예제 코드 // AppCompatActivity 상속: AppCompatActivity()로 기본 생성자를 바로 호출한다.// View.OnClickListener 구현class MyActivity: AppCompatActivity(), View.OnClickListener {  // AppCompatActivity의 onCreate() 메서드 상속  override fun onCreate(savedInstanceState: Bundle?) {    super.oncreate(savedInstanceState)  }  // View.OnClickListener 인터페이스 구현  override fun onClick(v: View) { }}// 'open' 키워드 사용 예제open class OpenClass {  open val openProperty = \"foo\"  val finalProperty = \"bar\"  open fun openFunc() { }  fun finalFunc() { }}// 성공: OpenClass 앞에 'open' 키워드가 있으므로 상속 가능한 클래스이다.class FinalClass : OpenClass() {  // 성공: '부모 클래스의 openProperty 변수 앞에 'open' 키워드가 있으므로 재정의가 가능한 프로퍼티이다.  override val openProperty = \"FOO\"  // 실패: 해당 프로퍼티에 'open' 키워드가 없다.  override val finalProperty = \"BAR\"  // 성공: '부모 클래스의 openFunc 함수 앞에 'open' 키워드가 있으므로 재정의가 가능한 함수이다.  override open fun openFunc() { }  // 실패: 해당 함수에 'open' 키워드가 없다.  override fun finalFunc() { }}// 실패: 해당 클래스에 'open' 키워드가 없다.class Foo : FinalClass()this   코틀린의 this 키워드는 자바와 거의 동일하다.  자바에서 {클래스 이름}.this를 코틀린에서는 this@{클래스 이름} 형태로 사용된다.정적 필드 및 메서드   코틀린에서는 자바와 달리 정적 필드와 메서드를 사용하여, 클래스 내에 상수를 정의하거나 static 메서드(인스턴스 생성 없이 사용할 수 있는 메서드)를 정의할 수 없다.  일반적인 경우 클래스 내에 선언했던 정적 필드나 메서드는 패키지 단위(package-level)로 선언할 수 있다.  패키지 단위로 선언한 값이나 함수는 패키지에 종속되므로 import {패키지 이름}.{값 혹은 함수 이름}으로 사용해야 한다.  예제자바 코드 //Foo.javapackage foo.bar;public class Foo {  //정적 필드 상수 선언  public static final int FOO = 123;  //정적(static) 메서드 선언  public static void foo() { }  //인스턴스 메서드: 인스턴스를 생성해야 사용할 수 있는 메서드  public void bar() { }}import foo.bar.Foo;public class Bar {  public void bar() {    //Foo클래스 내의 정적 필드 FOO의 값을 참조한다.    int foo = foo.Foo;    //Foo 클래스 내의 정적 메서드 foo를 호출한다.    Foo.foo();  }}코틀린 코드 //Foo.ktpackage foo.bar//값 FOO를 패키지 foo.bar에 선언한다.const val FOO = 123//함수 foo를 패키지 foo.bar에 선언한다.fun foo()class Foo {  //함수 bar는 Foo의 인스턴스를 생성해야 사용할 수 있다.  fun bar() { }}import foo.bar.Fooimport foo.bar.fooclas Bar {  //foo.bar 패키지 내의 FOO 값을 참조한다.  val foo = Foo  //foo.bar 패키지 내의 함수 foo를 호출한다.  foo()}  클래스 내 private로 선언된 멤버에 접근해야 하는 팩토리 메서드(factory method)는 패키지 단위 함수로 구현할 수 없다.          동반 객체(companion object)를 사용하면 클래스 내 모든 멤버에 접근할 수 있고, 인스턴스 생성 없이 호출가능한 함수를 작성할 수 있다.      동반 객체: 클래스별로 하나씩 클래스의 인스턴스 생성 없이 사용할 수 있는 오브젝트(object)를 정의할 수 있는데, 이를 동반 객체라 한다.      예제        class User private constructor(val name: String, val registerTime: Long) {  companion object {    //동반 객체는 클래스 내부에 존재하므로, private로 선언된 생성자에 접근할 수 있다.    fun create(name: String) : User {      return User(name, System.currentTimeMillis())    }  }}      싱글톤(singleton)   싱글톤은 단 하나의 인스턴스만 생성되도록 제약을 둔 디자인 패턴이다.  코틀린에서는 이를 단 한줄로 간편하게 선언할 수 있다.  예제object singletonenum 클래스 어노테이션 클래스(annotation class) 중첩 클래스(nested class) ","categories": ["Study"],
        "tags": ["Study_Kotlin"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/Kotlin-4.%ED%81%B4%EB%9E%98%EC%8A%A4%EB%B0%8F%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/",
        "teaser":null},{
        "title": "[Kotlin]5. 코틀린만의 클래스",
        "excerpt":"코틀린만의 클래스 데이터 클래스(data class)   데이터 클래스는 자료만을 저장하기 위해 사용하는 클래스이다.(메서드 없음)  사용 예제data class Person(val name: String, val address: String)  기본 생성자에서 선언된 속성을 통해, 컴파일러에서 자동으로 아래의 기능들을 만들어준다.          equals()      hashCode()      copy()      toString()      componentN() functions      만약 명시적으로 클래스 내에 선언해주는 경우, 해당 메서드는 컴파일러가 자동으로 생성해주지 않는다.        의미 있는 데이터 클래스 조건          기본 생성자에 1개 이상의 파라미터가 존재한다.      기본 생성자의 파라미터가 val, var로 선언되어 있다.      abstract, open, inner 키워드는 사용할 수 없다.      interface 구현과 한정 클래스(sealed class) 상속은 가능하다.        데이터 클래스는 componentN 함수를 사용하여, Destructuring Declarations가 가능하다.val person = User(\"Jane\", 35)val (name, age) = personprintln(\"$name, $age years of age\")// prints: \"Jane, 35 years of age\"한정 클래스(sealed class)   한정 클래스는 enum 클래스를 확장한 개념이다.          각 종류별로 하나의 인스턴스만 생성되어 있는 enum 클래스와 달리 잉ㄴ스턴스를 여러 개 생성 가능하다.        사용 예제// MoblieApp 한정 클래스와 이를 상속하는 Android, IOS 클래스sealed class MobileApp(val os: String) {  class Android(os: String, val packageName: String) : MobileApp(os)  calss IOS(os: String, val bundleId: String) : MobileApp(os)}  한정 클래스를 상속하는 클래스는 일반적으로 한정 클래스 내에 중첩하여 선언한다.          같은 파일 내에 정의한다면 클래스 외부에 선언 할수도 있다.        한정 클래스를 상속하는 클래스는 한정 클래스의 한 종류로 취급된다.  한정 클래스의 장점          한정 클래스로 취급된 여러 종류의 클래스마다 다른 작업을 처리해야할 때 유용하다.      임의의 클래스가 한정 클래스로 추가되었을 때 처리하는 작업이 간단하다.      대표적인 예제로 한정 클래스들로 when문을 처리할 때 이다.      프로퍼티의 사용자 지정 Getter/Setter   코틀린은 프로퍼티를 선언하면 자동으로 Getter/Setter를 내부에서 제공한다.  Getter/Setter 함수를 사용자가 필요에 맞게 수정하여 사용할 수 있다.          프로퍼티 선언과 함께 get(), set(value)로 같이 선언하면 된다.        선언 형식var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [=property_initializer&gt;]  [&lt;getter&gt;]  [&lt;setter&gt;]","categories": ["Study"],
        "tags": ["Study_Kotlin"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/Kotlin-5.%EC%BD%94%ED%8B%80%EB%A6%B0%EB%A7%8C%EC%9D%98%ED%81%B4%EB%9E%98%EC%8A%A4/",
        "teaser":null},{
        "title": "[Kotlin]6. 흐름 제어(control flow)",
        "excerpt":"흐름 제어(control flow) 자바와 동일한 구문   if-else문  while문, for문코틀린 구문 1. when문   when문은 자바의 switch문을 대체하며, 훨씬 더 많은 기능이 추가되었다.  when문은 각각의 branch의 조건문이 만족할 때까지 위에서 부터 순차적으로 인자를 비교한다.  when문 안의 else문은 다른 모든 branch가 조건에 성립하지 않을 때 수행된다.          else문은 필수로 있어야 하며, 없으면 컴파일 에러가 난다.      when문이 식으로 사용된 경우 else문이 없어도 된다는 것을 컴파일러가 입증할 수 있는 경우 생략 가능하다.        var res = when (x) {  true -&gt; \"맞다\"  false -&gt; \"틀리다\"}        사용 예제          기본 예제        when (x) {  1 -&gt; print(\"x == 1\")  2 -&gt; print(\"x == 2\")  else -&gt; { // Note the block    print(\"x is neither 1 nor 2\")  }}              여러 개의 조건이 사용된 경우        when (x) {  0, 1 -&gt; print(\"x == 0 or x == 1\")  else -&gt; print(\"otherwise\")}              조건에 함수나 식이 사용된 경우        when (x) {  parseInt(x) -&gt; print(\"s encodes x\")  1 + 3 -&gt; print(\"4\")  else -&gt; print(\"s does not encode x\")}              범위 연산자 ‘..’, collection에 ‘in’연산자로 범위를 검사하는 경우        val validNumbers = listOf(3, 6, 9)when (x) {  in validNumbers -&gt; print(\"x is valid\")  in 1..10 -&gt; print(\"x is in the range\")  !in 10..20 -&gt; print(\"x is outside the range\")  else -&gt; print(\"none of the above\")}              is 연산자를 이용하여 타입 검사를 하는 경우        //스마트 캐스트가 적용된다.fun hasPrefix(x: Any) = when(x) {  is String -&gt; x.startsWith(\"prefix\")  else -&gt; false}              when문에 인자를 입력하지 않으면 논리 연산을 검사한다. (if-else문 대체 가능)        when {  x.isOdd() -&gt; print(\"x is odd\")  x.isEven() -&gt; print(\"x is even\")  else -&gt; print(\"x is funny\")}      2. 범위 연산자   ..연산자//0부터 10까지, 시작과 끝을 포함하는 범위를 정의한다.val myRange: IntRange = 0..10  until 함수val items: List&lt;String&gt; = ... //항목이 담긴 리스트라고 가정val myRange: IntRage = 0..3//마지막 값을 포함하지 않는 범위, 즉 0, 1, 2, 3 의 인덱스를 나타낸다.val myRange: IntRage = 0 until 4  dounTo() 함수, step() 함수//2씩 감소하는 for문for (i in 5 downTo 1 step 2) {  System.out.print(i)}","categories": ["Study"],
        "tags": ["Study_Kotlin"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/Kotlin-6.%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4/",
        "teaser":null},{
        "title": "[SW Expert Academy]5650.핀볼 게임",
        "excerpt":"핀볼 게임 문제 링크   https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRF8s6ezEDFAUo해결 방법 시뮬레이션   각각의 벽돌이나 벽을 만났을 때 바뀌는 방향을 설정한다.  웜홀은 각 번호마다 2가지 좌표가 존재하므로 이를 번갈아 호출될 수 있도록 한다.  종료 조건은 블랙홀을 만났거나 다시 출발점으로 되돌아 온 경우이다.          출발점으로 되돌아 온 경우가 종료 조건이므로 반드시 종료되는 것을 보장할 수 있다.        위의 조건을 바탕으로 게임판에서 공을 둘 수 있는 모든 좌표와 그 좌표의 4 방향을 모두 검사하여 가장 큰 점수를 계산한다.시간 복잡도   게임판 최대 크기: 100 * 100  방향: 4  공을 둘 수 있는 모든 경우의 수: 100 * 100 * 4 = 40,000          벽돌, 블랙홀, 웜홀이 존재하므로 이 수보다 적을 것이라 예상된다.        시뮬레이션의 시간 복잡도 계산을 확신 할 수 없다.          최대는 100 * 100인 것 같지만, 이렇게 될려면 벽돌 위치가 특정한 조건을 만족해야 한다.      Notice   변수들을 갱신할 때, 계산의 중간 과정에서 초기 변수 값을 사용해야 한다면 그 값들을 임의의 저장소에 저장하여 사용해야 한다.          그렇지 않으면, 중간에 갱신된 변수 값들을 다른 변수의 계산 과정에서 사용하면 전혀 다른 값이 나오게 된다.      결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int my[4] = { -1, 0, 1, 0 };int mx[4] = { 0, 1, 0, -1 };int map[101][101];//웜홀 좌표 저장pair&lt;int, int&gt; wormhole[5][2];int wormCnt[5];//현재 방향에서 블록에 부딫혔을때 바뀌는 방향을 반환한다.int workBlock(int curDir, int blockNum) {\tif (blockNum == 1) {\t\tswitch (curDir) {\t\tcase 0: return 2;\t\tcase 1: return 3;\t\tcase 2: return 1;\t\tcase 3: return 0;\t\tdefault: return -1;\t\t}\t}\telse if (blockNum == 2) {\t\tswitch (curDir) {\t\tcase 0: return 1;\t\tcase 1: return 3;\t\tcase 2: return 0;\t\tcase 3: return 2;\t\tdefault: return -1;\t\t}\t}\telse if (blockNum == 3) {\t\tswitch (curDir) {\t\tcase 0: return 3;\t\tcase 1: return 2;\t\tcase 2: return 0;\t\tcase 3: return 1;\t\tdefault: return -1;\t\t}\t}\telse if (blockNum == 4) {\t\tswitch (curDir) {\t\tcase 0: return 2;\t\tcase 1: return 0;\t\tcase 2: return 3;\t\tcase 3: return 1;\t\tdefault: return -1;\t\t}\t}\telse if (blockNum == 5) {\t\tswitch (curDir) {\t\tcase 0: return 2;\t\tcase 1: return 3;\t\tcase 2: return 0;\t\tcase 3: return 1;\t\tdefault: return -1;\t\t}\t}\treturn -1;}void init() {\tfor (int i = 0; i &lt; 101; ++i)\t\tfor (int j = 0; j &lt; 101; ++j)\t\t\tmap[i][j] = 0;\tfor (int i = 0; i &lt; 5; ++i)\t\twormCnt[i] = 0;}int main(){\tint tc; scanf(\"%d\", &amp;tc);\tfor (int t = 1; t &lt;= tc; ++t) {\t\tinit();\t\tint n; scanf(\"%d\", &amp;n);\t\tfor (int i = 0; i &lt; n; ++i)\t\t\tfor (int j = 0; j &lt; n; ++j) {\t\t\t\tscanf(\"%d\", &amp;map[i][j]);\t\t\t\tif (map[i][j] &gt;= 6 &amp;&amp; map[i][j] &lt;= 10)\t\t\t\t\twormhole[map[i][j] - 6][wormCnt[map[i][j] - 6]++] = make_pair(i, j);\t\t\t}\t\tint ans = 0;\t\tint curScore, y, x, dir;\t\t//공을 놓을 수 있는 모든 좌표를 탐색한다.\t\tfor (int i = 0; i &lt; n; ++i)\t\t\tfor (int j = 0; j &lt; n; ++j)\t\t\t\t//빈 공간이면 공을 놓을 수 있다.\t\t\t\tif (map[i][j] == 0) {\t\t\t\t\t//상하좌우 모든 방향\t\t\t\t\tfor (int k = 0; k &lt; 4; ++k) {\t\t\t\t\t\ty = i;\t\t\t\t\t\tx = j;\t\t\t\t\t\tcurScore = 0;\t\t\t\t\t\tdir = k;\t\t\t\t\t\t//시뮬레이션\t\t\t\t\t\tfor (int m = 0; m &lt; n; ++m) {\t\t\t\t\t\t\ty += my[dir];\t\t\t\t\t\t\tx += mx[dir];\t\t\t\t\t\t\t// 벽을 만난 경우\t\t\t\t\t\t\t//인덱스가 게임밖으로 나가기 때문에 먼저 검사해야 한다.\t\t\t\t\t\t\tif (y &lt; 0 || y &gt;= n || x &lt; 0 || x &gt;= n) {\t\t\t\t\t\t\t\tdir = (dir + 2) % 4;\t\t\t\t\t\t\t\tcurScore++;\t\t\t\t\t\t\t\tm = -1;\t\t\t\t\t\t\t\tcontinue;\t\t\t\t\t\t\t}\t\t\t\t\t\t\t// 종료 조건: 블랙홀을 만나거나 처음으로 되돌아 온 경우\t\t\t\t\t\t\tif (map[y][x] == -1 || (y == i &amp;&amp; x == j)) {\t\t\t\t\t\t\t\tans = ans &gt; curScore ? ans : curScore;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\t}\t\t\t\t\t\t\t// 웜홀을 만난 경우\t\t\t\t\t\t\telse if (map[y][x] &gt;= 6 &amp;&amp; map[y][x] &lt;= 10) {\t\t\t\t\t\t\t\t//y가 변한 값으로 x를 계산과정에서 map 인덱스로 사용하므로\t\t\t\t\t\t\t\t//다른 변수에 저장해놓고 사용해야 한다.\t\t\t\t\t\t\t\tint nexty = y;\t\t\t\t\t\t\t\tint nextx = x;\t\t\t\t\t\t\t\tif (y == wormhole[map[nexty][nextx] - 6][0].first &amp;&amp;\t\t\t\t\t\t\t\t\tx == wormhole[map[nexty][nextx] - 6][0].second) {\t\t\t\t\t\t\t\t\ty = wormhole[map[nexty][nextx] - 6][1].first;\t\t\t\t\t\t\t\t\tx = wormhole[map[nexty][nextx] - 6][1].second;\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\telse {\t\t\t\t\t\t\t\t\ty = wormhole[map[nexty][nextx] - 6][0].first;\t\t\t\t\t\t\t\t\tx = wormhole[map[nexty][nextx] - 6][0].second;\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\tm = -1;\t\t\t\t\t\t\t\tcontinue;\t\t\t\t\t\t\t}\t\t\t\t\t\t\t// 블록을 만난 경우\t\t\t\t\t\t\telse if (map[y][x] &gt;= 1 &amp;&amp; map[y][x] &lt;= 5) {\t\t\t\t\t\t\t\tdir = workBlock(dir, map[y][x]);\t\t\t\t\t\t\t\tcurScore++;\t\t\t\t\t\t\t\tm = -1;\t\t\t\t\t\t\t\tcontinue;\t\t\t\t\t\t\t}\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t}\t\tprintf(\"#%d %d\\n\", t, ans);\t}\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_FCT"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/SW-Expert-Academy-5650.%ED%95%80%EB%B3%BC-%EA%B2%8C%EC%9E%84/",
        "teaser":null},{
        "title": "[SW Expert Academy]5656.벽돌 깨기",
        "excerpt":"벽돌 깨기 문제 링크 https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRQm6qfL0DFAUo 해결 방법 메모이제이션   단순히 완전 탐색을 사용하였을 때는 시간 초과가 발생하였다.(중복 순열 사용)  최대 보드 크기가 12 X 15로 작으므로 공을 3번 쏠 때까지 모든 경우의 보드 정보를 저장할 수 있다.  이를 활용하여 공을 한 번 쏠 때 모든 경우의 보드 내용을 저장하고, 두 번 쏠 때는 한 번 쐈을 때 보드 내용을 바탕으로 한 번만 더 계산하면 된다.시간 복잡도   최대 보드 크기에서 블록 제거(BFS): 12 * 15  가로 크기 12에서 공을 4번 쏘는 모든 경우의 수(중복 순열): 12^4  단순 완전 탐색: 12 * 15 * 12^4 * 4(공을 쏠 때마다 새로 계산하는 수, 공의 개수) = 14,929,920  완전 탐색 + 메모이제이션 12 * 15 * 12^4 = 3,732,480결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int INF = 987654321;class qState {public:\tint y, x;\tint size;};int my[4] = { 1, 0, -1, 0 };int mx[4] = { 0, 1, 0, -1 };//보드 정보 저장vector&lt;vector&lt;int&gt;&gt; board, tmp;//메모이제이션//1차원: 공을 한 번 쐈을 때의 모든 경우의 보드 정보를 저장//2차원: 공을 두 번 쐈을 때의 모든 경우의 보드 정보를 저장//3차원: 공을 세 번 쐈을 때의 모든 경우의 보드 정보를 저장vector&lt;vector&lt;int&gt;&gt; cache[15][15][15];//공을 1 ~ 3번 쐈을 때마다 부서진 벽돌의 개수 저장int bbn[15][15][15];vector&lt;int&gt; set;queue&lt;qState&gt; q;int n, w, h;//해당 좌표에 공을 쐈을 때 변화한 보드 내용을 계산하고 부서진 벽돌 개수를 반환한다.int shotAndDrop(int y, int x) {\t//벽돌 부수기(BFS 활용)\tint brokenBlock = 0;\tq.push({ y, x, tmp[y][x] });\tbrokenBlock++;\ttmp[y][x] = 0;\twhile (!q.empty()) {\t\tint nowy = q.front().y;\t\tint nowx = q.front().x;\t\tint size = q.front().size;\t\tq.pop();\t\tfor (int i = 0; i &lt; 4; ++i) {\t\t\tint nexty = nowy, nextx = nowx;\t\t\tfor (int k = 0; k &lt; size - 1; ++k) {\t\t\t\tnexty += my[i];\t\t\t\tnextx += mx[i];\t\t\t\tif (nexty &gt;= 0 &amp;&amp; nexty &lt; h &amp;&amp; nextx &gt;= 0 &amp;&amp; nextx &lt; w)\t\t\t\t\tif (tmp[nexty][nextx] &gt; 0) {\t\t\t\t\t\tif (tmp[nexty][nextx] &gt; 1)\t\t\t\t\t\t\tq.push({ nexty, nextx, tmp[nexty][nextx] });\t\t\t\t\t\ttmp[nexty][nextx] = 0;\t\t\t\t\t\tbrokenBlock++;\t\t\t\t\t}\t\t\t}\t\t}\t}\t//중간중간 비어진 공간 채우기\tfor (int i = 0; i &lt; w; ++i) {\t\tset.clear();\t\tfor (int k = h - 1; k &gt;= 0; --k)\t\t\tif (tmp[k][i] &gt; 0) {\t\t\t\tset.push_back(tmp[k][i]);\t\t\t\ttmp[k][i] = 0;\t\t\t}\t\tint idx = h - 1;\t\tfor (int k = 0; k &lt; set.size(); ++k)\t\t\ttmp[idx--][i] = set[k];\t}\treturn brokenBlock;}int main(void){\tint tc; scanf(\"%d\", &amp;tc);\tfor (int t = 1; t &lt;= tc; ++t) {\t\tboard.clear();\t\tmemset(bbn, 0, sizeof(bbn));\t\tscanf(\"%d %d %d\", &amp;n, &amp;w, &amp;h);\t\tboard = vector&lt;vector&lt;int&gt;&gt;(h, vector&lt;int&gt;(w));\t\tint totalBlock = 0;\t\tfor (int i = 0; i &lt; h; ++i)\t\t\tfor (int j = 0; j &lt; w; ++j) {\t\t\t\tscanf(\"%d\", &amp;board[i][j]);\t\t\t\tif (board[i][j] &gt; 0)\t\t\t\t\ttotalBlock++;\t\t\t}\t\tint ans = INF;\t\tfor (;;) {\t\t\t//공을 한 번 쏜 모든 경우\t\t\tfor (int i = 0; i &lt; w; ++i) {\t\t\t\ttmp = board;\t\t\t\tint brokenIdx = -1;\t\t\t\tfor (int k = 0; k &lt; h; ++k)\t\t\t\t\tif (tmp[k][i] &gt; 0) {\t\t\t\t\t\tbrokenIdx = k;\t\t\t\t\t\tbreak;\t\t\t\t\t}\t\t\t\t//해당 좌표에 부술 벽돌이 없으면 보드 정보를 그대로 저장한다.\t\t\t\tif (brokenIdx == -1) {\t\t\t\t\tcache[i + 1][0][0] = tmp;\t\t\t\t\tcontinue;\t\t\t\t}\t\t\t\t//해당 좌표에 공을 쐈을 때 부서진 벽돌 개수를 저장한다.\t\t\t\tint brokenBlock = shotAndDrop(brokenIdx, i);\t\t\t\t//변화한 정보를 각각 저장(메모이제이션)\t\t\t\tbbn[i + 1][0][0] = brokenBlock;\t\t\t\tcache[i + 1][0][0] = tmp;\t\t\t\t//남은 벽돌 개수 계산\t\t\t\tint curBlock = totalBlock - bbn[i + 1][0][0];\t\t\t\tans = ans &lt; curBlock ? ans : curBlock;\t\t\t}\t\t\tif (n == 1) break;\t\t\t//공을 두 번 쏜 모든 경우\t\t\tfor (int i = 0; i &lt; w; ++i) {\t\t\t\tfor (int j = 0; j &lt; w; ++j) {\t\t\t\t\t//해당 좌표에 공을 한 번 쏜 경우의 보드 내용을 사용한다.\t\t\t\t\ttmp = cache[i + 1][0][0];\t\t\t\t\tint brokenIdx = -1;\t\t\t\t\tfor (int k = 0; k &lt; h; ++k)\t\t\t\t\t\tif (tmp[k][j] &gt; 0) {\t\t\t\t\t\t\tbrokenIdx = k;\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t}\t\t\t\t\tif (brokenIdx == -1) {\t\t\t\t\t\tcache[i + 1][j + 1][0] = tmp;\t\t\t\t\t\tcontinue;\t\t\t\t\t}\t\t\t\t\tint brokenBlock = shotAndDrop(brokenIdx, j);\t\t\t\t\tbbn[i + 1][j + 1][0] = bbn[i + 1][0][0] + brokenBlock;\t\t\t\t\tcache[i + 1][j + 1][0] = tmp;\t\t\t\t\tint curBlock = totalBlock - bbn[i + 1][j + 1][0];\t\t\t\t\tans = ans &lt; curBlock ? ans : curBlock;\t\t\t\t}\t\t\t}\t\t\tif (n == 2) break;\t\t\t//공을 세 번 쏜 모든 경우\t\t\tfor (int l = 0; l &lt; w; ++l) {\t\t\t\tfor (int i = 0; i &lt; w; ++i) {\t\t\t\t\tfor (int j = 0; j &lt; w; ++j) {\t\t\t\t\t\ttmp = cache[l + 1][i + 1][0];\t\t\t\t\t\tint brokenIdx = -1;\t\t\t\t\t\tfor (int k = 0; k &lt; h; ++k)\t\t\t\t\t\t\tif (tmp[k][j] &gt; 0) {\t\t\t\t\t\t\t\tbrokenIdx = k;\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\t}\t\t\t\t\t\tif (brokenIdx == -1) {\t\t\t\t\t\t\tcache[l + 1][i + 1][j + 1] = tmp;\t\t\t\t\t\t\tcontinue;\t\t\t\t\t\t}\t\t\t\t\t\tint brokenBlock = shotAndDrop(brokenIdx, j);\t\t\t\t\t\tbbn[l + 1][i + 1][j + 1] = bbn[l + 1][i + 1][0] + brokenBlock;\t\t\t\t\t\tcache[l + 1][i + 1][j + 1] = tmp;\t\t\t\t\t\tint curBlock = totalBlock - bbn[l + 1][i + 1][j + 1];\t\t\t\t\t\tans = ans &lt; curBlock ? ans : curBlock;\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tif (n == 3) break;\t\t\t//공을 네 번 쏜 모든 경우\t\t\tfor (int i = 0; i &lt; w; ++i) {\t\t\t\tfor (int l = 0; l &lt; w; ++l) {\t\t\t\t\tfor (int kk = 0; kk &lt; w; ++kk) {\t\t\t\t\t\tfor (int j = 0; j &lt; w; ++j) {\t\t\t\t\t\t\ttmp = cache[i + 1][l + 1][kk + 1];\t\t\t\t\t\t\tint brokenIdx = -1;\t\t\t\t\t\t\tfor (int k = 0; k &lt; h; ++k)\t\t\t\t\t\t\t\tif (tmp[k][j] &gt; 0) {\t\t\t\t\t\t\t\t\tbrokenIdx = k;\t\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\tif (brokenIdx == -1) continue;\t\t\t\t\t\t\tint brokenBlock = shotAndDrop(brokenIdx, j);\t\t\t\t\t\t\tint curBlock = totalBlock - (bbn[i + 1][l + 1][kk + 1] + brokenBlock);\t\t\t\t\t\t\tans = ans &lt; curBlock ? ans : curBlock;\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tif (n == 4) break;\t\t}\t\tprintf(\"#%d %d\\n\", t, ans);\t}\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_FCT"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/SW-Expert-Academy-5656.%EB%B2%BD%EB%8F%8C-%EA%B9%A8%EA%B8%B0/",
        "teaser":null},{
        "title": "[BOJ] 15683.감시",
        "excerpt":"감시 문제 링크   https://www.acmicpc.net/problem/15683  삼성 SW 역량 테스트 기출 문제해결 방법 중복 순열을 이용한 완전 탐색   각각의 카메라는 총 4번 회전할 수 있으므로 카메라마다 어떤 방향을 설정해줄지에 대해 중복 순열을 사용하여 모든 경우의 수를 계산하였다.  경우의 수마다 사각지대의 개수를 검사하여 최소값을 갱신해준다.  이 문제는 DFS로도 풀이가 가능한데, 코드가 복잡해지는 대신 대체적으로 중복 순열을 사용하는 것보다 시간이 더 빠른 것으로 보인다. 시간 복잡도   최대 카메라 개수: 8  최대 사무실 크기: 8 X 8  4^8 * (8 * 8) = 4,194,304결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int INF = 987654321;typedef struct _camerainfo {\tint n;     //카메라 종류\tint y, x;  //카메라 위치} cameraInfo;int dy[4] = { 0, 1, 0, -1 };int dx[4] = { 1, 0, -1, 0 };//카메라 종류에 따른 방향 정보vector&lt;int&gt; camera[5];//각 카메라 정보cameraInfo ci[8];int map[9][9], tmp[9][9];int n, m;int ans = INF;//카메라 종류에 따른 방향 저장void initCameraDir() {\t//1번 카메라\tcamera[0].push_back(0);\t//2번 카메라\tcamera[1].push_back(0);\tcamera[1].push_back(2);\t//3번 카메라\tcamera[2].push_back(0);\tcamera[2].push_back(3);\t//4번 카메라\tcamera[3].push_back(0);\tcamera[3].push_back(2);\tcamera[3].push_back(3);\t//5번 카메라\tcamera[4].push_back(0);\tcamera[4].push_back(1);\tcamera[4].push_back(2);\tcamera[4].push_back(3);}//중복 순열void rperm(int *set, int size, int nn, int r) {\tif (size == r) {\t\tint res = 0;\t\t/*for (int i = 0; i &lt; r; ++i)\t\tprintf(\"%d \", set[i]);\t\tprintf(\"\\n\");*/\t\t//사각 지대 계산을 위해 임의로 맵을 저장한다.\t\tfor (int i = 0; i &lt; n; ++i)\t\t\tfor (int j = 0; j &lt; m; ++j)\t\t\t\ttmp[i][j] = map[i][j];\t\t//현재 순열의 번호에 따라 카메라들의 방향을 설정하여\t\t//카메라가 볼 수 있는 위치를 좌표에 모두 표시한다.\t\tfor (int i = 0; i &lt; r; ++i) {\t\t\tint nowCN = ci[i].n;\t\t\tfor (int j = 0; j &lt; camera[nowCN].size(); ++j) {\t\t\t\tint nowdy = (camera[nowCN][j] + set[i]) % 4;\t\t\t\tint nowdx = (camera[nowCN][j] + set[i]) % 4;\t\t\t\tint nexty = ci[i].y, nextx = ci[i].x;\t\t\t\tfor (int k = 0; k &lt; 8; ++k) {\t\t\t\t\tnexty += dy[nowdy];\t\t\t\t\tnextx += dx[nowdx];\t\t\t\t\tif (nexty &lt; 0 || nexty &gt;= n || nextx &lt; 0 || nextx &gt;= m ||\t\t\t\t\t\tmap[nexty][nextx] == 6)\t\t\t\t\t\tbreak;\t\t\t\t\ttmp[nexty][nextx] = 7;\t\t\t\t}\t\t\t}\t\t}\t\t//카메라 사각지대 개수를 계산한다.\t\tfor (int i = 0; i &lt; n; ++i)\t\t\tfor (int j = 0; j &lt; m; ++j)\t\t\t\tif (!tmp[i][j])\t\t\t\t\tres++;\t\tans = ans &lt; res ? ans : res;\t\t//printf(\"%d\\n\", ans);\t\treturn;\t}\tfor (int i = 0; i &lt; nn; ++i) {\t\tset[size] = i;\t\trperm(set, size + 1, nn, r);\t}}int main(){\tinitCameraDir();\tscanf(\"%d %d\", &amp;n, &amp;m);\tint csize = 0;\tfor (int i = 0; i &lt; n; ++i)\t\tfor (int j = 0; j &lt; m; ++j) {\t\t\tscanf(\"%d\", &amp;map[i][j]);\t\t\tif (map[i][j] &gt; 0 &amp;&amp; map[i][j] &lt; 6) {\t\t\t\tci[csize].n = map[i][j] - 1;\t\t\t\tci[csize].y = i;\t\t\t\tci[csize++].x = j;\t\t\t}\t\t}\t//중복 순열을 위한 초기화\tint arr[9] = { 0, };\tfor (int i = 0; i &lt; 4; ++i)\t\tarr[i] = i;\t//사각지대 계산\trperm(arr, 0, 4, csize);\tprintf(\"%d\\n\", ans);\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_BOJ"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/BOJ-15683.%EA%B0%90%EC%8B%9C/",
        "teaser":null},{
        "title": "[BOJ] 15685.드래곤 커브",
        "excerpt":"드래곤 커브 문제 링크   https://www.acmicpc.net/problem/15685  삼성 SW 역량 테스트 기출 문제해결 방법 시뮬레이션   드래곤 커브를 만드는 방법은 도형의 회전 공식을 이용하여 만들었다.          도형 회전 공식: 원점 기준 ((cos, -sin), (sin, cos)) * (x, y)      드래곤 커브의 규칙상 마지막에 만들어지는 좌표를 기준으로 현재 커브가 90도 회전하여 다음 커브를 만든다.      도래곤 커브 좌표들을 원점 이동 -&gt; 회전 -&gt; 원래 좌표로 이동 순으로 만들었다.        회전 공식뿐 아니라 드래곤 커브가 만들어지는 방향의 규칙성을 찾아서 풀 수도 있다는 것을 후에 알게 되었다.   사각형 개수는 드래곤 커브를 모두 배열에 표시하여 사각형 좌표가 모두 포함되는지 검사하였다.결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//도형 회전 90도 공식 { {cos, -sin}, {sin, cos} }int rot90[2][2] = { {0, -1}, {1, 0} };//우, 상, 좌, 하int my[4] = { 0, -1, 0, 1 };int mx[4] = { 1, 0, -1, 0 };vector&lt;pair&lt;int, int&gt;&gt; dragon[21];bool map[101][101];//현재 인덱스의 다음 드래곤 커브 모든 좌표를 계산하여 벡터에 모두 추가한다.void makeDragonCurve(int idx) {\t//드래곤 커브 좌표들의 현재 크기\tint dsize = dragon[idx].size();\t//중심점\tint cy = dragon[idx][dsize - 1].first;\tint cx = dragon[idx][dsize - 1].second;\t//dragon벡터의 마지막 인덱스의 좌표가 중심점임을 유지하기 위해\t//끝 좌표부터 회전시킨다.\tfor (int i = dsize - 2; i &gt;= 0; --i) {\t\tint nowy = dragon[idx][i].first;\t\tint nowx = dragon[idx][i].second;\t\t//중심점이 원점일 때 현재 드래콘커브 좌표를 그에 맞게 변환하기\t\tint movy = nowy - cy;\t\tint movx = nowx - cx;\t\t//현재 좌표를 중심점을 기준으로 90도 회전\t\tint roty = rot90[1][0] * movx + rot90[1][1] * movy;\t\tint rotx = rot90[0][0] * movx + rot90[0][1] * movy;\t\t//원점에서 다시 원래 중심점을 기준으로 좌표로 변환하기\t\tint oriy = roty + cy;\t\tint orix = rotx + cx;\t\tdragon[idx].push_back(make_pair(oriy, orix));\t}}int main(){\tint n; scanf(\"%d\", &amp;n);\tfor (int i = 0; i &lt; n; ++i) {\t\tint x, y, d, g;\t\tscanf(\"%d %d %d %d\", &amp;x, &amp;y, &amp;d, &amp;g);\t\tdragon[i].push_back({ y, x });\t\t//0세대\t\tdragon[i].push_back({ y + my[d], x + mx[d] });\t\t//1세대부터 주어진 세대까지 드래곤 커브 만들기\t\tfor (int j = 0; j &lt; g; ++j)\t\t\tmakeDragonCurve(i);\t\t//현재 드래곤커브 지도에 표시하기\t\tint dsize = dragon[i].size();\t\tfor (int j = 0; j &lt; dsize; ++j)\t\t\tmap[dragon[i][j].first][dragon[i][j].second] = true;\t}\tint ans = 0;\t//사각형 개수 구하기\tfor (int i = 0; i &lt; 100; ++i)\t\tfor (int j = 0; j &lt; 100; ++j)\t\t\tif (map[i][j] &amp;&amp; map[i + 1][j] &amp;&amp; map[i][j + 1] &amp;&amp; map[i + 1][j + 1])\t\t\t\tans++;\tprintf(\"%d\\n\", ans);\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_BOJ"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/BOJ-15685.%EB%93%9C%EB%9E%98%EA%B3%A4-%EC%BB%A4%EB%B8%8C/",
        "teaser":null},{
        "title": "[SW Expert Academy] 5648.원자 소멸 시뮬레이션",
        "excerpt":"원자 소멸 시뮬레이션 문제 링크 -https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRFInKex8DFAUo 해결 방법 시뮬레이션   주어진 원자들을 시간마다 직접 옮기면서 서로 부딪혔는지 검사한다.          한 칸을 두고 부딪힌 경우 0.5초가 소요되기 때문에 시간 단위는 0.5초씩 증가한다.        구현               위의 시뮬레이션으로 모든 탐색을 하면 시간 초과가 발생한다. 그러므로 좌표를 이용하여 직접 원자를 옮기지 않고 각 원자들을 서로 비교하며 충돌할 수 있는지 검사해야 한다.  먼저, 각 원자마다 충돌할 수 있는 모든 원자들을 검사하여 그 정보를 저장한다.          저장하는 정보는 서로 충돌하는 두 원소의 번호, 충돌 시간이다.      충돌하는 조건은 서로 충돌하는 좌표 4개를 임시로 만들어 계산하여 도출하였다.                  위 방향을 예로 들면, 같은 선상에 있는 아래 방향은 같은 x좌표에 있고, 위 y 좌표가 아래 y 좌표보다 작아야 서로 충돌할 수 있다. 좌, 우 방향은 위 방향과의 x, y 좌표 차이와 부호를 바탕으로 조건을 만든다.                      모든 충돌이 저장된 벡터를 충돌 시간을 기준으로 오름 차순으로 정렬한다.          그 이유는 각 원자마다 충돌할 수 있는 경우는 여러가지이지만 가장 빠른 시간에 충돌하는 원자들은 소멸하므로 그 이후를 무시하기 위해서이다.        bool 타입의 check 배열로 처음 충돌한 원소들을 모두 검사한다.(false - 아직 해당 원소는 충돌하지 않음)          한 충돌에서 두 원자가 모두 false인 경우는 처음 충돌하는 경우이므로 두 원자는 충돌 가능하다.      한 원자만 false인 경우, 이미 충돌한 다른 원자의 충돌 시간과 현재 충돌 시간이 같다면 이 충돌하지 않은 원자는 이미 충돌한 원자와 충돌해야한다는 것을 알 수 있다.(단적인 예로는 3개의 원자가 충돌하는 것을 검사하기 위함이다.)      시간 복잡도 시뮬레이션   시간 복잡도를 줄이기 위해 부딪혔는지 검사하는 부분을 x좌표 기준으로 정렬하여 원자 배열을 한번만 탐색해도 모두 검사할 수 있도록 구현하였다.  원자의 위치 범위는 -1,000 ~ 1,000이고, 0.5씩 증가하므로 원자가 이동할 수 있는 최대 횟수는 4,000회이다.  4,000 * (1,000(원자 이동) + 1,000*log1,000(원자 정렬) + 1000(충돌 검사)) = 20,000,000  원자가 움직일 수 있는 최대 횟수인 4,000번을 돌리면 시간 초과가 뜨는데 3,500으로 하면 통과를 한다. 아마 내부 케이스가 부족해서 그런 것 같다. 구현   최대 원자 개수 N = 1,000  충돌 검사: N * N  충돌 벡터 오름 차순 정렬: NlogN  충돌 검사: N  O(N^2)결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;class collision {public:\tint a1, a2;  //충돌한 두 원자\tfloat time;  //충돌 시간};vector&lt;collision&gt; cv;//배열 인덱스 = 원자 번호int atom[1001][4];   //x좌표, y좌표, 방향, 에너지float atomCT[1001];  //각 원자의 충돌 시간bool check[1001];    //충돌했는지 여부bool comp(const collision &amp;a, const collision &amp;b) {\treturn a.time &lt; b.time;}//각 원자마다 모든 충돌을 저장한다.void checkCollision(int n) {\tfor (int i = 0; i &lt; n; ++i) {\t\tfor (int j = 0; j &lt; n; ++j) {\t\t\t//두 원소의 x좌표 차이\t\t\tint dx = atom[i][0] - atom[j][0];\t\t\t//두 원소의 y좌표 차이\t\t\tint dy = atom[i][1] - atom[j][1];\t\t\t//현재 원소 방향이 '상'인 경우\t\t\tif (i != j &amp;&amp; atom[i][2] == 0) {\t\t\t\t//비교하는 원자의 방향이 '하'이고, x좌표가 같고,\t\t\t\t//아래 방향의 원소 y좌표가 더 위에 있는 경우 추가한다.\t\t\t\tif (atom[j][2] == 1 &amp;&amp; atom[i][0] == atom[j][0] &amp;&amp;\t\t\t\t\tatom[i][1] &lt; atom[j][1])\t\t\t\t\tcv.push_back({ i, j, ((atom[j][1] - atom[i][1]) / (float)2) });\t\t\t\t//비교하는 원자의 방향이 '우'이고, x좌표 차이가 0보다 크고,\t\t\t\t//y좌표 차이가 0보다 작고, 두 차이의 크기가 같은 경우 추가한다.\t\t\t\telse if (atom[j][2] == 3 &amp;&amp; dx &gt; 0 &amp;&amp; dy &lt; 0 &amp;&amp; dx == -dy)\t\t\t\t\tcv.push_back({ i, j, (float)dx });\t\t\t\t//비교하는 원자의 방향이 '좌'이고, x좌표 차이가 0보다 작고,\t\t\t\t//y좌표 차이가 0보다 작고, 두 차이의 크기가 같은 경우 추가한다.\t\t\t\telse if (atom[j][2] == 2 &amp;&amp; dx &lt; 0 &amp;&amp; dy &lt; 0 &amp;&amp; dx == dy)\t\t\t\t\tcv.push_back({ i, j, (float)-dx });\t\t\t}\t\t\t//현재 원소 방향이 '하'인 경우\t\t\telse if (i != j &amp;&amp; atom[i][2] == 1) {\t\t\t\tif (atom[j][2] == 0 &amp;&amp; atom[i][0] == atom[j][0] &amp;&amp;\t\t\t\t\tatom[i][1] &gt; atom[j][1])\t\t\t\t\tcv.push_back({ i, j, ((atom[i][1] - atom[j][1]) / (float)2) });\t\t\t\telse if (atom[j][2] == 3 &amp;&amp; dx &gt; 0 &amp;&amp; dy &gt; 0 &amp;&amp; dx == dy)\t\t\t\t\tcv.push_back({ i, j, (float)dx });\t\t\t\telse if (atom[j][2] == 2 &amp;&amp; dx &lt; 0 &amp;&amp; dy &gt; 0 &amp;&amp; dx == -dy)\t\t\t\t\tcv.push_back({ i, j, (float)-dx });\t\t\t}\t\t\t//현재 원소 방향이 '좌'인 경우\t\t\telse if (i != j &amp;&amp; atom[i][2] == 2) {\t\t\t\tif (atom[j][2] == 3 &amp;&amp; atom[i][1] == atom[j][1] &amp;&amp;\t\t\t\t\tatom[i][0] &gt; atom[j][0])\t\t\t\t\tcv.push_back({ i, j, ((atom[i][0] - atom[j][0]) / (float)2) });\t\t\t\telse if (atom[j][2] == 0 &amp;&amp; dx &gt; 0 &amp;&amp; dy &gt; 0 &amp;&amp; dx == dy)\t\t\t\t\tcv.push_back({ i, j, (float)dx });\t\t\t\telse if (atom[j][2] == 1 &amp;&amp; dx &gt; 0 &amp;&amp; dy &lt; 0 &amp;&amp; dx == -dy)\t\t\t\t\tcv.push_back({ i, j, (float)dx });\t\t\t}\t\t\t//현재 원소 방향이 '우'인 경우\t\t\telse if (i != j &amp;&amp; atom[i][2] == 3) {\t\t\t\tif (atom[j][2] == 2 &amp;&amp; atom[i][1] == atom[j][1] &amp;&amp;\t\t\t\t\tatom[i][0] &lt; atom[j][0])\t\t\t\t\tcv.push_back({ i, j, ((atom[j][0] - atom[i][0]) / (float)2) });\t\t\t\telse if (atom[j][2] == 0 &amp;&amp; dx &lt; 0 &amp;&amp; dy &gt; 0 &amp;&amp; dx == -dy)\t\t\t\t\tcv.push_back({ i, j, (float)-dx });\t\t\t\telse if (atom[j][2] == 1 &amp;&amp; dx &lt; 0 &amp;&amp; dy &lt; 0 &amp;&amp; dx == dy)\t\t\t\t\tcv.push_back({ i, j, (float)-dx });\t\t\t}\t\t}\t}}void init() {\tfor (int i = 0; i &lt; 1001; ++i)\t\tcheck[i] = false;\tcv.clear();}int main(void){\tint tc; scanf(\"%d\", &amp;tc);\tfor (int t = 1; t &lt;= tc; ++t) {\t\tinit();\t\tint n; scanf(\"%d\", &amp;n);\t\tfor (int i = 0; i &lt; n; ++i)\t\t\tscanf(\"%d %d %d %d\", &amp;atom[i][0], &amp;atom[i][1],\t\t\t\t&amp;atom[i][2], &amp;atom[i][3]);\t\t//충돌 검사\t\tcheckCollision(n);\t\t//충돌 시간을 기준으로 오름차순 정렬(후의 충돌들을 무시하기 위함)\t\tsort(cv.begin(), cv.end(), comp);\t\tint ans = 0;\t\tint csize = cv.size();\t\tfor (int i = 0; i &lt; csize; ++i) {\t\t\t//두 원소가 처음 충돌인 경우\t\t\tif (!check[cv[i].a1] &amp;&amp; !check[cv[i].a2]) {\t\t\t\tans += atom[cv[i].a1][3];\t\t\t\tans += atom[cv[i].a2][3];\t\t\t\tcheck[cv[i].a1] = true;\t\t\t\tcheck[cv[i].a2] = true;\t\t\t\tatomCT[cv[i].a1] = cv[i].time;\t\t\t\tatomCT[cv[i].a2] = cv[i].time;\t\t\t}\t\t\t//두 원소 중 한 원소가 충돌하지 않은 경우에 그 원소가 이미 충돌한 원소와 충돌 시간이 같다면\t\t\t//이 원소는 같은 시간에 충돌한 것이다.(원소 3개가 충돌한 경우)\t\t\telse if (!check[cv[i].a1] &amp;&amp; check[cv[i].a2] &amp;&amp; atomCT[cv[i].a2] == cv[i].time) {\t\t\t\tans += atom[cv[i].a1][3];\t\t\t\tcheck[cv[i].a1] = true;\t\t\t\tatomCT[cv[i].a1] = cv[i].time;\t\t\t}\t\t\telse if (check[cv[i].a1] &amp;&amp; !check[cv[i].a2] &amp;&amp; atomCT[cv[i].a1] == cv[i].time) {\t\t\t\tans += atom[cv[i].a2][3];\t\t\t\tcheck[cv[i].a2] = true;\t\t\t\tatomCT[cv[i].a2] = cv[i].time;\t\t\t}\t\t}\t\tprintf(\"#%d %d\\n\", t, ans);\t}\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_FCT"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/SW-Expert-Academy-5648.%EC%9B%90%EC%9E%90-%EC%86%8C%EB%A9%B8-%EC%8B%9C%EB%AE%AC%EB%A0%88%EC%9D%B4%EC%85%98/",
        "teaser":null},{
        "title": "[BOJ] 15684.사다리 조작",
        "excerpt":"사다리 조작 문제 링크   https://www.acmicpc.net/problem/15684  삼성 SW 역량 테스트 기출 문제해결 방법 완전 탐색   가로선을 0개, 1개, 2개, 3개 순서대로 모든 경우의 수마다 세로선에서 출발하여 같은 세로선에 도착하는지 검사한다.  사다리를 내려오는 시뮬레이션은 2차원 배열에서 행이 가로선이고 열을 세로선으로 둔다. 그리고 각각의 인덱스에서 가로선이 있다면 두 세로선을 연결한다는 의미이므로, 두 세로선 역할을 하는 두 열에서 앞 인덱스는 +1값을 넣어주고 뒤 인덱스에 -1값을 넣어준다. 문제의 예제 3번의 사다리를 배열로 나타내면 아래와 같다.                   1      2      3      4      5                  1      1      -1      0      0      0              2      0      0      1      -1      0              3      0      1      -1      0      0              4      0      0      0      0      0              5      1      -1      0      1      -1              6      0      0      0      0      0        사다리 타기는 한 열에서 바로 아래의 행으로 내려가면서 그 인덱스를 더하여 나오는 값이 그 다음 열 번호이다.  가로선을 추가하는 알고리즘은 문제의 조건을 맞추고, 셀 필요없는 경우를 가지치기하여 시간을 줄여야 한다.          먼저, 문제의 조건에서는 연속해서 가로선을 놓을 수 없으므로 현재 열 인덱스와 한 칸 뒤 열 인덱스 모두 0일 때 가로선을 만들 수 있다.      가로선을 2개 만드는 경우부터는 이미 만들어진 가로선의 행 인덱스 이후부터 만들면 된다.              시간이 더 짧게 걸린 코드들을 봤을 때, 현재 조건보다 더 추가할 것이 있는 것으로 보인다.       결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int ladder[32][12];int n, m, h;bool ladderSimul() {\tbool flag = true;\tfor (int i = 1; i &lt;= n; ++i) {\t\tint move = i;\t\tfor (int j = 0; j &lt;= h; ++j)\t\t\tmove += ladder[j][move];\t\tif (move != i) {\t\t\tflag = false;\t\t\tbreak;\t\t}\t}\treturn flag;}int main(){\tscanf(\"%d %d %d\", &amp;n, &amp;m, &amp;h);\tfor (int i = 0; i &lt; m; ++i) {\t\tint a, b; scanf(\"%d %d\", &amp;a, &amp;b);\t\tladder[a][b] = 1;\t\tladder[a][b + 1] = -1;\t}\t//가로선 0개 설치\tif (ladderSimul()) {\t\tprintf(\"0\\n\");\t\treturn 0;\t}\t//가로선 1개 설치\tfor (int i = 1; i &lt;= h; ++i) {\t\tfor (int j = 1; j &lt; n; ++j) {\t\t\t//가로선이 연속한지 검사\t\t\tif (!ladder[i][j] &amp;&amp; !ladder[i][j + 1]) {\t\t\t\t//사다리를 만든다.\t\t\t\tladder[i][j] = 1;\t\t\t\tladder[i][j + 1] = -1;\t\t\t\t//사다리 타기\t\t\t\tif (ladderSimul()) {\t\t\t\t\tprintf(\"1\\n\");\t\t\t\t\treturn 0;\t\t\t\t}\t\t\t\t//사다리를 지운다.\t\t\t\tladder[i][j] = 0;\t\t\t\tladder[i][j + 1] = 0;\t\t\t}\t\t}\t}\t//가로선 2개 설치\tfor (int i = 1; i &lt;= h; ++i) {\t\tfor (int j = 1; j &lt; n; ++j) {\t\t\tif (!ladder[i][j] &amp;&amp; !ladder[i][j + 1]) {\t\t\t\tladder[i][j] = 1;\t\t\t\tladder[i][j + 1] = -1;\t\t\t\t//이미 만들어진 가로선 이후부터 만든다.\t\t\t\tfor (int i2 = i; i2 &lt;= h; ++i2) {\t\t\t\t\tfor (int k = 1; k &lt; n; ++k) {\t\t\t\t\t\tif (!ladder[i2][k] &amp;&amp; !ladder[i2][k + 1]) {\t\t\t\t\t\t\tladder[i2][k] = 1;\t\t\t\t\t\t\tladder[i2][k + 1] = -1;\t\t\t\t\t\t\tif (ladderSimul()) {\t\t\t\t\t\t\t\tprintf(\"2\\n\");\t\t\t\t\t\t\t\treturn 0;\t\t\t\t\t\t\t}\t\t\t\t\t\t\tladder[i2][k] = 0;\t\t\t\t\t\t\tladder[i2][k + 1] = 0;\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t}\t\t\t\tladder[i][j] = 0;\t\t\t\tladder[i][j + 1] = 0;\t\t\t}\t\t}\t}\t//가로선 3개 설치\tfor (int i = 1; i &lt;= h; ++i) {\t\tfor (int j = 1; j &lt; n; ++j) {\t\t\tif (!ladder[i][j] &amp;&amp; !ladder[i][j + 1]) {\t\t\t\tladder[i][j] = 1;\t\t\t\tladder[i][j + 1] = -1;\t\t\t\tfor (int i2 = i; i2 &lt;= h; ++i2) {\t\t\t\t\tfor (int k = 1; k &lt; n; ++k) {\t\t\t\t\t\tif (!ladder[i2][k] &amp;&amp; !ladder[i2][k + 1]) {\t\t\t\t\t\t\tladder[i2][k] = 1;\t\t\t\t\t\t\tladder[i2][k + 1] = -1;\t\t\t\t\t\t\tfor (int i3 = i2; i3 &lt;= h; ++i3) {\t\t\t\t\t\t\t\tfor (int l = 1; l &lt; n; ++l) {\t\t\t\t\t\t\t\t\tif (!ladder[i3][l] &amp;&amp; !ladder[i3][l + 1]) {\t\t\t\t\t\t\t\t\t\tladder[i3][l] = 1;\t\t\t\t\t\t\t\t\t\tladder[i3][l + 1] = -1;\t\t\t\t\t\t\t\t\t\tif (ladderSimul()) {\t\t\t\t\t\t\t\t\t\t\tprintf(\"3\\n\");\t\t\t\t\t\t\t\t\t\t\treturn 0;\t\t\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\tladder[i3][l] = 0;\t\t\t\t\t\t\t\t\t\tladder[i3][l + 1] = 0;\t\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t}\t\t\t\t\t\t\tladder[i2][k] = 0;\t\t\t\t\t\t\tladder[i2][k + 1] = 0;\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t}\t\t\t\tladder[i][j] = 0;\t\t\t\tladder[i][j + 1] = 0;\t\t\t}\t\t}\t}\tprintf(\"-1\\n\");\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_BOJ"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/BOJ-16584.%EC%82%AC%EB%8B%A4%EB%A6%AC-%EC%A1%B0%EC%9E%91/",
        "teaser":null},{
        "title": "[BOJ] 1339.단어 수학",
        "excerpt":"단어 수학 문제 링크   https://www.acmicpc.net/problem/1339해결 방법 순열을 이용한 완전 탐색   등장하는 알파벳에 부여할 수 있는 점수의 모든 경우의 수를 순열을 통해 찾는다.          가장 높은 숫자부터 알파벳에 부여해야한다.      예제: GCF + ACDEB   등장하는 알파벳: ABCDEFG            알파벳      A      B      C      D      E      F      G                  숫자      9      8      7      6      5      4      3                  알파벳      A      B      C      D      E      F      G                  숫자      9      8      7      6      5      3      4      … 시간 복잡도   순열 계산: $P(10,10)$ = 10!  단어 계산: 10(단어 개수) * 8(단어 길이)  총 시간 복잡도: 10! * 10 * 8자릿수 활용하기   주어진 알파벳 문자열은 십집수의 자릿수와 같은 취급을 하기 때문에 등장하는 알파벳들의 자릿수 합을 구하여 이 합이 큰 알파벳부터 높은 숫자를 부여한다.예제: GCF + ACDEB   문자열1            알파벳      G      C      F                  자릿수      100      10      1        문자열2            알파벳      A      C      D      E      B                  자릿수      10000      1000      100      10      1        문자열1 + 문자열2(자리수 오름차순)            알파벳      A      C      D      E      G      B      F                  자릿수      10000      1010      100      10      10      1      1            처음에 자리수의 인덱스 누적값(예를 들어, 위의 문자열 2의 A에 5를 부여한다.)을 오름차순으로 하여 순서대로 큰 숫자를 부여했는데, 이렇게 하면 숫자 중복이 실제 수 크기와 관계없이 중복되는 경우가 생겨서 틀린 것 같다. 위처럼 자릿수를 기준으로 하여 정확하게 비교해야 한다는 것을 알았다.   시간 복잡도   자릿수 부여: 10 * 8  오름차순 정렬(퀵정렬): 26log26결과 코드   순열을 이용한 완전 탐색#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;//최초 등장하는 알파벳 검사bool check[27];//등장하는 알파벳 종류 저장char alph[10];//등장하는 알파벳에 해당하는 숫자 맵핑int nalph[27];//최대 점수를 찾기 위해 숫자 9를 우선적으로 대입하기 위한 배열//순열을 통해 만든어진 수열을 인덱스로 맵핑int num[10] = { 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 };vector&lt;int&gt; seq;string str[10];int main(void){\tint n; scanf(\"%d\", &amp;n);\t//등장하는 알파벳 개수\tint idx = 0;\tfor (int i = 0; i &lt; n; ++i) {\t\tcin &gt;&gt; str[i];\t\t//등장하는 알파벳 갯수 세기\t\tfor (int j = 0; j &lt; str[i].size(); ++j)\t\t\tif (!check[str[i][j] - 'A']) {\t\t\t\tcheck[str[i][j] - 'A'] = true;\t\t\t\talph[idx++] = str[i][j];\t\t\t}\t}\t//알파벳 개수만큼 순열을 사용하기 위해 초기화 0 ~ n-1\tfor (int i = 0; i &lt; idx; ++i)\t\tseq.push_back(i);\tint ans = 0;\t//순열 탐색\tdo {\t\t//등장하는 알파벳에 점수 부여\t\tfor (int i = 0; i &lt; idx; ++i)\t\t\tnalph[alph[i] - 'A'] = num[seq[i]];\t\tint deci = 0;\t\t//주어진 모든 문자열 수 계산\t\tfor (int i = 0; i &lt; n; ++i) {\t\t\tint coef = 0;\t\t\tint size = str[i].size();\t\t\tfor (int j = 0; j &lt; str[i].size(); ++j) {\t\t\t\tcoef = nalph[str[i][j] - 'A'];\t\t\t\tfor (int k = 0; k &lt; size - 1; ++k)\t\t\t\t\tcoef *= 10;\t\t\t\tsize--;\t\t\t\tdeci += coef;\t\t\t}\t\t}\t\t//가장 큰 수 찾기\t\tans = ans &gt; deci ? ans : deci;\t} while (next_permutation(seq.begin(), seq.end()));\tprintf(\"%d\\n\", ans);\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_BOJ"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/BOJ-1339.%EB%8B%A8%EC%96%B4-%EC%88%98%ED%95%99/",
        "teaser":null},{
        "title": "[BOJ] 2661.좋은수열",
        "excerpt":"좋은수열 문제 링크   https://www.acmicpc.net/problem/2661해결 방법 백트래킹 1. 좋은 수열 검사하기   한 수열의 시작점기준으로 부분 수열을 만들어 바로 다음 부분 수열과 같은지 비교한다.          시작점은 수열의 끝까지 옮겨간다.      부분 수열의 최대 크기는 전체 수열 크기의 ${\\frac{1}{2}}$ 만큼 이다.      예제: 1231231) (1)23123 -&gt; '2' 비교 -&gt; 다름2) (12)3123 -&gt; '31' 비교 -&gt; 다름3) (123)123 -&gt; '123' 비교 -&gt; 같음2. 수열 만들기   문제에서 요구하는 주어진 수열 크기에서 수로 표현했을 때 가장 작은 수열을 찾아야한다.  사용 가능한 숫자의 종류는 1, 2, 3이므로, 가장 작은 수를 찾을려면 수열의 시작 숫자는 1이서만 찾으면 된다.  가능한 모든 수열을 만들어 놓고 좋은 수열인지 검사하면 시간복잡도 O($3^{N-1}$) 이고, N의 최대 크기는 80이므로 시간안에 풀 수 없다.  수열 크기 1부터 하나씩 늘려 주어진 N의 크기를 만들어야 한다.          현재 수열에서 숫자 1을 추가한다.      좋은 수열인지 검사한다.      좋은 수열이 만족하면 1번 단계로 가며, 만족하지 않으면 숫자 1을 지우고 숫자 2를 추가하여 2번 단계로 간다.(숫자 2도 만족하지 않으면 숫자 3을 추가하고 2번 단계)        위와 같이 작은 숫자부터 그리디하게 추가하면 시간복잡도를 크게 줄일 수 있다.결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;int n;//나쁜 수열인지 검사하는 플래그bool badFlag = false;void check(string s, int sIdx) {\tint size = s.size();\t//기저 사례: 나쁜 수열로 판단되거나 시작 인덱스가 끝에 도달할 경우\tif (badFlag || sIdx == (size - 1)) return;\tstring cur, next;\tint nextSIdx;\t//현재 시작 인덱스에서 나타날 수 있는 나쁜 수열인 경우를 탐색한다.\tfor (int i = 1; i &lt;= size / 2; ++i) {\t\t//현재 시작 인덱스 부분 수열\t\tcur = s.substr(sIdx, i);\t\t//현재 시작 인덱스 부분 수열과 오른쪽에 인접한 부분 수열\t\tnextSIdx = sIdx + i;\t\tif (nextSIdx &gt;= size || (nextSIdx + i) &gt; size) continue;\t\tnext = s.substr(nextSIdx, i);\t\tif (cur == next) {\t\t\tbadFlag = true;\t\t\treturn;\t\t}\t}\t//다음 시작 인덱스 검사\tcheck(s, sIdx + 1);}//정답을 찾았는지 검사하는 플래그bool ansFlag = false;string ans;//수열의 크기를 하나씩 늘려가며 수열을 만든다.void makeSequence(string str, int len) {\t//기저 사례1: 정답을 찾았다면 검사할 필요가 없으므로 반환한다.\tif (ansFlag) return;\t//기저 사례2: 좋은 수열을 유지하여 정답을 찾았다면 저장하고 반환한다.\tif (len == n) {\t\tans = str;\t\tansFlag = true;\t\treturn;\t}\telse {\t\t//숫자 1, 2, 3을 차례로 추가한다.\t\tfor (int i = 1; i &lt; 4; ++i) {\t\t\tbadFlag = false;\t\t\t//char 변환\t\t\tchar num[2];\t\t\tnum[0] = i + '1' - 1;\t\t\tnum[1] = '\\0';\t\t\tstring next = str.append(num);\t\t\t//좋은 수열인지 검사한다.\t\t\tcheck(next, 0);\t\t\t//좋은 수열이라면 해당 숫자를 추가하고 다음 단계로 넘어간다.\t\t\tif (!badFlag)\t\t\t\tmakeSequence(next, len + 1);\t\t\t//좋은 수가 아니라면 해당 숫자를 제거한다.\t\t\tstr.pop_back();\t\t}\t}}int main(void){\tscanf(\"%d\", &amp;n);\tmakeSequence(\"1\", 1);\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_BOJ"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/BOJ-2661.%EC%A2%8B%EC%9D%80%EC%88%98%EC%97%B4/",
        "teaser":null},{
        "title": "[BOJ] 2023.신기한 소수",
        "excerpt":"신기한 소수 문제 링크   https://www.acmicpc.net/problem/2023해결 방법 백트래킹   시간 제한과 메모리 제한으로 볼 때 에라토스테네스의 체는 사용할 수 없다.  문제에서는 한 자리부터 N자리 모두 소수가 되야 하므로 첫 번째 자리 수부터 소수인 숫자로 시작하여 자릿수를 늘려나가는 방식으로 구현하였다.          첫 번째 자리가 소수가 될 수 있는 경우는 2, 3, 5, 7이다.      두 번째 자리부터 소수가 될 수 있는 경우는 홀수(1, 3, 5, 7, 9)인 경우이다. 짝수인 경우는 무조건 2의 배수이므로 소수가 될 수 없다.        재귀 함수 입력을 string으로 받아 자릿수를 간단하게 늘려주고 이를 atoi 함수로 int형으로 변경하여 해당 숫자가 소수인지 판단한다.시간 복잡도 줄이기   재귀 함수가 실행되는 수는 최대 8자리에서 ${4} * {5}^{7}$ 으로 고정이다.  재귀 함수내에서 소수를 판단하는 반복문에 따라 시간복잡도 차이가 난다.          현재 수가 N일 때, 가장 간단한 방법은 2 ~ N - 1까지 나누어 떨어지지 않으면 소수이다.        for (int i = 2; i &lt; rn; ++i)  if (rn % i == 0)  //소수가 아닌 경우    return;              위의 식을 좀 더 생각해보면 N을 나눌 때 나누는 수의 제곱이 N보다 작거나 같을 때만 나누면 된다. 예를 들어 16의 약수는 1, 2, 4, 8, 16이다. 여기서 16을 만드는 곱셈 쌍은 (1, 16), (2, 8), (4, 4)이다. 이것을 보면 앞의 숫자 1, 2, 4는 각각 제곱하면 16보다 작거나 같고 이 3개의 숫자로 나누면 16의 모든 약수를 구할 수 있다. 즉, 각 숫자의 약수를 나열했을 때 앞에서 부터 중간지점 숫자까지만 나누어 보면 되는데 이 중간 지점 숫자의 최대값이 $\\sqrt {N}$ 작거나 같기 때문이다.        for (int i = 2; i * i &lt;= rn; ++i)          if (rn % i == 0)  //소수가 아닌 경우              return;              이는 효율높은 코드를 보면서 내 방식대로 분석하여 내린 결론이다. 이 생각이 틀릴수도 있음…         실제 채점에서 시간은 764ms 에서 0ms로 크게 준 것을 확인할 수 있다.결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;int n;vector&lt;int&gt; ans;//모든 1 ~ N 자리수가 소수인 숫자를 찾는다.void solve(string num) {\t//현재 숫자 자릿수\tint size = num.size();\t//int형으로 변환\tint rn = atoi(num.c_str());\tif (size &gt; 1) {\t\t//현재 숫자가 소수인지 찾는다.\t\t//이 부분을 더 빠르게 고칠 수 있다면 시간복잡도가 줄어들 것 같다.(위 설명 참고)\t\tfor (int i = 2; i &lt; rn; ++i)\t\t\tif (rn % i == 0)\t\t\t\treturn;  //소수가 아니면 빠져나간다.\t\t//현재 자릿수가 입력된 자릿수와 일치한다면 추가한다.\t\tif (size == n) {\t\t\tans.push_back(rn);\t\t\treturn;\t\t}\t}\tchar an[2];\tstring next;\t//소수가 될 수 있는 홀수를 추가한다.(짝수는 무조건 2의 배수이다.)\tfor (int i = 1; i &lt; 10; i += 2) {\t\tnext = num;\t\t//숫자 추가\t\tan[0] = i + '1' - 1;\t\tan[1] = '\\0';\t\tnext.append(an);\t\tsolve(next);\t}}int main(void){\tscanf(\"%d\", &amp;n);\t//첫째 자리로 시작할 수 있는 소수\tint start[4] = { 2, 3, 5, 7 };\t//한 자리수인 경우\tif (n == 1) {\t\tfor (int i = 0; i &lt; 4; ++i)\t\t\tprintf(\"%d\\n\", start[i]);\t}\t//두 자리수 이상인 경우\telse {\t\tsolve(\"2\");\t\tsolve(\"3\");\t\tsolve(\"5\");\t\tsolve(\"7\");\t}\tfor (int i = 0; i &lt; ans.size(); ++i)\t\tprintf(\"%d\\n\", ans[i]);\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_BOJ"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/BOJ-2023.%EC%8B%A0%EA%B8%B0%ED%95%9C-%EC%86%8C%EC%88%98/",
        "teaser":null},{
        "title": "[BOJ] 2580.스도쿠",
        "excerpt":"스도쿠 문제 링크   https://www.acmicpc.net/problem/2580해결 방법 백트래킹   입력으로 주어진 스도쿠 배열에서 빈칸이면 해당 좌표를 저장하고, 숫자라면 해당 숫자가 나왔다는 표시를 한다.  재귀 함수는 모든 빈칸이 채워질 때까지 실행한다.  재귀 함수안에서는 빈칸인 좌표의 행, 열, 박스에서 숫자 1 ~ 9중에서 3곳 모두 나오지 않은 숫자를 보드에 삽입하고 다음 재귀 함수를 실행한다.결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;#define cell(y, x) (((y) / 3 * 3) + ((x) / 3))//빈칸 좌표 저장pair&lt;int, int&gt; hole[81];//스도쿠 보드int board[9][9];//빈칸 개수int hIdx = 0;//해당 행, 열, 박스안에 어떤 숫자가 있는지 검사하는 배열bool checkRow[10][10], checkCol[10][10], checkSeq[10][10];//모든 빈칸이 알맞게 채워졌는지에 대한 플래그bool finishFlag = false;//빈칸 채우기void fillBoard(int idx) {\t//기저 사례: 빈칸이 모두 채워진 경우\tif (idx == hIdx) {\t\tfinishFlag = true;\t\treturn;\t}\t//현재 x, y 좌표\tint nowy = hole[idx].first;\tint nowx = hole[idx].second;\t//빈칸에 추가하기\tfor (int i = 1; i &lt; 10; ++i) {\t\t//행, 열, 박스 모두 없는 숫자인 경우 빈칸에 추가한다.\t\tif (!checkRow[nowy][i] &amp;&amp; !checkCol[nowx][i]\t\t\t&amp;&amp; !checkSeq[cell(nowy, nowx)][i]) {\t\t\t//해당 숫자를 추가한다.\t\t\tcheckRow[nowy][i] = checkCol[nowx][i] =\t\t\t\tcheckSeq[cell(nowy, nowx)][i] = true;\t\t\tboard[nowy][nowx] = i;\t\t\tfillBoard(idx + 1);\t\t\t//모두 찾았다면 함수를 나간다.\t\t\tif (finishFlag) return;\t\t\t//아닌 경우 다시 빈칸으로 만든다.\t\t\tboard[nowy][nowx] = 0;\t\t\tcheckRow[nowy][i] = checkCol[nowx][i] =\t\t\t\tcheckSeq[cell(nowy, nowx)][i] = false;\t\t}\t}}int main(void){\tfor (int i = 0; i &lt; 9; ++i) {\t\tfor (int j = 0; j &lt; 9; ++j) {\t\t\tscanf(\"%d\", &amp;board[i][j]);\t\t\t//빈칸이면 좌표 배열에 저장한다.\t\t\tif (!board[i][j])\t\t\t\thole[hIdx++] = make_pair(i, j);\t\t\t//빈칸이 아니면 해당 숫자가 나왔다는 표시를 한다.\t\t\telse {\t\t\t\tcheckRow[i][board[i][j]] = true;\t\t\t\tcheckCol[j][board[i][j]] = true;\t\t\t\tcheckSeq[cell(i, j)][board[i][j]] = true;\t\t\t}\t\t}\t}\t//모든 빈칸 채우기\tfillBoard(0);\tfor (int i = 0; i &lt; 9; ++i) {\t\tfor (int j = 0; j &lt; 9; ++j)\t\t\tprintf(\"%d \", board[i][j]);\t\tprintf(\"\\n\");\t}\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_BOJ"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/BOJ-2580.%EC%8A%A4%EB%8F%84%EC%BF%A0/",
        "teaser":null},{
        "title": "[BOJ] 1799.비숍",
        "excerpt":"비숍 문제 링크   https://www.acmicpc.net/problem/1799해결 방법 백트래킹   순수하게 비숍을 놓는 모든 경우를 재귀 함수로 구현하면 시간 복잡도는 O(${2}^{N * N}$)이므로, 시간 제한이 10초지만 이를 훨씬 넘어선다.  시간 복잡도를 줄이기 위해 체스판을 아래의 그림같이 나타내보자.   흰색과 검은색은 각각 대각선으로 모두 연결되는 것을 알 수 있다. 하지만 흰색과 검은색은 서로 대각선 관계가 아니기 때문에 흰색에 비숍을 놓고 검은색에 연속해서 비숍을 놓을 수 있다. 즉, 흰색과 검은색은 서로 독립적이므로 둘을 나눠서 생각할 수 있다.  흰색과 검은색을 둘로 나누어 재귀 함수를 구현하면 시간 복잡도는 O(${2}^{N/2 * N/2}$)로 대폭 줄일 수 있다.시간 복잡도 더 줄이기   재귀 구현에 방식에 따라 시간 복잡도를 더 줄일 수 있다.          현재 수준에서 이해할 수 있는 코드를 참고하여 구현하였는데, 비숍을 놓을 수 있는 모든 좌표마다 재귀 함수를 돌리고 재귀 함수내에서는 현재 좌표 이후에 놓을 수 있는 비숍을 검사한다.       결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int board[11][11];//한 대각선에 비숍이 있는지를 판단하는 배열//check[][0]: \\ 방향//check[][1]: / 방향bool check[21][2];int n;//ans: 검은색 부분과 흰색 부분의 비숍을 놓을 수 있는 최대값을 저장한다.int ans1, bn1, ans2, bn2;//검은색 부분에서 비숍을 놓을 수 있는 최대값을 계산한다.void dfs(int y, int x) {\t//기저 사례: 현재 좌표가 포함되어있는 2개의 대각선 중 어느 한 대각선이라도 비숍이\t//있다면 반환한다.\tif (check[y - x + n][0] || check[y + x][1])\t\treturn;\t//현재 좌표가 포함된 대각선에 비숍이 있다는 것을 표시한다.\tcheck[y - x + n][0] = check[y + x][1] = true;\t//비숍 개수를 갱신한다.\tbn1++;\tans1 = ans1 &gt; bn1 ? ans1 : bn1;\t//현재 x좌표 이후 부터 비숍을 놓을 수 있는지 검사한다.\tfor (int j = x + 1; j &lt; n; ++j) {\t\tif (y % 2 == 0 &amp;&amp; j % 2 == 0 &amp;&amp; board[y][j])\t\t\tdfs(y, j);\t\telse if (y % 2 == 1 &amp;&amp; j % 2 == 1 &amp;&amp; board[y][j])\t\t\tdfs(y, j);\t}\tfor (int i = y + 1; i &lt; n; ++i)\t\tfor (int j = 0; j &lt; n; ++j) {\t\t\tif (i % 2 == 0 &amp;&amp; j % 2 == 0 &amp;&amp; board[i][j])\t\t\t\tdfs(i, j);\t\t\telse if (i % 2 == 1 &amp;&amp; j % 2 == 1 &amp;&amp; board[i][j])\t\t\t\tdfs(i, j);\t\t}\tbn1--;\tcheck[y - x + n][0] = check[y + x][1] = false;}void dfs2(int y, int x) {\tif (check[y - x + n][0] || check[y + x][1])\t\treturn;\tcheck[y - x + n][0] = check[y + x][1] = true;\tbn2++;\tans2 = ans2 &gt; bn2 ? ans2 : bn2;\tfor (int j = x + 1; j &lt; n; ++j) {\t\tif (y % 2 == 0 &amp;&amp; j % 2 == 1 &amp;&amp; board[y][j])\t\t\tdfs2(y, j);\t\telse if (y % 2 == 1 &amp;&amp; j % 2 == 0 &amp;&amp; board[y][j])\t\t\tdfs2(y, j);\t}\tfor (int i = y + 1; i &lt; n; ++i)\t\tfor (int j = 0; j &lt; n; ++j) {\t\t\tif (i % 2 == 0 &amp;&amp; j % 2 == 1 &amp;&amp; board[i][j])\t\t\t\tdfs2(i, j);\t\t\telse if (i % 2 == 1 &amp;&amp; j % 2 == 0 &amp;&amp; board[i][j])\t\t\t\tdfs2(i, j);\t\t}\tbn2--;\tcheck[y - x + n][0] = check[y + x][1] = false;}int main(void){\tscanf(\"%d\", &amp;n);\tfor (int i = 0; i &lt; n; ++i)\t\tfor (int j = 0; j &lt; n; ++j)\t\t\tscanf(\"%d\", &amp;board[i][j]);\t//검은색 부분\tfor (int i = 0; i &lt; n; ++i)\t\tfor (int j = 0; j &lt; n; ++j)\t\t\tif (i % 2 == 0 &amp;&amp; j % 2 == 0 &amp;&amp; board[i][j] == 1)\t\t\t\tdfs(i, j);\t\t\telse if (i % 2 == 1 &amp;&amp; j % 2 == 1 &amp;&amp; board[i][j] == 1)\t\t\t\tdfs(i, j);\t//흰색 부분\tfor (int i = 0; i &lt; n; ++i)\t\tfor (int j = 0; j &lt; n; ++j)\t\t\tif (i % 2 == 0 &amp;&amp; j % 2 == 1 &amp;&amp; board[i][j] == 1)\t\t\t\tdfs2(i, j);\t\t\telse if (i % 2 == 1 &amp;&amp; j % 2 == 0 &amp;&amp; board[i][j] == 1)\t\t\t\tdfs2(i, j);\tprintf(\"%d\\n\", ans1 + ans2);\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_BOJ"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/BOJ-1799.%EB%B9%84%EC%88%8D/",
        "teaser":null},{
        "title": "[BOJ] 1941.소문난 칠공주",
        "excerpt":"소문난 칠공주 문제 링크   https://www.acmicpc.net/problem/1941해결 방법 조합 + BFS 문제를 읽고 처음에 바로 드는 생각은 DFS를 사용하여 각 인덱스마다 모두 탐색하면 해결할 수 있을 것이라 생각했다. 하지만 DFS를 사용하면 아래와 같은 구성에서는 찾을 수 없다. S Y S Y S  Y  S위는 문제 테스트 케이스에서의 한 구성이다. 이와 같이 십자 형태는 DFS를 사용한다면 지나온 길은 모두 FALSE로 변경하거나 TRUE인 칸은 지나지 못하기 때문에 탐색할 수 없다. 그러므로 다른 방법을 찾아야 한다. 문제에서 학생 수는 25명으로 고정되어 있고, 뽑아야 하는 학생 수도 7명으로 고정되어 있다. 이러한 상황에서 조합을 쓰기에 알맞다. 그리고 뽑은 7명의 구성이 가로나 세로로 인접하고 ‘이다솜파’ 학생이 4명 이상인지 검사한다면 문제는 해결된다. 시간 복잡도는 25명에서 7명을 뽑는 경우의 수 ${25} \\choose {7}$ = 480,700 이고, 서로 인접한지 검사를 BFS를 사용하면 배열 크기가 5 X 5이므로 25이다. 총 480,700 * 25 = 12,017,500로 시간안에 해결 가능하다. 결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;int my[4] = { 0, 1, 0, -1 };int mx[4] = { 1, 0, -1, 0 };string classroom[6];//check: 조합으로 계산한 7명을 표시하는 배열//visited: 방문한 것을 표시하는 배열bool check[6][6], visited[6][6];queue&lt;pair&lt;int, int&gt;&gt; q;int main(void){\tfor (int i = 0; i &lt; 5; ++i)\t\tcin &gt;&gt; classroom[i];\tint ans = 0;\t//조합 설정\tvector&lt;bool&gt; flag;\tfor (int i = 0; i &lt; 25 - 7; ++i)\t\tflag.push_back(0);\tfor (int i = 0; i &lt; 7; ++i)\t\tflag.push_back(1);\t//조합 탐색\tdo {\t\t//초기화\t\tmemset(check, false, sizeof(check));\t\tmemset(visited, false, sizeof(visited));\t\tint sn = 0;\t\tpair&lt;int, int&gt; pos;\t\t//계산된 7명 표시 및 '이다솜파' 수 계산\t\tfor (int i = 0; i &lt; 25; ++i)\t\t\tif (flag[i]) {\t\t\t\tpos = { i / 5, i % 5 };\t\t\t\tcheck[i / 5][i % 5] = true;\t\t\t\tif (classroom[i / 5][i % 5] == 'S') sn += 1;\t\t\t}\t\t//이다솜파가 4명보다 적으면 다음으로 넘어간다.\t\tif (sn &lt; 4) continue;\t\t//7명이 모두 인접한지 BFS를 통해 구한다.\t\tq.push(pos);\t\tint cn = 1;\t\tvisited[pos.first][pos.second] = true;\t\t//BFS\t\twhile (!q.empty()) {\t\t\tint nowy = q.front().first;\t\t\tint nowx = q.front().second;\t\t\tq.pop();\t\t\tfor (int i = 0; i &lt; 4; ++i) {\t\t\t\tint nexty = nowy + my[i];\t\t\t\tint nextx = nowx + mx[i];\t\t\t\tif (nexty &lt; 0 || nexty &gt;= 5 || nextx &lt; 0 || nextx &gt;= 5)\t\t\t\t\tcontinue;\t\t\t\t//7명 중의 하나이고 아직 방문하지 않은 경우\t\t\t\tif (check[nexty][nextx] &amp;&amp; !visited[nexty][nextx]) {\t\t\t\t\tcn += 1;\t\t\t\t\tvisited[nexty][nextx] = true;\t\t\t\t\tq.push({ nexty, nextx });\t\t\t\t}\t\t\t}\t\t}\t\t//인접한 학생이 7명인 경우\t\tif (cn == 7) ans++;\t} while (next_permutation(flag.begin(), flag.end()));\tprintf(\"%d\\n\", ans);\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_BOJ"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/BOJ-1941.%EC%86%8C%EB%AC%B8%EB%82%9C-%EC%B9%A0%EA%B3%B5%EC%A3%BC/",
        "teaser":null},{
        "title": "[BOJ] 2629.양팔저울",
        "excerpt":"양팔저울 문제 링크   https://www.acmicpc.net/problem/2629해결 방법 DP 주어진 추를 양쪽 저울에 모두 올릴 수 있으므로, 추를 사용하는 모든 경우의 수는 아래와 같이 3가지로 나뉜다.   구슬과 같은 저울에 올린 경우: -1  올리지 않은 경우: 0  구슬과 반대 저울에 올린 경우: 1예를 들어, 문제의 테스트 케이스와 같이 추의 무게가 1g, 4g 2개가 있을 때,   초기 상태: {0}  추 1g 추가: {-1, 0, 1}  추 4g 추가: {-5, -4, -3, 3, 4, 5}총 가능한 구슬 무게는 {0, 1, 3, 4, 5}가 된다. 하지만 중간 과정의 음수 무게도 추를 추가할 때마다 사용해야 하기 때문에 저장을 해두어야 한다. 위의 예제에서 확인할 수 있듯이 추를 추가할 때마다 가능한 무게의 경우의 수는 3의 제곱수로 증가한다. 위와 같은 과정을 완전 탐색으로 구현한다면 시간 복잡도는 하나의 추마다 3가지 경우가 존재하므로 ${3}^{N}$이다. 추의 개수 N은 최대 30개가 존재하므로 실제 계산량은 ${3}^{30}$ = 205891132094649 로 시간내에 해결 불가능하다. 위의 문제점을 해결하기 위해 DP를 사용한다. DP를 사용하면 아래의 구현 코드에서 확인할 수 있듯이 시간 복잡도는 O(N * 2M)이다.(N: 추 개수, M: 가능한 추의 무게) 구현 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;//계산 중간 과정에서 음수가 나올 수 있으므로//양수로 변환하기 위해 기준을 0에서 15000으로 변경한다.#define M 15000//weight[n] = n 무게의 구슬은 측정 가능하다.bool weight[30001];//추 무게를 추가하는 과정에서 반복문이 순서대로 검사하므로//현재 추가된 추 무게를 검사하는 현상이 발생한다. 이를 방지하기 위함.//(현재 추가된 추 무게는 다음 추를 추가할 때 검사되어야 한다.)bool access[30001];int w[31], marble;int main(void){\tint n; scanf(\"%d\", &amp;n);\tfor (int i = 0; i &lt; n; ++i)\t\tscanf(\"%d\", &amp;w[i]);\tweight[M] = true;\tfor (int i = 0; i &lt; n; ++i) {\t\t//현재 추를 추가했을 때 가능한 무게들을 검사하여 임의로 저장한다.\t\tfor (int j = 0; j &lt; 30001; ++j) {\t\t\tif (weight[j]) {\t\t\t\taccess[j + w[i]] = true;\t\t\t\taccess[j - w[i]] = true;\t\t\t}\t\t}\t\t//가능한 무게들을 실제로 추가하여 다음 계산에 사용할 수 있도록 한다.\t\tfor (int j = 0; j &lt; 30001; ++j)\t\t\tif (access[j])\t\t\t\tweight[j] = true;\t}\tint m; scanf(\"%d\", &amp;m);\tfor (int i = 0; i &lt; m; ++i) {\t\tscanf(\"%d\", &amp;marble);\t\tprintf(\"%c \", weight[marble + M] ? 'Y' : 'N');\t}\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_BOJ"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/BOJ-2629.%EC%96%91%ED%8C%94%EC%A0%80%EC%9A%B8/",
        "teaser":null},{
        "title": "[BOJ] 3109.빵집",
        "excerpt":"빵집 문제 링크   https://www.acmicpc.net/problem/3109해결 방법 그리디 + 백트래킹 주어진 최대 격자 크기가 10000 x 500이므로, 백트래킹으로 완전 탐색을 할 수 없다는 것을 알 수 있다. 문제에서 파이프라인은 왼쪽에서 오른쪽 방향 한 방향 으로 움직이며, 어느 한 칸에서 다음 칸으로 가는 경우의 수는 아래와 같다.   대각선 위  수평  대각선 아래이것으로 볼 때, 파이프라인을 대각선 위부터 순서대로 검사한다면 갈 수 있는 최대를 구할 수 있을 것이다.(그리디) 또 하나, 중요한 점은 어느 한 칸에서 다음 칸으로 넘어갈 수 없는 경우를 발견했다면 이 칸은 어느 파이프라인이 온다고 해도 다음 칸으로 넘어갈 수 없다. 1 X X . 12 1 X 1 23 2 1 2 .. 3 2 X .. . 3 X .위의 배열은 문제 테스트 케이스에서 파이프라인을 만드는 과정을 보여준다. 1번과 2번 파이프는 완전히 만들어진 상황이고 3번 파이프라인을 만들고 있다. 하지만 가장 아래의 3번에서 볼 수 있듯이, 더이상 앞으로 진행할 수 없다. 이 때 저 칸은 어느 파이프라인이라도 진행할 수 없으므로 이를 표시해두어 다음부터는 예외처리를 해야 한다. 결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;string&gt;using namespace std;int my[3] = { -1, 0, 1 };int mx[3] = { 1, 1, 1 };int map[10001][501];int r, c, pn;int dfs(int y, int x) {\t//기저 사례: 자신의 빵집에 도착한 경우(파이프라인이 만들어진 경우)\tif (x == c - 1) return 1;\tmap[y][x] = pn;\t//갈 수 있는 경우 탐색\tfor (int i = 0; i &lt; 3; ++i) {\t\tint nexty = y + my[i];\t\tint nextx = x + mx[i];\t\tif (nexty &lt; 0 || nexty &gt;= r || nextx &lt; 0 || nextx &gt;= c)\t\t\tcontinue;\t\tif (map[nexty][nextx] == 0) {\t\t\t//파이프라인을 만들었다면 모든 재귀 함수를 빠져나간다.\t\t\tif (dfs(nexty, nextx))  //greedy\t\t\t\treturn 1;\t\t}\t}  //키포인트\t//한번 갈 수 없는 파이프라인이면 다음 파이프라인도 가지 못한다.\t//map[y][x] = 0;\treturn 0;}int main(void){\tscanf(\"%d %d\", &amp;r, &amp;c);\tfor (int i = 0; i &lt; r; ++i) {\t\tstring input;\t\tcin &gt;&gt; input;\t\tfor (int j = 0; j &lt; c; ++j)\t\t\tif (input[j] == '.')\t\t\t\tmap[i][j] = 0;\t\t\telse\t\t\t\tmap[i][j] = -1;\t}\tint ans = 0;\tfor (int i = 0; i &lt; r; ++i) {\t\t//한 칸앞으로 가는길이 있는 경우에 파이프라인을 계산한다.\t\tif (!map[i + my[0]][1] || !map[i + my[1]][1]\t\t\t|| !map[i + my[2]][1]) {\t\t\tpn = ans + 1;\t\t\tans += dfs(i, 0);\t\t}\t}\tprintf(\"%d\\n\", ans);\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_BOJ"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/BOJ-3109.%EB%B9%B5%EC%A7%91/",
        "teaser":null},{
        "title": "[BOJ] 1342.행운의 문자열",
        "excerpt":"행운의 문자열 문제 링크   https://www.acmicpc.net/problem/1342해결 방법 순열(next_permutation STL 함수) 문자열의 길이가 10 이하이므로 순열을 사용하여 모든 문자열의 경우의 수(10! = 3,628,800)를 구할 수 있다. 문자열을 만들 때마다 인접한 문자들이 같은지 다른지 검사하고, 모두 다르면 행운의 문자열 개수에 추가한다. 여기서 next_permutation 함수를 사용하였는데, 이 함수는 다음 경우의 수열을 사전 순서대로 만들기 때문에 현재의 수열이 이전의 수열보다 사전 순서에서 빠르면 false를 반환한다. 그러므로, 오름차순의 수열은 정상적으로 모든 순열의 경우를 찾지만 오름차순이 아니라면 중간에 끝나서 모든 경우를 찾지 못할 수도 있다.(일반적인 while() 문의 조건문으로 사용한 경우) 이를 2가지로 해결할 수 있다.   입력받은 문자열을 오름차순으로 정렬한다.  while 문의 조건문에 next_permutation 함수를 쓰지 않고, 중간에 사용하고 조건문에는 원래의 문자열과 같은지를 검사하여 같으면 while 문을 빠져나간다.(원래 문자열과 같아진 경우, 그 다음에는 이전과 반복되기 때문이다.)백트래킹 모든 경우의 문자열을 만드는 것은 백트래킹으로도 가능하다. 하지만 현재 문자열은 중복 문자가 포함되어 있으므로, 같은 문자열을 여러개 만들어, 행운의 문자열 개수에 중복이 포함된다. 이 중복을 없애는 방법은 중복 원소를 포함한 순열 찾기에서와 같은 공식을 사용할 수 있다. 예제 테스트 케이스에서 문자열 aabbbaa가 만들 수 있는 모든 문자열의 개수는 7!이다. 여기서 중복 원소는 총 2가지로 aaaa, bbb 이다. aaaa가 만들 수 있는 모든 문자열의 개수는 4! 이고, bbb는 3! 이다. 그러므로 총 중복되는 개수는 4! * 3! 이라는 것을 알 수 있다. 결과적으로 중복을 제거해주기 위해서는 4! * 3!으로 나누어 주어야 한다. 백트래킹이 재귀 함수이므로 위의 next_permutation 함수를 사용하는 것보다는 시간이 훨씬 오래 걸리는 것을 확인할 수 있었다. 결과 코드 순열 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;int main(void){\tstring buf, tmp;\tcin &gt;&gt; buf;\tint size = buf.size();\ttmp = buf;\tint ans = 0;\tint iter = 0;\tdo {\t\tbool flag = true;\t\tfor (int i = 0; i &lt; size - 1; ++i)\t\t\tif (buf[i] == buf[i + 1]) {\t\t\t\tflag = false;\t\t\t\tbreak;\t\t\t}\t\tans += flag;\t\titer++;\t\tnext_permutation(buf.begin(), buf.end());\t} while (iter &gt; 0 &amp;&amp; tmp != buf);\tprintf(\"%d\\n\", ans);\treturn 0;}백트래킹 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;int ssize, ans = 0;bool check[11];//알파벳이 얼마나 중복되는 지 저장하는 배열int alpha_count[27];string str, tmp;//팩토리얼 계산int calFacto(int n) {\tif (n == 0) return 1;\tint ret = 1;\tfor (int i = 1; i &lt;= n; ++i)\t\tret *= i;\treturn ret;}//행운의 문자열인지 아닌지 검사bool lucky(string source) {\tint size = source.size();\tfor (int i = 0; i &lt; size - 1; ++i)\t\tif (source[i] == source[i + 1])\t\t\treturn false;\treturn true;}//모든 문자열 생성void dfs(int len) {\tif (len == ssize) {\t\t//cout &lt;&lt; tmp &lt;&lt; endl;\t\tif (lucky(tmp))\t\t\tans++;\t\treturn;\t}\tfor (int i = 0; i &lt; ssize; ++i) {\t\tif (!check[i]) {\t\t\tcheck[i] = true;\t\t\ttmp.push_back(str[i]);\t\t\tdfs(len + 1);\t\t\ttmp.pop_back();\t\t\tcheck[i] = false;\t\t}\t}\treturn;}int main(void){\tcin &gt;&gt; str;\tssize = str.size();\tfor (int i = 0; i &lt; ssize; ++i)\t\talpha_count[str[i] - 'a']++;\tdfs(0);\t//중복을 없애기 위해 중복되는 문자열이 만드는 경우의 수를 모두 나눠준다.\tfor (int i = 0; i &lt; 27; ++i)\t\tans /= calFacto(alpha_count[i]);\tprintf(\"%d\\n\", ans);\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_BOJ"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/BOJ-1342.%ED%96%89%EC%9A%B4%EC%9D%98-%EB%AC%B8%EC%9E%90%EC%97%B4/",
        "teaser":null},{
        "title": "[C++ STL] next_permutation",
        "excerpt":"next_permutation next_permutation 함수는 원래 순서를 다음 사전 순서의 순열로 재배치해주는 함수이다. (사전 순서는 오름차순이라고 볼 수 있다.) 구문 template&lt;class BidirectionalIterator&gt;  bool next_permutation(    BidirectionalIterator _First,    BidirectionalIterator _Last  );//배치 순서를 직접 지정해줄 수 있다.template&lt;class BidirectionalIterator, class BinaryPredicate&gt;  bool next_permutation(    BidirectionalIterator _First,    BidirectionalIterator _Last,    BinaryPredicate _Comp  );  _First: 다음 순열로 배치할 배열의 첫 번째 원소를 가르키는 반복자.  _Last: 다음 순열로 배치할 배열의 마지막 원소를 가르키는 반복자.  _Comp: 두 개의 인수를 사용하여 순서 조건이 만족하면 true, 만족하지 않으면 false를 반환한다.  반환값: 다음 순열이 현재 순열보다 사전 편찬 상 다음 순서이면 true, 사전 편찬 상 가장 작은 순서이면 false를 반환한다.          반환값을 통해 주의할 점은 순열을 구할 초기 배열이 오름차순으로 정렬되어 있다면 모든 순열을 순조롭게 구할 수 있지만, 오름차순이 아니라면 중간에 사전 편찬 상 가장 작은 순서(즉, 오름 차순으로 된 순서)가 발견되면 false를 반환하여 순열을 구하는 반복문을 빠져나갈 수 있다.       코드 분석  위 코드는 algorithm 헤더파일에 있는 next_permutation 함수와 참고자료를 참고하여 만들었으며, int 배열에서만 동작한다. next_permutation 함수는 배열의 뒤에서 부터 탐색하여 사전 편찬 방식에서 그 다음 순열을 찾는다. 시간 복잡도는 (last - first) / 2 swap(reverse 함수의 시간 복잡도) * N(배열의 길이)이다. reference의 설명을 참고하면 O(N)으로 선형적이라고 설명하고 있다. 요구 사항   헤더:   네임스페이스: std예제 코드 #include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(void){\tint arr[4] = { 1, 2, 3, 4 };\tdo {\t\tfor (int i = 0; i &lt; 4; ++i)\t\t\tprintf(\"%d \", arr[i]);\t\tprintf(\"\\n\");\t} while (next_permutation(arr, arr + 4));\treturn 0;}1 2 3 41 2 4 31 3 2 41 3 4 21 4 2 31 4 3 22 1 3 42 1 4 32 3 1 42 3 4 12 4 1 32 4 3 13 1 2 43 1 4 23 2 1 43 2 4 13 4 1 23 4 2 14 1 2 34 1 3 24 2 1 34 2 3 14 3 1 24 3 2 1참고 자료   Microsoft MSDN next_permutation  http://jeonggyun.tistory.com/110","categories": ["Cpp"],
        "tags": ["C++ STL 함수"],
        "url": "https://codemcd.github.io/pages/CODEMCD/cpp/Cpp-next_permutation/",
        "teaser":null},{
        "title": "[BOJ] 1019.책 페이지",
        "excerpt":"책 페이지 문제 링크   https://www.acmicpc.net/problem/1019해결 방법 수학 문제는 입력 값이 주어지면 1 ~ 입력 값까지 숫자 0 ~ 9까지 총 몇 번나오는지 출력하는 문제이다. 입력 값이 10억이하의 숫자이므로 1 부터 순차 탐색하면 최소 10억 번 계산을 해야 하기 때문에 시간 초과이다. 시간 초과를 해결하기 위해 자릿 수마다 숫자가 얼만큼 나왔는지 탐색한다. 예를 들어, 2345 숫자가 입력 값으로 주어졌다고 가정하자.   일의 자리: 5  십의 자리: 4  백의 자리: 3  천의 자리: 2위와 같이 자릿 수 별로 나눌 수 있다. 각 자리 수를 계산할 때는 1부터 2345가 가질 수 있는 모든 해당 자리 수를 구한다. 일의 자리 수를 구한다고 하면, [1, 2339(= 2345 / 10 - 1)] 범위에서는 1 ~ 9까지 각각 234 번이 나오는 것을 알 수 있다. 그리고 0은 1부터 시작하므로 총 233 나온다. 이를 수식으로 나타내면 아래와 같다.   0: 2345 / 10 - 1 번  1: 2345 / 10 번  2: 2345 / 10 번  …아직 [2340 ~ 2345] 범위가 남아 있다. 이는 0, 1, 2, 3, 4, 5 가 각각 한 번 씩 나온다.   2345 % 10 = 5 를 계산하면 0 ~ 5까지 한 번씩 더 남아있는 것을 알 수 있다.십의 자리는 일의 자리를 구할 때와 조금 다르다. 예를 들어, [10, 19]에서 십의 자리가 1인 숫자는 총 10번 나온다. 이는 2 ~ 9까지도 마찬 가지이다. 그리고 십의 자리수에서 0으로 시작하는 숫자는 없으며, 백의 자리 수부터 0으로 시작하는 십의 자리가 존재한다. 숫자 [1, 2229(= 2345 / 100 - 1)] 에서 십의 자리가 0일 때는 0이 출현하는 횟수는 100, 200, 300, ... 2200이고 각각 마다 총 10개가 있으므로, 22 * 10 개가 존재한다. 십의 자리가 1일 때는 10, 110, 210, 310, ... 2210으로 23 * 10 개가 있다.   0: (2345 / 100 - 1) * 10 번  1: 2345 / 100 * 10 번  2: 2345 / 100 * 10 번  …그리고 2300 ~ 2345까지는 [2300, 2309], [2310, 2319], [2320, 2329], [2330, 2339], [2340, 2345]로 0, 1, 2, 3이 각각 10개씩있고, 4가 5개 나오는 것을 알 수 있다. 백의 자리는 십의 자리와 똑같이 구할 수 있다. 마지막으로 천의 자리 숫자는 2이므로 1과 2인 경우 2가지가 있다.   1: [1000, 1999] 로 1000 개가 존재한다.  2: [2000, 2345] 로 346 개가 존재한다.총 정리하면 각 자리수의 출현 횟수를 구하는 것은 자릿수 마다 정확히 나누어 떨어진 경우 를 제외하면 3가지로 나눌 수 있다.   가장 오른쪽 자릿수(일의 자리)  중간 자릿수(가장 오른쪽과 가장 왼쪽 자릿수를 제외한 자릿수)  가장 왼쪽 자릿수결과 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;//각 숫자가 몇 번 나오는지 저장하는 배열int num_count[10] = { 0, };//제곱근 계산int Pow(int n, int d) {\tint ret = 1;\tfor (int i = 0; i &lt; d; ++i)\t\tret *= n;\treturn ret;}int main(void){\tstring num;\tcin &gt;&gt; num;\tint len = num.size();\tint n = atoi(num.c_str());\t//각 자리수일 때 해당 숫자가 몇번 나오는지 계산\t//i = 0: 일의 자리에서 해당 숫자가 몇 번 나왔는지 계산 ...\tfor (int i = 0; i &lt; len; ++i) {\t\tint div = Pow(10, i + 1);\t\tint tenAmp = i == 0 ? 1 : Pow(10, i);\t\tint share = n / div;\t\tint remainder = n % div;\t\t// 0)\t\tif (share &gt; 0) {\t\t\tnum_count[0] += (share - 1) * tenAmp;\t\t\tfor (int j = 1; j &lt; 10; ++j)\t\t\t\tnum_count[j] += (share * tenAmp);\t\t\t// 1)\t\t\tif (i == 0) {\t\t\t\tfor (int j = 0; j &lt;= remainder; ++j)\t\t\t\t\tnum_count[j] += tenAmp;\t\t\t}\t\t\t// 2)\t\t\telse {\t\t\t\tdiv = Pow(10, i);\t\t\t\tint nextShare = remainder / div;\t\t\t\tint nextRem = n % div;\t\t\t\tfor (int j = 0; j &lt; nextShare; ++j)\t\t\t\t\tnum_count[j] += tenAmp;\t\t\t\tnum_count[nextShare] += (nextRem + 1);\t\t\t}\t\t}\t\t// 3)\t\telse if(share == 0 &amp;&amp; remainder &gt; 0) {\t\t\tdiv = Pow(10, i);\t\t\tint nextShare = n / div;\t\t\tint nextRem = n % div;\t\t\tnum_count[nextShare] += (nextRem + 1);\t\t\tfor (int j = 1; j &lt; nextShare; ++j)\t\t\t\tnum_count[j] += tenAmp;\t\t}\t}\tfor (int i = 0; i &lt; 10; ++i)\t\tprintf(\"%d \", num_count[i]);\tprintf(\"\\n\");\treturn 0;}","categories": ["Algorithm"],
        "tags": ["Algorithm_BOJ"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/BOJ-1019.%EC%B1%85-%ED%8E%98%EC%9D%B4%EC%A7%80/",
        "teaser":null},{
        "title": "[Docker] Docker(도커)란?",
        "excerpt":"Docker란?  Docker는 부두 노동자라는 영어 단어로서, Linux 기반의 Container RunTime 오픈소스 가상화 플랫폼이다. 등장 배경 여러 OS와 플랫폼의 등장으로 서버를 관리하는데 비용이 너무나 커졌다. Linux, Windows, Mac과 같이 여러 운영체제가 존재하고 Linux 내에서도 CentOS, Ubuntu 등등 다양하다. 이에 더해 현재에는 클라우드 서비스가 활발하며, 클라우드 역시 AWS, Azure, 구글 클라우드 등 서버를 운영하기 위한 환경이 매우 다양하다. 하나의 서버에서 여러 프로그램을 설치하는 것에는 많은 충돌이 발생한다. 현재에는 위와 같이 여러 환경이 존재하기 때문에 가상머신을 여러 개 사용해야한다. 하지만 가상머신 기술은 전체 운영체제를 설치하는 방식이므로 매우 느리고 관리하기 힘들다. 이를 해결하기 위해 Docker가 등장한다. 가상머신(Virtual Machine) 가상머신은 하드웨어를 소프트웨어적으로 구현해서 그 위에서 운영체제를 작동하도록하는 기술이다. 즉, 리얼머신에서 하나의 운영체제가 동작하고 있는 상황에서 가상머신을 통해 다른 운영체제를 하나 더 사용할 수 있다. 가상화의 방식에는 전가상화(Full-Virtualization)과 반가상화(Para-Virtualization)으로 나뉜다. 전가상화는 하드웨어 자원을 완전히 가상화하는 방식이다. 그러므로 Guest OS를 아무런 수정없이 쉽게 도입이 가능하다. 하지만, CPU의 VT(Virtual Technology)를 이용하므로 오버헤드가 상당히 크다. 전가상화를 사용하는 플랫폼은 VMware, VirtualBox 등이 있다. 반가상화는 게스트 OS를 수정하여 게스트 OS가 가상화되고 있음을 인식하도록 하여 하이퍼바이저(Hyperviser, 가상화를 지원하는 소프트웨어)가 필요할 때만 호출되도록 한다. 반가상화는 게스트 OS를 수정해야 하므로 OS 소스코드에 접근가능해야 하므로 도입이 어렵다. 하지만, 가상화를 호출하는 빈도를 최소화하여 성능을 대폭 향상시킬 수 있다. 반가상화는 대표적으로 Xen이 있다.  가상머신 자체는 완전한 게스트 운영체제를 설치해야 하므로 용량이 크고 반가상화라 할지라도 리얼 머신에 비해 성능이 크게 감소된다. Docker Docker는 반가상화보다도 조금 더 경령화된 방식이다. Docker는 게스트 OS 자체를 설치하지 않고 운영에 필요한 프로그램과 라이브러리만 설치하여 이미지 크기를 대폭 줄였다. 그리고 시스템 콜과 같은 OS 자원은 호스트 OS와 공유한다.  Docker는 하이퍼바이저가 없기 때문에 리얼 머신과 성능이 거의 비슷하다. 아래의 표를 보면 확인할 수 있듯이 CPU, 메모리 접근, 파일 시스템 성능이 거의 똑같이 나오는 것을 볼 수 있고, 네트워크 속도 역시 비슷하게 측정된다고 한다.  Docker 구성 Docker는 크게 컨테이너(Container)와 이미지(Image)로 구성되어 있다. 컨테이너는 리눅스의 컨테이너 기술에서 왔으며, 이미지는 컨테이너 실행에 필요한 파일이다. 리눅스 컨테이너 LXC(Linux Container)는 운영 시스템 레벨의 가상화 방법이다. 단일 호스트 환경에서 여러 개의 고립된 리눅스 시스템(컨테이너)들을 사용하기 위해 만들어졌다. 이를 위해 리눅스 커널안에서 고립된 가상의 공간을 만든다고 볼 수 있다. 컨테이너는 가상머신과 달리 호스트 OS에서 바로 시작하여 훨씬 성능이 좋다. 컨테이너는 자체적인 그룹화를 시행하여 다른 그룹이나 그룹에 속하지 않는 프로세스들과 단절된 공간을 만든다. 컨테이너간 역시 서로 내부를 볼 수 없다. LXC는 리눅스 커널의 cgroups(Control Groups)와 namespaces(Namespace Isolation)를 결합하여 고립된 공간을 만든다. cgroups는 CPU, 메모리, 블록 I/O, 네트워크 등과 같은 자원을 할당한다. namespace isolation은 애플리케이션 입장에서 프로세스 트리, 네트워크, 사용자 ID, 마운트된 파일 등을 호스트와 완전히 격리하여 고립된 운영 환경을 만들고, 이는 cgroups에서 제공한다.  LXC는 리눅스가 제공하는 기술 중 하나인 “chroot”와 비슷하다. chroot는 프로세스의 루트 디렉토리를 변경하는 명령으로, 프로세스가 접근 할 수 있는 디렉트로리를 제한하거나 시스템 라이브러리와 관련 라이브러리를 로드할 수 있다. 하지만 이것만으로는 네트워크와 프로세스를 제어할 수 없었다. 이를 해결하기 위해 더 발전시킨 “jail” 기능이 만들어졌다. LXC는 jail과 유사한 개념으로 여러 자원을 제어 및 격리하는 기능이 구현되어 있다. Docker는 초기에는 LXC기반으로 컨테이너 생성 및 관리 기능 등 다양한 기능을 추가하였다. 버전 0.9 이후로는 libcontainer를 자체적으로 개발하여 사용하고 있으며, 옵션을 통해 LXC와 libcontainer를 선택적으로 사용할 수 있다.  이미지(Image) Docker 이미지는 보통 2가지로 구성되어 있다. 첫 번째는 리눅스 운영체제이다. 어떤 프로그램(예를들어, Nginx, MySQL 등)을 실행하려면 운영체제가 있어야 한다. Docker 이미지에서는 기본적으로 리눅스 배포판을 사용한다. 배포판에는 리눅스 부팅에 필요한 최소한의 실행 파일과 라이브러리가 존재한다. 배포판만으로도 패키징 시스템을 사용할 수 있다. 물론 다른 필요한 기능들을 추가하여 이미지를 만들 수도 있다. 두 번째는 사용할 애플리케이션이다. Docker 이미지 크기는 수메가에서 수기가바이트까지 필요에 따라 다양하지만, 운영체제 하나가 수십기가바이트이므로, 훨씬 작은 크기인 것을 알 수 있다. Docker 이미지는 Docker hub를 통해 대부분 공개되어 있어 필요에 따라 적절한 이미지를 찾아 사용할 수 있고, 자신이 만든 이미지 역시 등록할 수 있다. 컨테이너(Container) 컨테이너는 이미지 파일을 실행한 상태라고 볼 수 있다. 하나의 이미지로 여러 컨테이너를 만들 수 있고, 이들은 모두 독립적이다. 운영체제로 보면 이미지는 실행 파일이고, 컨테이너는 프로세스라고 볼 수 있다. 이미 실행된 컨테이너에서 해당 이미지가 변경된 부분을 바로 새로운 이미지로 만들 수도 있다. Docker layer Docker 이미지를 수정할 때마다 수백메가의 크기를 계속 다시 다운로드받는다면 엄청난 비효율을 가져온다. Docker는 이를 해결하기 위해 레이어(layer)라는 개념을 도입하여 유니온 파일 시스템(Union File System)을 사용한다. 이를 통해 여러 개의 레이어를 하나의 파일 시스템으로 사용할 수 있다. Docker 이미지는 읽기 전용 상태이다. 여기서 내용이 바뀌면 해당 이미지를 수정하지 않고, 쓰기 이미지를 생성한 뒤 수정된 내용만을 기록한다. 이러한 방식을 Union mount라고 한다. 예를 들어, Ubuntu 이미지가 A, B, C로 구성되어 있다. 여기서 웹서비스를 제공하기 위해 Nginx를 설치 한다. 그러면 기존의 Ubuntu에 Nginx라는 새로운 내용이 추가되어 새로운 이미지 (A, B, C), Nginx가 만들어진다. 마지막으로 애플리케시션 소스를 추가하면 최종으로 (A, B, C, Nginx), Source 이미지가 생성된다.  위 그림은 예제를 그림으로 표시한 것이다. 컨테이너를 생성할 때는 읽기/쓰기 레이어(R/W layer)를 기본적으로 추가하여 해당 이미지에서 변경된 내용을 저장한다. 이와 같이 이미지들은 수정될 때마다 새로운 이미지를 만들어내며, 기존의 이미지와 새로 만들어진 이미지 사이에 부모-자식 관계가 만들어진다. 위의 예제를 이러한 의존적 관계로 나타내면 아래 그림과 같다. Docker 이미지를 생성할 때는 바뀐 부분만 생성한 뒤 부모 이미지와 연결한다. 컨테이너를 실행하면 해당 이미지를 불러온 뒤 부모를 계속 참조하는 방식으로 동작한다.  Docker 이미지 파일을 Docker hub에 올릴 때는 부모 이미지들을 모두 포함하여 올린다. Dockerfile FROM node:9.4.0-alpineCOPY app.js .COPY package.json .RUN npm install &amp;&amp;\\    apk update &amp;&amp;\\    apk upgradeEXPOSE  8080CMD node app.jsDocker 이미지를 만들기 위해서는 Dockerfile을 빌드해야 한다. 이 파일은 DSL(Domain Specific Language)를 사용한다. 이 파일은 해당 이미지를 생성하기 위해서 필요한 여러 사전 작업을 명시하여 실행시킨다. 여러 의존성 패키지를 설치하거나 포트를 연결해주는 일 등을 한다. DSL   FROM: 어떤 이미지를 기반으로 할지 설정  MAINTAINER: 이미지 작성자 정보  RUN: 이미지에서 스크립트나 명령 실행  CMD: 컨테이너가 시작되었을 때 스크립트나 명령 실행  ENTRYPOINT: 컨테이너가 시작되었을 때 스크립트나 명령 실행(docker run에서 처리 방식이 다름)  EXPOSE: 호스트와 연결할 포트 번호 설정  ENV: 환경 변수 설정  ADD, COPY: 이미지에 파일 추가  VOLUME: 데이터를 호스트에 저장하도록 설정  USER: 명령을 실행할 사용자 계정 설정  WORKDIR: 명령을 실행할 디렉토리 설정  ONBUILD: FROM으로 이미지가 사용될 때 실행할 명령 설정이미지 만들기 예제 간단하게 웹(web)에 글을 출력하는 이미지 파일을 만들어보자. 이를 위해 아래의 3개의 파일이 필요하고, 해당 디렉토리안에서 명령어를 사용해야 한다.   DockerfileFROM node:9.4.0-alpineCOPY app.js .COPY package.json .RUN npm install &amp;&amp;\\    apk update &amp;&amp;\\    apk upgradeEXPOSE  8080CMD node app.js  app.jsvar express = require('express')var os = require(\"os\");var hostname = os.hostname();var app = express()app.get('/', function(req, res) {  res.send('Hello world from ' + hostname + '! Your app is up and running in a cluster!\\n')})app.listen(8080, function() {  console.log('Sample app is listening on port 8080.')})  package.json{  \"name\": \"hello-world-demo\",  \"private\": false,  \"version\": \"0.0.1\",  \"description\": \"Basic hello world application for Node.js\",  \"dependencies\": {    \"express\": \"3.x\"  }}  이미지 빌드(Build)docker image build -t hello-world:1 .          docker build        -t: tag의 약자로 해당 이미지에 이름을 붙인다.(이름:버전 양식)        이미지 확인docker image ls  이미지 세부 사항docker image inspect hello-world:1  이미지 실행docker container run -d -p 8080:8080 -v /root/date:/date --name hello-world-a hello-world:1          -d: 컨테이너를 백그라운드로 실행한다.      -p Host Port:Container Port: 호스트 포트와 컨테이너 포트를 연결하고 외부에 노출시킨다. http://:8080에 접속하면 컨테이너의 8080번 포트로 접속된다.      -v Host Directory:Container Directory: volume의 약자로 호스트의 디렉토리를 컨테이너 디렉토리에 연결한다. 그러면 호스트의 디렉토리에 파일을 컨테이너에서 사용할 수 있다.(변경사항들도 모두 적용된다.)      --name: 이미지 이름을 설정한다.            컨테이너 확인docker container ls     실행 결과 화면 참고 자료   전가상화와 반가상화  리눅스 컨테이너  Docker  Docker 예제","categories": ["Study"],
        "tags": ["Study_Cloud"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/Docker-WhatIsDocker/",
        "teaser":null}]
