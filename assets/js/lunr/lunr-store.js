var store = [{
        "title": "[Algorithm]절단점 찾기 알고리즘",
        "excerpt":"깊이 우선 탐색(DFS)를 활용한 절단점 관련 알고리즘 절단점이란?   절단점(cut vertex): 어떤 무향 그래프의 절단점이란 이 점과 인접한 간선들을 모두 지웠을 때 해당 컴포넌트가 2개 이상으로 나뉘어지는 정점을 말한다.   위 그래프에서 1, 3, 5 정점이 각각 절단점이다.절단점 찾기 알고리즘   무향 그래프에서 한 번의 깊이 우선 탐색으로 그래프의 모든 절단점으르 찾을 수 있다.  무향 그래프에서 절단점을 포함하지 않는 서브그래프를 이중 결합 컴포넌트(biconnected component)라고 부른다.          이중 결합 컴포넌트에서 임의의 한 정점을 지우더라도 정정 간의 연결 관계는 유지된다.        탐색 과정               임의의 정점에서부터 깊이 우선 탐색을 수행하여 DFS 스패닝 트리를 만든다.  무향 그래프에서 어떤 정점 u는 연결된 모든 정점들은 u의 선조 아니면 자손 관계에 있다.          무향 그래프에서는 교차 간선이 없기 때문이다.      따라서, u의 자손들을 루트로 하는 서브트리들은 서로 연결되어 있지 않다.        위의 조건을 이용하면 u가 지워졌을 때, 그래프가 쪼개지지 않는 유일한 경우는 u의 선조와 자손들이 서로 전부 역방향 간선으로 연결되어 있는 경우이다.   u의 자손들이 전부 역방향 간선을 통해 u의 선조로 갈 수 있다면, u는 절단점이 아니다.  u가 스패닝 트리의 루트라서 선조가 없는 경우는 둘 이상의 자손을 가질때만 절단점이 될 수 있다.          u의 선조가 없다고 무조건 절단점이 되는 것은 아니다.      u의 자손이 하나도 없거나 하나만 있을 경우, u정점이 지워져도 그래프는 쪼개지지 않는다.      구현   u정점의 조상들이 항상 u보다 먼저 발견되어야 한다는 점을 활용하여, 깊이 우선 탐색이 해당 정점을 루트로 하는 서브트리에서 역방향 간선을 통해 닿는 정점들의 최소 발견순서를 반환한다.//그래프의 인접 리스트 표현vector&lt;vector&lt;int&gt;&gt; adj;//각 정점의 발견 순서, -1로 초기화vector&lt;int&gt; discovered;//각 정점이 절단점인지 여부를 저장한다. false로 초기화vector&lt;bool&gt; isCutVertex;int counter = 0;//here를 루트로 하는 서브트리에 있는 절단점들을 찾는다.//반환 값은 해당 서브트리에서 역방향 간선으로 갈 수 있는 정점 중 가장 일찍 발견된 정점의 발견 시점.//처음 호출은 isRoot = true이다.int findCutVertex(int here, bool isRoot) {  //발견 순서를 기록한다.  discovered[here] = counter++;  int ret = discovered[here];  //루트인 경우의 절단점 판정을 위해 자손 서브트리의 개수를 센다.  int children = 0;  for(int i = 0; i &lt; adj[here].size(); ++i) {    int there = adj[here][i];    if (discovered[there] == -1) {      ++children;      //이 서브트리에서 갈 수 있는 가장 높은 정점의 번호      int subtree = findCutVertex(there, false);      //그 번호가 자기 자신 이하라면 현재 위치는 절단점!      if (!isRoot &amp;&amp; subtree &gt;= discovered[here])        isCutVertex[here] = true;      ret = min(ret, subtree);    }    else      ret = min(ret, discovered[there]);  }  //루트인 경우 절단점 판정은 서브트리의 개수로 한다.  if(isRoot) isCutVertex[here] = (children &gt;= 2);  return ret;}강결합 컴포넌트 (Strongly Connected Components, SCC) 분리   방향 그래프에서는 무향 그래프의 절단점 정의를 그대로 사용할 수 없으므로, 이중 결합 컴포넌트를 정의할 수 없다.  방향 그래프에서는 이중 결합 컴포넌트와 유사한 강결합 컴포넌트가 있다.          방향 그래프 상에서 두 정점 u, v에 대해 양 방향으로 가는 경로가 모두 있을 때, 두 정점은 같은 SCC에 속해 있다고 말한다.         위 그림은 한 그래프의 각 SCC들을 짙은 색 배경으로 구분한 모습이다.  SCC 특징          위 그래프에서도 볼 수 있듯이, SCC 사이를 연결하는 간선들을 모으면 각 SCC들을 정점으로 하는 DAG를 만들 수 있다.                  원 그래프의 정점들을 SCC별로 분리하고 각 SCC를 표현하는 정점들을 갖는 새로운 그래프를 만드는 과정을 그래프 압축(condensation)이라 부른다.                    한 사이클에 포함된 정점들은 항상 같은 SCC에 속한다.      반대로 한 SCC에 속한 두 정점 사이를 잇는 양방향 경로를 합치면 두 정점을 포함하는 사이클이 된다.      강결합 컴포넌트 분리를 위한 타잔(Tarjan)의 알고리즘   타잔 알고리즘은 한 번의 깊이 우선 탐색으로 강결합 컴포넌트를 분리할 수 있다.1. 알고리즘 과정   임의의 정점에서부터 깊이 우선 탐색을 수행하여 DFS 스패닝 트리를 만든다.   위 그림은 예제 그래프의 가장 왼쪽 정점에서 깊이 우선 탐색을 해서 얻은 스패닝 트리이다.          스패닝 트리를 적절히 자르기만 하면 정점들을 SCC로 분리할 수 있다는 것을 알 수 있다.        동심원으로 표현된 정점들을 각 SCC의 루트라고 하자.  이때 SCC를 분리하기 위해 끊어야할 간선들은 모두 SCC의 루트로 내려가는 트리 간선임을 알 수 있다.          스패닝 트리에서 인접한 두 정점이 서로 다른 SCC에 속한다면, 그 중 자손 정점은 자신이 속한 SCC의 루트여야만 한다.        한 정점이 해당 SCC의 루트에 속하는지 알기 위해서는 절단점 찾기 알고리즘을 응용하여 판단할 수 있다.          어떤 정점 u가 SCC의 루트라면, u의 선조와 u가 서로 다른 SCC에 속한다는 의미이다.      위의 조건을 만족하려면, u에서 그 선조로 가는 경로가 없어야하는데 이 경로를 탐색 없이 확인하는 방법은 절단점 찾기 알고리즘을 응용해야 한다.        u를 루트로 하는 서브 트리 깊이 우선 탐색하면서 만나는 모든 역방향 간선을 이용해 닿을 수 있는 가장 상위 정점을 찾는다.  이 정점이 u의 선조거나 그보다 높이 있다면 이 역방향 간선을 이용해 u에서 그 선조로 갈 수 있으며, 따라서 u는 SCC의 루트가 아니다.  방향 그래프에서는 교차 간선이 존재하므로, 이를 유의해야 한다.          어떤 정점이 SCC의 루트인데, 자손 중 하나가 교차 간선을 통해 다른 정점에 연결되어 있다면 판정이 잘못 될 수 있다.       - 위 그림에서 u에서 깊이 우선 탐색을 시작하여 왼쪽의 SCC를 먼저 탐색한 뒤 v로 왔다고 한다면, w에서 왼쪽으로 가는 교차 간선을 v의 선조로 가는 역방향 간선이라고 판단하여 v가 SCC의 루트가 아니라고 잘못된 판단을 내린다.- 해결 방법은 그래프의 모든 교차 간선은 무시한다.2. 구현   현재 위치를 루트로 하는 서브트리에 남아 있는 정점들을 모두 찾는 방법을 스택을 이용하여 구현한다.          scc()함수는 깊이 우선 탐색 과정에서 지금까지 방문한 정점 중 아직 SCC로 묶이지 않은 모든 정점들을 스택에 담는다.      각 정점을 처음 방문할 때마다 스택에 넣기 때문에, here가 SCC의 루트라는 것을 확인하면 스택에서 here 위에 있는 정점들은 모두 here의 후손이다.      따라서, here를 만날 때까지 계속 스택에서 정점을 꺼내는 방식으로 쉽게 구현이 가능하다.        시간 복잡도: O(|V| + |E|)  SCC의 위상 정렬          아래의 코드에서 새 SCC가 생성되는 시점은 항상 scc()함수가 종료하기 직전이다.      위와 같은 속성때문에, 각 SCC는 위상 정렬의 역순으로 번호가 매겨진다. (dfs()가 늦게 종료하는 정점부터 배열하면 위상 정렬 결과가 나온다)      그래프의 압축을 바로 사용할 수 있다.        구현 코드 및 예제구현 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; adj;//각 정점의 컴포넌트 번호, 컴포넌트 번호는 0부터 시작하며,//같은 강결합 컴포넌트에 속한 정점들의 컴포넌트 번호가 같다.vector&lt;int&gt; sccId, discovered, finished;stack&lt;int&gt; st;  //정점의 번호를 담는 스택int sccCounter, vertexCounter;//here를 루트로 하는 서브트리에서 역방향 간선으로 닿을 수 있는 최소의 발견 순서를 반환한다.int scc(int here) {\tint ret = discovered[here] = vertexCounter++;\t//스택에 here를 넣는다. here의 후손들은 모두 스택에서 here 후에 들어간다.\tst.push(here);\tfor (int i = 0; i &lt; adj[here].size(); ++i) {\t\tint there = adj[here][i];\t\t//(here, there)가 트리 간선\t\tif (discovered[there] == -1)\t\t\tret = min(ret, scc(there));\t\t//(here, there)가 역행 간선인 경우 선조 정점의 발견 순서를 확인한다.\t\telse if (discovered[there] &lt; discovered[here] &amp;&amp; finished[there] == -1)\t\t\tret = min(ret, discovered[there]);\t}\t//here가 강결합 컴포넌트의 루트인지 확인한다.\tif (ret == discovered[here]) {\t\t//here를 루트로 하는 서브트리에 남아 있는 정점들을 전부 하나의 컴포넌트로 묶는다.\t\twhile (true) {\t\t\tint t = st.top();\t\t\tst.pop();\t\t\tsccId[t] = sccCounter;\t\t\tif (t == here) break;\t\t}\t\t++sccCounter;\t}\tfinished[here] = 1;\treturn ret;}//tarjan의 SCC알고리즘vector&lt;int&gt; tarjanSCC() {\t//배열과 카운터 초기화\tsccId = discovered = finished = vector&lt;int&gt;(adj.size(), -1);\tsccCounter = vertexCounter = 0;\t//모든 정점에 대해 scc()호출\tfor (int i = 0; i &lt; adj.size(); ++i)\t\tif (discovered[i] == -1) scc(i);\treturn sccId;}int main(){\t//n: 정점의 개수, m: 간선의 개수\tint n, m; scanf(\"%d %d\", &amp;n, &amp;m);\tadj = vector&lt;vector&lt;int&gt;&gt;(n);\tfor (int i = 0; i &lt; m; i++) {\t\tint s, e; scanf(\"%d %d\", &amp;s, &amp;e);\t\tadj[s].push_back(e);\t}\tvector&lt;int&gt; ans;\tans = tarjanSCC();\tfor (int i = 0; i &lt; n; ++i)\t\tprintf(\"%d \", ans[i]);\treturn 0;}  예제 그래프(위의 예제 그래프에 정점 번호 부여)   예제 입력    11 150 10 71 22 02 33 43 64 55 37 87 98 68 99 1010 8        예제 결과    4 4 4 1 1 1 0 3 2 2 2                  정점 번호      0      1      2      3      4      5      6      7      8      9      10                  SCC 번호      4      4      4      1      1      1      0      3      2      2      2      참고 문헌   프로그래밍 대회에서 배우는 알고리즘 문제해결전략, 인사이트, 구종만 지음","categories": ["Algorithm"],
        "tags": ["Algorithm_Algorithm"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-%EC%A0%88%EB%8B%A8%EC%A0%90-%EC%B0%BE%EA%B8%B0-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/",
        "teaser":null},{
        "title": "[Algorithm]소수 구하기",
        "excerpt":"소수 에라토스테네스의 체 정의   제일 작은 소수 2부터 N-1까지 수 중에서 2의 배수를 모두 체로 거르고, 남은 수중에서 3의 배수를 거르는 과정을 반복하여 루트N 까지 걸러서 남은 수들이 이 범위안의 소수이다.구현 //에라토스테네스의 체prime[0] = prime[1] = 1;  //0,1은 소수 판별에서 제외되는 숫자이기 때문for (int i = 2; i &lt; N; i++) {\tif (prime[i] == 0) {\t       for (int j = i + i; j &lt; N; j += i)\t                prime[j] = 1;\t}}  //prime 배열의 값이 0인 인덱스가 소수이다.  일정 범위 내의 수에서 모든 소수를 구하는 문제에 주로 사용된다.","categories": ["Algorithm"],
        "tags": ["Algorithm_Algorithm"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-%EC%86%8C%EC%88%98-%EA%B5%AC%ED%95%98%EA%B8%B0/",
        "teaser":null},{
        "title": "[Algorithm]순열과 조합",
        "excerpt":"순열과 조합 경우의 수   합의 법칙: 분류          분류의 조건                  동시에 일어나지 않음.          하나도 빠짐없이 포함되어 있어야함.                      곱의 법칙: 동시에 일어나는 일 = 함께 일어나는 일  예제자연수 999이하의 수 중에서 숫자 5가 포함된 수의 개수를 구하라.1. 합의 법칙 = 분류1) 5가 1개 있는 경우의 수 (곱의 법칙)- 5xx = 9 * 9 = 81 * 1- x5x = 9 * 9 = 81 * 1- xx5 = 9 * 9 = 81 * 12) 5가 2개 있는 경우의 수 (곱의 법칙)- 55x = 9 * 2 = 18- 5x5 = 9 * 2 = 18- x55 = 9 * 2 = 183) 5가 3개 있는 경우의 수 (곱의 법칙)- 555 = 1 * 3=&gt; (81 + 81 + 81) + (18 + 18 + 18) + 3 = 300순열(Permutation)   순서 있는 나열  nPr: n개 중에서 r개를 뽑아서 일렬로 나열하는 경우의 수  nPr = n! / (n-r)!STL함수 next_permutation을 활용한 순열 구현(C++)   기본적으로 next_permutation은 nPn을 구하는 함수이다.  nPr을 next_permutation을 활용하여 구할려면 nPn을 구한 상태에서 r크기까지만 저장한다.          하지만, nPn과 시간복잡도가 같다는 단점이 있다.      구현 코드 /*순열은 초기화가 필요하다.for (int i = 0; i &lt; n; ++i)\t\tset.push_back(i);*/void permutationSTL(vector&lt;int&gt; set, int n, int r) {\tdo {\t\tfor (int i = 0; i &lt; r; ++i)\t\t\tprintf(\"%d \", set[i]);\t\tprintf(\"\\n\");\t} while (next_permutation(set.begin(), set.end()));}재귀 함수를 활용한 순열 구현(C++) void swapSet(vector&lt;int&gt; &amp;num, int a, int b) {\tint tmp = num[a];\tnum[a] = num[b];\tnum[b] = tmp;}void permutation(vector&lt;int&gt; set, int setSize, int n, int r) {\t//종료 조건\tif (setSize == r) {\t\tfor (int i = 0; i &lt; setSize; ++i)\t\t\tprintf(\"%d \", set[i]);\t\tprintf(\"\\n\");\t\treturn;\t}\t//분기 조건\tfor (int i = setSize; i &lt; n; ++i) {\t\tswapSet(set, i, setSize);\t\tpermutation(set, setSize + 1, n, r);\t\tswapSet(set, i, setSize);\t}}중복 순열(Repeated permutation)   중복 원소를 포함하는 순서있는 나열void repeatedPerm(vector&lt;int&gt; set, int setSize, int n, int r) {\t//종료 조건\tif (setSize == r) {\t\tfor (int i = 0; i &lt; setSize; ++i)\t\t\tprintf(\"%d \", set[i]);\t\tprintf(\"\\n\");\t\treturn;\t}\t//분기 조건\tfor (int i = 0; i &lt; n; ++i) {\t\tset[setSize] = i;\t\trepeatedPerm(set, setSize + 1, n, r);\t}}조합(Combination)   순서를 고려하지 않고 선택하는 방법의 수  nCr: n개 중에서 r개를 순서에 상관없이 선택하는 방법의 수  nCr = nPr / r! = n! / (n-r)!r!STL함수 next_permutation을 활용한 조합 구현(C++)   n 크기의 배열에서 r 개수만큼의 1을 배열 뒤에서 부터 삽입하고 나머지는 0으로 채운다.  위의 배열을 이용하여 next_permutation 함수를 사용하여 순열을 구한 후 1에 해당하는 인덱스를 뽑는다.구현 코드 void combinationSTL(vector&lt;int&gt; set, int n, int r) {\tfor (int j = 0; j &lt; n - r; ++j)\t\tset.push_back(0);\tfor (int j = 0; j &lt; r; ++j)\t\tset.push_back(1);\tdo {\t\tfor (int j = 0; j &lt; n; ++j)\t\t\tif (set[j])\t\t\t\tprintf(\"%d \", j);\t\tprintf(\"\\n\");\t} while (next_permutation(set.begin(), set.end()));}재귀 함수를 활용한 조합 구현(C++) //set = vector&lt;int&gt;(n);void repeatedComb(vector&lt;int&gt; set, int setSize, int n, int r, int idx) {\t//종료 조건\tif (setSize == r) {\t\tfor (int i = 0; i &lt; setSize; ++i)\t\t\tprintf(\"%d \", set[i]);\t\tprintf(\"\\n\");\t\treturn;\t}\tif (n == idx) return;\t//분기 조건\tset[setSize] = idx;\trepeatedComb(set, setSize + 1, n, r, idx + 1);\trepeatedComb(set, setSize, n, r, idx + 1);}중복 조합(Repeated combination)   중복 원소를 포함하여 선택하는 방법의 수void repeatedComb(vector&lt;int&gt; set, int setSize, int n, int r, int idx) {\t//종료 조건\tif (setSize == r) {\t\tfor (int i = 0; i &lt; setSize; ++i)\t\t\tprintf(\"%d \", set[i]);\t\tprintf(\"\\n\");\t\treturn;\t}\tif (n == idx) return;\t//분기 조건\tset[setSize] = idx;\trepeatedComb(set, setSize + 1, n, r, idx);  //idx 중복 가능\trepeatedComb(set, setSize, n, r, idx + 1);}결과 main 함수 int main(){\tint n = 3;\tint r = 2;\tvector&lt;int&gt; set;\t//초기화\tfor (int i = 0; i &lt; n; ++i)\t\tset.push_back(i);\tprintf(\"permutationSTL(%d, %d)\\n\", n, r);\tpermutationSTL(set, n, r);\tprintf(\"============================\\n\");\tprintf(\"permutation(%d, %d)\\n\", n, r);\tpermutation(set, 0, n, r);\tprintf(\"============================\\n\");\tprintf(\"repeatedPerm(%d, %d)\\n\", n, r);\trepeatedPerm(set, 0, n, r);\tprintf(\"============================\\n\");\tset.clear();\tprintf(\"combinationSTL(%d, %d)\\n\", n, r);\tcombinationSTL(set, n, r);\tprintf(\"============================\\n\");\tset = vector&lt;int&gt;(n);\tprintf(\"combination(%d, %d)\\n\", n, r);\tcombination(set, 0, n, r, 0);\tprintf(\"============================\\n\");\tprintf(\"repeatedComb(%d, %d)\\n\", n, r);\trepeatedComb(set, 0, n, r, 0);\treturn 0;}결과 화면 permutationSTL(3, 2)0 10 21 01 22 02 1============================permutation(3, 2)0 10 21 01 22 12 0============================repeatedPerm(3, 2)0 00 10 21 01 11 22 02 12 2============================combinationSTL(3, 2)1 20 20 1============================combination(3, 2)0 10 21 2============================repeatedComb(3, 2)0 00 10 21 11 22 2","categories": ["Algorithm"],
        "tags": ["Algorithm_Algorithm"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-%EC%88%9C%EC%97%B4%EA%B3%BC-%EC%A1%B0%ED%95%A9/",
        "teaser":null},{
        "title": "[Algorithm]KMP 알고리즘",
        "excerpt":"KMP 알고리즘   풀네임은 커누스-모리스-프랫(Knuth-Morris-Pratt) 알고리즘으로, 문자열 검색 알고리즘이다.미리 알아 둘점   문자열 S의 길이는 |S|로 표기  문자열 S의 i번부터 j번까지 구성된 부분 문자열을 S[i...j]로 표기  문자열 S의 0번부터 a번까지 구성된 부분 문자열을 접두사(prefix)라 부르고, S[...a]로 표기  문자열 S의 b번부터 끝까지 구성된 부분 문자열을 접미사(suffix)라 부르고, S[b...]로 표기기본 개념   기본적인 검색 알고리즘은 한 문자열의 시작점을 하나씩 옮겨가면서 찾을 문자열을 검색하는 것이다.  KMP 알고리즘은 시작점을 하나씩 옮기는 것이 아니라 최적화 과정을 거쳐 옮길 칸 수를 정한다.  예를 들어, N = “aabaabac”를 찾는 경우가 있다.          H 문자열의 해당 부분 문자열인 H[i...i + 6]이 “aabaaba”까지 일치한다.      그렇다면, i + 1에서 시작하는 N은 H와 일치할 수 없다는 것을 알 수 있다.      가능성이 있는 위치는 i + 3, i + 6 이라는 것을 아래의 그림을 보면 알 수 있다.       다음 시작 위치 찾기   다음 시작 위치를 어떻게 찾는지 예제 그림을 보며, 알아보자   위 그림에서 시작 위치 i일때, H와 N을 맞춰보면 matched글자가 일치하고 다음 글자가 불일치하는 상황을 볼 수 있다.  matched글자가 일치했기 때문에, N의 접두사 N[...matced - 1]가  H[i...i + matched - 1]와 일치했음을 알 수 있다.(회색으로 칠해진 부분)  시작 위치 i + k가 답이 될려면, B와 C가 서로 같아야 하며, 결과적으로 A와 C도 같아야 한다.(굵은 선 네모 부분)          A = C는 N[...matced - 1]의 접두사이기도 하고 접미사이기도 한다.      시작 위치 i + k가 답을 찾을 수 있기 위해서는 N[...matced - 1]의 길이 matched - k인 접두사와 접미사가 같아야 한다.        정리하면, 답이 될 수 있는 바로 다음 위치를 찾기 위해서는 N의 각 접두사에 대해 접두사도 되고 접미사도 되는 문자열의 최대 길이를 계산해야 한다.          위의 예제 “aabaaba”에서 접두사도 되고 접미사도 되는 문자열은 “aaba”와 “a” 두가지 있다.      여기서 최대 길이 문자열은 “aaba”이기 때문에, 시작 위치를 3만큼 옮겨주었던 것이다.      KMP 알고리즘 구현   다음 시작 위치를 찾는 배열을 다음과 같이 정의한다.          pi[i] = N[...i]의 접두사도 되고 접미사도 되는 문자열의 최대 길이        pi[]는 어디까지 일치했는지가 주어질 때 다음 시작 위치를 알려주기 때문에, 이를 흔히 부분 일치 테이블(partial match table) 또는 실패 함수(faulure function)이라 부른다.          찾는 문자열 “aabaabac”의 각 접두사에 대한 부분 일치 테이블은 밑에와 같이 계산된다.                                i          N[…i]          접두사이면서 접미사인 최대 문자열          pi[i]                                      0          a          (없음)          0                          1          aa          a          1                          2          aab          (없음)          0                          3          aaba          a          1                          4          aabaa          aa          2                          5          aabaab          aab          3                          6          aabaaba          aaba          4                          7          aabaabac          (없음)          0                      KMP 알고리즘 동작 과정          초기에는 단순한 알고리즘과 같이 시작 위치 0부터 시작한다.      만약 matched글자가 일치한 후 불일치가 발생한다면, 위 그림의 A의 길이는 pi[matched - 1]이다.      시작 위치를 matched - pi[matched - 1]만큼 증가 시킨다.                  위와 같이 동작하면, 시작 위치를 움직인 이후 첫 글자부터 다시 대응시켜 나갈 필요가 없다는 것이 중요한 관점이다.          새로운 위치에서 비교를 시작하더라도 N의 첫 pi[matched - 1]글자는 대응되는 H의 글자와 일치하기 때문이다.(위 그림에서 B와 C가 서로 같기 때문이다.)                    matched를 pi[matched - 1]로 변경하고 비교를 계속한다.      답을 찾은 경우에는 현재 시작 위치를 답의 목록에 추가해주고, 불일치가 발생한 경우와 같이 다음 시작 위치에서부터 다시 검색을 한다.      matched = 0이면 한 글자도 일치하지 않았다는 의미이므로, 바로 다음 시작 위치에서 처음부터 검색을 시작한다.        구현 코드          참고사항으로, 부분 일치 테이블의 구현과 관련된 점은 아래에서 설명한다.      //'짚더미' H의 부분 문자열로 '바늘' N이 출현하는 시작 위치들을 모두 반환한다.vector&lt;int&gt; kmpSearch(const string &amp;H, const string &amp;N) {\tint n = H.size(), m = N.size();\tvector&lt;int&gt; ret;\t//pi[i] = N[...i]의 접미사도 되고 접두사도 되는 문자열의 최대 길이\tvector&lt;int&gt; pi = getPartialMatch(N);\t//begin = matched = 0 에서부터 시작\tint begin = 0, matched = 0;\twhile (begin &lt;= n - m) {\t\t//만약 짚더미의 해당 글자가 바늘의 해당 글자와 같다면\t\tif (matched &lt; m &amp;&amp; H[begin + matched] == N[matched]) {\t\t\t++matched;\t\t\t//결과적으로 m글자가 모두 일치했다면 답에 추가한다.\t\t\tif (matched == m) ret.push_back(begin);\t\t}\t\telse {\t\t\t//예외: matched가 0인 경우에는 다음 칸에서부터 계속\t\t\tif (matched == 0)\t\t\t\t++begin;\t\t\telse {\t\t\t\tbegin += matched - pi[matched - 1];\t\t\t\t//begin을 옮겼다고 처음부터 다시 비교할 필요가 없다.\t\t\t\t//옮긴 후에도 pi[matched - 1]만큼은 항상 일치하기 때문이다.\t\t\t\tmatched = pi[matched - 1];\t\t\t}\t\t}\t}\treturn ret;}  시간 복잡도          getPartialMatch() 시간 복잡도는 아직 고려하지 않는다.      while문에서 begin + matched 는 절대 감소하지 않는다.                  matched가 감소하면 그만큼 begin이 증가하기 때문이다.                    따라서, 최대 시간 복잡도는 O(|H|)입니다.      부분 일치 테이블 생성하기 1. 간단한 알고리즘   N의 각 접두사에 대해 가능한 모든 답을 시도한다.  길이 p인 접두사 N[...p - 1]이 주어졌을때, 길이 p - 1, p - 2, ...들을 순회하며 이들이 N[... p - 1]의 접미사가 되는지 확인한다.  모든 접두사에 대해 한꺼번에 계산한다면, 시간 복잡도는 O(|N|^2)이다.  구현 코드    //N에서 자기 자신을 찾으면서 나타나는 부분 일치를 이용해 pi[]를 계산한다.//pi[i] = N[...i]의 접미사도 되고 접두사도 되는 문자열의 최대 길이vector&lt;int&gt; getPartialMatchNaive(const string &amp;N) {  int m = N.size();  vector&lt;int&gt; pi(m, 0);  //단순한 문자열 검색 알고리즘을 구현한다.  for (int begin = 1; begin &lt; m; ++begin) {      for (int i = 0; i &lt; m; ++i) {          if (N[begin + i] != N[i]) break;          //i + 1글자가 서로 대응되었다.          pi[begin + i] = max(pi[begin + i], i + 1);      }  }  return pi;}      2. KMP 알고리즘 활용   고려 사항          begin을 옮길 때 이전에 계산한 pi[] 값을 사용한다.                  현재 matched글자가 일치했다면 pi[matched - 1]는 항상 계산된 뒤임을 증명할 수 있기 때문이다.                    pi[]의 각 원소는 최대 한 번만 변경되기 때문에 위의 간단한 알고리즘에서 처럼 max()연산을 해줄 필요가 없다.        구현 코드vector&lt;int&gt; getPartialMatch(const string &amp;N) {\tint m = N.size();\tvector&lt;int&gt; pi(m, 0);\t//KMP로 자기 자신을 찾는다.\t//N을 N에서 찾는다. begin = 0이면 자기 자신을 찾아버리니까 안됨!\tint begin = 1, matched = 0;\t//비교할 문자가 N의 끝에 도달할 때까지 찾으면서 부분 일치를 모두 기록한다.\twhile (begin + matched &lt; m) {\t\tif (N[begin + matched] == N[matched]) {\t\t\t++matched;\t\t\tpi[begin + matched - 1] = matched;\t\t}\t\telse {\t\t\tif (matched == 0)\t\t\t\t++begin;\t\t\telse {\t\t\t\tbegin += matched - pi[matched - 1];\t\t\t\tmatched = pi[matched - 1];\t\t\t}\t\t}\t}\treturn pi;}  시간 복잡도: O(|N|)","categories": ["Algorithm"],
        "tags": ["Algorithm_Algorithm"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-KMP%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/",
        "teaser":null},{
        "title": "[Algorithm]너비 우선 탐색(BFS)",
        "excerpt":"너비 우선 탐색(BFS)과 최단 거리 알고리즘 너비 우선 탐색으로 최단 거리 구하기   가중치가 없는 그래프에 대해 주로 사용할 수 있다.  최단 경로를 구성하는 정점들의 목록을 구할 수 있다.넓이 우선 탐색으로 최단거리 구하는 과정   간선(u, v)를 통해 정점 v를 처음 발견하여 큐에 넣었다.  시작점으로부터 정점 v까지 최단 거리 distance[v]는 시작적으로부터 정점 u까지 최단 거리 distance[u]에 1을 더한 것이다.  너비 우선 탐색 스패닝 트리를 보면 시작점으로부터 각 정점이 모두 실제 그래프상 최단 경로임을 알 수 있다. 구현   bfs(): 각 정점까지의 최단 거리를 계산하고, 너비 우선 탐색 스패닝 트리를 만든다.  shortestPath(): 너비 우선 탐색 스패닝 트리와 정점을 입력받아, 루트로부터 해당 입력된 정점까지의 최단 경로를 반환한다.          루트로부터 입력 정점까지 경로와 입력 정점으로부터 루트까지 경로가 같은 것을 이용한다.      BFS 스패닝 트리에서 각 정점의 부모 정점을 저장한 배열을 이용하여 계산한다.(parent[])      vector&lt;vector&lt;int&gt;&gt; adj;//start에서 시작해 그래프를 너비 우선 탐색하고 시작점부터 각 정점까지의//최단 거리와 너비 우선 탐색 스패닝 트리를 계산한다.//distance[i] = start부터 i까지의 최단 거리//parent[i] = 너비 우선 탐색 스패닝 트리에서 i의 부모 번호(루트인 경우 자신의 번호)void bfs(int start, vector&lt;int&gt; &amp;distance, vector&lt;int&gt; &amp;parent) {\tdistance = vector&lt;int&gt;(adj.size(), -1);\tparent = vector&lt;int&gt;(adj.size(), -1);\t//방문할 정점 목록을 유지하는 큐\tqueue&lt;int&gt; q;\tdistance[start] = 0;\tparent[start] = start;\tq.push(start);\twhile (!q.empty()) {\t\tint here = q.front();\t\tq.pop();\t\t//here의 모든 인접한 정점을 검사한다.\t\tfor (int i = 0; i &lt; adj[here].size(); ++i) {\t\t\tint there = adj[here][i];\t\t\t//처음 보는 정점이면 방문 목록에 집어넣는다.\t\t\tif(distance[there] == -1) {\t\t\t\tq.push(there);\t\t\t\tdistance[there] = distance[here] + 1;\t\t\t\tparent[there] = here;\t\t\t}\t\t}\t}}//v로부터 시작점까지의 최단 경로를 계산한다.vector&lt;int&gt; shortestPath(int v, const vector&lt;int&gt; &amp;parent) {\tvector&lt;int&gt; path(1, v);\twhile (parent[v] != v) {\t\tv = parent[v];\t\tpath.push_back(v);\t}\treverse(path.begin(), path.end());\treturn path;}상태 객체와 너비 우선 탐색을 사용하여 최단 경로 구하기 예제: 15-퍼즐   4 X 4 격자에 끼워진 15개의 임의의 순서의 숫자 타일이 주어졌을 때, 순서에 맞게 맞추는 퍼즐 문제이다.  게임판의 상태를 정점으로 표현하여 그래프를 만든 후, 문제를 해결할 수 있다.          상태를 정점으로 하는 그래프를 상태 공간(state space)라고 부른다.        게임판에 총 15개의 숫자와 1개의 빈칸이 있으므로, 상태 공간은 총 16!개의 정점을 갖는다.  한 번의 움직임으로 한 상태를 다른 상태로 바꿀 수 있을 때, 두 정점을 간선으로 연결한다.          각 정점마다 최대 4개의 이웃 정점이 있을 수 있다.(위, 아래, 오른쪽, 왼쪽으로 옮길 수 있기 때문)        15-퍼즐 구현               게임판의 상태를 State라는 별도의 객체로 표현한다.          15-퍼즐에 관련된 부분을 전부 State 객체 내에 구현함으로서 bfs()함수와 독립적이다.      State만 바꾸면 다른 문제에서도 활용할 수 있다.        State가 가질 수 있는 값의 종류가 너무 많기 때문에 배열 대신 map을 사용한다.  아직 덜구현된듯 문제에 맞게 구현해서 예제 넣어 풀어보기(State 클래스 구현)//게임판의 상태를 표현한다.class State {\t//인접한 상태들의 목록을 반환한다.\tvector&lt;State&gt; getAdjacent() const;\t//map에 State를 넣기 위한 비교 연산자\tbool operator &lt; (const State &amp;rhs) const;\t//종료 상태와 비교하기 위한 연산자\tbool operator == (const State &amp;rhs) const;};typedef map&lt;State, int&gt; stateMap;//start에서 finish까지 가는 최단 경로의 길이를 반환한다.int bfs(State start, State finish) {\t//예외: start == finish인 경우\tif (start == finish) return 0;\t//각 정점까지의 최단 경로의 길이를 저장한다.\tstateMap c;\t//앞으로 방문할 정점들을 저장한다.\tqueue&lt;State&gt; q;\tq.push(start);\tc[start] = 0;\t//너비 우선 탐색\twhile (!q.empty()) {\t\tState here = q.front();\t\tq.pop();\t\tint cost = c[here];\t\t//인접한 정점들의 번호를 얻어낸다.\t\tvector&lt;State&gt; adjacent = here.getAdjacent();\t\tfor (int i = 0; i &lt; adjacent.size(); ++i) {\t\t\tif (c.count(adjacent[i]) == 0) {\t\t\t\t//답을 찾았나?\t\t\t\tif (adjacent[i] == finish) return cost + 1;\t\t\t\tc[adjacent[i]] = cost + 1;\t\t\t\tq.push(adjacent[i]);\t\t\t}\t\t}\t}\t//답을 찾지 못한 경우\treturn -1;}시간 복잡도 분석   이 문제는 답을 찾는 대로 탐색을 종료하기 때문에, 일반적인 너비 우선 탐색의 시간복잡도 O(|V| + |E|)와 다르다.  너비 우선 탐색이 방문하는 정점의 개수에 비례한다.  이 문제에서 너비 우선 탐색이 방문하는 정점의 개수에 직접적인 영향을 주는 요소는 시작 정점에서 목표 정점까지의 최단 거리 d와 탐색의 분기 수(branching factor) b이다.          분기 수는 경로의 길이가 하나 늘어날 때마다 닿을 수 있는 정점의 개수를 말한다.      이 문제에서 분기 수는 최대 4개 이지만, 이 중에는 돌아가는 정점이나 중복된 정점이 있기 때문에 2나 3으로 계산할 수 있다.        이를 바탕으로, 시간 복잡도는 대략 O(b^d)가 된다.너비 우선 탐색보다 더 효율적인 최단 경로 알고리즘   양방향 탐색  점점 깊어지는 탐색(Iteratively Deeping Search, IDS)탐색 방법 선택하기   상태 공간에서의 최단 경로를 찾는 경우, 너비 우선 탐색을 최우선적으로 고려한다.          탐색의 깊이 한계가 정해져 있지 않거나 너무 깊어서 메모리 사용량이 너무 크지 않은지 확인해야 한다.        탐색의 최대 깊이가 정해져 있고 너비 우선 탐색을 하기에는 메모리와 시간이 부족한 경우 양방향 탐색을 고려한다.  위의 두 탐색이 모두 메모리나 시간이 초과될 경우, 점점 깊어지는 탐색을 사용한다.참고 문헌   프로그래밍 대회에서 배우는 알고리즘 문제해결전략, 인사이트, 구종만 지음","categories": ["Algorithm"],
        "tags": ["Algorithm_DataStructure"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/DataStructure-BFS%EC%99%80-%EC%B5%9C%EB%8B%A8%EA%B1%B0%EB%A6%AC/",
        "teaser":null},{
        "title": "[Algorithm]깊이 우선 탐색(DFS)의 간선 분류",
        "excerpt":"깊이 우선 탐색(DFS)과 간선의 분류   어떤 그래프를 깊이 우선 탐색을 했을 때, 탐색이 따라가는 간선들만을 모아 보면 트리 형태를 띤다.  예제 그래프   위 그래프를 0번 정점부터 깊이 우선 탐색했을 때 탐색이 따라가는 간선들을 굵은 실선으로 표시하면 아래의 그림과 같다.   굵은 실선이 0번 정점을 루트로 하는 트리 형태를 띠는 것을 볼 수 있다.  이와 같은 트리를 주어진 트리의 깊이 우선 탐색 스패닝 트리 혹은 DFS 스패닝 트리(Spanning Tree)라고 부른다.  DFS 스패닝 트리는 4가지의 간선으로 분류된다.          트리 간선(tree edge): 스패닝 트리에 포함된 간선을 의미한다. (위 그래프의 굵은 선으로 표시된 간선)      순방향 간선(forward edge): 스패닝 트리의 선조에서 자손으로 연결되지만 트리 간선이 아닌 간선을 의미한다. (위 그래프의 (0, 6)간선이 그 예이다.)      역방향 간선(back edge): 스패닝 트리의 자손에서 선조로 연결되는 간선이다. (위 그래프의 (2, 0)간선이 그 예이다.)      교차 간선(cross edge): 위 세 간선을 제외한 나머지 간선을 의미하며, 트리에서 선조와 자손 관계가 아닌 정점들 간에 연결된 간선이다. (위 그래프의 (6, 3)간선이 그 예이다.)        같은 그래프에서도 깊이 우선 탐색이 어느 순서대로 정점을 방문하느냐에 따라 서로 다른 트리가 만들어질 수 있다. (아래 그래프 예제)   무향 그래프에서 간선의 분류          모든 간선은 양방향으로 통행 가능하므로, 교차 간선이 없다.      순방향 간선과 역방향 간선의 구분이 없다.      참고 문헌   프로그래밍 대회에서 배우는 알고리즘 문제해결전략, 인사이트, 구종만 지음","categories": ["Algorithm"],
        "tags": ["Algorithm_DataStructure"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/DataStructure-DFS%EC%99%80-%EA%B0%84%EC%84%A0%EC%9D%98-%EB%B6%84%EB%A5%98/",
        "teaser":null},{
        "title": "[Algorithm]깊이 우선 탐색(DFS) 사이클",
        "excerpt":"깊이 우선 탐색(DFS)로 사이클 존재 여부 확인하기 개요   미리 알아야 할 내용: DFS와 간선의 분류 링크 해주기  간선의 분류를 이용하면 방향 그래프에서 사이클이 존재하는지 쉽게 알 수 있다.          사이클의 존재 여부는 역방향 간선의 존재 여부와 동치이다.        탐색 과정          어떤 그래프에서 깊이 우선 탐색 중 만나는 한 정점을 u라고 하자.      dfs(u)는 u에서 갈 수 있는 모든 정점들을 방문한 후에 종료된다.      따라서, u이전에 있는 한 정점이 dfs(u)가 종료되기 전에 u정점을 방문을 한다면, 해당 정점은 u로 가는 역방향 간선이 된다.      결과적으로, 이 그래프는 사이클이 존재하는 그래프가 된다.      간선 구분하기   깊이 우선 탐색을 하면서 간선의 종류를 구분하기 위해서는 기존의 저장해야하라 정보보다 더 많은 정보가 필요하다.1. 해당 정점이 몇 번째로 방문 되었는지에 대한 정보(방문 순서 정보)   기존의 깊이 우선 탐색에서 필요한 정보였던 해당 정점이 방문되었는지에 대한 정보를 대체한다.  이 정보로 (u, v)간선이 있을 때, 두 정점의 관계가 선조인지, 자손인지, 아무관계가 없는지를 알 수 있다.  (u, v)간선이 순방향 간선인지 알 수 있다.(역방향 간선과 교차 간선은 구분하지 못함)          (u, v)가 순방향 간선이면 v는 u의 자손이므로, v는 u보다 더 늦게 발견된다.      (u, v)가 역방향 간선이면 v는 u의 선조이므로, v는 u보다 더 일찍 발견된다.      (u, v)가 교차 간선이면 dfs(v)가 종료된 후에 dfs(u)가 호출되므로, v는 u보다 더 일찍 발견된다.        discovered[]배열2. 해당 정점의 dfs()함수가 종료되었는지에 대한 정보   이 정보로 (u v)간선이 역방향 간선인지 교차 간선인지 구분할 수 있다.  (u, v)에서 dfs(v)가 아직 종료되지 않았다면 v는 u의 선조이니 역방향 간선이 되고, 종료되었다면 교차 간선이 된다.  finished[]배열구현 //그래프으이 인접 리스트 표현vector&lt;vector&lt;int&gt;&gt; adj;//discovered[i] = i번 정점의 발견 순서, -1로 초기화//finished[i] = dfs(i)가 종료했으면 1, 아니면 0vector&lt;int&gt; discovered, finished;//지금까지 발견한 정점의 수int counter;void classifyEdgeDfs(int here) {  discovered[here] = counter++;  //모든 인접 정점을 순회하면서  for(int i =0; i &lt; adj[here].size(); ++i) {    int there = adj[here][i];    cout &lt;&lt; \"(\" &lt;&lt; here &lt;&lt; \",\" &lt;&lt; there &lt;&lt; \") is a \";    //아직 방문한 적이 없다면 방문한다. (트리 간선)    if (discovered[there] == -1) {      cout &lt;&lt; \"tree edge\" &lt;&lt; endl;      classifyEdgeDfs(there);    }    //만약 there가 here보다 늦게 발견됐으면 there은 here의 후손이다. (순방향 간선)    else if (discovered[here] &lt; discovered[there])      cout &lt;&lt; \"forward edge\" &lt;&lt; endl;    //만약 classifyEdgeDfs(there)가 아직 종료되지 않았으면 there은 here의 선조이다. (역방향 간선 = 사이클 존재)    else if (finished[there] == 0)      cout &lt;&lt; \"back edge\" &lt;&lt; endl;    //이 외의 모든 경우는 교차 간선    else      cout &lt;&lt; \"cross edge\" &lt;&lt; endl;  }  finished[here] = 1;}참고 문헌   프로그래밍 대회에서 배우는 알고리즘 문제해결전략, 인사이트, 구종만 지음","categories": ["Algorithm"],
        "tags": ["Algorithm_DataStructure"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/DataStructure-DFS%EC%99%80-%EC%82%AC%EC%9D%B4%ED%81%B4/",
        "teaser":null},{
        "title": "[DataStructure]N^2 정렬 알고리즘",
        "excerpt":"O(N^2) 정렬 알고리즘 버블 정렬(Bubble Sort)   버블 정렬은 인접한 두 원소를 검사하여 정렬하는 방법이다.  버블 정렬 알고리즘 순서(오름차순)          주어진 배열 범위 중에서 첫 번째 위치와 두 번재 위치 크기를 비교하여 크기가 큰 수를 두 번째 위치에 둔다.      첫 번째 위치를 한 칸 뒤로 옮겨 과정 1을 반복한다.                  두 번째 위치가 주어진 배열 범위의 끝에 도달하면 마지막 위치를 제외하여 배열 범위를 설정하고 과정 1로 돌아간다.  (첫 번째 과정이 끝나면 가장 큰 원소가 가장 끝에 위치한다.)                      총 비교 횟수: (n-1) + (n-2) + (n-3) ... + 1   구현 코드(C언어)//오름차순//arr[]: 입력 배열, n: arr배열 크기void BubbleSort(int arr[], int n) {\tint i, j;\tint temp;\tfor(i = 0; i &lt; n - 1; i++)\t\tfor(j = 0; j &lt; (n - i) - 1; j++)\t\t\tif(arr[j] &gt; arr[j + 1]) {\t\t\t\ttemp = arr[j];\t\t\t\tarr[j] = arr[j + 1];\t\t\t\tarr[j + 1] = temp;\t\t\t}}선택 정렬(Selection Sort)   선택 정렬 알고리즘 순서(오름차순)          주어진 배열 범위 중에서 최소값을 찾는다.      해당 값을 가장 앞에 위치한 값과 교환한다.      가장 앞에 위치한 값을 제외하여 배열 범위를 설정하고 과정 1로 돌아간다.         구현 코드(C언어)//오름차순//arr[]: 입력 배열, n: arr배열 크기void SelectionSort(int arr[], int n) {\tint i, j;\tint maxIdx;\tint temp;\tfor(i = 0; i &lt; n - 1; i++) {\t\tmaxIdx = i;    // 정렬 순서상 가장 앞서는 데이터의 index    // 최소값 탐색\t\tfor(j = i + 1; j &lt; n; j++) {\t\t\tif(arr[j] &lt; arr[maxIdx])\t\t\t\tmaxIdx = j;\t\t}\t\t/* 교환 */\t\ttemp = arr[i];\t\tarr[i] = arr[maxIdx];\t\tarr[maxIdx] = temp;\t}}삽입 정렬(Insertion Sort)   삽입 정렬 알고리즘 순서(오름차순)          배열의 두 번째 위치부터 시작한다.      현재 위치보다 앞선 위치를 차례대로 순회하며 현재 값보다 작은 값을 찾는다.      작은 값을 찾으면, 그 바로 다음 위치로 옮기고 현재 위치 바로 다음 위치에서 과정 1을 반복한다.         구현 코드(C언어)//오름차순//arr[]: 입력 배열, n: arr배열 크기void InserSort(int arr[], int n) {\tint i, j;\tint insData;  //두 번째 위치부터 시작\tfor(i = 1; i &lt; n; i++) {\t\tinsData = arr[i];          // 정렬 대상을 insData에 저장\t\tfor(j = i - 1; j &gt;= 0 ; j--) {\t\t\tif(arr[j] &gt; insData)\t\t\t\tarr[j + 1] = arr[j];   // 비교 대상 한 칸 뒤로 밀기\t\t\telse\t\t\t\tbreak;                 // 삽입 위치 찾았으니 탈출!\t\t}\t\tarr[j + 1] = insData;        // 찾은 위치에 정렬 대상 삽입!\t}}","categories": ["Algorithm"],
        "tags": ["Algorithm_DataStructure"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/DataStructure-N-2-%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/",
        "teaser":null},{
        "title": "[DataStructure]NlogN 정렬 알고리즘",
        "excerpt":"O(NlogN) 정렬 알고리즘 합병 정렬(Merge Sort)   합병 정렬은 분할 정복(Divide and conquer)방식으로 설계한 알고리즘이다.  합병 정렬 알고리즘 순서(오름차순)          분할 과정                  주어진 배열 범위를 반으로 분할한다.          반으로 분할된 배열의 크기가 0 또는 1일때 까지 반복한다.                    합병 과정                  두 배열 A, B를 합병한다고 가정하자.          두 배열 A, B를 합친 크기의 배열 C를 만든다.          배열 A부터 시작하는 인덱스와 배열 B부터 시작하는 인덱스를 설정하여 순서대로 서로 비교하여 작은 값부터 배열 C에 차례대로 삽입한다. (배열A, B는 반복된 위의 과정으로 오름차순으로 정렬되어 있다.)          배열 C가 원래 주어진 배열의 크기와 같을때까지 반복한다.                       구현 코드(C언어)void MergeTwoArea(int arr[], int left, int mid, int right) {\tint fIdx = left;\tint rIdx = mid+1;\tint i;  //두 배열을 합친 크기의 임의의 배열\tint * sortArr = (int*)malloc(sizeof(int)*(right+1));\tint sIdx = left;\twhile(fIdx &lt;= mid &amp;&amp; rIdx &lt;= right) {\t\tif(arr[fIdx] &lt;= arr[rIdx])\t\t\tsortArr[sIdx] = arr[fIdx++];\t\telse\t\t\tsortArr[sIdx] = arr[rIdx++];\t\tsIdx++;\t}\tif(fIdx &gt; mid) {\t\tfor(i = rIdx; i &lt;= right; i++, sIdx++)\t\t\tsortArr[sIdx] = arr[i];\t}\telse {\t\tfor(i = fIdx; i &lt;= mid; i++, sIdx++)\t\t\tsortArr[sIdx] = arr[i];\t}  //기존 배열의 원래 위치에 정렬된 배열을 삽입한다.\tfor(i = left; i &lt;= right; i++)\t\tarr[i] = sortArr[i];\tfree(sortArr);}//오름차순//arr[]: 입력 배열, left: arr배열의 가장 왼쪽 인덱스, right: arr배열의 가장 오른쪽 인덱스void MergeSort(int arr[], int left, int right) {\tint mid;\tif(left &lt; right) {\t\t// 중간 지점을 계산한다.\t\tmid = (left + right) / 2;\t\t// 둘로 나눠서 각각을 정렬한다.\t\tMergeSort(arr, left, mid);\t\tMergeSort(arr, mid + 1, right);\t\t// 정렬된 두 배열을 병합한다.\t\tMergeTwoArea(arr, left, mid, right);\t}}퀵 정렬(Quick Sort)   퀵 정렬은 분할 정복(Divide and conquer)방식으로 설계한 알고리즘이다.  퀵 정렬 알고리즘 순서(오름차순)          pivot을 설정한다.                  pivot을 설정하는 방법은 배열의 특정 위치나 배열 원소의 값 중 중간값, 랜덤값 n번째 값으로 설정한다.                    현재 주어진 배열에서 pivot 위치를 찾아서 그 위치로 교환한다.                  pivot보다 작은 값들은 모두 pivot 앞에 위치하고 큰 값은 모두 뒤에 위치해야한다.                    pivot을 기준으로 둘도 분할한 뒤 과정 1을 반복한다.      퀵 정렬 특징   퀵 정렬의 최악의 시간 복잡도는 O(N^2)이다.          pivot의 위치가 지속적으로 주어진 배열의 가장 왼쪽 또는 오른쪽에 위치하여 2개로 분할하지 못하는 경우이다.        하지만, 퀵 정렬은 평균적으로 정렬 알고리즘 중에서 가장 빠르다.          최초 pivot을 설정하는 방법 중에서 주어진 배열을 2개로 분할할 수 있는 효율적인 방법들이 존재한다.      퀵 정렬의 내부 루프는 대부분의 컴퓨터 아키텍처에서 효율적으로 동작하도록 설계되어 있다.                  메모리 참조가 지역화되어 있으므로 CPU의 cache 히트률이 높기 때문이다.                       구현 코드(C언어)void Swap(int arr[], int idx1, int idx2) {\tint temp = arr[idx1];\tarr[idx1] = arr[idx2];\tarr[idx2] = temp;}// pivot의 위치를 반환한다.int Partition(int arr[], int left, int right) {\tint pivot = arr[left];    // 피벗의 위치는 가장 왼쪽!\tint low = left+1;\tint high = right;  // 교차되지 않을 때까지 반복\twhile(low &lt;= high) {\t\twhile(pivot &gt;= arr[low] &amp;&amp; low &lt;= right)\t\t\tlow++;\t\twhile(pivot &lt;= arr[high] &amp;&amp; high &gt;= (left + 1))\t\t\thigh--;    // 교차되지 않은 상태라면 Swap 실행\t\tif(low &lt;= high)\t\t\tSwap(arr, low, high);\t}  //현재 high의 위치가 pivot이 있어야할 위치이다.\tSwap(arr, left, high);    \treturn high;}//오름차순//arr[]: 입력 배열, left: arr배열의 가장 왼쪽 인덱스, right: arr배열의 가장 오른쪽 인덱스void QuickSort(int arr[], int left, int right) {\tif(left &lt;= right) {\t\tint pivot = Partition(arr, left, right);    // pivot 설정 후 위치를 찾는다.\t\tQuickSort(arr, left, pivot-1);              // 왼쪽 영역을 정렬\t\tQuickSort(arr, pivot+1, right);             // 오른쪽 영역을 정렬\t}}","categories": ["Algorithm"],
        "tags": ["Algorithm_DataStructure"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/DataStructure-NlogN-%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/",
        "teaser":null},{
        "title": "[DataStructure]동적 배열과 연결 리스트",
        "excerpt":"선형 자료 구조 동적 배열(dynamic array) 일반 배열의 가장 큰 문제점은 배열의 크기가 고정되어 그 이상의 자료를 집어넣을 수 없다는 점이다. 이를 해결하기 위해 고안된 것이 자료의 개수가 변함에 따라 크기가 변경되는 동적 배열이다. 동적 배열은 언어 차원에서 지원하는 것이 아니라 일반 배열을 이용하여 만들어 낸 별도의 자료 구조이다. 때문에 동적 배열은 대부분 언어의 표준 라이브러리에 포함되어 있다. 동적 배열의 특징은 다음과 같다.   일반 배열과 동적 배열의 공통적인 특징          원소들은 메모리의 연속된 위치에 저장된다. (이는 캐시 효율성을 높여준다.)      주어진 위치의 원소를 반환하거나 변경하는 동작을 O(1)에 수행가능하다.        동적 배열만의 특징          배열의 크기를 변경하는 resize() 연산이 가능하다. 이 동작은 수행하는 데 배열의 크기 N에 비례하는 시간이 걸린다.      주어진 원소를 배열의 맨 끝에 추가함으로써 크기를 1 늘리는 append() 연산을 지원한다. 이 동작은 수행하는 데는 상수 시간이 걸린다.      이와 같은 동작을 위해 동적 배열은 내부적으로 동적으로 할당 받은 배열(new 나 malloc 으로 할당받은 배열)을 사용한다.   resize()배열 크기를 변경하는 resize() 연산은 단순하게 새 배열을 동적으로 할당받은 뒤 기존 원소들을 복사하고, 새 배열을 참조하도록 바꿔치기한다. 따라서 동적 배열 클래스는 아래와 같은 정보를 저장하고 있어야 한다.int size;             //배열 크기ElementType* array;   //실제 배열을 가리키는 포인터새 배열을 할당받고 기존 자료를 복사하는 데는 배열의 크기에 비례하는 시간이 걸리므로, 시간복잡도는 O(N) 이다.   append()이 연산이 상수 시간으로 구현하기 위해서는 몇 가지 전략이 필요하다. 기본적으로 동적 배열은 메모리를 할당받을 때 배열의 크기가 커질 때를 대비하여 여유분의 메모리를 미리 할당받는다. 위의 그림에서 볼 수 있듯이 실제 배열의 크기는 size 이고, 여유분의 메모리까지 합친 배열의 용량은 capacity 로 표현한다. 이러한 전략으로 append() 연산은 아래와 같이 상수 시간으로 간단히 구현할 수 있다. array[size++] = newValue;하지만, 문제는 capacity 까지 배열이 찬 상태에서 append() 연산을 수행하는 것이다. 이러한 상황에서는 필수적으로 기존 배열보다 큰 배열로 옮겨주는 작업이 필요하다. //배열 용량이 꽉 찬  경우 재할당받는다.if (size == capacity) {  //용량을 M 만큼 늘린 새 배열을 할당받는다.  int newCapacity = capacity + M;  int* newArray = new int[newCapacity];  //기존의 자료를 복사한다.  for (int i = 0; i &lt; size; ++i)    newArray[i] = array[i]  //기존 배열을 삭제하고 새 배열로 바꾼다.  if (array) delete [] array;  array = newArray;  capacity = newCapacity;}//배열의 끝에 원소를 삽입한다.array[size++] = newValue;여기서 M 을 어떻게 설정할지에 따라 시간복잡도가 결정된다. 먼저, 단순하게 M 을 100, 1000 으로 설정하는 것과 같이 정해진 개수로 늘린다고 하자. 이 경우는 재할당마다 복사하는 원소의 수는 M개, 2M개, …, KM개로 증가하므로, N번의 append() 연산은 총 O($N^2$) 이 소요된다. 이를 한 번의 append() 연산에 드는 시간은 평균적으로 O(N) 이 된다. 따라서 이런 재할당 전략은 상수 시간에 해결할 수 없다. 상수 시간에 append() 를 구현하기 위해서는 재할당을 할 때마다 정해진 개수의 여유분이 아니라, 현재 가진 원소의 개수에 비례해서 여유분을 확보 하는 것이다. 예를 들어, 재할당을 할 때마다 현재 용량의 두 배로 늘리는 것이다. 이러한 방법을 사용하면 append() 연산을 N번 실행하는 수행 시간은 O(N)이 되고, 한 번 연산에 드는 시간은 평균적으로 O(1)이 된다. 대표적으로 C 언어를 제외한 대부분의 언어는 동적 배열을 표준 라이브러리에서 제공한다. C++의 vector, 자바나 C#의 ArrayList 등이 그 예이다. 이들은 내부적으로 배열을 사용하므로 배열과 속도에서 차이가 거의 없다. 동적 배열 사용에서 한 가지 팁은, append() 연산을 여러 번 수행할 때 배열의 최종 크기가 얼마일지 미리 짐작할 수 있다면, 동적 배열의 용량(capacity)을 미리 늘려둠으로써 재할당 비용을 없앨 수 있다. 대부분의 동적 배열 구현체들은 이와 같은 연산을 지원한다. (이는 일반 배열에서 동적 배열로 교체했을 때, 훨씬 느려지는 현상을 해결하는 하나의 방법으로 볼 수 있다.) 연결 리스트(Linked List) 배열은 원소들의 순서를 유지하면서 임의의 위치에 원소를 삽입하거나, 삭제하는 작업 시간이 오래 걸린다. 해당 위치 뒤에 있는 원소들을 한 칸 앞 또는 뒤로 옮겨야 하기 때문이다. 즉, 선형 시간에 비례한다. 이를 해결하기 위해 고안된 자료 구조가 연결 리스트이다. 배열과 다르게 특정 위치에서 삽입, 삭제를 상수 시간에 할 수 있다. 이는 연결 리스트가 원소들이 메모리 여기 저기 흩어져 있고 서로 포인터로 연결되어 있기 때문이다. 연결 리스트의 원소는 실제 값 뿐아니라 자신의 이전 원소와 다음 원소를 가리켜야 하므로 그에 대한 포인터 정보 역시 가지고 있어야 한다. 이러한 집합을 노드(node)라고 부르며, 아래와 같다. struct ListNode {  int element;             //담고 있는 원소  ListNode *prev, *next;   //이전 노드, 다음 노드의 포인터};연결 리스트는 대부분 첫 번재 노드와 마지막 노드를 가리키는 포인터인 head, tail 을 가지고 있다.(구현에 따라 다르지만, 편의성을 위해 head, tail 이 텅 빈 노드를 가리키게 구현하기도 한다. 이는 항상 이전 노드와 다음 노드가 존재하는 것을 보장한다.) 이러한 구현적 특징 때문에 연결 리스트는 다음과 같은 특징을 갖는다.   노드들이 메모리 여기저기 흩어져 있기 때문에 특정 위치를 찾으려면, head 부터 시작해 하나씩 포인터를 따라가야 한다. 이는 리스트의 길이에 선형 비례하게 된다.  리스트의 순서를 유지하면서 새 노드를 삽입하거나 기존 노드를 삭제하는 작업은 매우 간단하다. 해당 노드 앞, 뒤 노드의 포인터만 바꿔주면 되므로 상수 시간에 이루어진다.연결 리스트 역시 대부분 언어의 표준 라이브러리에서 제공한다. C++은 list, C#은 LinkedList 가 있다. 연결 리스트의 구현적 특징을 이용해 몇 가지 응용 연산이 가능하다. 이는 사용 범위가 매우 제한적이고 트릭에 가깝기 때문에 대부분 표준 라이브러리에서 제공하지는 않는다. 간단히 무엇이 있고, 특징만을 알아보자.   잘라 붙이기 연산(splicing): 두 개의 서로 다른 리스트에서 각각의 일부 리스트를 서로 잘라서 붙이는 연산이다. 이 연산의 문제점은 결과 리스트의 크기를 상수 시간에 알 수 없다는 것이다. 즉, 모든 리스트를 순회하여 알아내야 한다.  삭제했던 원소 돌려놓기(undo): 연결 리스트는 한 번 삭제했던 원소를 제자리에 쉽게 돌려 놓을 수 있다. 연결 리스트의 삭제는 포인터의 연결만 해제할 뿐 노드의 정보는 변하기 않기 때문이다. 한 가지 주의할 점은 항상 삭제한 순서의 반대로 복구를 해야한다.(리스트가 망가질 수 있으므로)// node 이전/이후 노드의 포인터를 바꿔서 node를 리스트에서 삭제한다.void deleteNode(ListNode* node) {  node-&gt;prev-&gt;next = node-&gt;next;  node-&gt;next-&gt;prev = node-&gt;prev;}// node 이전/이후 노드의 포인터를 바꿔서 자기 자신을 다시 리스트에 삽입한다.void recoverNode(ListNode* node) {  node-&gt;prev-&gt;next = node;  node-&gt;next-&gt;prev = node;}동적 배열과 연결 리스트 비교   동적 배열          임의의 원소에 빠르게 접근 가능하다.      원소들이 메모리에 연속해 배치되어 있어 CPU 캐시의 효율을 높여준다.      삽입과 삭제가 거의 없고, 끝에 추가만 하면 될 경우에 활용하기 좋다.        연결 리스트          삽입과 삭제가 빠르다.      모든 원소들을 순회하며 삽입과 삭제를 많이 수행하는 작업에 활용하기 좋다.                                작업          동적 배열          연결 리스트                                      이전 원소/다음 원소 찾기          O(1)          O(1)                          맨 뒤에 원소 추가/삭제하기          O(1)          O(1)                          맨 뒤 이외의 위치에 원소 추가/삭제하기          O(N)          O(1)                          임의의 위치의 원소 찾기          O(1)          O(N)                          크기 구하기          O(1)          O(N), 구현에 따라 O(1)가능                    ","categories": ["Algorithm"],
        "tags": ["Algorithm_DataStructure"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/DataStructure-%EB%B0%B0%EC%97%B4%EA%B3%BC%EB%A6%AC%EC%8A%A4%ED%8A%B8/",
        "teaser":null},{
        "title": "[Algorithm]이분 탐색",
        "excerpt":"Binary Search / Lower Bound / Upper Bound 개요   Binary Search: 원하는 값 K를 찾는 과정  Lower Bound: 원하는 값 K 이상인 값 이 처음 나오는 위치를 찾는 과정  Upper Bound: 원하는 값 K 초과인 값 이 처음 나오는 위치를 찾는 과정Lower Bound 알고리즘 과정   arr[] = { 1, 3, 5, 7, 9, 11 }, target = 8 일때, Louwer Bound를 구하라.   시작 인덱스 = 0, 끝 인덱스 = 5, 중간 인덱스 = 2 이다.          중간 인덱스 2의 값은 5이고, 이 값은 타겟인 8보다 작기 때문에 시작 인덱스 = 중간 인덱스 + 1로 설정하고 다음 반복문으로 간다.         시작 인덱스 = 3, 끝 인덱스 = 5, 중간 인덱스 = 4 이다.          9는 타겟인 8보다 크기 때문에 끝 인덱스 = 중간 인덱스로 설정하고 다음 반복문으로 간다.         시작 인덱스 = 3, 끝 인덱스 = 4, 중간 인덱스 = 3 이다.          7은 타겟 8보다 작기 때문에 시작 인덱스 = 중간 인덱스 + 1로 설정한다.         시작 인덱스 = 4, 끝 인덱스 = 4, 중간 인덱스 = 4 이다.          시작 인덱스와 끝 인덱스가 같기 때문에 반복문에 들어가지 않으며, 끝 인덱스를 Lower Bound가 찾는 인덱스로 반환한다.        Bound의 반환 값은 인덱스가 0부터 시작하므로 +1을 해서 몇 번째인지 바로 반환할 수도 있고, 반환받은 값에서 +1을해도 상관없다.구현 코드   Binary Search예제 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int binarySearch(int *arr, int size, int target){\tint first = 0;\tint last = size - 1;\tint mid;\twhile (first &lt;= last) {\t\tmid = (first + last) / 2;\t\tif (arr[mid] == target)\t\t\treturn mid;\t\tif (mid &gt; target)\t\t\tlast = mid - 1;\t\telse\t\t\tfirst = mid + 1;\t}\treturn -1;}int main(){\tint arr[6] = { 1, 3, 5, 7, 9, 11 };\tint target = 8;\tint find;\t//Binary Search\tfind = binarySearch(arr, sizeof(arr), target);\tprintf(\"Binary Search, target: 8 =&gt; INDEX: %d, VALUE: %d\\n\", find, find == -1 ? -1 : arr[find]);\treturn 0;}결과 Binary Search, target: 8 =&gt; INDEX: -1, VALUE: -1  Lower Bound예제 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int lowerBound(int *arr, int size, int target){\tint start = 0;\tint end = size - 1;\tint mid;\twhile (start &lt; end) {\t\tmid = (start + end) / 2;\t\tif (arr[mid] &lt; target)\t\t\tstart = mid + 1;\t\telse\t\t\tend = mid;\t}\treturn end;}int main(){\tint arr[6] = { 1, 3, 5, 7, 9, 11 };\tint target = 8;\tint find;\t//Lower Bound\tfind = lowerBound(arr, sizeof(arr), target);\tprintf(\"Lower Bound, target: 8 =&gt; INDEX: %d, VALUE: %d\\n\", find, arr[find]);\treturn 0;}결과 Lower Bound, target: 8 =&gt; INDEX: 4, VALUE: 9  Upper Bound예제 코드 #define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int upperBound(int *arr, int size, int target){\tint start = 0;\tint end = size - 1;\tint mid;\twhile (start &lt; end) {\t\tmid = (start + end) / 2;\t\tif (arr[mid] &lt;= target)\t\t\tstart = mid + 1;\t\telse\t\t\tend = mid;\t}\treturn end;}int main(){\tint arr[6] = { 1, 3, 5, 7, 9, 11 };\tint target = 8;\tint find;\t//Upper Bound\tfind = upperBound(arr, sizeof(arr), target);\tprintf(\"Upper Bound, target: 8 =&gt; INDEX: %d, VALUE: %d\\n\", find, arr[find]);\treturn 0;}결과 Upper Bound, target: 8 =&gt; INDEX: 4, VALUE: 9","categories": ["Algorithm"],
        "tags": ["Algorithm_DataStructure"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/DataStructure-%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/",
        "teaser":null},{
        "title": "[DataStructure]정렬 알고리즘 비교",
        "excerpt":"정렬 알고리즘 비교 정렬 알고리즘 비교 표             Sort      Best      Worst      Stable      Memory                  버블 정렬      N      N^2      TRUE      1              선택 정렬      N^2      N^2      FALSE      1              삽입 정렬      N      N^2      TRUE      1              셸 정렬      NlogN      Nlog^2N      FALSE      1              합병 정렬      NlogN      NlogN      TRUE      N              퀵 정렬      NlogN      N^2      FALSE      logN ~ N      추천 링크   정렬 시뮬레이션: https://www.toptal.com/developers/sorting-algorithms","categories": ["Algorithm"],
        "tags": ["Algorithm_DataStructure"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/DataStructure-%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B9%84%EA%B5%90/",
        "teaser":null},{
        "title": "[Database]SQL 개념 정리",
        "excerpt":"SQL(Structed Query Language) SQL에서 지원하는 기본 데이터 타입   정수(Integer): INT(4Byte), SMALLINT(2Byte)  실수(Float): FLOAT, REAL, DOUBLE PRECISION  형식화된 숫자: DEC(i, j) (i = 전체 자릿수, j = 소수부 자릿수)  고정길이 문자: CHAR(n) (n = 문자수)  가변길이 문자: VARCHAR(n) (n = 최대 문자 수)  고정길이 비트 열(Bit String): BIT(n)  가변길이 비트 열: VARBIT(n)  날짜: DATE  시간: TIMEDDL(Data Define Language)   DDL로 정의된 내용은 메타데이터가 되며, 시스템카탈로그에 저장한다.  CREATE, ALTER, DROP 명령문이 존재한다.    CREATE     스키마, 도메인 테이블, 뷰 인덱스를 정의한다.    CREATE SCHEMA     스키마를 정의하는 명령문  스키마는 하나의 응용(사용자)에 속하는 테이블과 기타 구성 요소등을 그룹짓기 위함이다.CREATE SCHEMA 스키마명 AUTHORIZATION 사용자ID;예제   ID가 홍길동인 사용자의 스키마 ‘대학교’를 정의하는 SQL문CREATE SCHEMA 대학교 AUTHORIZATION 홍길동;CREATE DOMAIN   도메인을 정의하는 명령문  도메인은 하나의 속성이 취할 수 있는 동일한 타입의 원자값들의 집합이다.CREATE DOMAIN 도메인명 데이터타입  [DEFAULT 기본값]  [CONSTRAINT 제약조건명 CHECK (범위값)];  데이터타입: SQL에서 지원하는 데이터 타입  기본값: 데이터를 입력하지 않았을 때 자동으로 입력되는 값예제   성별을 ‘남’ 또는 ‘여’와 같은 정해진 1개의 문자로 표현되는 도메인 SEX를 정의하는 SQL문CREATE DOMAIN SEX CHAR(1)  DEFAULT '남'  CONSTRAINT VALID-SEX CHECK (VALUE IN('남', '여'));CREATE TABLE   테이블을 정의하는 명령문CREATE TABLE 테이블명  (속성명 데이터타입[NOT NULL], ...  [, PRIMARY KEY (기본키 속성명, ...)]  [, UNIQUE (대채키 속성명, ...)]  [, FOREIGN KEY (외래키 속성명, ...)    REFERENCES 참조테이블(기본키 속성명, ...)]    [ON DELETE 옵션]    [ON UPDATE 옵션]  [, CONSTRAINT 제약조건명][CHECK (조건식)]);  옵션 종류          NO ACTION: 참조 테이블에 변화가 있어도 기본 테이블에는 아무런 조취를 취하지 않는다.      CASCADE: 참조 테이블의 튜플이 삭제되거나 속성이 변경되면 그에 해당하는 기본 테이블의 모든 튜플이 그에 맞게 갱신된다.      SET NULL: 참조 테이블에 변화가 생기면 기본 테이블의 관련 튜플의 속성 값을 NULL로 변경한다.      SET DEFAULT: 참조 테이블에 변화가 있으면 기본 테이블의 관련 튜플의 속성 값을 기본값으로 변경한다.        CONSTRAINT: 제약  조건의 이름을 지정하며, 반드시 지정할 필요는 없다.예제   이름, 학번, 전공, 성별, 생년월일로 구성된  테이블을 정의하는 SQL문          이름은 NULL이 올 수 없고, 학번은 기본키이다.      전공은  테이블의 학과코드를 참조하는 외래키로 사용된다.               테이블에서 삭제가 일어나면 관련된 튜플들의 전공 값을 NULL로 만든다.                     테이블에서 학과코드가 변경되면 전공 값도 같은 값으로 변경된다.            생년월일은 1980-01-01 이후의 데이터만 저장할 수 있다.      제약 조건의 이름은 ‘생년월일제약’으로 한다.      각 속성의 데이터형은 적당하게 지정한다. 단 성별은 도메인 ‘SEX’를 사용한다.      CREATE TABLE 학생  (이름 VARCHAR(15) NOT NULL,  학번 CHAR(8),  전공 CHAR(5),  성별 SEX,  생년월일 DATE,  PRIMARY KEY(학번),  FOREIGN KEY(전공) REFERENCES 학과(학과코드)    ON DELETE SET NULL    ON UPDATE CASCADE,  CONSTRAINT 생년월일제약 CHECK(생년월일 &gt;= '1980-01-01'));CREATE VIEW   뷰를 정의하는 명령문  뷰(View)는 하나 이상의 기본 테이블로부터 유도되는 이름을 갖는 가상 테이블이다.CREATE VIEW 뷰명[(속성명[, 속성명, ...])]AS SELECT문;  SELECT문을 서브 쿼리로 사용하여 SELECT문의 결과로서 뷰를 생성한다.예제        테이블에서 주소가 '안산시'인 고객들의 성명과 전화번호를 '안산고객'이라는 뷰로 정의한다.  CREATE VIEW 안산고객(성명, 전화번호)AS SELECT 성명, 전화번호FROM 고객WHERE 주소='안산시';CREATE INDEX   인덱스를 정의하는 명령문  인덱스는 검색을 빠르게 하기 위해 만든 보조적인 데이터 구조이다.CREATE [UNIQUE] INDEX &lt;인덱스명&gt;  ON 테이블명({속성명 [ASC | DESC] [,속성명 [ASC | DESC]]})  [CLUSTER];  UNIQUE          사용된 경우: 중복 값이 없는 속성으로 인덱스를 생성한다.      생략된 경우: 중복 값을 허용하는 속성으로 인덱스를 생성한다.        정렬 여부 지정          ASC: 오름차순 정렬      DESC: 내림차순 정렬      생략된 경우: 오름차순으로 정렬된다.        CLUSTER: 지정된 키에 따라 튜플들으르 그룹으로 지정하기 위해 사용된다.예시        테이블에서 UNIQUE한 특성을 갖는 고객번호 속성에 대해 내림차순으로 정렬하여 '고객번호_idx'라는 이름으로 인덱스를 정의한다.  CREATE UNIQUE INDEX 고객번호_idx  ON 고객(고객번호 DESC);ALTER ALTER TABLE   테이블에 대한 정의를 변경하는 명령문ALTER TABLE 테이블명 ADD 속성명 데이터타입 [DEFAULT '기본값'];ALTER TABLE 테이블명 ALTER 속성명 [SET DEFAULT '기본값'];ALTER TABLE 테이블명 DROP COLUMN 속성명 [CASCADE];  ADD: 새로운 속성을 추가한다.  ALTER:  속성의 기본값을 변경한다.  DROP COLUMN: 속성을 제거한다.예시        테이블에 최대 3문자로 구성되는 학년 속성을 추가하는 SQL문  ALTER TABLE 학생 ADD 학년 VARCHAR(3);DROP   스키마, 도메인, 테이블, 뷰, 인덱스, 트리거를 제거하는 명령문DROP SCHEMA 스키마명 [CASCADE | RESTRICT];DROP DOMAIN 도메인명 [CASCADE | RESTRICT];DROP TABLE 테이블명 [CASCADE | RESTRICT];DROP VIEW 뷰명 [CASCADE | RESTRICT];DROP INDEX 인덱스명 [CASCADE | RESTRICT];DROP TRIGGER 트리거명 [CASCADE | RESTRICT];DROP CONSTRAINT 제약조건명;  CASCADE: 제거할 개체를 참조하는 다른 모든 개체를 함께 제거한다. 즉, 주 테이블의 데이터 제거 시, 각각의 외래키와 관계를 맺고 있는 모든 데이터를 함께 제거한다.(참조 무결성 제약 조건을 위함)  RESTRICT: 다른 개체가 제거할 개체를 참조중일 경우 제거가 취소된다.SELECT   테이블을 구성하는 튜플들 중에서 전체 또는 조건을 만족하는 튜플을 검색하여 주기억장치에 임시 테이블로 구성하는 명령문이다.SELECT [PREDICATE] [테이블명.]속성명[ AS 별칭][, [테이블명.]속성명, ...]FROM 테이블명[, 테이블명, ...][WHERE 조건][GROUP BY 속성명[, 속성명, ...]][HAVING 조건][ORDER BY 속성명 [ASC | DESC][, 속성명 [ASC | DESC], ...]];  PREDICATE: 검색할 튜플을 제한할 목적으로 사용되는 조건이다.          ALL: 모든 튜플들을 검삭할 때 사용되며, 기본값이다.      DISTINCT: 중복된 튜플들을 제거할 때 사용된다.      DISTINCTROW: 중복된 튜플을 제거하지만, 선택된 속성의 값이 아닌 튜플의 전체 값을 대상으로 사용된다.        AS: 속성 및 연산의 이름을 다른 제목으로 표시하기 위해 사용된다.  FROM절: 검색할 데이터가 들어 있는 테이블명을 기술한다.  WHERE절: 검색할 조건을 기술한다.  GROUP BY절: 특정 속성을 기준으로 그룹화하여 검색할 때 사용된다. 일반적으로 그룹 함수와 함께 사용한다.  HAVING절: 그룹에 대한 조건을 기술한다.  ORDER BY절: 특정 속성을 기분으로 정렬하여 검색할 때 사용된다.    하위 질의          테이블에서 취미가 '나이트댄스'인 사원에 대해  테이블에서 해당 사원의 이름과 주소를 검색하는 SQL문  SELECT 이름, 주소FROM 사원WHERE 이름 IN(SELECT 이름 FROM 여가활동 WHERE 취미='나이트댄스');복수 테이블 검색   경력이 10년 이상인 사원의 이름, 부서, 취미, 경력을 검색하는 SQL문SELECT 사원.이름, 사원.부서, 여가활동.취미, 여가활동.경력FROM 사원, 여가활동WHERE 여가활동.경력 &gt;= 10 AND 사원.이름 = 여가활동.이름;통합(UNION) 질의   UNION은 일반 집합 이론에서의 합집합과 같다.  두 테이블을 합치면 두 테이블에 모두 속해 있는 튜플은 중복이 제거되어 1개만 표시된다.  사원들의 명단이  테이블과  테이블에 저장되어 있다. 두 테이블을 통합하는 SQL문(중복 제거)SELECT *FROM 임원UNION SELECT * 직원;JOIN   조인은 2개의 테이블에 대해 연관된 튜플들을 결합하여, 하나의 새로운 릴레이션을 반환한다.  조인은 크게 INNER JOIN과 OUTER JOIN으로 구분된다.    INNER JOIN     INNER JOIN은 일반적으로 EQUI JOIN과 NON-EQUI JOIN으로 구분된다.    EQUI JOIN     EQUI JOIN은 JOIN 대상 테이블에서 공통 속성을 기준으로 ‘=’(equal)비교에 의해 같은 값을 가지는 행을 연결하여 결과를 생성하는 방법이다.  중복된 속성을 제거하여 같은 속성을 한 번만 표기하는 방법을 NATURAL JOIN이라 한다.  WHERE절을 이용한 EQUI JOINSELECT [테이블명1.]속성명, [테이블명2.]속성명, ...FROM 테이블명1, 테이블명2, ...WHERE 테이블명1.속성명 = 테이블명2.속성명;  NATURAL JOIN을 이용한 EQUI JOINSELECT [테이블명1.]속성명, [테이블명2.]속성명, ...FROM 테이블명1 NATURAL JOIN 테이블명2;  JOIN ~ USING절을 이용한 EQUI JOINSELECT [테이블명1.]속성명, [테이블명2.]속성명, ...FROM 테이블명1 JOIN 테이블명2 USING(속성명);예제        테이블과  테이블에서 학과코드 값이 같은 튜플을 JOIN하여 학번, 이름, 학과코드, 학과명을 출력하는 SQL문  SELECT 학번, 이름, 학생.학과코드, 학과명FROM 학생, 학과WHERE 학생.학과코드 = 학과.학과코드;SELECT 학번, 이름, 학생.학과코드, 학과명FROM 학생 NATURAL JOIN 학과;SELECT 학번, 이름, 학생.학과코드, 학과명FROM 학생 JOIN 학과 USING(학과코드);NON-EQUI JOIN   NON-EQUI JOIN은 JOIN조건에 ‘=’ 조건이 아닌 나머지 비교 연산자인 ‘&gt;’, ‘&lt;’, ‘&lt;=’, ‘&gt;=’ 연산자를 사용하는 방법이다.예제        테이블과  테이블을 JOIN하여 각 학생의 학번, 이름, 성적, 등급을 출력하는 SQL문  SELECT 학번, 이름, 성적, 등급FROM 학생, 성적등급WHERE 학생.성적 BETWEEN 성적등급.최저 AND 성적등급.최고;OUTER JOIN   OUTER JOIN은 릴레이션에서 JOIN조건에 만족하지 않는 튜플도 결과로 출력하기 위한 JOIN 방법이다.    LEFT OUTER JOIN     INNER JOIN의 결과를 구한 후, 우측 항 릴레이션과 맞지 않는 좌측 항 릴레이션의 튜플에 NULL값을 대입한다.  좌측 릴레이션은 모두 출력된다.SELECT [테이블명1.]속성명, [테이블명2.]속성명, ...FROM 테이블명1 LEFT OUTER JOIN 테이블명2ON 테이블명1.속성명 = 테이블명2.속성명;SELECT [테이블명1.]속성명, [테이블명2.]속성명, ...FROM 테이블명1, 테이블명2WHERE 테이블명1.속성명 = 테이블명2.속성명(+);RIGHT OUTER JOIN   INNER JOIN의 결과를 구한 후, 좌측 항 릴레이션과 맞지 않는 우측 항 릴레이션의 튜플에 NULL값을 대입한다.  우측 릴레이션은 모두 출력된다.SELECT [테이블명1.]속성명, [테이블명2.]속성명, ...FROM 테이블명1 RIGHT OUTER JOIN 테이블명2ON 테이블명1.속성명 = 테이블명2.속성명;SELECT [테이블명1.]속성명, [테이블명2.]속성명, ...FROM 테이블명1, 테이블명2WHERE 테이블명1.속성명(+) = 테이블명2.속성명;FULL OUTER JOIN   LEFT OUTER JOIN과 RIGHT OUTER JOIN을 합쳐 놓은 것이다.  양쪽 릴레이션이 모두 출력된다.SELECT [테이블명1.]속성명, [테이블명2.]속성명, ...FROM 테이블명1 FULL OUTER JOIN 테이블명2ON 테이블명1.속성명 = 테이블명2.속성명;SELF JOIN   SELF JOIN은 같은 테이블에서 2개의 속성을 연결하여 EQUI JOIN을 하는 방법이다.SELECT [별칭1.]속성명, [별칭2.]속성명, ...FROM 테이블명1 [AS] 별칭1 JOIN 테이블명1 [AS] 별칭2ON 별칭1.속성명 = 별칭2.속성명;SELECT [별칭1.]속성명, [별칭2.]속성명, ...FROM 테이블명1 [AS] 별칭1, 테이블명1 [AS] 별칭2WHERE 별칭1.속성명 = 별칭2.속성명;DML(Date Manipulation Language)   DML은 데이터베이스 사용자가 응용 프로그램이나 질의어를 통해 저장된 데이터를 실질적으로 관리하는데 사용되는 언어이다.  DML은 데이터베이스 사용자와 데이터베이스 관리 시스템 간의 인터페이스를 제공한다.  INSERT, DELETE, UPDATE 명령문이 있다.    INSERT문     테이블에 새로운 튜플을 삽입할 때 사용하는 명령문이다.INSERT INTO 테이블명[(속성명1, 속성명2, ...)]VALUES (데이터1, 데이터2, ...);예시        테이블에 이름이 \"이순신\"이고, 부서가 \"기획\"인 사원을 삽입하는 SQL문  INSERT INTO 사원(이름, 부서) VALUES ('이순신', '기획');       테이블에 있는 편집 부서의 모든 튜플을 &lt;편집부원(이름, 생일, 주소, 기본급)&gt; 테이블에 삽입하는 SQL문  INSERT INTO 편집부원(이름, 생일, 주소, 기본급)SELECT 이름, 생일, 주소, 기본급 FROM 사원 WHERE 부서='편집';DELETE문   테이블에 있는 튜플들 중에서 특정 튜플을 삭제할 때 사용하는 명령문이다.DELETE FROM 테이블명 WHERE 조건;예시        테이블에서 이름이 \"임꺽정\"인 튜플을 삭제하는 SQL문  DELETE FROM 사원 WHERE 이름='임꺽정';       테이블의 모든 튜플을 삭제하는 SQL문  DELETE FROM 사원;UPDATE문   테이블에 있는 튜플들 중에서 특정 튜플의 내용을 갱신할 때 사용하는 명령문이다.UPDATE 테이블명SET 속성명=데이터[, 속성명=데이터, ...]WHERE 조건;예시        테이블에서 홍길동의 주소를 \"퇴계동\"으로 갱신하는 SQL문  UPDATE 사원 SET 주소='퇴계동' WHERE 이름='홍길동';       테이블에서 황진이의 부서를 \"기획\"으로 변경하고 기본급을 5 인상하는 SQL문  UPDATE 사원 SET 부서='기획', 기본급=기본급+5 WHERE 이름='황진이';DCL(Data Control Language)   DCL은 데이터의 보안, 무결성, 회복, 병행 제어 등을 정의하는데 사용하는 언어이다.  DCL은 데이터베이스 관리자(DBA)가 데이터 관리를 목적으로 사용한다.  COMMIT, ROLLBACK, GRANT, REVOKE 명령문이 있다.    COMMIT     트랜잭션의 모든 변경 내용들을 영구적으로 데이터베이스에 반영하는 명령어이다.    ROLLBACK     변경된 모든 내용들을 취소하고 데이터베이스를 이전 상태로 되돌리는 명령어이다.  트랜잭션의 일부를 성공적으로 끝내지 못하면 데이터베이스가 비일관성인 상태를 가질 수 있으므로 모든 내용들을 취소해야한다.    GRANT     데이터베이스 관리자가 데이터베이스 사용자에게 권한을 부여하기 위한 명령어이다.  사용자등급 지정GRANT 사용자등급 TO 사용자ID리스트[IDENTIFIED BY 암호];  사용자 등급: DBA(데이터베이스 관리자), RESOURCE(데이터베이스 및 테이블 생성 가능자), CONNECT(단순 사용자)  테이블 및 속성에 대한 권한 부여GRANT 권한리스트 ON 개체 TO 사용자 [WITH GRANT OPTION];REVOKE   권한 취소를 위한 명령어이다.  사용자등급 해제REVOKE 사용자등급 FROM 사용자ID리스트;  테이블 및 속성에 대한 권한 취소REVOKE [GRANT OPTION FOR] 권한리스트 ON 개채 FROM 사용자 [CASCADE];","categories": ["Study"],
        "tags": ["Study_Database"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/Database-SQL-%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC/",
        "teaser":null},{
        "title": "[Database]개념 정리",
        "excerpt":"데이터베이스(Database) 데이터베이스 개념 정의   특정 조직의 업무를 수행하는데 있어서 필요한 상호 관련된 데이터들의 모임  통합 데이터(Integrated Data): 검색의 효율성을 위해 중복을 최소화한 데이터  저장 데이터(Stored Data): 컴퓨터가 접근 가능한 저장 매체에 저장된 데이터  운영 데이터(Operational Data): 조직의 목표를 위해 존재 가치가 확실하고 반드시 필요한 데이터  공유 데이터(Shared Data): 여러 프로그램들이 공동으로 사용하는 데이터특징   실시간 접근성(Real Time Accessibility): 사용자의 질의(query)에 대해 즉시 처리하여 응답한다.  계속적인 진화(Continuous Evolution): 항상 최근의 정확한 데이터를 동적으로 유지한다.  동시 공유(Concurrent Sharing): 여러 사용자가 동시에 원하는 데이터를 사용가능하다.  내용에 의한 참조(Content Reference): 데이터를 참조할 때 내용으로 참조한다.(물리적 주소값이 아님)  독립성(Independence)          논리적 독립성(응용프로그램과 데이터베이스와의 관계): 데이터의 논리적 구조를 변경하더라도 응용프로그램에는 영향을 주지 않는다.      물리적 독립성(응용프로그램과 보조기억장치와의 관계): 새로운 저장장치의 추가에도 응용프로그램에는 영향을 주지 않는다.        무결성(Integrity): 데이터베이스에 저장된 데이터 값과 실제 값이 일치하는 정확성          무결성 제약 조건: 정확하지 않은 데이터가 데이터베이스내에 저장되는 것을 방지하기 위한 제약 조건                  널 무결성(NULL Integrity): 특정 속성(attribute)값이 NULL일 수 없다.          고유 무결성(Unique Integrity): 특정 속성에 대해 각 튜플들은 서로 다른 값이어야 한다.          키 무결성(Key Integrity): 하나의 릴레이션에는 적어도 하나의 key가 있어야 한다.          도메인 무결성(Domain Integrity): 특정 속성값이 해당 속성이 정의된 도메인에 속한 값이어야 한다.          관계 무결성(Relationship Integrity): 릴레이션에서 튜플의 삽입 가능 여부와 서로 다른 릴레이션의 튜플들 사이의 관계가 적절해야 한다.          참조 무결성(Referential Integrity): Foreign key는 NULL값이거나 참조 릴레이션의 primary key와 동일해야한다.          개체 무결성(Entity Integrity): Primary key를 구성하는 속성은 NULL일 수 없다.                      보안성  일관성  데이터 중복 최소Data Language   데이터베이스의 구축과 사용을 위해 DBMS와의 통신 수단이다.  종류          DDL(Data Definition Language): 데이터베이스의 구조, 형식, 접근방식 등을 구축하거나 변경한다.      DML(Data Manipulation Language): 데이터 처리를 위한 연산의 집합(검색, 삽입, 삭제, 갱신)이다.      DCL(Data Control Language): 보안 및 권한제어, 무결성, 회복, 벙행제어를 수행한다.      데이터베이스 사용자   DBA(DataBase Administrator, 데이터베이스 관리자): 데이터베이스를 정의하고 제어하는 사람 또는 그룹  DA(Data Administrator, 데이터 관리자): 조직내에서 데이터에 대한 정의, 체계화, 감독 및 보안 업무를 수행한다.  DA(Data Architect, 데이터 설계자): 데이터의 구조를 체계적으로 정의한다.시스템 카탈로그(System Catalog)   DBA의 도구로써, 데이터베이스에 저장되어 있는 모든 데이터 개체들에 대한 정의와 명세와 같은 정보들이 저장되어 있는 테이블이다.  데이터 사전(Data Dictionary) 라고도 불린다.  시스템 카탈로그에 저장된 내용을 메타 데이터(Meta Data)라고 한다.  시스템 카탈로그는 DBMS에 의해 생성되고 유지되며, 사용자가 SQL문으로 수정할 수 없다.(DBMS와 사용자가 접근 가능하다.)DBMS(Database Management System)   다수의 사용자들이 데이터베이스 내의 데이터를 접근할 수 있도록 해주는 소프트웨어 도구의 집합이다.  주어진 설정에 따라 데이터베이스 스키마를 생성하고, 생성된 스키마를 참조하여 명령을 수행한다.  DDL 컴파일러와 트랜잭션 관리자로 구성되어 있다.기능   사용자 또는 다른 프로그램의 요구를 처리하고 적절히 응답하여 데이터를 사용할 수 있도록 도와준다.  정의: 데이터에 대한 형식, 구조, 제약조건들을 명세하는 기능(데이터베이스에 대한 정의 및 설명은 카탈로그나 사전의 형태로 저장된다.)  구축: DBMS가 관리하는 기억 장치에 데이터를 저장하는 기능  조작: 특정한 데이터를 검색하기 위한 질의, 데이터베이스의 갱신, 보고서 생성 기능 등  공유: 여러 사용자와 프로그램이 데이터베이스에 동시에 접근하도록 하는 기능  보호: 하드웨어나 소프트웨어의 오동작 또는 권한이 없는 악의적인 접근으로부터 시스템을 보호  유지보수: 시간이 지남에 따라 변화하는 요구사항을 반영할 수 있도록 하는 기능장점   데이터의 통합성 향상  데이터의 접근성 용이  데이터 통제 강화  애플리케이션 프로그램들을 쉽게 개발 및 관리가 가능  보안 강화스키마(Schema)   데이터베이스에서 데이터의 구조, 표현 방법, 관계를 형식 언어로 정의한 구조이다.  외부 스키마(External Schema): 프로그래머나 사용자의 입장에서 데이터베이스 모습을 정의한다.  개념 스키마(Conceptual Schema): 모든 응용 시스템과 사용자들의 관점에서 데이터베이스 구조를 논리적으로 정의한다.  내부 스키마(Internal Schema): 전체 데이터베이스의 물리적 저장 형태를 기술한다.데이터베이스 설계 1. 요구 조건 분석 2. 개념적 설계   개념 스키마 모델링: ER Model과 같은 추상화 기법을 통해 개념 스키마를 만든다.  트랜잭션 모델링3. 논리적 설계   논리 스키마를 설계한다.  관계형 DBMS의 경우 ER Model을 relation schema로 변환한다.(정규화 수행)  트랜잭션의 전체적인 구조를 설계하고 인터페이스를 정의한다.4. 물리적 설계   물리 스키마를 설계한다.  데이터베이스 파일에 대한 저장 구조와 접근 경로를 설정한다.5. 데이터베이스 구현   DBMS의 DDL을 사용하여 데이터베이스를 구축한다.Model Relationship Data Model   대표적인 논리적 데이터 모델로서, 테이블(Table) 또는 릴레이션(Relation)의 구조로 표현한다.  테이블 그림 삽입  Relation: 데이터를 표현하는 2차원 테이블          Relation Schema: Relation의 이름, 각 attribute에 대한 정의      Relation Instance: Relation에 들어있는 tuple들의 집합        Attribute(속성): Relation의 columns  Tuple(튜플): Relation의 rows  Domain: 하나의 attribute가 가질 수 있는 같은 타입의 값들의 집합  Degree: Relation의 attribute의 개수  Cardinality: Relation의 tuple의 개수ER Model(Entity - Relationship Model)   대표적인 개념적 데이터 모델로서, Entity, Relationship, Attribute 를 도형화하여 표현한 것이다.  위를 ERD(ER Diagram)이라고 부른다.  그림 삽입key             Key      특징      유일성      최소성                  Super Key(슈퍼키)      한 릴레이션 내에 있는 속성들의 집합      O      X              Candidate Key(후보키)      한 릴레이션에서 튜플을 유일하게 식별할 수 있는 속성      O      O              Primary Key(기본키)      후보키 중 특별히 선정된 키(중복된 값과 NULL을 가질 수 없음)      O      O              Alternate Key(대체키)      후보키중 기본키를 제외한 나머지 속성들      O      O              Foreign Key(외래키)      다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합(중복된 값과 NULL을 가질 수 없음)      O      O      관계대수와 관계해석   관계대수로 표현한 식은 관계해석으로도 표현 가능하다.  관계해석과 관계대수는 관계형 데이터베이스를 처리하는 기능과 능력면에서는 동등하다.    관계대수(Relation Algebra)     관계형 데이터베이스에서 원하는 정보를 검색하기 위해서 어떻게 유도할지를 기술한 절차적 언어로 연산자와 연산규칙을 제공한다.  질의에 대한 해를 구하기 위해 수행해야할 연산의 순서를 명시한다.(절차적 성격)  순수 관계 연산자          표 그림 삽입        일반 집합 연산자          표 그림 삽입        관계해석(Relation Calculus)               E.F.Codd박사가 제안한 것으로 수학의 술어해석에 기반을 둔다.  원하는 정보가 무엇이라는 것만 정의하는 비절차적 특징을 갖는다.  SQL문과 같은 질의어를 사용하며 튜플 관계해석과 도메인 해석으로 구성된다.정규화(Normalization)   테이블 속성들 사이의 종속적인 관계를 이용하여 테이블을 손실없이 분해하는 과정이다.  이러한 분해를 통해, 중복을 최대한 제거하고 이상(anomaly)의 발생 가능성을 줄인다.    이상(Anomaly)     테이블 일부 속성들이 종속으로인해 중복이 발생하여 테이블 조작에 문제가 발생하는 현상이다.  종류          삽입 이상(Insert Anomaly): 원하지 않는 데이터가 삽입되거나 삽입하는데 데이터가 부족하여 삽입이 되지 않는 문제점을 말한다.      삭제 이상(Delete Anomaly): 하나의 데이터만을 삭제하는 동작에서 해당 데이터가 포함된 튜플 전체가 삭제됨과 같은 원하지 않는 정보 손실이 발생하는 문제점을 말한다.      갱신 이상(Update Anomaly): 튜플에 있는 속성값을 갱신하는 동작에서 일부 튜플 정보만 갱신되어 정보에 불일치성이 생기는 문제점을 말한다.        원인: 여러가지 종류의 값들을 하나의 릴레이션에 표현하기 때문이다.  해결 방안: 속성들간의 종속성을 분석하여 하나의 종속성은 하나의 릴레이션에 표현되도록 분해한다.(정규화)    함수적 종속(Functional Dependency)     임의의 테이블 R에서 X와 Y를 각각 R의 속성 집합의 부분 집합이라고 할때, X의 값이 Y의 값을 유일하게(unique) 결정한다면 “X는 Y를 함수적으로 결정한다”라고 한다.  이를 X -&gt; Y로 표기하며, X를 결정자(Determinant), Y를 종속자(Dependent)라고 부른다.  완전 함수적 종속(Full Functional Dependency): X -&gt; Y일때, X의 임의의 애트리뷰트를 제거하면 더 이상 함수적 종속성이 성립하지 않는 경우를 말한다.  부분 함수적 종속(Partial Functional Dependency): X -&gt; Y일때, X의 임의이 애트리뷰트를 제거하더라도 함수적 종속성을 성립하는 경우를 말한다.  이행 함수적 종속(Transitive Functional Dependency): X -&gt; Y, Y -&gt; Z의 경우에서 추론될 수 있는 X -&gt; Z가 성립하는 경우를 말한다.  다치종속(Multi-Valued Dependency, MVD): X, Y -&gt; Z와 X -&gt; Z가 성립하는 경우이다.  조인 종속: 테이블 R과 R의 프로젝션들을 모두 조인한 결과가 동일한 경우를 말한다.    정규화 과정     제 1 정규형(1NF)     애트리뷰트의 도메인이 오직 원자값 만을 포함하고, 튜플의 모든 애트리뷰트가 도메인에 속하는 하나의 값을 가져야 한다.  복합 애트리뷰트, 다중값 애트리뷰트, 중첩 릴레이션 등 비원자적인 애트리뷰트를 혀용하지 않는 릴레이션 형태이다.    제 2 정규형(2NF)     모든 비주요 애트리뷰트들이 주요 애트리뷰트에 대해서 완전 함수적 종속 이면 제 2 정규형을 만족한다.  기본키가 아닌 모든 애트리뷰트들이 기본키에 완전 함수적 종속이 되는 릴레이션 형태이다.    제 3 정규형(3NF)     모든 비주요 애트리뷰트들이 기본키에 대해서 이행 함수적 종속이 성립하지 않으면 제 3 정규형을 만족한다.  비주요 애트리뷰트가 비주요 애트리뷰트에 의해 종속되는 경우가 없는 릴레이션 형태를 말한다.    BCNF(Boyce-Codd) 정규형     여러 후보키가 존재하는 릴레이션에 해당하는 정규화이다.  모든 종속의 결정자가 후보키가 되면 BCNF 정규형을 만족한다.    제 4 정규형(4NF)     다치종속관계 가 성립되는 경우를 모두 제거한 형태를 말한다.    제 5 정규형(5NF)     조인종속 이 후보키를 통해서만 성립되는 형태를 말한다.인덱스(Index)   DBMS가 데이터베이스 테이블의 데이터를 빠르게 검색하기 위해서 &lt;데이터, 데이터가 저장된 주소&gt; 쌍으로 구성되는 데이터 구조이다.  DBMS의 인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 탐색하는것은 빠르지만 새로운 값을 추가, 삭제, 수정하는 경우에는 느리다.  즉, 인덱스는 데이터의 저장 성능을 희생하는 대신 데이터의 읽기 속도를 높이는 역할을 한다.    인덱스 종류     기본 인덱스          기본키를 위한 인덱스      관계형 DBMS에서는 모든 기본키에 자동적으로 기본 인덱스를 생성한다.        보조 인덱스: 기본 인덱스가 아닌 나머지 인덱스  클러스터드(Clustered) 인덱스          인덱스 테이블의 키 값 순서와 튜플의 물리적 순서를 동일하게 유지하는 인덱스(물리적으로 인접한 장소에 저장되어 있는 데이터들)      클러스터드 인덱스는 기본키에 대해서만 적용되며, 기본키가 비슷한 레코드끼리 묶어서 저장한 것이다.      기본키값에 따라 레코드의 저장 위치가 결졍되므로 기본키값이 변경되면 해당 레코드의 물리적인 저장 위치 역시 변경되어야 한다.      클러스터드 인덱스는 테이블당 기본키와 같이 한 개만 생성할 수 있다.(Non-clustered 인덱스는 한 테이블당 여러개를 생성할 수 있다.)        인덱스 자료구조         B+-Tree 인덱스 알고리즘               일반적으로 사용되는 인덱스 알고리즘은 B+-Tree 알고리즘이다.  B+-Tree 인덱스는 칼럼의 값을 변형하지 않고(사실, 값의 일부분만 잘라서 관리함), 원래의 값을 이용해 인덱싱하는 알고리즘이다.    Hash 인덱스 알고리즘     칼럼 값을 해시 값으로 계산해서 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원한다.  값을 변형해서 인덱싱하므로, 특정 문자로 시작하는 검색인 전방 일치 검색과 같이 값의 일부만으로 검색하고자 할 때는 사용할 수 없다.  주로 메모리 기반의 데이터베이스에 사용된다.    왜 index를 생성하는데 주로 B-Tree를 사용하는가?     데이터에 접근하는 시간복잡도가 O(1)인 hash table이 더 효율적일 것 같지만, SELECT질의의 조건에는 부등호(&lt; &gt;)연산도 포함이 되는데 이는 hash table에서 사용할 수 없다.  동등 연산(=)에 특화된 hash table은 데이터베이서의 자료구조에 적합하지 않다.    인덱스 성능     인덱스를 사용하면 SELECT 쿼리의 성능을 크게 상향시킬 수 있다.  그에 반해 INSERT, DELETE, UPDATE 쿼리를 실행할 때 별도의 과정이 추가적으로 발생하기 때문에 오히려 전체적인 성능은 떨어진다.          INSERT는 인덱스에 대한 데이터도 따로 추가해한다.      DELETE는 인덱스에 존재하는 값은 삭제하지 않고 사용을 안한다는 표시로만 남는다.(즉, row의 수는 그대로이다.)        결과적으로, 인덱스는 꼭 필요한 컬럼에만 적용해야 한다.트랜잭션(Transaction)   트랜잭션은 작업의 완전성 을 보장해준다.  논리적인 작업 셋을 모두 완벽하게 처리한다. 만약 처리하지 못할 경우에는 원래 상태로 복구해서 작업의 일부만 적용되는 현상을 막아주는 기능을 한다.  사용자의 입장에서는 작업의 논리적 단위로 볼 수 있고, 시스템의 입장에서는 데이터들을 접근 또는 변경하는 프로그램의 단위가 된다.  COMMIT: 하나의 트랜잭션이 정상적으로 종료될 경우 수행되는 연산  ROLLBACK: 하나의 트랜잭션이 비정상적으로 종료될 경우 수행되는 연산    특징     ACID    원자성(Atomicity)     만약 트랜잭션 중간에 어떤 문제가 발생했다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행해되어서는 안된다. 즉, 아무런 문제가 발생하지 않았을 경우에만 모든 작업이 수행된다.    일관성(Consistency)     트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.    고립성(Isolation)     각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.    지속성(Durability)     트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.    상태     그림 삽입  Active: 트랜잭션의 활동 상태, 트랜잭션이 실행중이며 동작중인 상태를 말한다.  Failed: 트랜잭션 실패 상태, 트랜잭션이 더이상 정상적으로 진행할 수 없는 상태를 말한다.  Partial Committed: 트랜잭션의 Commit 명령어가 도착한 상태, 트랜잭션의 commit 이전의 sql 문이 수행되고 commit 만 남은 상태를 말한다.  Committed: 트랜잭션 완료 상태, 트랜잭션이 정상적으로 완료된 상태를 말한다.  Aborted: 트랜잭션 취소 상태, 트랜잭션이 취소되고 트랜잭션 실행 이전 데이터로 돌아간 상태를 말한다.    Partial Committed 와 Committed 의 차이     Commit 요청이 들어오면 트랜잭션의 상태는 Partial Committed 상태가 된다. 이후 commit 을 문제없이 수행할 수 있으면 Committed 상태로 전이되고, 만약 오류가 발생하면 Failed 상태가 된다. 즉, Partial Committed 는 commit 요청이 들어왔을때를 말하며, Committed 는 commit 을 정상적으로 완료한 상태를 말한다.    병행제어(Concurrency Control)     병행제어란 다중 프로그램의 이점을 활용하여 동시에 여러개의 트랜잭션을 병행 수행할 때, 동시에 실행되는 트랜잭션들이 데이터베이스의 일관성을 파괴하지 않도록 트랜잭션 간의 상호작용을 제어하는 것이다.    목적     데이터베이스의 공유를 최대화한다.  시스템의 활용도를 최대화한다.  데이터베이스의 일관성을 유지한다.  사용자에 대한 응답시간을 최소화한다.    문제점     갱신 분실(Lost Update): 두 개 이상의 트랜잭션이 같은 자료를 공유하여 갱신할 때 갱신 결과의 일부가 없어지는 현상이다.  비완료 의존성(Uncommitted Dependency): 하나의 트랜잭션 수행이 실패한 후 이를 회복하기 전에 다른 트랜잭션이 그 실패한 갱신 결과를 참조하는 현상이며, 임시 갱신이라고도 한다.  모순성(Inconsistency): 두 개의 트랜잭션이 병행수행될 때 원치 않는 자료를 이용함으로써 발생하는 문제이며, 불일치 분석이라고도 한다.  연쇄 복귀(Cascading Rollback): 병행수행하는 트랜잭션들 중 어느 하나에 문제가 발생하여 Rollback 하는 경우 다른 트랜잭션도 함께 Rollback 되는 현상이다.    병행제어 기법의 종류           로킹(Locking, 잠금)        로킹은 주요 데이터의 접근을 상호 배타적으로 하는 것이다.  트랜잭션들이 어떤 로킹 단위를 접근하기 전에 Lock(잠금)을 요청하여 접근을 허용해주어야만 그 로킹 단위에 접근할 수 있는 기법이다.  데이터 갱신 과정: 잠금(Lock) -&gt; 실행(Excute) -&gt; 해제(Unlock)  잠금 단위          병행제어에서 한 번에 잠금할 수 있는 단위는 데이터베이스, 테이블, 레코드, 필드 등이 있다.      단위가 커지면 Locking Overhead는 감소하지만 공유성이 낮아진다.      단위가 작아지면 Locking Overhead는 증가하지만 공유성은 높아진다.        종류: 공유 잠금, 배타 잠금, 의도 잠금, 의도 공유 잠금, 배타 의도 잠금, 공유 의도 독점 잠금  2단계 잠금 규약(Two-Phase Lock Protocol)          각 트랜잭션의 잠금 요청과 해제 요청을 2단계로 실시한다.      직렬성을 보장하는 대표적인 잠금 규약이다.      확장 단계: 새로운 Lock은 수행할 수 있지만, Unlock은 수행할 수 없다.      축소 단계: 새로운 Unlick은 수행할 수 있지만, Lock은 수행할 수 없다.      직렬성을 보장하지만, 교착상태를 예방할 수 없다.    2. 타임 스탬프 순서(Time Stamp Ordering)        직렬성 순서를 결정하기 위해 트랜잭션 간의 처리 순서를 선택하는 기법 중 가장 보편적인 방법이다.  트랜잭션과 트랜잭션이 읽거나 갱신한 데이터에 대해 트랜잭션이 실행을 시작하기 전에 시간표(Time Stamp)를 만들어 정해진 시간에 따라 작업을 수행하는 기법이다.  교착상태가 발생하지 않는다.          최적 병행 수행(검증 기법, 확인 기법, 낙관적 기법)        병행수행하고자 하는 트랜잭션의 대부분이 읽기 전용(Read only) 트랜잭션일 경우, 트랜잭션 간의 충돌방생률이 매우 낮으므로 병행제어 기법을 사용하지 않아도 시스템의 일관성을 유지할 수 있다는 점을 이용하는 기법이다.          다중 버전 기법        타임 스탬프의 개념을 이용하는 기법으로, 다중 버전 타임 스탬프 기법이라고도 한다.  타임 스탬프 기법은 트랜잭션 및 데이터들의 이용 시간을 시간표로 관리하지만, 다중 버전 기법은 갱신될 때마다의 버전을 만들어 관리한다.    회복(Recovery)     데이터베이스 운영 도중 예기치 못한 장애(Failure)가 발생한 경우, 데이터베이스를 장애 발생 이전의 일관된 상태(Consistent State)로 복원시키는 것이다.  데이터베이스 관리 시스템에 회복 기능이 없을 경우, 데이터베이스에 저장된 내용을 신뢰할 수 없으므로 핵심적인 역할을 담당하는 회복 관리기(Recovery Manager)가 필요하다.    장애(Failure) 유형     실행 장애(Action Failure): 사용자의 실수나 무결성 규칙 위반 등 질의 실행이 실패한 경우.  트랜잭션 장애(Transaction Failure): 내부적인 오류나 Deadlock과 같은 오류로 정상적으로 트랜잭션을 실행할 수 없는 경우.  시스템 장애(System Failure): 전원, 하드웨어, 소프트웨어 등의 고장으로 모든 트랜잭션을 사용할 수 없는 경우.  미디어 장애(Media Failure): 저장장치의 손상이나 오류로 데이터베이스의 일부 또는 전체가 물리적으로 손상되는 경우.    회복 관리기(Recovery Manager)     Log, Memory Dump 등을 이용하여 회복을 수행하는 DBMS의 핵심 구성요소이다.  트랜잭션이 성공적으로 완료되지 않았을 때, Log를 이용하여 트랜잭션이 데이터베이스의 모든 변화를 취소(Undo)하여 회복한다.  트랜잭션이 성공적으로 완료되었으나 저장장치에 반영되지 않았을 때, Log를 이용하여 재작업(Redo)를 수행한다.    회복 기법     연기 갱신(Differed Update)          트랜잭션이 성공적으로 종료될 때까지 데이터베이스에 대한 실질적인 갱신을 연기한다.      실행되는 동안 변경된 내용은 Log에 보관하며 부분완료 시점에 Log에 저장된 내용을 데이터베이스에 반영한다.      내용을 Log에 저장하고 데이터베이스에 적용을 하지 않기 때문에 장애가 발생하면 Redo 작업만을 수행하면 된다.        즉각 갱신(Immediate Update)          트랜잭션이 데이터를 변경하면 트랜잭션이 부분 완료가 되기 전이라도 데이터베이스에 바로 반영한다.      장애를 대비하여 모든 변경 내용을 Log에 저장한다.      Undo, Redo 모두 수행한다.        그림자 페이지(Shadow Paging)          갱신 이전의 데이터베이스를 페이지단위로 구성하여 복사해놓고, 실제 페이지를 대상으로 트랜잭션에 대한 변경 작업을 반영한다.      장애가 발생하여 Rollback을 할 때, 해당 페이지만 복구한다.      Log와 Undo, Redo 모두 수행할 필요가 없다.        검사점(Check Point)          Undo, Redo를 수행할 때 Log 전체를 조사해야하는 것을 피하기 위한 기법이다.      트랜잭션 실행 중 주기적으로 변경 내용과 검사점을 같이 Log에 저장한다.      장애가 발생할 때, 전체 Log를 조회하지 않고 가장 최근 검사점을 기준으로 회복 작업을 수행한다.        미디어 회복(Media Recovery)          데이터베이스의 내용을 주기적으로 안전한 저장소에 덤프한다.      장애가 발생하면 가장 최근의 덤프를 디스크에 적재하고, Log를 조회하여 최근의 트랜잭션에 대하여 Redo를 수행한다.      고급 데이터베이스 분산 데이터베이스(Distributed Database)   논리적으로 같은 시스템에 속하지만, 물리적으로 분산되어있는 데이터베이스    분산 데이터베이스 시스템 구성요소     분산 처리기: 지리적으로 분산되어있는 컴퓨터 시스템, 자체 처리 능력을 가진다.  분산 데이터베이스: 지리적으로 분산되어있는 데이터베이스  통신 네트워크: 분산 처리기들을 통신망으로 연결해 하나의 시스템처럼 작동할 수 있는 네트워크    목표     위치 투명성(Location Transparency): 접근하려는 데이터베이스의 실제 위치를 알 필요는 없다.  중복 투명성(Replication Transparency): 동일한 데이터가 여러 곳에 중복되어도 하나의 데이터만 존재하는 것처럼 사용할 수 있다.  병행 투명성(Concurrency Transparency): 다수의 트랜잭션들이 동시에 수행되어도 서로 영향을 주지 않는다.  장애 투명성(Failure Transparency): 각종 장애에도 불구하고 트랜잭션은 정확히 수행된다.    멀티미디어 데이터베이스(Multimedia Database)     텍스트, 그래픽, 정지화상, 동영상, 음성 등이 복합적으로 구성된 데이터베이스    주기억장치 데이터베이스(Main Memory Database)     데이터베이스 전체를 주기억장치에 저장한 후, 데이터베이스 연산을 수행하는 시스템  디스크 I/O가 발생하지 않는다.    데이터 웨어하우스(Data Warehouse)     다량의 데이터를 효과적으로 분석하여 정보화하고, 이를 계층의 사용자가 효율적으로 사용하도록 하는 데이터베이스  다양한 원본 데이터베이스로부터 정제되어 추출된 데이터만을 저장하고 필요한 인덱스를 생성한다.  빠르고 정확한 의사결정을 도와준다.    데이터 마트(Data Mart)     전사적으로 구축된 데이터 웨어하우스로부터, 특정 주제나 부서 중심으로 구성된 단일 주제의 데이터 웨어하우스    데이터 마이닝(Data Mining)     데이터 웨어하우스에 저장된 데이터 집합에서 사용자의 요구에 따라 유용하고 가능성 있는 정보를 발견하기 위한 기법    기법 종류     연관, 연속, 분류, 클러스터링, 특성화, 패턴 분석, 경향 분석 등    OLAP(Online Analytical Processing)     다차원으로 이루어진 데이터로부터, 통계적인 요약 정보를 분석하여 의사결정에 활용하는 방식  데이터 웨어하우스, 데이터 마트 같은 시스템과 상호 연관되는 시스템  데이터 웨어하우스의 데이터를 전략적인 정보로 변환시키는 역할  중간 매개체 없이 이용자들이 직접 컴퓨터를 이용해 데이터에 접근하는데 있어서 필수적인 시스템    OLAP 연산     Roll-up: 더 요약된 정보보기  Drill-down: 더 구체적인 정보보기  Pivoting: 보고서의 행/열/페이지 차원을 바꾸어 보는 기능  Slicing: 다차원 데이터 항목들을 다양한 각도에서 조회하고 자유롭게 비교하는 기능  Dicing: Slicing을 더 세분화하는 기능    OLAP 종류     ROLAP(Relational-OLAP): 관계형 데이터베이스와 관계형 질의어를 사용하여 다차원 데이터를 저장하고 분석한다.  MOLAP(Multi-dimension OLAP)          다차원 데이터를 저장하기 위해 특수한 구조의 다차원 데이터베이스를 사용한다.      검색 속도를 위해 큐브 캐시(Cube Cache)라고 하는 주기억장치 속에 데이터 큐브를 저장한다.      데이터 큐브(Data Cube): 특정 목적의 OLAP에서 사용하기 위한 큐브형태의 다차원 논리적 구조        HOLAP(Hybrid OLAP)          ROLAP와 MOLAP의 특성을 모두 가지고 있다.      빠른 검색을 필요할 때는 요약을 메모리에 저장하고 다른 요약들은 관계형 데이터베이스에 저장한다.        OLTP(Online Transaction Processing)               온라인 업무 처리 형태의 하나로 네트워크 상에서 다수의 유저가 데이터베이스의 데이터를 갱신, 검색하는 등의 트랜잭션을 처리하는 방식이다.  OLTP 시스템은 일반적으로 빠른 응답 시간을 요구하며, 개개의 레코드를 효율적으로 조회하고 수정할 수 있도록 정규화 되어 있다.    OLTP와 OLAP 비교     |        구분        \t|                OLTP                \t|                OALP                \t||:——————:\t|:———————————-:\t|:———————————-:\t||    데이터의 구조   \t|    복잡(운영시스템 계산에 적합)    \t|       단순(사업 분석에 적합)       \t||    데이터의 갱신   \t|             순간적/동적            \t|             주기적/정적            \t||      응답 시간     \t|         2,3초 ~ 몇 초 이내         \t|            수 초 ~ 몇 분           \t||    데이터의 범위   \t|          과거 30일 ~ 90일          \t|           과거 5년 ~ 10년          \t||     데이터 성격    \t| 정규/핵심 업무 데이터, 변경 어려움 \t| 비정규/일기 전용 데이터, 변경 용이 \t||    데이터의 크기   \t|            수 Giga Byte            \t|            수 Tera Byte            \t||    데이터의 내용   \t|             상세 데이터            \t|    기록 보관된 요약/계산 데이터    \t||     데이터 특성    \t|      트랜잭션 중심, 중복 배제      \t|    주제(subject) 중심, 중복 허용   \t|| 데이터 액세스 빈도 \t|                높음                \t|           보통 혹은 낮음           \t||   데이터의 사용법  \t|      고도로 구조화된 연속 처리     \t|     고도로 비구조화된 분석 처리    \t||     쿼리의 성격    \t|          예언 가능, 주기적         \t|       예측하기 어려움, 특수함      \t|     ODBC(Open Database Connectivity)     프로그램과 데이터베이스의 종류에 관계업이 자유롭게 사용할 수 있도록 MS에서 만든 API  구조상 데이터베이스 바로 위에 ODBC가 위치한다.    구조     Application: ODBC API를 이용해 데이터베이스에 접근한다.  Driver Manager: 애플리케이션과 ODBC Driver 간의 통신을 관리하는 라이브러리  DSN(Domain Service Name): 서버에 연결할 때 필요한 드라이버와 데이터베이스 정보를 저장한다.  ODBC Driver: ODBC API가 지원하는 함수를 구현하는 라이브러리  데이터베이스: ODBC Driver에서 요청한 SQL에 대한 결과를 반환한다.","categories": ["Study"],
        "tags": ["Study_Database"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/Database-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC/",
        "teaser":null},{
        "title": "[Java]1. 클래스와 객체",
        "excerpt":"1. 클래스와 객체 정의와 용도   클래스의 정의: 클래스란 객체를 정의해 놓은 것이다.  클래스의 용도: 클래스는 객체를 생성하는데 사용된다.  객체의 정의: 실제로 존재하는것, 사물 또는 개념  객체의 용도: 객체가 가지고 있는 기능과 속성에 따라 다르다.          유형의 객체: 책상, 의자, 자동차, TV와 같은 사물      무형의 객체: 수학공식, 프로그램 에러와 같은 논리나 개념        객체를 사용한다. = 객체가 가지고 있는 속성과 기능을 사용한다.  프로그래밍적인 관점에서의 클래스          자료형의 종류와 상관없이 서로 관계가 깊은 변수와 함수들을 하나로 묶은 집합                  변수: 하나의 데이터를 저장할 수 있는 공간          배열: 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간          구조체: 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집으로 저장할 수 있는 공간          클래스: 데이터와 함수의 결합(구조체 + 함수)                    프로그래밍언어에서 제공하는 기본 자료형외에 프로그래머가 새로운 타입을 추가할 수 있는 사용자정의 타입(user-defined type)이다.      객체와 인스턴스   인스턴스화(Instantiate): 클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화라고 한다.  인스턴스(Instance): 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다.  인스턴스와 객체는 같은 의미이지만 문맥상으로 구분하여 사용하는 것이 좋다.          ‘책상은 객체다.’      ‘책상은 책상 클래스의 인스턴스다.’      객체의 구성요소 - 속성과 기능   클래스로부터 객체를 생성하면, 클래스에 정의된 속성과 기능을 가진 객체가 만들어진다.  속성(Property) = 멤버변수 (member variable), 특성(attribute), 필드(field), 상태(state)  기능(Function) = 메서드 (method), 함수(function), 행위(behavior)인스턴스의 생성과 사용   인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야한다.클래스명 변수명;참조 변수명 = new 클래스명();","categories": ["Language"],
        "tags": ["Language_Java"],
        "url": "https://codemcd.github.io/pages/CODEMCD/language/Java-1.-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EA%B0%9D%EC%B2%B4/",
        "teaser":null},{
        "title": "[Java]10. 오버라이딩(Overriding)",
        "excerpt":"10. 오버라이딩(Overriding) 정의   조상 래스로부터 상속받은 메서드의 내용을 변경하는 것을 오버라이딩이라고 한다.  예제예제 코드 class Point {\tint x;\tint y;\tString getLocation() {\t\treturn \"x: \" + x + \", y: \" + y;\t}}class Point3D extends Point {\tint z;\tString getLocation() {\t\treturn \"x: \" + x + \", y: \" + y + \", z: \" + z;\t}}조건   자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 매서드와          이름이 같아야 한다.      매개변수가 같아야 한다.      반환타입이 같아야 한다.                  JDK1.5부터 ‘공변 반환타입(covariant return type)’이 추가되어, 반환타입을 자손 클래스의 타입으로 변경 가능하게 완화되었다.                      조상 클래스의 메서드를 자손 클래스에서 오버라이딩할 때          접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.                  범위 순서(넓은 순): public &gt; protected &gt; (default) &gt; private                    예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.      인스턴스메서드를 static메서드로 또는 그 반대로 변경할 수 없다.      오버로딩 vs 오버라이딩   오버로딩(overloading): 기존에 없는 새로운 메서드를 정의하는 것  오버라이딩(overriding): 상속받은 메서드의 내용을 변경하는 것  예제예제 코드 class Parent {\tvoid parentMethod() { }}class Child extends Parent {\tvoid parentMethod() { }       //오버라이딩\tvoid parentMethod(int i) { }  //오버로딩\tvoid childMethod() { }\tvoid childMethod(int i) { }   //오버라이딩\tvoid childMethod() { }        //중복정의 에러('already defined in Child')}super 1. 정의   자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는 참조변수이다.2. 특징   super대신 this를 사용할 수 있으며, 조상 클래스 멤버와 자손 클래스 멤버가 중복 정의되어 서로 구별을 해야 하는 경우에만 super를 사용한다.          위의 기능을 제외하고는 super와 this는 근본적으로 같다.        static메서드에서는 사용할 수 없고, 오직 인스턴스메서드에서만 사용가능하다.  예제1: super멤버변수예제 코드 class SuperTest {\tpublic static void main(String args[]) {\t\tChild c = new Child();\t\tc.method();\t}}class Parent {\tint x = 10;}//super == this 경우class Child extents Parent {\tvoid method() {\t\tSystem.out.println(\"x = \" + x);\t\tSystem.out.println(\"this.x = \" + this.x);\t\tSystem.out.println(\"super.x = \" + super.x);\t}}//super != this 경우class Child extents Parent {\tint x = 20;\tvoid method() {\t\tSystem.out.println(\"x = \" + x);\t\tSystem.out.println(\"this.x = \" + this.x);\t\tSystem.out.println(\"super.x = \" + super.x);\t}}실행 결과 //super == thisx = 10this.x = 10super.x = 10//super != thisx = 20this.x = 20super.x = 10  예제2: super메서드예제 코드 class Point {\tint x;\tint y;\tString getLocation() {\t\treturn \"x: \" + x + \", y: \" + y;\t}}class Point3D extends Point {\tint z;\tString getLocation() {\t\t//return \"x: \" + x + \", y: \" + y + \", z: \" + z;\t\treturn super.getLocation() + \", z: \" + z;\t}}super() - 조상 클래스의 생성자   this()와 마찬가지로 super()도 생성자이다.  자손 클래스의 인스턴스를 생성하면, 자손의 멤버와 조상의 멤버가 모두 합쳐진 하나의 인스턴스가 생성된다.  자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수 있으므로 메서드 첫 줄에 super() 생성자를 선언해주어야 한다.          그렇지 않으면 컴파일러가 자동적으로 ‘super()’를 생성자의 첫 줄에 삽입한다.        예제예제 코드 class PointTest {\tpublic static void main(String args[]) {\t\tPoint3D p3 = new Point3D();\t\tSystem.out.println(\"p3.x = \" + p3.x);\t\tSystem.out.println(\"p3.y = \" + p3.y);\t\tSystem.out.println(\"p3.z = \" + p3.z);\t}}class Point {\tint x;\tint y;\tPoint(int x, int y) {\t\t//super()(=Object())를 컴파일러가 자동으로 추가한다.\t\tthis.x = x;\t\tthis.y = y;\t}\tString getLocation() {\t\treturn \"x: \" + x + \", y: \" + y;\t}}class Point3D extends Point {\tint z;\tPoint3D() {\t\tthis(100, 200, 300);    //Point3D(int x, int y, int z) 호출\t}\tPoint3D(int x, int y, int z) {\t\tsuper(x,y);    //Point(int x, int y) 호출\t\tthis.z = z;\t}}실행 결과 p3.x = 100p3.y = 200p3.z = 300  Point3D p3 = new Point3D(); 인스턴스 생성시, 생성자 호출 순서          Point3D()      Point3D(int x, int y, int z)      Point(int x, int y)      Object()      ","categories": ["Language"],
        "tags": ["Language_Java"],
        "url": "https://codemcd.github.io/pages/CODEMCD/language/Java-10.-%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%94%A9/",
        "teaser":null},{
        "title": "[Java]11. package와 import",
        "excerpt":"11. package와 import 패키지(package) 1. 정의   패키지란, 클래스의 묶음으로서, 서로 관련된 클래스 및 인터페이스들끼리 그룹 단위로 묶는것을 의미한다.  클래스의 실제 이름(full name)은 패키지명을 포함한 것이다.  클래스가 물리적으로 하나의 클래스 파일(.class)인 것과 같이 패키지는 물리적으로 하나의 디렉토리이다.2. 특징   같은 이름의 클래스 일지라도 서로 다른 패키지에 존재하는 것이 가능하다.          자신만의 패키지 체계를 유지할 수 있으며, 다른 개발자가 개발한 클래스 라이브러리의 클래스와 이름이 충돌하는 것을 피할 수 있다.        하나의 소스파일에는 첫 번째 문장으로 단 한 번의 패키지 선언만을 허용한다.  모든 클래스는 반드시 하나의 패키지에 속해야 한다.  패키지는 점(.)을 구분자로 하여 계층구조로 구성할 수 있다.          예를들어, String클래스의 실제 이름은 java.lang.String이다.        패키지는 물리적으로 클래스 파일(.class)을 포합하는 하나의 디렉토리이다.패키지 선언 1. 선언 방법 pachage 패키지명;2. 특징   패키지 선언문은 클래스나 인터페이스의 소스파일(.java)에서 반드시 주석과 공배을 제외한 첫 번째 문장에 선언해야 한다.  하나의 소스파일에 단 한번만 선언될 수 있다.  해당 소스파일에 포함된 모든 클래스나 인터페이스는 선언된 패키지에 속하게 된다.  패키지명은 대소문자를 모두 허용한다.          클래스명과 구분하기 위해 일반적으로 소문자로 하는 것을 원칙으로 한다.        모든 클래스는 반드시 하나의 패키지에 포함되어야 한다.          패키지를 선언하지 않는다면 ‘이름없는 패키지(unnamed package)’에 속하게 된다.      3. 새로운 패키지 생성 순서   패키지 예제예제 코드 package com.javachobo.book;class PackageTest {\tpublic static void main(String args[]) {\t\tSystem.out.println(\"Hello World!\");\t}}  컴파일: C:\\Program Files\\Java\\jdk1.8.0_171\\work&gt;javac -d . PackageTest.java          ‘-d’ 옵션                  소스파일에 지정된 경로를 통해 패키지의 위치를 찾아서 클래스 파일을 생성한다. (일치하는 디렉토리가 없다면 자동생성)          ‘-d’옵션 뒤에는 해당 패키지의 루트(root)디렉토리의 경로를 적어준다.          ‘-d’옵션을 사용하지 않으면, 프로그래머가 직접 계층구조를 만들어야 한다.                      해당 패키지의 루트 디렉토리를 클래스패스(classpath)에 포함시킨다.          클래스패스는 컴파일러(javac.exe)나 JVM 등이 클래스의 위치를 찾는데 사용되는 경로이다.      com.javachobo.book 패키지의 루트 디렉토리는 ‘com’의 상위 디렉토리인 ‘C:\\Program Files\\Java\\jdk1.8.0_171\\work’이다.      ‘제어판 - 시스템 - 고급 시스템 설정 - 환경변수 - 새로 만들기’를 하면 ‘새 시스템 변수’ 팝업창이 뜬다.                  변수 이름: CLASSPATH          변수 값: .;C:\\Program Files\\Java\\jdk1.8.0_171\\work;                    클래스패스를 지정해주지 않으면 기본적으로 현재 디렉토리(.)로 지정되지만, 클래스패스를 따로 지정해주는 경우에는 직접 추가해주어야 한다.      클래스패스 확인 명령어: C:...&gt;echo %classpath%        실행 결과C:/...&gt;java com.javachobo.book.PackageTestHello World!  위의 방법으로 클래스패스를 이용하면, 클래스패스를 따로 설정하지 않아도 된다.          새로 추가하고자 하는 클래스는 ‘JDK설치디렉토리\\jre\\classes’디렉토리에 추가한다.                  classes디렉토리는 사용자가 직접 생성해야한다.                    jar파일은 ‘JDK설치디렉토리\\jre\\lib\\ext’디렉토리에 추가한다.        ‘-cp’옵션을 이용해서 일시적으로 클래스패스르르 지정할 수도 있다. C:...&gt;java -cp C:\\Program Files\\Java\\jdk1.8.0_171\\work com.javachobo.book.PackageTestimport문 1. 정의   컴파일러에게 소스파일에 사용된 클래스의 패키지에 대한 정보를 제공한다.2. 특징   클래스를 사용하기 전, 클래스의 패키지를 import문으로 미리 명시해주면 소스코드에 사용되는 클래스이름에서 패키지명을 생략할 수 있다.  컴파일시, import문을 통해 소스파일에 사용된 클래스들의 패키지를 알아낸 다음, 모든 클래스 이름 앞에 패키지명을 붙여 준다.          import문은 프로그램의 성능에 전혀 영향을 미치지 않으며, 컴파일 시간이 아무 조금 더 걸릴 뿐이다.      3. 선언   import문은 모든 소스파일(.java)에서 package문 다음, 클래스 선언문 이전에 위치해야 한다.          일반적인 소스파일(.java) 구성: package문, import문, 클래스 선언 순        한 소스파일에서 여러 번 선언할 수 있다.  선언 방식import 패키지명.클래스명;import 패키지명.*;  .*를 사용할 때 주의할 점은 하위 패키지의 클래스까지 포함하는 것은 아니라는 것이다.import java.util.*;import java.text.*;//import java.*;로 대신할 수 없다!  import문을 선언하지 않아도 묵시적으로 import java.lang.*;가 선언되어 있기 때문에 String과 같은 클래스를 사용할 수 있다.4. static import문   static멤버를 호출할 때 클래스 이름을 생략할 수 있다.import static java.lang.Integer.*;     //Integer클래스의 모든 static 메서드import static java.lang.Math.random;   //Math.random()만 . 괄호 안붙임import static java.lang.System.out;    //System.out을 out만으로 참조가능  위와 같이 선언하였다면 System.out.println(Math.random());을 out.println(random());로 선언가능하다.","categories": ["Language"],
        "tags": ["Language_Java"],
        "url": "https://codemcd.github.io/pages/CODEMCD/language/Java-11.-package%EC%99%80-import/",
        "teaser":null},{
        "title": "[Java]12. 제어자(Modifier)",
        "excerpt":"12. 제어자(Modifier) 정의   클래스, 변수, 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다.종류   접근 제어자: public, protected, default, private  그 외: static, final, abstract, native, transient, synchronized, volatile, strictfp특징   하나의 대상에 대해서 여러 제어자를 조합하여 사용하는 것이 가능하지만, 접근 제어자는 하나만 사용할 수 있다.  제어자들간의 순서는 관계없지만 주로 접근 제어자를 제일 왼쪽에 선언한다.static - 클래스의, 공통적인   static은 ‘클래스의’, ‘공통적인’의 의미를 가지고 있다.  클래스변수(static멤버변수)는 모든 인스턴스가 하나의 변수를 공유하기 때문에 인스턴스와 관계없이 같은 값을 갖는다.  static은 멤버변수, 클래스, 초기화 블럭에 사용될 수 있으며, 인스턴스를 생성하지 않고도 사용할 수 있다.            제어자      대상      의미                  static      멤버변수      - 모든 인스턴스에 공통적으로 사용되는 클래스변수가 된다.&lt;/br&gt; - 클래스 변수는 인스턴스를 생성하지 않고도 사용 가능하다.&lt;/br&gt; - 클래스가 메모리에 로드될 때 생성된다.              static      메서드      - 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다.&lt;/br&gt; - static 메서드 내에서는 인스턴스 멤버들을 직접 사용할 수 없다.              static      초기화 블럭      - 클래스가 메모리에 로드될 때 단 한번만 수행된다.&lt;/br&gt; - 주로 클래스변수를 초기화 하는데 사용된다.      final - 마지막의, 변경될 수 없는   final은 ‘마지막의’, ‘변경될 수 없는’의 의미를 가진다.  클래스, 메서드, 멤버변수, 지역변수에 사용가능하다.            제어자      대상      의미                  final      클래스      변경될 수 없는 클래스, 확장될 수 없는 클래스가 되며, final 클래스는 다른 클래스의 조상이 될 수 없다.              final      메서드      변경될 수 없는 메섣, final 메서드는 오버라이딩을 통해 재정의 될 수 없다.              final      멤버변수      변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다.              final      지역변수      변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다.        일반적으로 final이 붙은 변수는 선언과 동시에 초기화를 하지만, 인스턴스 변수의 경우에는 생성자에서 초기화가 가능하다.          각 인스턴스마다 final이 붙은 멤버변수가 각각 다른 값을 갖도록 하는 것이 가능하다.      abstract - 추상의, 미완성의   abstract는 ‘미완성’의 의미를 가진다.  클래스, 메서드에 사용가능하다.            제어자      대상      의미                  abstract      클래스      클래스 내에 추상 메서드가 선언되어 있음을 의미한다.(추상 클래스)              abstraact      메서드      선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알린다.      abstract class AbstractTest {     // 추상 클래스(추상 메서드를 포함한 클래스)\tabstract void move();     // 추상 메서드(구현부가 없는 메서드)}  추상 클래스는 미완성이므로, 인스턴스를 생성할 수 없다.  완성된 클래스도 abstract를 선언하여 추상 클래스로 만드는 경우가 있다.          메서드들에 아무 내용이 없어 인스턴스 자체를 생성하지 못하게 하기 위함이다.      이 경우, 주로 원하는 메서드만 오버라이딩을 해서 쓰기 위해 사용된다.      접근 제어자(access modifier) 1. 정의와 특징   접근 제어자는 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.  클래스, 멤버변수, 메서드, 생성자에 사용된다.  O: 접근 가능, X: 접근 불가능            제어자      같은 클래스      같은 패키지      자손 클래스      전 체                  public      O      O      O      O              protected      O      O      O      X              (default)      O      O      X      X              private      O      X      X      X        default는 접근 제어자를 선언하지 않으면 자동으로 지정된다.  protected는 패키지에 관계없이 상속관계에 있는 자손클래스와 같은 패키지내에 있는 모든 클래스에서 접근 가능하다.            대 상      사용가능한 접근 제어자                  클래스      public, (default)              메서드      public, protected, (default), private              멤버변수      public, protected, (default), private              지역변수      없 음      2. 접근 제어자를 이용한 캡슐화   접근 제어자를 사용하는 이유 = 캡슐화(encapsulation)를 하는 이유          외부로부터 데이터를 보호하기 위해(data hiding)                  데이터가 유효한 값을 유지하며, 외부로부터 함부로 변경하는 것을 막는다.                    외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서                  복잡성을 줄이고, 접근 범위를 최소화한다.          에러 테스트 상황에서 public은 모든 범위, default는 패키지 내부, private는 클래스 내부만 확인하면 된다.                      올바른 사용 예제          상속을 통해 확장될 것이 예상된다면, 멤버 변수 접근 제어자를 protected로 하며, 그렇지 않다면 private로 한다.      멤버변수의 값을 읽는 메서드의 이름은 ‘get멤버변수이름’ 값을 변경하는 메서드의 이름은 ‘set멤버변수이름’을 주로 사용한다.      예제 코드 public class Time {\t// 접근 제어자를 private로 하여 외부에서 직접 접근하지 못하도록 한다.\tprivate int hour;\tprivate int minute;\tprivate int second;\t//getter\tpublic int getHour() { return hour; }\tpublic int getMinute() { return minute; }\tpublic int getSecond() { return second; }\t//setter\tpublic void setHour(int hour) {\t\tif (hour &lt; 0 || hour &gt; 23) return;\t\tthis.hour = hour;\t}\tpublic void setMinute(int minute) {\t\tif (minute &lt; 0 || minute &gt; 59) return;\t\tthis.minute = minute;\t}\tpublic void setSecond(int second) {\t\tif (second &lt; 0 || second &gt; 23) return;\t\tthis.second = second;\t}}  하나의 소스파일(.java)에는 public클래스가 단 하나만 존재할 수 있으며, 소스파일 이름은 반드시 public클래스의 이름과 같아야 한다.3. 생성자의 접근 제어자   생성자에 접근 제어자를 사용하여 인스턴스의 생성을 제한할 수 있다.  사용 예제          생성자의 접근 제어자를 private(또는 protected)로 지정하여, 클래스 내부에서 인스턴스를 생성한다. (인스턴스 개수 제한)      인스턴스를 생성해서 반환해주는 메서드의 접근 제어자는 public으로 해야하며, 동시에 static이어야 한다.                  인스턴스를 생성하지 않고도 호출할 수 있어야 하기 때문에 static을 사용한다.                    예제 코드 class Singleton {\t// getInstance()에서 사용될 수 있도록 인스턴스가 미리 생성되어야 하므로 static을 사용한다.\tprivate static Singleton s = new Singleton();\tprivate Singleton() {\t\t...\t}\t// 인스턴스를 생성하지 않고도 호출할 수 있어야 하기 때문에 static을 사용한다.\tpublic static Singleton getInstance() {\t\treturn s;\t}\t...}제어자의 조합             대 상      사용가능한 제어자                  클래스      public, (default), final, abstract              메서드      public, protected, (default), private, final, abstract, static              멤버변수      public, protected, (default), private, final, static              지역변수      final        제어자 조합시 주의사항          메서드에 static과 abstract를 동시에 사용할 수 없다.                  static메서드는 몸통이 있는 메서드에만 사용할 수 있기 때문이다.                    클래스에 abstract와 final을 동시에 사용할 수 없다.                  final 클래스는 확장할 수 없다는 의미이고, abstract는 상속을 통해서 완성되어야 하는 의미이므로 서로 모순된다.                    abstract 메서드의 접근 제어자가 private일 수 없다.                  abstract 메서드는 자손클래스에서 구현해주어야 하는데 접근 제어자가 private이면, 자손클래스에서 접근할 수 없다.                    메서드에 private와 final을 같이 사용할 수 없다.                  접근 제어자가 private인 메서드는 오버라이딩될 수 없기 때문에, 이 둘 중 하나만 사용하면 된다.                    ","categories": ["Language"],
        "tags": ["Language_Java"],
        "url": "https://codemcd.github.io/pages/CODEMCD/language/Java-12.-%EC%A0%9C%EC%96%B4%EC%9E%90/",
        "teaser":null},{
        "title": "[Java]13. 다형성(Polymorphism)",
        "excerpt":"13. 다형성(Polymorphism) 다형성의 정의   객체지향개념에서 다형성이란 ‘여러 가지 형태를 가질 수 있는 능력’이다.          자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 하여 다형성을 구현하였다.        조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있다.          참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 항상 같거나 적어야 한다.      위의 이유 때문에, 자손타입의 참조변수로 조상타입의 인스턴스는 참조할 수 없다.        예제예제 코드 class Tv {\tboolean power;\tint channel;\tvoid power() { power != power; }\tvoid channelUp() { ++channel; }\tvoid channelDown() { --channel; }}class CaptionTv extends Tv {\tString text;\tvoid caption() { ... }}  위의 코드를 바탕으로, 다형성에 의해 아래와 같은 초기화가 가능하다.CaptionTv c = new CaptionTv();Tv t = new CaptionTv();  하지만, Tv타입의 참조변수로 CaptionTv인스턴스를 생성한 변수 t는 Tv클래스에 정의되지 않은 멤버인 text와 caption()은 사용할 수 없다.          같은 타입의 인스턴스라도 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라진다.      참조변수의 형변환   참조변수는 서로 상속관계 에 있는 클래스 사이에서만 서로 형변환이 가능하다.          조상의 조상으로도 형변환이 가능하기 때문에, 상속관계에만 있다면 서로 형변환이 가능하다.      클래스 A, B, C가 있을 때, A &lt;- C, A &lt;- B의 상속관계가 있다고 가정하자. 이 때, B, C는 서로 형변환이 불가능하다.(B,C는 서로 아무 관계가 없음)        기본형 변수 형변환과 유사하다.          작은 자료형에서 큰 자료형의 형변환이 생략이 가능하듯이, 자손타입의 참조변수를 조상타입의 참조변수로 형변환활 경우에는 생략이 가능하다.      참조변수의 형변환에도 캐스트연산자 ‘()’를 사용한다.        자손타입 -&gt; 조상타입 (Up-casting): 형변환 생략가능  자손타입 &lt;- 조상타입 (Down-casting): 형변환 생략불가  참조변수의 형변환은 인스턴스에 아무런 영향을 미치지 않는다.  참조변수의 형변환을 통해서 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위(개수)를 조절할 수 있다.  주의할 예제예제 코드 class CastingTest {\tpublic static void main(String args[]) {\t\tCar car = new Car();\t\tCar Car2 = null;\t\tFireEngine fe = null;\t\tcar.drive();\t\tfe = (FireEngine)car;  // 8번째 줄, 컴파일은 가능하지만 실행 시 에러가 발생한다.\t\tfe.drive();\t\tcar2 = fe;\t\tcar2.drive();\t}}실행 결과 drive, ...java.lang.ClassCastException: Car at CastingTest.main(CastingTest.java:8)  컴파일 시에는 참조변수간의 타입만 체크하고 인스턴스의 타입에 대해서는 알지 못하므로, 컴파일 시에는 에러가 발생하지 않는다.  참조변수가 참조하고 있는 인스턴스의 자손타입으로 형변환하는 것은 허용되지 않는다.          Car car = new Car(); -&gt; Car car = new FireEngine();으로 변경하면 실행 가능하다.      instanceof 연산자   instanceof 연산자는 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용한다.  형태는 참조변수 incstanceof 타입(클래스명)이며, 반환값은 true, false이다.          true: 참조변수가 검사한 타입으로 형변환이 가능하다는 의미이다.      값이 null인 참조변수는 항상 false를 반환한다.      참조변수와 인스턴스의 연결   조상타입의 참조변수로 자손 인스턴스를 참조하는 경우와 자손타입의 참조변수로 자손 인스턴스를 참조하는 경우는 다른 결과를 얻는다.          메서드의 경우는 참조변수의 타입에 관계없이 오버라이딩에 따라 다르게 호출된다. (인스턴스 메서드)                  static 메서드는 참조변수의 타입에 영향을 받기 때문에, 반드시 ‘클래스이름.메서드()’로 호출해야한다.                    멤버변수의 경우 참조변수의 타입에 따라 달라진다.                  멤버변수가 조상과 자손클래스에 중복 정의된 경우, 조상타입의 참조변수를 사용했을 때는 조상 클래스에 선언된 멤버변수가 사용되고, 자손타입의 참조변수를 사용했을 때는 자손 클래스에 선언된 멤버변수가 사용된다.                    매개변수의 다형성   메서드의 매개변수에도 다형성은 적용된다.  예제예제 코드 class Product {\tint price;        // 제품 가격\tint bonusPoint;   // 제품구매시 제공하는 보너스 점수}class Tv extends Product {}class Computer extends Product {}class Audio extends Product {}class Buyer {                 // 고객\tint money = 1000;     // 소유금액\tint bonusPoint = 0;   // 보너스 점수}  물건을 구입하는 메서드          다형성 적용하기 전      void buy(Tv t) { ... }void buy(Computer c) { ... }void buy(Audio a) { ... }  다형성 적용void buy(Product p) { ... }여러 종류의 객체를 배열로 다루기   참조변수를 배열로 처리할 수 있다.  예제          배열 사용하기 전      Product p1 = new Tv();Product p2 = new Computer();Product p3 = new Audio();  배열Product p[] = new Product[3];p[0] = new Tv();p[1] = new Computer();p[2] = new Audio();  동적 크기 배열인 Vector 클래스 역시 사용가능하다.  Vector 클래스의 주요 메서드            메서드 / 생성자      설 명                  Vector()      10개의 객체를 저장할 수 있는 Vector인스턴스를 생성한다. 10개이상의 인스턴스가 저장되면, 자동적으로 크기가 증가한다.              boolean add(Object o)      Vector에 객체를 추가한다. 추가에 성공하면 true, 실패하면 false를 반환한다.              boolean remove(Object o)      Vector에 저장되어 있는 객체를 제거한다. 제거에 성공하면 true, 실패하면 false를 반환한다.              boolean isEmpty()      Vector가 비어있는지 검사한다. 비어있으면 true, 비어있지 않으면 false를 반환한다.              Object get(int index)      지정된 위치(index)의 객체를 반환한다. 반환타입이 Object타입이므로 적절한 타입으로의 형변환이 필요하다.              int size()      Vector에 저장된 객체의 개수를 반환한다.      ","categories": ["Language"],
        "tags": ["Language_Java"],
        "url": "https://codemcd.github.io/pages/CODEMCD/language/Java-13.-%EB%8B%A4%ED%98%95%EC%84%B1/",
        "teaser":null},{
        "title": "[Java]2. 추상클래스(abstract class)",
        "excerpt":"2. 추상클래스(abstract class) 정의와 특징   추상클래스는 미완성 메서드(추상메서드)를 포함하고 있는 클래스이다.  추상클래스로는 인스턴스를 생성할 수 없으며, 오직 상속을 통해서 자손클래스에 의해서만 완성될 수 있다.  새로운 클래스를 작성하는데 있어 바탕이 되는 조상클래스로서의 중요한 의미를 갖는다.          새로운 클래스에서 아무것도 없는 상태에서 시작하는 것보다 어느 정도 틀을 갖춘상태에서 시작하는 것이 더 효율적이다.        추상클래스는 추상메서드를 포함하고 있다는 것을 제외하고는 일반 클래스와 같다.          생성자, 멤버변수, 메서드 모두 가질 수 있다.        추상클래스는 클래스 앞에 키워드 ‘abstract’를 붙이기만 하면 된다.abstract class 클래스이름 {  ...}  추상메서드가 없더라고 ‘abstract’를 붙여 추상클래스로 지정할 수도 있다.추상메서드(abstract method)   추상메서드는 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 것이다.  추상메서드를 사용하는 이유는 메서드의 내용이 상속받는 클래스에 따라 달라질 수 있기 때문이다.          추상클래스를 상속받는 자손클래스는 오버라이딩을 통해 조상의 추상메서드를 상황에 맞게 적절히 구현해주어야 한다.      만약 자손클래스에서도 추상메서드를 구현하지 않는다면 자손클래스에서 역시 추상메서드로 지정해야 한다.        추상메서드 형태/* 주석을 통해 어떤 기능을 수행할 목적으로 작성하였는지 설명한다. */abstract 리턴타입 메서드이름 ();추상클래스 작성   추상: 낱낱의 구체적 표상이나 개념에서 공통된 성질을 뽑아 이를 일반적인 개념으로 파악하는 정신 작용  상속은 조상클래스를 사용하여 자손클래스를 만드는 것이지만, 추상화는 반대로 자손클래스를 이용해 공통부분을 뽑아내서 조상클래스를 만드는 것이다.  추상화: 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업  구체화: 상속을 통해 클래스를 구현 및 확장하는 작업  추상메서드는 일반메서드에서 내용없는 빈 몸통만 만들어 놓은 것과 같지만, 굳이 사용하는 이유는 자손클래스에서 오버라이딩을 강제하기 위해서이다.  예제일반 클래스 코드 class Marine {    // 보병  int x, y;       // 현재 위치  void move(int x, int y) { /* 지정된 위치로 이동 */ }  void stop()             { /* 현재 위치에 정지 */ }  void stimPack()         { /* 스팀팩을 사용한다. */ }}class Tank {      // 탱크  int x, y;       // 현재 위치  void move(int x, int y) { /* 지정된 위치로 이동 */ }  void stop()             { /* 현재 위치에 정지 */ }  void changeMode()       { /* 공격모드를 변환한다. */ }}class Dropship {  // 수송선  int x, y;       // 현재 위치  void move(int x, int y) { /* 지정된 위치로 이동 */ }  void stop()             { /* 현재 위치에 정지 */ }  void load()             { /* 선택된 대상을 태운다. */ }  void unload()           { /* 선택된 대상을 내린다. */ }}추상 클래스 코드 abstract class Unit {  int x, y;  /* 각 유닛마다 고유의 이동방식을 구현한다. */  abstract void move(int x, int y);  void stop() { /* 현재 위치에 정지 */ }}class Marine extends Unit {  void move(int x, int y) { /* 지정된 위치로 이동 */ }  void stimPack()         { /* 스팀팩을 사용한다. */ }}class Tank extends Unit {  void move(int x, int y) { /* 지정된 위치로 이동 */ }  void changeMode()       { /* 공격모드를 변환한다. */ }}class Dropship extends Unit {  void move(int x, int y) { /* 지정된 위치로 이동 */ }  void load()             { /* 선택된 대상을 태운다. */ }  void unload()           { /* 선택된 대상을 내린다. */ }}","categories": ["Language"],
        "tags": ["Language_Java"],
        "url": "https://codemcd.github.io/pages/CODEMCD/language/Java-2.-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4/",
        "teaser":null},{
        "title": "[Java]3. 인터페이스(interface)",
        "excerpt":"3. 인터페이스(interface) 정의 및 특징   인터페이스는 일종의 추상 클래스이다.  추상클래스보다 추상화 정도가 높다.          일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다.      추상메서드와 상수만을 멤버로 가질 수 있다.      인터페이스 작성   인터페이스를 작성하는 것은 클래스를 작성하는 것과 같다          키워드 ‘class’ 대신 ‘interface’를 사용해야 한다.      접근제어자를 사용할 수 있다.      interface 인터페이스이름 {  public static final 타입 상수이름 = 값;  public abstract 메서드이름(매개변수목록);}  인터페이스 멤버들의 제약사항          모든 멤버변수는 public static final 이어야 하며, 이를 생략할 수 있다.      모든 메서드는 public abstract 이어야 하며, 이를 생략할 수 있다.      JDK1.8부터 static메서드와 디폴트 메서드를 사용할 수 있다.        인터페이스에 정의된 모든 멤버에게 적용되기 때문에 생략될 수 있으며, 컴파일 시에 자동으로 추가해준다.인터페이스 상속   인터페이스는 인터페이스로부터만 상속이 가능하다.  클래스와 달리 다중상속이 가능하다.  인터페이스는 Object클래스와 같은 최고 조상이 없다.  예제예제 코드 interface Movable {  /** 지정된 위치 (x,y)로 이동하는 기능의 메서드 */  void move(int x, int y);}interfave Attackable {  /** 지정된 대상 (u)를 공격하는 기능의 메서드 */  void attack(Unit u);}interface Fightable extends Movable, Attackable { }인터페이스 구현   인터페이스도 추상클래스와 같이 그 자체로는 인스턴스를 생성하지 못한다.          인터페이스 자신을 상속받는 클래스를 선언하여 메서드의 몸통을 오버라이딩을 통해 만들어주어야한다.        인터페이스를 상속할 때는 키워드 ‘extends’(확장하다) 대신 ‘implements’(구현하다)를 사용해야 한다.class 클래스이름 implements 인터페이스이름 {  // 인터페이스에 정의된 추상메서드를 구현해야 한다.}class Fighter implements Fightable {  public void move(int x, int y) { ... }  public void attack(Unit u) { ... }}  만일 구현하는 인터페이스의 메서드 중 일부만 구현한다면, ‘abstract’를 붙여 추상클래스로 선언해야 한다.abstract class Fighter implements Fightable {  public void move(int x, int y) { ... }}  상속과 구현을 동시에 할 수 있다.class Fighter extends Unit implements Fightable {  ...}  인터페이스의 이름에는 주로 ‘~able’(할 수 있는) 이라는 키워드를 붙인다.          반드시 붙는 것은 아니기 때문에 위의 키워드가 붙었다면 인터페이스라고 추측만 할 수 있다.        예제예제 코드 class FighterTest {\tpublic static void main(String[] args) {\t\tFighter f = new Fighter();\t\tif(f instanceof Unit) {\t\t\tSystem.out.println(\"f는 Unit클래스의 자손입니다.\");\t\t}\t\tif(f instanceof Fightable) {\t\t\tSystem.out.println(\"f는 Fightable인터페이스를 구현했습니다.\");\t\t}\t\tif(f instanceof Movable) {\t\t\tSystem.out.println(\"f는 Movable인터페이스를 구현했습니다.\");\t\t}\t\tif(f instanceof Attackable) {\t\t\tSystem.out.println(\"f는 Attackable인터페이스를 구현했습니다.\");\t\t}\t\tif(f instanceof Object) {\t\t\tSystem.out.println(\"f는 Object클래스의 자손입니다.\");\t\t}\t}}class Fighter extends Unit implements Fightable {\tpublic void move(int x, int y) { /*내용 생략*/ }\tpublic void attack(Unit u) { /*내용 생략*/ }}class Unit {\tint currentHP;  //유닛의 체력\tint x;          //유닛의 x좌표\tint y;          //유닛의 y좌표}interface Fightable extends Movable, Attackable { }interface Movable { void move(int x, int y); }interface Attackable { void attack(Unit u); }결과 f는 Unit클래스의 자손입니다.f는 Fightable인터페이스를 구현했습니다.f는 Movable인터페이스를 구현했습니다.f는 Attackable인터페이스를 구현했습니다.f는 Object클래스의 자손입니다.  클래스와 인터페이스간의 관계도   Moavable인터페이스에서 move메서드의 접근 제어자는 ‘public abstract’가 생략되었다.          Fighter클래스에서 move메서드의 접근 제어자가 public인 이유이다.      인터페이스를 이용한 다중상속   자바에서는 일반적으로 다중상속의 단점이 더 크다고 판단되어 허용하지 않는다.  C++에서는 다중상속이 가능하므로 자바에서는 인터페이스를 이용하여 다중상속이 가능하도록 만들었다.          하지만 인터페이스가 다중상속을 위한 것이 아니고 여전히 단점이 크므로 다중상속으로 구현하는 경우는 거의 없다.      인터페이스를 이용한 다형성   인터페이스 역시 클래스와 같이 다형성을 제공한다.          인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있다.      인터페이스 타입으로 형변환이 가능하다.                  인터페이스의 타입을 매개변수 타입으로 사용할 수 있다.          메서드의 리턴타입으로 인터페이스의 타입을 지정할 수 있다.                          리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인터페이스를 반환한다는 것을 의미한다.                                            예제예제 코드 interface Parseable {\t//구문 분석작업을 수행한다.\tpublic abstract void parse(String fileName);}class ParserManager {\t//리턴타입이 Parseable인터페이스이다.\tpublic static Parseable getParser(String type) {\t\tif(type.equals(\"XML\")) {\t\t\t/*\t\t\tParseable p = new XMLParser();\t\t\treturn p;\t\t\t*/\t\t\treturn new XMLParser();\t\t}\t\telse {\t\t\t/*\t\t\tParseable p = new HTMLParser();\t\t\treturn p;\t\t\t*/\t\t\treturn new HTMLParser();\t\t}\t}}class XMLParser implements Parseable {\tpublic void parse(String fileName) {\t\t/* 구문 분석작업을 수행하는 코드를 적는다. */\t\tSystem.out.println(fileName + \" - XML parsing completed.\");\t}}class HTMLParser implements Parseable {\tpublic void parse(String fileName) {\t\t/* 구문 분석작업을 수행하는 코드를 적는다. */\t\tSystem.out.println(fileName + \" - HTML parsing completed.\");\t}}class ParserTest {\tpublic static void main(String args[]) {\t\tParseable parser = ParserManager.getParser(\"XML\");\t\tparser.parse(\"document.xml\");\t\tparser = ParserManager.getParser(\"HTML\");\t\tparser.parse(\"document2.html\");\t}}출력 결과 document.xml - XML parsing completed.document2.html - HTMLparsing completed.  밑의 예제코드를 통해 분산환경 프로그래밍에서 큰 장점을 가진다.          사용자 컴퓨터에 설치된 프로그램을 변경하지 않고 서버측의 변경만으로도 사용자가 새로 개정된 프로그램을 사용할 수 있다.      예를들어, ParserManager클래스의 getParser메서드에서 ‘return new XMLParser(); 대신 ‘return new NEWXMLParser();’로 변경하기만 하면 된다.      인터페이스의 장점   개발시간을 단축시킬 수 있다.          인터페이스가 작성되면, 이를 사용해서 프로그램을 작성하는 것이 가능하다. 메서드를 호출하는 쪽에서는 메서드의 내용에 관계없이 선언부만 알면되기 때문이다.      동시에 다른 한 쪽에서는 인터페이스를 구현하는 클래스를 작성하도록 하여, 인터페이스를 구현하는 클래스가 작성할 때까지 기다리지 않고 양쪽에서 동시에 개발이 가능하다.        표준화가 가능하다.          프로젝트에 사용되는 기본 틀을 인터페이스로 작성한 다음, 개발자들에게 인터페이스를 구현하여 프로그램을 작성하도록 함으로써 보다 일관되고 정형화된 프로그램 개발이 가능하다.        서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.          서로 상속관계에 있지 않고, 같은 조상클래스를 가지고 있지 않은 서로 아무런 관계가 없느느 클래스들에게 하나의 인터페이스를 공통으로 구현하도록 하여 관계를 맺어 줄 수 있다.        독립적인 프로그래밍이 가능하다.          인터페이스를 이용하면 클래스의 선언과 구현을 분리시킬 수 있어 독립적인 프로그램을 작성할 수 있다.      클래스간의 직접적인 관계를 인터페이스를 이용해서 간접적인 관계로 변경하면, 한 클래스의 변경이 관련된 다른 클래스에 영향을 미치지 않는다.      인터페이스의 의해   클래스를 사용하는 쪽(User)과 클래스를 제공하는 쪽(Provider)이 있다.  메서드를 사용(호출)하는 쪽(User)에서는 사용하려는 메서드(Provider)의 선언부만 알면 된다.  예제예제 코드 class A {\tpublic void methodA(B b) {\t\tb.methodB();\t}}class B {\tpublic void methodB() {\t\tSystem.out.println(\"methodB()\");\t}}class InterfaceTest {\tpublic static void main(Sting args[]) {\t\tA a = new A();\t\ta.methodA(new B());\t}}출력 결과 methodB()  위 예제 코드의 클래스간의 관계는 A(User) -&gt; B(Provider)와 같이 서로 직접적인 관계에 있다.          이 경우, 클래스 A를 작성하기 위해서는 클래스 B가 이미 작성되어 있어야 한다.      클래스 B의 methodB()의 선언부가 변경되면, 이를 사용하는 클래스 A도 변경되어야 한다.        위의 단점을 개선하기 위해 2가지를 생각해보자.          Provider 클래스는 인터페이스를 활용하여 구현한다.                  클래스 A를 작성하는데 클래스 B가 관련되지 않는다.                    클래스 A가 매개변수를 통해서 인터페이스를 구현한 클래스의 인스턴스를 동적으로 생성하는 것보다 제 3의 클래스를 활용한다.                  나중에 다른 클래스의 인스턴스로 변경되어도 클래스 A는 변경할 필요가 없다.                    예제 코드 class InterfaceTest {\tpublic static void main(String args[]) {\t\tA a = new A();\t\ta.methodA();\t}}class A {\tvoid methodA() {\t\t//제 3의 클래스의 메서드를 통해서 인터페이스 I를 구현한 클래스의 인스턴스를 얻어온다.\t\tI i = InstanceManager.getInstance();\t\ti.methodB();\t\t//인터페이스 I 타입의 참조변수 i로도 Object클래스에 정의된 메서드들을 호출 가능하다.\t\tSystem.out.println(i.toString());\t}}interface I {\tpublic abstract void mathodB();}class B implements I {\tpublic void methodB() {\t\tSystem.out.println(\"methodB int B class\");\t}\tpublic String toString() { return \"class B\"; }}class InstanceManager {\tpublic static I getInstance() {\t\treturn new B();\t}}출력 결과 methodB in B classclass B디폴트 메서드와 static 메서드   JDK1.8부터 인터페이스에 디폴트 메서드와 static 메서드도 추가할 수 있게 되었다.  디폴트 메서드: 추상 메서드의 기본적인 구현을 제공하는 메서드          추상 메서드가 아니기 때문에, 새로 추가되어도 해당 인터페이스를 구현한 클래스를 변경하지 않아도 된다.      메서드 앞에 키워드 ‘default’를 붙이며, 일반 메서드처럼 몸통 {}이 있어야 한다.      접근 제어자는 ‘public’이며, 생략할 수 있다.        새로 추가된 디폴트 메서드는 기존의 메서드와 이름이 중복되어 충돌하는 경우가 생긴다.          여러 인터페이스의 디폴트 메서드 간의 충돌                  인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩해야 한다.                    디폴트 메서드와 조상 클래스의 메서드 간의 충돌                  조상 클래스의 메서드가 상속되고, 디폴트 메서드는 무시된다.                    ","categories": ["Language"],
        "tags": ["Language_Java"],
        "url": "https://codemcd.github.io/pages/CODEMCD/language/Java-3.-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/",
        "teaser":null},{
        "title": "[Java]4. 내부 클래스(inner class)",
        "excerpt":"4. 내부 클래스(inner class) 내부 클래스란?   내부클래스: 클래스 내에 선언된 클래스  장점          내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.      코드의 복잡성을 줄일 수 있다.(캡슐화)        주로 AWT나 Swing과 같은 GUI어플리케이션의 이벤트처리 이외에는 잘 사용하지 않는다.class A { //외부 클래스  //...  class B { //내부 클래스    //...  }  //...}내부 클래스의 종류와 특징             내부 클래스      특 징                  인스턴스 클래스 (instance class)      - 외부 클래스의 멤버변수 선언위치에 선언한다. &lt;/br&gt;- 외부 클래스의 인스턴스멤버처럼 다루어진다.&lt;/br&gt; - 주로 외부 클래스의 인스턴스멤버들과 관련된 작업에 사용된다.              스태틱 클래스 (static class)      - 외부 클래스의 멤버변수 선언 위치에 선언한다.&lt;/br&gt; - 외부 클래스의 static 멤버처럼 다루어진다.&lt;/br&gt; - 주로 외부 클래스의 static멤버, static메서드에서 사용된다.              지역 클래스 (local class)      - 외부 클래스의 메서드나 초기화 블럭 안에 선언한다.&lt;/br&gt; - 선언된 영역 내부에서만 사용가능하다.              익명 클래스 (anonymous class)      클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스(일회용)      내부 클래스 선언   내부 클래스는 변수와 마찬가지로 선언된 위치에 따라 유효범위(scope)와 접근성(accessibility)을 갖는다.class Outer {  class InstanceInner { }  static class StaticInner { }  void Mymethod() {    class LocalInner { }  }}익명 클래스(anonymous class)   익명 클래스는 다른 내부 클래스들과는 달리 이름이 없다.  클래스의 선언과 객체의 생성을 동시에 하기 때문에 단 한번만 사용될 수 있고, 오직 하나의 객체만을 생성할 수 있다.  이름이 없기 때문에 생성자를 가질 수 없다.  오로지 단 하나의 클래스를 상속받거나 단 하나의 인터페이스만을 구현할 수 있다.new 조상클래스이름() {  //멤버 선언}new 구현인터페이스이름() {  //멤버 선언}예제 코드 class anonymousTest {  Object iv = new Object() { void method() {} };          //익명클래스  static Object cv = new Object() { void method() {} };   //익명클래스  void myMethod() {    Object lv = new Object() { void method() {} };        //익명클래스  }}  위의 예제를 컴파일 하면 다음과 같은 4개의 클래스파일을 생성한다.          ‘외부 클래스명$숫자.class’      anonymousTest.classanonymousTest$1.classanonymousTest$2.classanonymousTest$3.class","categories": ["Language"],
        "tags": ["Language_Java"],
        "url": "https://codemcd.github.io/pages/CODEMCD/language/Java-4.-%EB%82%B4%EB%B6%80%ED%81%B4%EB%9E%98%EC%8A%A4/",
        "teaser":null},{
        "title": "[Java]5. 변수와 메서드",
        "excerpt":"5. 변수와 메서드 선언위치에 따른 변수의 종류   인스턴스 변수(instance variable)          클래스 영역에 선언되며, 클래스의 인스턴스를 생성할 때 만들어진다.      인스턴스 변수를 사용하기 위해서는 먼저 인스턴스를 생성해야한다.      독립적인 저장공간을 가지기 때문에 각각의 인스턴스마다 서로 다른 값을 가질 수 있다.      인스턴스마다 고유한 상태를 유지해야하는 속성의 경우, 인스턴스 변수를 사용해야한다.        클래스 변수(class variable)          클래스 변수는 인스턴스 변수 앞에 static을 붙인 형태이다.      모든 인스턴스가 공통된 저장공간(변수)으르 공유한다.      한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야하는 속성의 경우, 클래스 변수를 사용해야한다.      인스턴스 변수와 달리 인스턴스를 생성하지 않고도 언제든지 사용가능하다.      사용 형식은 ‘클래스이름.클래스변수’를 사용하는 것을 권장하며, 이는 인스턴스 변수 사용과 구분하기 위함이다.        지역 변수(local variable)          메서드 내에 선언되어 메서드 내에서만 사용가능하며, 메서드가 종료되면 소멸된다.      for문, while문의 {}블럭내에 선언된 변수도 지역 변수이다.      생성자와 초기화 블럭은 내부적으로 메서드로 취급한다.                  변수의 종류      선언위치      생성시기                  클래스변수      클래스 영역      클래스가 메모리에 올라갈 때              인스턴스변수      클래스 영역      인스턴스가 생성되었을 때              지역변수      클래스 영역 이외의 영역 (메서드, 생성자, 초기화 블럭 내부)      변수 선언문이 수행되었을 때        인스턴스 변수와 클래스 변수 사용 예제&lt;/br&gt;예제 코드 class CardTest {\tpublic static void main(String args[]) {\t\tSystem.out.println(\"Card.width = \" + Card.width);\t\tSystem.out.println(\"Card.height +\" + Card.height);\t\tCard c1 = new Card();  //인스턴스 생성\t\tc1.kind = \"Heart\";     //인스턴스 변수 값 설정\t\tc1.number = 7;         //인스턴스 변수 값 설정   \t\tCard c2 = new Card();  //인스턴스 생성\t\tc2.kind = \"Spade\";     //인스턴스 변수 값 설정\t\tc2.number = 4;         //인스턴스 변수 값 설정\t\tSystem.out.println(\"c1은 \" + c1.kind + \", \" + c1.number + \"이며, 크기는 (\" + c1.width + \", \" + c1.height + \")\");\t\tSystem.out.println(\"c2은 \" + c2.kind + \", \" + c2.number + \"이며, 크기는 (\" + c2.width + \", \" + c2.height + \")\");\t\tSystem.out.println(\"c1의 width와 height를 각각 50, 80으로 변경한다.\");\t\tc1.width = 50;   //클래스 변수 변경\t\tc1.height = 80;\t\t/* 밑과 같이 사용하는 것을 권장한다.\t\tCard.width = 50;  \t\tCard.height = 80;\t\t*/\t\tSystem.out.println(\"c1은 \" + c1.kind + \", \" + c1.number + \"이며, 크기는 (\" + c1.width + \", \" + c1.height + \")\");\t\tSystem.out.println(\"c2은 \" + c2.kind + \", \" + c2.number + \"이며, 크기는 (\" + c2.width + \", \" + c2.height + \")\");\t}}class Card {\tString kind;              //카드의 무늬 - 인스턴스 변수\tint number;               //카드의 숫자 - 인스턴스 변수\tstatic int width = 100;   //카드의 폭   - 클래스 변수\tstatic int height = 250;  //카드의 높이 - 클래스 변수}실행 결과 Card.width = 100Card.height = 250c1은 Heart, 7이며, 크기는 (100, 250)c2은 Spade, 4이며, 크기는 (100, 250)c1의 width와 height를 각각 50, 80으로 변경한다.c1은 Heart, 7이며, 크기는 (50, 80)c2은 Spade, 4이며, 크기는 (50, 80)메서드   메서드는 C/C++에서 사용하는 함수와 동일하다.  메서드의 3가지 특징          높은 재사용성(reusability)      중복된 코드의 제거      프로그램의 구조화      JVM의 메모리구조    메서드 영역(method area)          프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(.class)을 읽어서 분석하여 클래스에 대한 정보(클래스 데이터)를 이곳에 저장한다. 이 때, 그 클래스의 클래스 변수도 이 영역에 함께 생성된다.        힙(heap)          인스턴스가 생성되는 공간으로서, 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다. 즉 인스턴스변수들이 생성되는 공간이다.        호출스택(call back or execution stack)          메서드의 작업에 필요한 메모리 공간을 제공한다. 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당된다.                  이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용된다.                    메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거된다.      첫 번째로 호출된 메서드를 위한 메모리가 호출스택의 맨 밑에 생성되고, 그 다음은 차례로 그 위로 쌓인다.(스택)                  아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.                    호출스택의 제일 상위에 위치한 메서드가 현재 실행 중인 메서드이며, 나머지는 대기상태에 있게 된다.      반환타입이 있는 메서드는 종료되면서 결과값을 자신을 호출한 메서드(caller)에게 반환한다.      매개변수 및 반환   매개변수          기본형 매개변수: 변수의 값을 읽기만 할 수 있다. (read only)      참조형 매개변수: 변수의 값을 읽고 변경할 수 있다. (read &amp; write)        참조형 반환타입: 메서드가 ‘객체의 주소’를 반환한다.  참조형 매개변수 및 반환타입 예제          C/C++의 call by address와 유사하다.&lt;/br&gt;      예제코드 class Data { int x; }class ReferenceReturnEx {\tpublic static void main(String args[]) {\t\tData d = new Data();\t\td.x = 10;\t\tData d2 = copy(d);  //참조형 매개변수, 참조형 타입을 매개변수로 사용한다.\t\tSystem.out.println(\"d.x = \" + d.x);\t\tSystem.out.println(\"d2.x = \" + d2.x);\t}\tstatic Data copy(Data d) {\t\tData tmp = new Data();  //새로운 객체 tmp를 생성한다.\t\ttmp.x = d.x;            //d.x의 값을 tmp.x에 복사한다.\t\treturn tmp;  //참조형 반환타입, 복사한 객체의 주소를 반환한다.\t}}실행결과 d.x = 10d2.x = 10  재귀호출 역시 C/C++과 동일하게 사용가능하다.클래스 메서드(static 메서드)와 인스턴스 메서드   클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통적으로 사용해야하는 것에 static을 붙인다.          생성된 각 인스턴스는 서로 독립적이기 때문에 각 인스턴스 변수(iv)는 서로 다른 값을 유지한다. 그러나 모든 인스턴스에서 같은 값이 유지되어야 하는 변수는 static을 붙여서 클래스변수로 정의해야 한다.        클래스 변수(static 변수)는 인스턴스를 생성하지 않아도 사용할 수 있다.          static이 붙은 변수(클래스 변수)는 클래스가 메모리에 올라갈 때 이미 자동적으로 생성되기 때문이다.        클래스 메서드(static 메서드)는 인스턴스 변수를 사용할 수 없다.          인스턴스 변수는 인스턴스가 반드시 존재해야만 사용할 수 있는데, 클래스 메서드는 인스턴스 생성 없이 호출이 가능하므로 클래스 메서드가 호출되엇었을 때 인스턴스가 존재하지 않을 수도 있다. 반면에 인스턴스 변수나 메서드는 클래스 변수나 메서드를 언제나 사용가능하다.        메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.          클래스 메서드를 사용하면 메서드 호출시간이 짧아지므로 성능이 향상된다. 인스턴스 메서드는 실행 시 호출되어야할 메서드를 찾는 과정이 추가적으로 필요하기 때문에 시간이 더 걸린다.        예제예제코드 class MyMath {\tlong a, b;\t//인스턴스변수 a, b만을 이용해서 작업하므로 매개변수가 필요없다.\tlong add()      { return a + b; }  //a, b는 인스턴스변수\tlong subtract() { return a - b; }\tlong multiply() { return a * b; }\tdouble divide() { return a / b; }\t//인스턴스변수와 관계없이 매개변수만으로 작업이 가능하다.\tstatic long add(long a, long b)          { return a + b; }  //a, b는 지역변수\tstatic long subtract(long a, long b)     { return a - b; }\tstatic long multiply(long a, long b)     { return a * b; }\tstatic double divide(double a, double b) { return a / b; }}class MyMathTest {\tpublic static void main(String args[]) {\t\t//클래스 메서드 호출, 인스턴스 생성없이 호출가능\t\tSystem.out.println(MyMath.add(200L, 100L));\t\tSystem.out.println(MyMath.subtract(200L, 100L));\t\tSystem.out.println(MyMath.multiply(200L, 100L));\t\tSystem.out.println(MyMath.divide(200.0, 100.0));\t\tMyMath mm = new MyMath();  //인스턴스 생성\t\tmm.a = 200L;\t\tmm.b = 100L;\t\t//인스턴스 메서드는 객체생성 후에만 호출이 가능함.\t\tSystem.out.println(mm.add());\t\tSystem.out.println(mm.subtract());\t\tSystem.out.println(mm.multiply());\t\tSystem.out.println(mm.divide());\t}}실행결과 300100200002.0300100200002.0클래스 멤버와 인스턴스 멤버간의 참조와 호출   같은 클래스에 속한 멤버들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조 또는 호출이 가능하다. 하지만, 클래스 멤버가 인스턴스 멤버를 참조 또는 호출하고자하는 경우에는 인스턴스를 생성해야한다.          클래스 멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수도 있기 때문이다.        인스턴스 멤버는 클래스 멤버를 포함하여 언제나 참조 및 호출이 가능하다.","categories": ["Language"],
        "tags": ["Language_Java"],
        "url": "https://codemcd.github.io/pages/CODEMCD/language/Java-5.-%EB%B3%80%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C/",
        "teaser":null},{
        "title": "[Java]6. 오버로딩(Overloading)",
        "excerpt":"6. 오버로딩(Overloading) 정의   한 클래스내에 같은 이름의 메서드를 여러 개 정의하는 것을 말한다.          이름이 같지만 매개변수의 개수 또는 타입으로 구분한다.        메서드 오버로딩(method overloading)을 간단히 줄여서 오버로딩이라고 한다.조건   메서드 이름이 같아야 한다.  매개변수의 개수 또는 타입이 달라야 한다.          컴파일러는 같은 이름의 메서드라면 오직 매개변수로만 구분하며, 타입은 영향을 끼치지 않는다.      메서드 이름과 매개변수가 같다면 컴파일러는 중복 정의로 간주하여 에러를 발생시킨다.      예제   잘못된 예제          매개변수의 이름만 다른 경우              컴파일할 경우, ‘add(int, int) is already defined’라는 에러 메시지가 나타난다.      int add(int a, int b) { return a + b; }int add(int x, int y) { return x + y; }  리턴 타입만 다른 경우int add(int a, int b) { return a + b; }long add(int  a, int b) {return (long)(a + b); }  올바른 예제          타입이 다른 두 매개변수의 순서만 다른 경우              이는 사용할 때 순서가 헷갈릴 수 있어 추천하는 방법은 아니다.      long add(int a, long b) { return a + b; }long add(long a, int b) { return a + b; }  추천하는 방식int add(int a, int b) { return a + b; }long add(long a, long b) { return a + b; }long add(int[] a} {\tlong result = 0;\tfor(int i=0; i &lt; a.length; i++) {\t\tresult += a[i];\t}\treturn result;}  대표적인 사용 예제(println)void println()void println(boolean x)void println(char x)void println(char[] x)void println(double x)void println(float x)void println(int x)void println(long x)void println(object x)void println(String x)장점   하나의 메서드로 여러 기능을 사용할 수 있으므로, 기억하기 쉽고 오류를 줄일 수 있다.  메서드의 이름을 절약할 수 있다.가변인자(varargs)와 오버로딩   가변인자: 메서드의 매개변수 개수를 동적으로 지정하는 인자          ‘타입… 변수명’ 형식      가변인자는 매개변수 중 가장 마지막에 선언되어야 한다. (그렇지 않으면 컴파일 에러)      public PrintStream printf(String format, Object... args) {...}  장점          매개변수의 개수를 다르게 사용하기위해 간단히 선언할 수 있다.      인자가 아예 없어도 되고, 배열도 인자가 될 수 있다.                  매개변수를 배열로 할 시 인자를 무조건 지정해주어야 하는 단점이 있다.(길이가 0인 배열(JAVA에서만 가능), null을 사용해야함)                    String concatenate(String... str) {...}System.out.println(concatenate());System.out.println(concatenate(\"a\"));System.out.println(concatenate(\"a\", \"b\"));System.out.println(concatenate(new String[] {\"A\", \"B\"}));  단점          가변인자는 내부적으로 배열을 이용하기 때문에 서언된 메서드를 호출할 때마다 배열이 새로 생성되므로 비효율적이다.      가변인자를 선언한 메서드를 오버로딩하면, 메서드를 호출했을 때 구분하지 못하는 경우가 쉽게 발생하므로 오버로딩을 사용하지 않는 것이 좋다.                  매개변수를 다르게 선언한다 해도 에러가 발생할 확률이 높다.                    ","categories": ["Language"],
        "tags": ["Language_Java"],
        "url": "https://codemcd.github.io/pages/CODEMCD/language/Java-6.-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9/",
        "teaser":null},{
        "title": "[Java]7. 생성자(Constructor)",
        "excerpt":"7. 생성자(Constructor) 정의   인스턴스가 생성될 때 호출되는 ‘인스턴스 초기화 메서드’이다.  조건          메서드와 같이 클래스 내부에 선언된다.      생성자의 이름은 클래스의 이름과 같아야 한다.      생성자는 리턴 값이 없다.                  void도 사용하지 않으며, 아무것도 적지 않는다.                      오버로딩이 가능하다.  주의할 점은 연산자 new가 인스턴스를 생성하는 것이며, 생성자는 단지 인스턴스를 초기화하는 것이다.  예제class Card {\tCard() {    //매개변수가 없는 생성자\t\t...\t}\tCard(String k, int num) {    //매개변수가 있는 생성자(오버로딩)\t\t...\t}}  클래스 변수명 = new 클래스(); 동작 과정          연산자 new에 의해 메모리(heap)에 클래스의 인스턴스가 생성된다.      생성자 클래스() 가 호출되어 수행된다.      연산자 new의 결과로, 생성된 클래스 인스턴스의 주소가 반환되어 참조변수 변수명에 저장된다.      기본 생성자(default constructor)   모든 클래스에는 반드시 하나 이상의 생성자가 정의되어 있어야 하지만, 만약 정의되어 있지 않다면 컴파일러가 기본 생성자를 제공한다.  기본 생성자의 형태는 클래스이름() { }이며, 매개변수와 내용은 아무것도 정의되지 않는다.  클래스의 접근 제어자가 ‘public’인 경우의 기본생성자는 public 클래스이름() { }이다.  클래스 내부에 생성자가 하나라도 선언되어 있다면, 기본생성자는 생성되지 않는다.생성자에서 다른 생성자 호출하기 - this(), this   조건          생성자의 이름으로 클래스이름 대신 this를 사용한다.      한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.        잘못된 예제Car(String color) {\tdoor = 5;              //첫 번째 줄\tCar(color, \"auto\", 4); //에러1: 생성자의 두 번째 줄에서 다른 생성자 호출\t                       //에러2: this(color, \"auto\", 4);로 해야함}  특징          밑의 예제에서 1)생성자와 같이 this()를 사용하면, 간략히 표현이 가능하고 유지보수가 쉬운 코드를 만들 수 있다.      3)생성자에서 매개변수(지역변수) 이름과 인스턴스변수가 이름이 같은데 이를 구분하기 위해 참조변수 this를 사용한다.(this를 붙히지 않으면 둘 다 지역변수로 사용된다.)      참조변수 this                  인스턴스 자신을 가리키는 참조변수(인스턴스 주소가 저장되어 있음.)          모든 인스턴스 메서드에 지역변수로 줌겨진 채로 존재한다.          static 메서드(클래스 메서드)에서는 사용할 수 없다.                    생성자 this(), this(매개변수)                  생성자로서, 같은 클래스의 다른 생성자를 호출할 때 사용한다.                    현재 사용하고 있는 인스턴스와 같은 상태를 갖는 인스턴스를 하나 더 만들고자 할 때 생성자의 매개변수에 클래스의 참조변수를 사용할 수 있다.  (밑의 예제 4) 참고)                  같은 내용의 서로 독립적인 인스턴스를 만들 수 있다.&lt;/br&gt;                    예제 코드 class Car {\tString color;\tString gearType;\tint door;\t// 1)\tCar() {\t\tthis(\"White\", \"auto\", 4);  //Car(String color, String gearType, int door) 호출\t}\t// 2)\tCar(String color) {\t\tthis(color, \"auto\", 4);\t}\t// 3)\tCar(String color, String gearType, int door) {\t\tthis.color = color;\t\tthis.gearType = gearType;\t\tthis.door = door;\t}\t// 4) 인스턴스의 복사를 위한 생성자\tCar(Car c) {\t\tcolor = c.color;\t\tgearType = c.gearType;\t\tdoor = c.door;\t\t//this(c.color, c.gearType, c.door); // 더 바람직한 방법\t}}class CarTest {\tpublic static void main(String[] args) {\t\tCar c1 = new Car();\t\tCar c2 = new Car(\"Blue\");\t\tCar c3 = new Car(c1);\t\tSystem.out.println(\"c1 color: \" + c1.color + \", gearType: \" + c1.gearType + \", door: \" + c1.door);\t\tSystem.out.println(\"c2 color: \" + c2.color + \", gearType: \" + c2.gearType + \", door: \" + c2.door);\t\tSystem.out.println(\"c3 color: \" + c3.color + \", gearType: \" + c3.gearType + \", door: \" + c3.door);\t}}실행 결과 c1 color: While, gearType: auto, door: 4c2 color: Blue, gearType: auto, door: 4c3 color: While, gearType: auto, door: 4","categories": ["Language"],
        "tags": ["Language_Java"],
        "url": "https://codemcd.github.io/pages/CODEMCD/language/Java-7.-%EC%83%9D%EC%84%B1%EC%9E%90/",
        "teaser":null},{
        "title": "[Java]8. 변수의 초기화",
        "excerpt":"8. 변수의 초기화   멤버변수(클래스 변수와 인스턴스 변수)는 초기화하지 않아도 자동적으로 자료형에 맞는 기본값으로 초기화한다.  지역변수는 사용하기 전에 반드시 초기화해야 한다.  각 타입의 기본값(default value)            자료형      기본값                  boolean      false              char      ‘\\u000’              byte, short, int      0              long      0L              float      0.0f              double      0.0d or 0.0              참조형 변수      null      멤버변수 초기화 방법   명시적 초기화(explicit initialization)  생성자(constructor)  초기화 블럭(initialization block)  명시적 초기화          변수를 선언과 동시에 초기화하는 것을 말한다.      가장 우선시되는 초기화 방법      classs Car {\tint door = 4;              //기본형 변수의 초기화\tEngine e = new Engine();   //참조형 변수의 초기화}  초기화 블럭          클래스 초기화 블럭: 클래스변수의 복잡한 초기화에 사용된다.                  클래스내에 블럭 static { }만들고 그 안에 코드를 작성한다.          클래스가 메모리에 처음 로딩될 때 한 번 수행된다.                    인스턴스 초기화 블럭: 인스턴스변수의 복잡한 초기화에 사용된다.                  클래스 내에 블럭 { } 만들고 그 안에 코드를 작성한다.          생성자와 같이 인스턴스를 생성할 때 마다 수행된다. (생성자보다 인스턴스 초기화 블럭이 먼저 수행된다.)          생성자는 주로 인스턴스 변수의 초기화에 사용되고, 초기화 블럭은 모든 생성자에 공통적으로 수행되어야할 코드를 삽입한다.                    초기화 블럭 내에서 조건문, 반복문, 예외처리구문 등을 사용할 수 있다.&lt;/      예제 코드 class BlockTest {\t//클래스 초기화 블럭\tstatic {\t\tSystem.out.println(\"static { }, 클래스 초기화 블럭\");\t}\t//인스턴스 초기화 블럭\t{\t\tSystem.out.println(\"{ }, 인스턴스 초기화 블럭\");\t}\t//생성자\tpublic BlockTest() {\t\tSystem.out.println(\"생성자\");\t}\tpublic static void main(String[] args) {\t\tSystem.out.println(\"bt1 인스턴스 생성 전\");\t\tBlockTest bt1 = new BlockTest();\t\tSystem.out.println(\"bt1 인스턴스 생성 후\");\t\tSystem.out.println(\"bt2 인스턴스 생성 전\");\t\tBlockTest bt2 = new BlockTest();\t\tSystem.out.println(\"bt2 인스턴스 생성 후\");\t}}실행 결과 static { }, 클래스 초기화 블럭bt1 인스턴스 생성 전{ } 인스턴스 초기화 블럭생성자bt1 인스턴스 생성 후bt2 인스턴스 생성 전{ } 인스턴스 초기화 블럭생성자bt2 인스턴스 생성 후  멤버변수 초기화 시기와 순서          클래스변수의 초기화 시점: 클래스가 처음 로딩될 때 단 한 번 초기화 된다.      클래스변수의 초기화 순서: 기본값 -&gt; 명시적 초기화 -&gt; 클래스 초기화 블럭      인스턴스변수의 초기화 시점: 인스턴스가 생성될 때마다 각 인스턴스별로 초기화가 이루어진다.      인스턴스변수의 초기화 순서: 기본값 -&gt; 명시적 초기화 -&gt; 인스턴스 초기화 블럭 -&gt; 생성자      ","categories": ["Language"],
        "tags": ["Language_Java"],
        "url": "https://codemcd.github.io/pages/CODEMCD/language/Java-8.-%EB%B3%80%EC%88%98%EC%9D%98-%EC%B4%88%EA%B8%B0%ED%99%94/",
        "teaser":null},{
        "title": "[Java]9. 상속(Inhertance)",
        "excerpt":"9. 상속(Inhertance) 상속의 정의와 장점 1. 정의   상속: 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다.2. 장점   코드의 재사용성          보다 적은 양의 코드로 새로운 클래스를 작성할 수 있다.        프로그램의 생상성 향상과 유지보수가 간단함          코드를 공통적으로 관리할 수 있기 때문에 코드의 추가 및 변경이 매우 용이하다.      3. 특징   상속의 구현 방법          클래스의 이름 뒤에 상속받고자 하는 클래스의 이름을 키워드 ‘extends‘와 함께 작성하면 된다.      class Child extends Parent {  ... }  용어          조상 클래스: 부모(parent)클래스, 상위(super)클래스, 기반(base)클래스      자손 클래스: 자식(child)클래스, 하위(sub)클래스, 파생된(derived)클래스        상속계층도(class hierarchy)class Parent P { ... }class Child extends Parent { ... }   자손 클래스는 조상 클래스의 모든 멤버를 상속 받으므로 항상 조상 클래스보다 같거나 많은 멤버를 갖는다.          접근 제어자가 private 또는 default인 멤버들은 상속은 받지만 자손 클래스로부터의 접근이 제한된다.        생성자와 초기화 블럭은 상속되지 않는다.  클래스간 관계에서는 형제 관계는 존재하지 않고 오직 상속 관계만 존재한다.4. 예제 예제 코드 class Tv {\tboolean power;  //전원상태(on/off)\tint channel;    //채널\tvoid power() { power = !power; }\tvoid channelUp() { ++channel; }\tvoid channelDown() { --channel; }}class CaptionTv extends Tv {\tboolean caption;   //캡션상태(on/ofF)\tvoid displayCaption(String text) {\t\tif(caption) {    //캡션상태가 true면 해당 text를 출력한다.\t\t\tSystem.out.println(text);\t\t}\t}}class CaptionTvTest {\tpublic static void main(String[] args) {\t\tCaptionTv ctv = new CaptionTv();\t\tctv.channel = 10;                    //조상 클래스로부터 상속받은 멤버\t\tctv.channelUp();                     //조상 클래스로부터 상속받은 멤버\t\tSystem.out.println(ctv.channel);\t\tctv.displayCaption(\"Hello World\");\t\tctv.caption = true;\t\tctv.displayCaption(\"Hello World\");\t}}실행 결과 11Hello World  상속계층도   벤다이어그램   자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다.클래스간의 관계 - 포함(Composite)관계   상속이외에 클래스를 재사용하는 방법으로서, 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것이다.class Point {  int x;   // x좌표  int y;   // y좌표}class Circle {  Point c = new Point();  // 원점 (x, y) 좌표, 포함관계  int r;   // 반지름}클래스간의 관계 결정하기   상속 관계: ‘~은 ~이다. (is-a)’  포함 관계: ‘~은 ~을 가지고 있다. (has-a)’  예제          원(Circle)은 점(Point)를 가지고 있다. =&gt; 포함 관계 (‘원은 점이다’는 어색하다.)      스포츠카(SportsCar)는 차(Car)이다. =&gt; 상속 관계      단일 상속(Single inheritance)   JAVA에서는 단일 상속만을 허용한다.          C++에서는 다중 상속을 허용한다.        단일 상속 특징          클래스 간의 관계가 명확하다.      코드의 신뢰성을 높인다.        다중 상속 특징          여러 클래스로부터 상속을 받을 수 있기 때문에 복합적인 기능을 가지는 클래스를 쉽게 작성할 수 있다.      서로 다른 클래스로부터 상속받은 멤버간의 이름이 같은 경우 구별할 수 있는 방법이 없다. (큰 단점)      Object 클래스 - 모든 클래스의 조상   모든 클래스의 상속계층도의 최상위에는 Object 클래스가 있다.  상속을 명시하지 않는 클래스는 컴파일러가 자동으로 ‘extends Object’를 추가한다.          상속이 명시되어 있다면 추가하지 않는다. (다중 상속이 안되기 때문)      ","categories": ["Language"],
        "tags": ["Language_Java"],
        "url": "https://codemcd.github.io/pages/CODEMCD/language/Java-9.-%EC%83%81%EC%86%8D/",
        "teaser":null},{
        "title": "[Java]JAVA 변수와 자료형",
        "excerpt":"JAVA 변수와 자료형 변수와 자료형 정의   변수: 단 하나의 값(data)을 저장할 수 있는 메모리 공간  자료형: 변수에 저장할 값의 유형변수의 명명규칙   대소문자가 구분되며 길이에 제한이 없다.          True와 true는 서로 다른 것으로 간주된다.        예약어를 사용해서는 안 된다.          true는 예약어라서 사용할 수 없지만, True는 가능하다.        숫자로 시작해서는 안 된다.          top10은 허용되지만, 7up은 혀용되지 않는다.        특수문자는 ‘_ ‘ 와 ‘$’ 만을 허용한다.  그 외 프로그래머들간의 규칙          이는 필수는 아니지만 코드의 가독성을 위해 프로그래머들간의 약속이다.      클래스 이름의 첫 글자는 항상 대문자로 한다.                  클래스 이름은 ASCII코드로 하는 것이 좋다.(일부 운영체제에서 유니코드를 인식하지 못한다.)                    변수와 메서드의 이름의 첫 글자는 항상 소문자로 한다.      여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 한다.      상수의 이름은 모두 대문자로 한다.      여러 단어로 이루어진 경우 ‘_ ‘로 구분한다.      상수와 리터럴(constant &amp; literal)   상수: 선언과 동시에 초기화하며, 이 초기화된 값은 변경할 수 없다.(변수 앞에 final 기호를 붙임)  리터럴: 그 자체로 값을 의미하는 것이다.int year = 2014;final int MAX_VALUE = 100;//변수: year//상수: MAX_VALUE//리터럴: 2014, 100기본형(Primitive type)   기본형에는 모두 8개의 자료형이 있으며, 크게 논리형, 문자형, 정수형, 실수형으로 구분된다.논리형   true와 false 중 하나를 값으로 갖으며, 조건식과 논리적 계산에 사용된다.  기본값(default)은 false이다.  두 가지 값만을 사용하므로 1bit만으로 충분하지만 자바의 최소단위가 1byte이기 때문에 논리형의 크기는 1byte이다.            자료형      저장 가능한 값의 범위      bit      byte                  boolean      false, true      8      1      문자형   문자를 저장하기 위한 변수를 선언할 때 사용한다.  자료형은 char 하나이며, 크기는 2byte 이다.            자료형      저장 가능한 값의 범위      bit      byte                  char      0 ~ 2^16 -1,(0 ~ 65535)      16      2        특수 문자            특수 문자      문자 리터럴                         tab      \\t                     backspace      \\b                     form feed      \\f                     new line      \\n                     carriage return      \\r                     역슬래쉬()      \\      ㅅ              작은따옴표      '                     큰따옴표      \"                     유니코드(16진수)문자      \\u유니코드(ex, char a = ‘\\u0041’)             정수형   정수값을 저장하는데 사용된다.  자료형은 byte 크기순으로 byte(1), short(2), int(4), long(8) 이 있다.            자료형      저장 가능한 값의 범위      bit      byte      설명                  byte      -2^7 ~ 2^7-1 (-128 ~ 127)      8      1      성능보다 저장공간을 절약하는 것이 중요할 때 사용된다.              short      -2^15 ~ 2^15-1 (-32,768 ~ 32,767)      16      2      byte타입과 같은 이유로 사용된다.              int      -2^31 ~ 2^31-1 (약 +/-20억)      32      4      JVM의 피연산자 스택은 4byte단위로 저장하기 때문에 같은 크기를 사용하는 int 타입이 가장 효율적이다.              long      -2^63 ~ 2^63-1      64      8      int타입의 범위를 넘어사는 수를 저장할 때 사용된다.(리터럴에 접미사 ‘L’을 붙임)        오버플로우: 연산과정에서 타입이 표현할 수 있는 값의 범위를 넘어서는 것을 말하며, 에러가 발생하지는 않지만 예상할 수 없는 값을 얻게 된다.실수형   실수값을 저장하는데 사용된다.  실수형의 타입은 float와 double 이 있으며, 다른 자료형과 달리 소수점을 표현하기 때문에 정밀도가 존재한다.  해당 리터럴에 접미사 ‘f’, ‘d’ 를 붙여야 한다.  실수형은 큰 값을 표현하는 것과 얼마나 ‘0’에 가깝게 표현할 수 있는가도 중요하다.            자료형      저장 가능한 값의 범위(양수)      정밀도      bit      byte                  float      1.4 * 10^-45 ~ 3.4 * 10^38      7자리      32      4              double      4.9 * 10^-324 ~ 1.8 * 10^308      15자리      64      8        오버플로우: 실수형에서 오버플로우가 발생하면 해당 변수의 값은 무한대가 된다.  언더플로우: 실수형으로 표현할 수 없는 아주 작은 값의 경우 해당 변수의 값은 ‘0’이 된다.  실수형의 저장형식          flaot: 1 + 8 + 23 = 32(4byte)      | S(1) |      E(8)     |         M(23)         ||:—-:|:————-:|:———————:|   double: 1 + 11 + 52 = 64(8byte)| S(1) |        E(11)       |              M(52)              ||:—-:|:——————:|:——————————-:|             기호      의미      설명                  S      부호(Sign bit)      크기: 1 bit, 0이면 양수, 1이면 음수              E      지수(Exponent)      부호있는 정수, 지수의 범위는 float: -127 ~ 128, double: -1023 ~ 1024              M      가수(Mantissa)      실제 값을 저장하는 부분, float: 10진수로 7자리, double: 15자리 정밀도로 저장가능      출력 - printf()   기본 출력            지시자      자료형      설명                  %b      boolean                     %d      int      10진수              %o      int      8진수              %x, %X      int      16진수              %f      float      10진수              %e, %E             지수형태표현              %c      char      문자              %s      string      문자열        특수 출력System.out.printf(\"[%s]%n\", url);      //문자열의 길이만큼 출력공간을 확보한다.System.out.printf(\"[%20s]%n\", url);    //최소 20글자 출력공간 확보(우측정렬)System.out.printf(\"[%-20s]%n\", url);   //최소 20글자 출력공간 확보(좌측정렬)System.out.printf(\"[%.8s]%n\", url);    //왼쪽에서 8글자만 출력int finger = 10;System.out.printf(\"finger = [%5d]%n\", finger);    //finger = [   10]System.out.printf(\"finger = [%-5d]%n\", finger);   //finger = [10   ]System.out.printf(\"finger = [%05d]%n\", finger);   //finger = [00010]","categories": ["Language"],
        "tags": ["Language_Java"],
        "url": "https://codemcd.github.io/pages/CODEMCD/language/Java-%EB%B3%80%EC%88%98%EC%99%80%EC%9E%90%EB%A3%8C%ED%98%95/",
        "teaser":null},{
        "title": "[Java]예외처리(exception handing)",
        "excerpt":"예외처리(exception handing) 프로그램 오류   컴파일 에러(compile-time error): 컴파일 시에 발생하는 에러  런타임 에러(runtime error): 실행 시에 발생하는 에러  논리적 에러(logical error): 실행은 되지만, 의도와는 다르게 동작하는 것  자바에서는 실행 시(runtime)에 발생할 수 있는 프로그램 오류를 두 가지로 구분한다.          에러(error): 프로그램 코드에 의해서 수습될 수 없는 심각한 오류를 말한다.                  예를들어, 메모리 부족(OutOfMemoryError)나 스택오버플로우(StackOverflowError)가 있다.                    예외(exception): 프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류를 말한다.      예외 클래스의 계층구조   Exception과 Error클래스 역시 Object클래스의 자손들이다.  밑의 그림은 예외클래스 계층도를 주요 클래스들만을 나열한 모습이다.   Exception클래스는 두 개의 그룹으로 구분할 수 있다.          RuntimeException클래스와 그 자손클래스들                  자손클래스는 ArithmeticException, ClassCastException, NullPointerException, …, IndexOutOfBoundException 클래스 등이 있다.          해당 클래스들은 주로 프로그래머의 실수에 의해 발생될 수 있는 예외들로 자바의 프로그래밍 요소들과 관계가 깊다.          IndexOutOfBoundException: 배열의 범위를 벗어난 경우          NullPointerException: null인 참조변수의 멤버를 호출한 경우          ClassCastException: 클래스의 형변환이 잘못된 경우          ArithmeticException: 정수를 0으로 나누려고하는 경우                    Exception클래스와 그 자손클래스들(RuntimeException과 자손들 제외)                  자손클래스는 IOException, ClassNotFoundException 클래스 등이 있다.          프로그램의 사용자의 실수와 같은 외적인 요인에 의해 발생하는 예외이다.          FileNotFoundException: 존재하지 않은 파일의 이름을 입력한 경우          ClassNotFoundException: 실수로 클래스의 이름을 잘못된 경우          DataFormatException: 입력한 데이터 형식이 잘못된 경우                    예외처리하기 1. try-catch문   예외처리: 프로그램 실행 시 발생할 수 있는 예기치 못한 예외의 발생에 대비한 코드를 작성하는 것이다.  예외처리의 목적은 예외의 발생으로 인한 프로그램의 비정상적인 종료를 막고, 정상적인 실행상태를 유지하는 것이다.  예외를 처리하지 못하면, 프로그램은 비정상적으로 종료되며, JVM의 예외처리기(UncaughtExceptionHandler)에서 처리하지 못한 예외(uncaught exception)를 받아서 그 원인을 출력한다.  try-catch문의 구조try {  //예외가 발생할 가능성이 있는 문장들을 넣는다.} catch(Exception e1) {  //Exception1이 발생했을 경우, 이를 처리하기 위한 문장을 적는다.} catch(Exception e2) {  //Exception2이 발생했을 경우, 이를 처리하기 위한 문장을 적는다.}... catch(Exception eN) {  //ExceptionN이 발생했을 경우, 이를 처리하기 위한 문장을 적는다.}  여러 개의 catch블럭이 올 수 있지만, 이 중 발생한 예외의 종류와 일치하는 단 하나의 catch블럭만 실행된다.  if문과 같은 문법과 달리, 괄호({ })를 절대 생략할 수 없다.  try-catch문은 여러개 반복해서 사용할 수 있고, try-catch문 안에 또 다른 try-catch문의 선언도 가능하다.          중첩된 try-catch문을 사용할 때 같은 이름의 참조변수를 사용해서는 안된다.      2. try-catch문 흐름   try블럭 내에서 예외가 발생한 경우          발생한 예외와 일치하는 catch블럭이 있는지 확인한다.      일치하는 catch블럭을 찾으면, 그 catch블럭 내의 문장들을 수행하고 전체 try-catch문을 빠져나가서 그 다음 문장을 계속해서 수행한다.(try블럭 내의 예외 발생 시점 밑의 코드들은 수행하지 않는다.)      일치하는 catch블럭을 찾지 못하면, 예외는 처리되지 못한다.        tyr블럭 내에서 예외가 발생하지 않은 경우          catch블럭을 거치지 않고 전체 try-catch문을 빠져나가서 계속해서 수행한다.      3. catch블럭   예외가 발생했을 때, 생성되는 예외 클래스의 인스턴스에는 발생한 예외에 대한 정보가 담겨져 있으며, getMessage()와 printStackTrace()를 통해서 이 정보에 접근가능하다.  printStackTrace(): 예외발생 당시의 호출스택(Call Stack)에 있었던 메서드의 정보와 예외 메시지를 화면에 출력한다.          printStackTrace(PrintStream s)나 printStackTrace(PrintWriter s)를 통해 예외에 대한 정보를 파일에 저장할 수도 있다.        getMessage(): 발생한 예외클래스의 인스턴스에 저장된 메시지를 얻을 수 있다.                              멀티 catch블럭: JDK1.7부터 여러 catch블럭을 ‘          ‘기호를 이용해서 하나의 catch블럭으로 합칠 수 있다.                            조상과 자손 관계를 연결 시킬수는 없다.      예외 클래스들의 공통 분모인 조상 예외 클래스에 선언된 멤버만을 사용할 수 있고, 참조변수는 ‘e’로 고정된다.        기존 catch 블럭 코드     try {  ...} catch (ExceptionA e) {  e.printStackTrace();} catch (ExceptionB e2) {  e2.printStackTrace();}        멀티 catch 블럭 코드     try {  ...} catch (ExceptionA | ExceptionB e) {  e.printStackTrace();}      예외 발생시키기   키워드 ‘throw’를 사용해서 프로그래머가 고의로 예외를 발생시킬 수 있다.  사용 방법          연산자 new를 이용해서 발생시키려는 예외 클래스의 객체를 만든다. Exception e = new Exception(\"고의로 발생시킴\");      키워드 throw를 이용해서 예외를 발생시킨다. throw e;        예외를 고의로 발생시켰다면, 반드시 그 예외에 대한 처리를 해주어야 한다.(try-catch문)          Exception 클래스(checked 예외)의 경우, 처리를 해주지 않으면 컴파일 단계에서 오류가 발생한다.      RuntimeException 클래스(unchecked 예외)의 경우, 컴파일에는 성공하지만 비정상적으로 종료된다.      메서드에 예외 선언하기   try-catch문 외에, 메서드의 선언부에 키워드 ‘throws’를 사용해서 메서드 내에서 발생할 수 있는 예외를 선언해주면 된다.          예외가 여러개일 경우, 쉼표(,)로 구분하고, 키워드 ‘throw’와 구분해야 한다.      void method() throws Exception1, Exception2, ... ExceptionN {  //메서드 내용}  메서드의 선언부에 예외를 선언함으로써, 메서드를 사용하려는 사람이 해당 메서드를 사용하기 위해 어떠한 예외들을 처리해야 하는지 알려 줄 수 있다.          예외 발생 가능성을 예측해야 하는 프로그래머들의 수고를 덜어주고, 보다 견고한 프로그램 코드를 작성할 수 있다.      특히, JAVA API 작성된 메서드를 사용할때 보다 정확히 사용할 수 있다.        대부분 RuntimeException클래스는 적어 주지 않고, 반드시 처리해주어야 하는 예외들만 선언한다.  예외가 발생한 메서드에서 예외처리를 해주지 않으면, 그 메서드를 호출한 메서드에게 예외를 넘겨준다.          예외가 발생하면, 해당 메서드나 호출한 메서드 둘 중 한 곳에서는 예외 처리를 해주어야 한다.      finally 블럭   finally블럭은 try-catch문과 함께 예외의 발생여부에 상관없이 실행되어야할 코드를 포함 시킬 목적으로 사용한다.try {  //예외가 발생할 가능성이 있는 문장들} catch(Exception1 e1) {  //예외처리를 위한 문장} finally {  //예외의 발생여부에 관계없이 항상 수행되어야하는 문장들}  finally블럭은 try-catch문의 맨 마지막에 위치해야 한다.  실행 순서는 다음과 같다.          예외 발생: try -&gt; catch -&gt; finally      그 외: try -&gt; finally        try블럭에 return문이 있은 경우에도, finally블럭을 실행한 후에 return문이 실행된다.자동 자원 반환 - try-with-resourced문   JDK1.7부터 try-with-resourced문이라는 try-catch문 번형이 새로 추가되었다.  주로 입출력(I/O)과 관련된 클래스를 사용할 때 주로 사용된다.          입출력이 끝난 자원을 반환할 때, finally문을 사용한다고 해도 여기서 오류가 발생하면 처리해줄 수 없기 때문에 try-with-resourced문을 사용한다.        예제try(fis = new FileInputStream(\"score.dat\");    dis = new DataInputStream(fis)) {  while(true) {    score = dis.readInt();    System.out.println(score);    sum += score;  }} catch(EOFException e) {  System.out.println(\"점수의 총합은 \", + sum + \"입니다.\");} catch(IOException ie) {  ie.printStackTrace();}  try-with-resourced문dml 괄호()안에 객체를 생성하는 문장을 넣으면, 이 객체는 따로 close()를 호출하지 않아도 try블럭을 벗어나는 순간 자동으로 close()가 호출된다.          그 다음에 catch블럭 또는 finally블럭이 수행된다.        괄호()안에 두 문장 이상을 넣을 경우 세미콜론(;)으로 구분해주고, 변수 선언도 가능하다.          선언된 변수는 try블럭안에서만 사용가능하다.      사용자 정의 예외   프로그래머가 직접 Exception클래스로부터 상속을 받아 클래스를 만들거나, 필요에 따라 새로운 예외 클래스를 만들 수 있다.          기존 예외 클래스를 상속받아 만드는 것을 추천한다.        예제class MyException extends Exception {  privatee final int ERR_CODE;  //생성자  MyException(String msg, int errCode) {    super(mag);            //조상인 Excepton클래스의 생성자를 호출한다.    ERR_CODE = errCode;  }  //생성자  MyException(String msg) {    this(msg, 100);        //ERR_CODE를 100을 기본값으로 초기화한다.  }  //에러 코드를 얻을 수 있는 메서드  public int getErrCode() {    return ERR_CODE;  }}예외 되던지기(exception re-throwin)   하나의 예외에 대해서 예외가 발생한 메서드와 호출한 메서드 양쪽에서 처리하고자 할때, 예외 되던지기 방법을 사용한다.  예외 되던지기는 예외를 처리한 후에 인위적으로 다시 발생시키는 것을 말한다.  예외가 발생한 메서드에서는 try-catch문으로 예외를 처리해줌과 동시에 메서드의 선언부에 발생할 예외를 throws에 지정해줘야 한다.  예제class ExceptionEX {  public static void main(String[] args) {    try {      method1();    } catch(Exception e) {      System.out.println(\"main메서드에서 예외가 처리되었습니다.\");    }  }  static void method1() throws Exception {    try {      throw new Exception();    } catch(Exception e) {      System.out.println(\"method1메서드에서 예외가 처리되었습니다.\");      throw e;   //다시 예외를 발생시킨다.    }  }}결과 화면 method1메서드에서 예외가 처리되었습니다.main메서드에서 예외가 처리되었습니다.연결된 예외(chained exception)   한 예외가 다른 예외를 발생시킬 수 있다.          예를 들어, A가 예외 B를 발생시켰다면, A를 B의 ‘원인 예외(cause exception)’라고 한다.      Throwable initCause(Throwable cause)   //지정한 예외를 원인 예외로 등록Throwable getCause()                   //원인 예외를 반환  연결된 예외를 사용하는 이유          여러가지 예외를 하나의 큰 분류의 예외로 묶어서 다루기 위함이다.      checked예외를 unchecked예외로 바꾸기 위함이다.      ","categories": ["Language"],
        "tags": ["Language_Java"],
        "url": "https://codemcd.github.io/pages/CODEMCD/language/Java-%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC/",
        "teaser":null},{
        "title": "[Kotlin]1. 코틀린이란?",
        "excerpt":"코틀린(Kotlin)이란? 코틀린 소개   코틀린은 인텔리제이(IntelliJ IDEA)라는 제품으로 유명한 JetBrains에서 만든 언어로, 2011년 최초로 공개된 후 오랜 시간 개발을 거쳐 2016년 2월1.0 정식 버전이 출시되었다.  코틀린의 목표는 간결한 문법, 풍부한 기능, 높은 안정성을 토대로 높은 생산성을 보장하는 것이다.  코틀린은 자바와 100% 호환되기 때문에, 한 프로젝트에 혼합해서 사용할 수 있다.  구글 I/O 2017에서 안드로이드 공식 지원 언어로 채택되었다.코틀린 특징 1. 간결한 문법   코틀린 문법은 자바에 비해 더 간결한 형태를 추구한다.  자바와 주요 차이점          문장 끝에 세미콜론(;)을 넣지 않아도 된다.      new 키워드를 쓰지 않고 객체를 생성한다.      타입 추론을 지원하므로 일반적인 경우 타입을 적지 않아도 된다.        예제자바 코드 String name = \"John Smith\"Person person = new Person(name);코틀린 코드 val nmae = \"John Smith\"val person = Person(name)2. 널 안정성   객체 타입의 변수에서 널(null) 값의 허용 여부를 구분하지 않던 자바와 달리, 코틀린은 이를 명확히 구분한다.  널 값의 허용 여부를 컴파일 단계에서 검사하므로 런타임에서 발생하는 오류를 대폭 줄일 수 있다.  예제// 널 값을 허용하는 문자열 타입(String?)val foo: String? = null// 널 값을 허용하지 않는 문자열 타입(String)val bar: String  = \"bar\"3. 가변/불변 구분   코틀린에서는 변수 및 변수 내 할당된 값의 불변 여부를 구분한다.          불변 여부: 최초 생성 시 할당된 값을 이후에도 변경할 수 있는지 여부        키워드 ‘val’: 값을 한번 할당하고 나면 그후에 변경할 수 없다.          자바의 키워드 ‘final’과 유사하다.        키워드 ‘var’: 할당된 값을 자유자재로 변경할 수 있다.  변수와 마찬가지로 컬렉션 자료형에 대해서도 불변 여부를 구분한다.4. 람다 표현식 지원   코틀린에서는 람다 표현식을 기본으로 지원한다.5. 스트림 API 지원   코틀린에서는 컬렉션 내 자료를 다루는데 유용한 스트림(stream) API를 표준 라이브러리에서 제공한다.6. 완벽한 자바 호환성   코틀린에서 자바를 사용하는 것과 자바에서 코틀린을 사용하는 것이 모두 가능하다.  자바 라이브러리와도 모두 호환된다.  혼용 시 유의해야 하거나 사용 방법이 약간 다른 부분이 있으니 주의해야한다.","categories": ["Language"],
        "tags": ["Language_Kotlin"],
        "url": "https://codemcd.github.io/pages/CODEMCD/language/Kotlin-1.%EC%BD%94%ED%8B%80%EB%A6%B0%EC%9D%B4%EB%9E%80_/",
        "teaser":null},{
        "title": "[Kotlin]2. 기본 자료형",
        "excerpt":"기본 자료형 특징   자바의 자료형은 원시 타입과 참조 타입 두 가지로 나뉜다.          원시 타입(primitive type; int, double 등): 값 자체를 저장함.      참조 타입(reference type; String 등): 객체의 참조 값을 저장함.        코틀린은 모든 타입을 객체로 표현한다.          원시 타입과 래퍼(wrapper; Integer, Double 등)클래스를 구분하지 않는다.                  wrapper class: 기본 자료형을 객체로 사용하기 위해 기본 자료형 값을 객체로 포장해주는 클래스                    자바의 원시 타입 및 래퍼 클래스를 코틀린에서 사용하는 자료형으로 처리한다.        코틀린 코드를 작성하는 시점에서는 원시 타입과 래퍼를 구분하지 않지만, 컴파일 단계를 거치면서 가장 효율적인 타입으로 변환된다.          값이나 변수 타입으로 사용되는 경우: 원시 타입으로 변환      컬렉션의 타입 인자로 사용되는 경우: 래퍼로 변환      컴파일 단계는 intelliJ 플랫폼에서 디컴파일 하는 기능으로 컴파일 단계의 자바코드를 확인할 수 있다.                  Java(원시 타입)      Java(래퍼)      Kotlin                  byte      java.lang.Byte      kotlin.Byte              short      java.lang.Short      kotlin.Short              int      java.lang.Integer      kotlin.Int              long      java.lang.Long      kotlin.Long              char      java.lang.Character      kotlin.Char              float      java.lang.Float      kotlin.Float              double      java.lang.Double      kotlin.Double              boolean      java.lang.Boolean      kotlin.Boolean      숫자   숫자를 표현하는 모든 자료형은 Number 클래스를 상속합니다.  자료형 변환          코틀린은 작은 타입이 큰 타입으로 대입될 때, 자동으로 형변환을 해주지 않는다.(무조건 명시적 변환을 해주어야 함)                  java.lang.Number      kotlin.Number                  byte byteValue()      fun toByte(): Byte              없음      fun toChar(): Char              double doubleValue()      fun toDouble(): Double              float floatValue()      fun toFloat(): Float              int intValue()      fun toInt(): Int              long longValue()      fun toLong(): Long              short shortValue()      fun toShort(): Short        리터럴(Literal) 표기법          Long 타입은 대문자 ‘L’을 사용하는 것 외에는 자바와 모두 동일하다.      val dec: Int = 100val hex: Int = 0x100val binary: Int = 0b100val longValue: Long = 100Lval doubleValue: Double = 100.1 //(= 1.001e2)val flaotValue: Float = 100.0f  숫자 연산에 사용하는 사칙연산(+, -, *, /)은 자바와 동일하지만, 비트 연산자의 이름은 좀더 직관적으로 바뀌었다.            Java      Kotlin      의미                         &amp;      and      비트 연산 AND                                   or      비트 연산 OR              ^      xor      비트 연산 XOR                     ~      inv      비트 연산 NOT                     «      shl      왼쪽으로 시프트(부호 비트 유지)                     »      shr      오른쪽으로 시프트(부호 비트 유지)                     »&gt;      ushr      오른쪽으로 시프트(부호 비트 무시)             문자   코틀리은 자바와 달리 문자 자료형에 숫자의 형태로 대입할 경우 컴파일 에러가 발생한다.          해당 문자의 아스키 코드 값을 알고 싶을 때, toChar()를 사용하여 위 문제를 해결할 수 있다.      논리   논리 연산자는 자바와 동일하다. (Boolean 사용)문자열   String 클래스로 표현하며, 자바와 거의 동일하다.  get() 메서드 혹은 대괄호([])와 인덱스를 통해 특정 문자에 접근 가능하다.  문자열 리터럴          escaped string(“ “): 전통 적인 방식으로 자바와 거의 동일하다.      raw string(“”” “””): 개행이나 어떠한 문자열도 사용가능하다.        val espstr = \"Hello, kotlin!\"val rawstr = \"\"\"\"Hello, kotlin.I'm John.\"\"\"\"      배열   자바에서는 배열 타입이 별도로 존재하지만, 코틀린에서의 배열은 타입 인자를 갖는 Array클래스로 표현한다.  get(), set(), [], size 등 다양한 기능을 제공한다.  예제val words: Array&lt;String&gt; = arrayOf(\"Lorem\", \"ipsum\", \"dolor\", \"sit\")val intArr: IntArray = intArrayOf(1, 2, 3, 4, 5)            Java      Kotlin                  byte[]      kotlin.ByteArray              double[]      kotlin.DoubleArray              float[]      kotlin.FloatArray              int[]      kotlin.IntArray              long[]      kotlin.LongArray              short[]      kotlin.ShortArray      ","categories": ["Language"],
        "tags": ["Language_Kotlin"],
        "url": "https://codemcd.github.io/pages/CODEMCD/language/Kotlin-2.%EA%B8%B0%EB%B3%B8%EC%9E%90%EB%A3%8C%ED%98%95/",
        "teaser":null},{
        "title": "[Kotlin]3. 컬렉션(collection)",
        "excerpt":"컬렉션(collection) 개요   코틀린에서 컬렉션은 자바에서 제공하는 클래스들을 그대로 사용합니다.  코틀린의 컬렉션은 타입 별칭(type alias)을 사용하여 컬럭션 내 다른 클래스와의 일관성을 유지한다.  컬렉션 내 자료의 수정 가능 여부에 따라 컬렉션의 종류를 구분한다.          이는 새로운 타입을 선언하는 것이 아닌, 인터페이스를 통해 사용 가능한 함수를 제한하는 방식으로 구현된다.        자바의 List 인터페이스 상속 관계도   코틀린의 List 인터페이스 상속 관계도          컬렉션 내 자료를 수정 할 수 있는 가변 타입(mutable)과 수정이 불가능한 불변 타입(immutable)로 구분된다.         코틀린은 가변/불변 타입의 컬렉션이 있지만, 자바에서는 모두 가변 타입의 컬렉션이다. 그러므로 혼용 시에 이를 주의 해야 한다.          코틀린의 불변 타입 컬렉션을 자바로 변경 시 가변 타입의 컬렉션이 된다.        컬렉션은 배열과 마찬가지로 표준 라이브러리에서 쉽게 생성하는 함수를 제공한다.          일부 타입은 타입 별칭을 사용하므로 실제 반환되는 타입이 따로 존재한다.                  함수명      자료 수정가능 여부      반환 타입(실제 타입)                  listOf()      X      kotlin.collections.List              arrayListOf()      O      kltlin.collections.ArrayList(java.util.ArraryLsit)              setOf()      X      kltlin.collections.Set              hashSetOf()      O      kltlin.collections.HashSet(java.util.HashSet)              linkedSetOf()      O      kltlin.collections.LinkedHashSet(java.util.LinkedHashSet)              sortedSetOf()      O      kltlin.collections.TreeSet(java.util.TreeSet)              mapOf()      X      kltlin.collections.Map              hashMapOf()      O      kltlin.collections.HashMap(java.util.HashMap)              linkedMapOf()      O      kltlin.collections.LinkedHashMar(java.util.LinkedHashMap)              sortedMapOf()      O      kltlin.collections.SortedMap(java.util.SortedMap)        예제예제 코드 //자료를 수정할 수 없는 리스트 생성val immutableList: List&lt;String&gt; = listOf(\"Lorem\", \"ipsum\", \"dolor\", \"sit\")//컴파일 에러: 자료 수정을 위한 함수를 지원하지 않음immutableList.add(\"amet\")//자료를 수정할 수 있는 리스트 생성val mutableList: MutableList&lt;String&gt; = arrayListOf(\"Lorem\", \"ipsum\", \"dolor\", \"sit\")//자료 수정 가능mutableList.add(\"amet\")//자료를 수정하지 않는 자료형으로 재할당val immutableList2: List&lt;String&gt; = mutatbleList//컴파일 에러: 자료 수정을 위한 함수를 지원하지 않음immutableList2.add(\"amet\")","categories": ["Language"],
        "tags": ["Language_Kotlin"],
        "url": "https://codemcd.github.io/pages/CODEMCD/language/Kotlin-3.%EC%BB%AC%EB%A0%89%EC%85%98/",
        "teaser":null},{
        "title": "[Kotlin]4. 클래스 및 인터페이스",
        "excerpt":"클래스 및 인터페이스 클래스와 인터페이스의 선언 및 인스턴스 생성 1. 클래스   클래스를 선언하는 방법은 자바와 거의 동일하다.  예제예제 코드 //패키지 foo.bar에 포함된 클래스 Baz선언package foo.barclass Baz {  ---}//클래스 본체 없이 클래스를 선언할 수 있다.class Foo  코틀린에서 접근 제한자를 지정하지 않는 경우 public으로 간주한다.  코틀린에서는 키워드 ‘new’없이 인스턴스 생성이 가능하다.  예제예제 코드 val foo: Foo = Foo()//인자 하나를 받는 생성자로 인스턴스 생성val bar: Bar = Bar(1);2. 인터페이스   인터페이스의 생성은 자바와 비슷하지만, 인터페이스의 인스턴스 생성은 조금 다르다.  예제예제 코드 //인터페이스 선언interface Bar {  fun baz()}//인터페이스의 인스턴스 생성//object: [인터페이스 이름] 형태val bar = object: Bar {  override fun baz() {    //함수 구현  }}추상 클래스(abstract class)   추상 클래스의 선언 방법은 자바와 동일하지만, 인스턴스 생성은 다르며, 코틀린의 인터페이스의 인스턴스 생성과 유사하다.  추상 클래스에서는 인스턴스 생성 시 생성자를 사용하지만, 생성자가 없는 인스턴스는 인스턴스 이름만 사용한다.  예제예제 코드 //추상 클래스 선언abstract class Foo {  abstract fun bar()}//추상 클래스의 인스턴스 생성//object: [생성자] 형태val foo = object: Foo() {  override fun bar() {    //함수 구현  }}프로퍼티(property)   프로퍼티는 자료를 저장할 수 있는 필드(field)와 이에 상응하는 Getter/Setter 메서드를 함께 제공하며, 자바의 필드와 유사한 형태로 선안한다.          자바는 클래스내의 멤버함수에 접근하기 위해 Getter/Setter 메서드를 직접 추가해주어야 하기 때문에 코드의 양이 불필요하게 늘어난다.        프로퍼티 역시 ‘val’와 ‘var’ 중 하나로 선언해야 한다.          val: Getter 메서드만 존재한다.      var: Getter/Setter 메서드 모두 존재한다.        프로퍼티는 초기값을 명시적으로 지정해야 하며, 그렇지 않은 경우 컴파일 에러가 발생한다.  프로퍼티 선언 시점이나 생성자 호출 시점에 값을 할당하지 않을 경우 ‘lateinit’ 키워드를 사용하여 초기 할당없이 사용할 수 있다.          키워드 ‘lateinit’은 프로퍼티 값을 나중에 할당할 것이라고는 것을 명시하는 것으로서, ‘var’ 프로퍼티에만 사용가능하다.        프로퍼티 역시 타입 추론이 가능하기 때문에 타입 선언을 생략할 수 있다.  예제예제 코드 class Person {  //기본 예제  val name: String? = null  var address: String? = null  //lateinit  lateinit var adderss: String?  //타입 추론  var name = \"No Name\"  var address: String? = null  //null만으로는 타입을 추론할 수 없기 때문에 타입 선언이 필요하다.}접근 제한자   접근 제한자는 자바와 거의 동일하다.          제한자가 없으면 자동으로 public으로 간주한다.        자바와 다르게 ‘internal’ 접근 제한자가 존재한다.          자바에서 public의 접근 범위는 동일한 패키지 안이다. 하지만 외부 모듈이라도 패키지 이름이 같다면 접근이 가능하다.      위를 보완하기 위해 코틀린에서는 internal 접근 제한자를 제공한다.        ‘internal’ 접근 제한자의 범위는 동일한 모듈 내이다.          IntelliJ IDEA 모듈      Maven/Gradle 프로젝트      하나의 Ant 태스크 내에서 함께 컴파일되는 파일들      생성자 1. 기본 생성자   코틀린의 기본 생성자는 자바보다 더욱 직관적으로 정의한다.          init {} 사용        예제_ 예제 코드_ class Foo {  init {    //생성자에서 수행할 작업들...  }}2. 주 생성자(primary constructor)   생성자에 인자가 필요한 경우 주 생성자를 활용한다.  주 생성자로 클래스 내부의 프로퍼티를 대신해서 사용할 수 있으므로, 프로퍼티를 생략할 수 있다.  예제예제 코드 //기본 생성자에서 주 생성자의 인자를 사용할 수 있다.class Foo(a: Int) {  init {    Log.d(\"Foo\", \"Number: $a\")  }}//프로퍼티 대신 주 생성자를 사용할 수 있다.class Foo(val a: Int, var b: Char)3. 추가 생성자   주 생성자 외에 다른 형태의 생성자가 필요한 경우 ‘constructor’ 키워드를 사용하여 추가 생성자를 선언할 수 있다.  추가 생성자를 정의하는 경우 주 생성자를 반드시 호출해야 한다.  추가 생성자에서는 인자와 프로퍼티를 함께 선언할 수 없다.          프로퍼티 선언이 필요한 인자인 경우 반드시 주 생성자에서 이를 처리해야 한다.      예제        예제 코드     class Foo(val a: Int, var b: Char) {  //a값만 인자로 받는 추가 생성자  constructor(a: Int) : this(a, 0)  //두 인자의 값을 모두 0으로 지정하는 생성자  constructor() : this(0, 0)}      4. 생상자의 접근 제한자   생성자의 가시성을 변경하려면 constructor 키워드 앞에 접근 제한자를 추가하면 된다.  주 생성자는 생략하였던 constructor 키워드를 추가하고 그 앞에 접근 제한자를 추가해야 한다.  예제예제 코드 class Foo internal constructor(val a: Int, var b: Char) {  private constructor(a: Int) this(a, 0)  // 접근 제한자를 지정하지 않았으므로 public  constructor(): this(0, 0)}함수(function)   코틀린은 자바의 클래스 내 메서드를 함수로 표현한다.  함수에서 특별한 값을 반환하지 않는다면 ‘함수 자체’를 의미하는 Unit 타입을 반환하며, 이는 생략 할 수 있다.  예제예제 코드 class Foo {  //아무 값도 반환하지 않는 함수, 생략 가능  fun foo(): Unit { }  //정수 값을 반환하는 함수  private fun bar(): Int {    return 0  }}상속 및 인터페이스 구현   코틀린에서 상속 및 인터페이스는 키워드로 구분하는 자바와 달리 콜론(:) 뒤에 상속한 클래스나 구현한 인터페이스를 표기한다.  클래스를 상속하는 경우 반드시 부모 클래스의 생성자를 호출해야 한다.          부모 클래스의 생성자가 여러 개일 경우, 클래스의 선언부가 아닌 내부에서 호출할 수도 있다.        코틀린에서 부모 클래스의 메서드 재정의, 인터페이스 구현한 메서드는 앞에 ‘override’ 키워드를 반드시 붙여야 한다.          자바에서 이를 ‘@Override’ 어노테이션으로 구분하는데, 이는 선택 사항이다.        코틀린에서는 ‘open’ 키워드를 붙인 클래스나 함수만이 상속이나 재정의를 할 수 있다.          자바에서는 ‘final’ 키워드로 더 이상 상속이나 재정의를 할 수 없도록 한다.        예제예제 코드 // AppCompatActivity 상속: AppCompatActivity()로 기본 생성자를 바로 호출한다.// View.OnClickListener 구현class MyActivity: AppCompatActivity(), View.OnClickListener {  // AppCompatActivity의 onCreate() 메서드 상속  override fun onCreate(savedInstanceState: Bundle?) {    super.oncreate(savedInstanceState)  }  // View.OnClickListener 인터페이스 구현  override fun onClick(v: View) { }}// 'open' 키워드 사용 예제open class OpenClass {  open val openProperty = \"foo\"  val finalProperty = \"bar\"  open fun openFunc() { }  fun finalFunc() { }}// 성공: OpenClass 앞에 'open' 키워드가 있으므로 상속 가능한 클래스이다.class FinalClass : OpenClass() {  // 성공: '부모 클래스의 openProperty 변수 앞에 'open' 키워드가 있으므로 재정의가 가능한 프로퍼티이다.  override val openProperty = \"FOO\"  // 실패: 해당 프로퍼티에 'open' 키워드가 없다.  override val finalProperty = \"BAR\"  // 성공: '부모 클래스의 openFunc 함수 앞에 'open' 키워드가 있으므로 재정의가 가능한 함수이다.  override open fun openFunc() { }  // 실패: 해당 함수에 'open' 키워드가 없다.  override fun finalFunc() { }}// 실패: 해당 클래스에 'open' 키워드가 없다.class Foo : FinalClass()this   코틀린의 this 키워드는 자바와 거의 동일하다.  자바에서 {클래스 이름}.this를 코틀린에서는 this@{클래스 이름} 형태로 사용된다.정적 필드 및 메서드   코틀린에서는 자바와 달리 정적 필드와 메서드를 사용하여, 클래스 내에 상수를 정의하거나 static 메서드(인스턴스 생성 없이 사용할 수 있는 메서드)를 정의할 수 없다.  일반적인 경우 클래스 내에 선언했던 정적 필드나 메서드는 패키지 단위(package-level)로 선언할 수 있다.  패키지 단위로 선언한 값이나 함수는 패키지에 종속되므로 import {패키지 이름}.{값 혹은 함수 이름}으로 사용해야 한다.  예제자바 코드 //Foo.javapackage foo.bar;public class Foo {  //정적 필드 상수 선언  public static final int FOO = 123;  //정적(static) 메서드 선언  public static void foo() { }  //인스턴스 메서드: 인스턴스를 생성해야 사용할 수 있는 메서드  public void bar() { }}import foo.bar.Foo;public class Bar {  public void bar() {    //Foo클래스 내의 정적 필드 FOO의 값을 참조한다.    int foo = foo.Foo;    //Foo 클래스 내의 정적 메서드 foo를 호출한다.    Foo.foo();  }}코틀린 코드 //Foo.ktpackage foo.bar//값 FOO를 패키지 foo.bar에 선언한다.const val FOO = 123//함수 foo를 패키지 foo.bar에 선언한다.fun foo()class Foo {  //함수 bar는 Foo의 인스턴스를 생성해야 사용할 수 있다.  fun bar() { }}import foo.bar.Fooimport foo.bar.fooclas Bar {  //foo.bar 패키지 내의 FOO 값을 참조한다.  val foo = Foo  //foo.bar 패키지 내의 함수 foo를 호출한다.  foo()}  클래스 내 private로 선언된 멤버에 접근해야 하는 팩토리 메서드(factory method)는 패키지 단위 함수로 구현할 수 없다.          동반 객체(companion object)를 사용하면 클래스 내 모든 멤버에 접근할 수 있고, 인스턴스 생성 없이 호출가능한 함수를 작성할 수 있다.      동반 객체: 클래스별로 하나씩 클래스의 인스턴스 생성 없이 사용할 수 있는 오브젝트(object)를 정의할 수 있는데, 이를 동반 객체라 한다.      예제        class User private constructor(val name: String, val registerTime: Long) {  companion object {    //동반 객체는 클래스 내부에 존재하므로, private로 선언된 생성자에 접근할 수 있다.    fun create(name: String) : User {      return User(name, System.currentTimeMillis())    }  }}      싱글톤(singleton)   싱글톤은 단 하나의 인스턴스만 생성되도록 제약을 둔 디자인 패턴이다.  코틀린에서는 이를 단 한줄로 간편하게 선언할 수 있다.  예제object singletonenum 클래스 어노테이션 클래스(annotation class) 중첩 클래스(nested class) ","categories": ["Language"],
        "tags": ["Language_Kotlin"],
        "url": "https://codemcd.github.io/pages/CODEMCD/language/Kotlin-4.%ED%81%B4%EB%9E%98%EC%8A%A4%EB%B0%8F%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/",
        "teaser":null},{
        "title": "[Kotlin]5. 코틀린만의 클래스",
        "excerpt":"코틀린만의 클래스 데이터 클래스(data class)   데이터 클래스는 자료만을 저장하기 위해 사용하는 클래스이다.(메서드 없음)  사용 예제data class Person(val name: String, val address: String)  기본 생성자에서 선언된 속성을 통해, 컴파일러에서 자동으로 아래의 기능들을 만들어준다.          equals()      hashCode()      copy()      toString()      componentN() functions      만약 명시적으로 클래스 내에 선언해주는 경우, 해당 메서드는 컴파일러가 자동으로 생성해주지 않는다.        의미 있는 데이터 클래스 조건          기본 생성자에 1개 이상의 파라미터가 존재한다.      기본 생성자의 파라미터가 val, var로 선언되어 있다.      abstract, open, inner 키워드는 사용할 수 없다.      interface 구현과 한정 클래스(sealed class) 상속은 가능하다.        데이터 클래스는 componentN 함수를 사용하여, Destructuring Declarations가 가능하다.val person = User(\"Jane\", 35)val (name, age) = personprintln(\"$name, $age years of age\")// prints: \"Jane, 35 years of age\"한정 클래스(sealed class)   한정 클래스는 enum 클래스를 확장한 개념이다.          각 종류별로 하나의 인스턴스만 생성되어 있는 enum 클래스와 달리 잉ㄴ스턴스를 여러 개 생성 가능하다.        사용 예제// MoblieApp 한정 클래스와 이를 상속하는 Android, IOS 클래스sealed class MobileApp(val os: String) {  class Android(os: String, val packageName: String) : MobileApp(os)  calss IOS(os: String, val bundleId: String) : MobileApp(os)}  한정 클래스를 상속하는 클래스는 일반적으로 한정 클래스 내에 중첩하여 선언한다.          같은 파일 내에 정의한다면 클래스 외부에 선언 할수도 있다.        한정 클래스를 상속하는 클래스는 한정 클래스의 한 종류로 취급된다.  한정 클래스의 장점          한정 클래스로 취급된 여러 종류의 클래스마다 다른 작업을 처리해야할 때 유용하다.      임의의 클래스가 한정 클래스로 추가되었을 때 처리하는 작업이 간단하다.      대표적인 예제로 한정 클래스들로 when문을 처리할 때 이다.      프로퍼티의 사용자 지정 Getter/Setter   코틀린은 프로퍼티를 선언하면 자동으로 Getter/Setter를 내부에서 제공한다.  Getter/Setter 함수를 사용자가 필요에 맞게 수정하여 사용할 수 있다.          프로퍼티 선언과 함께 get(), set(value)로 같이 선언하면 된다.        선언 형식var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [=property_initializer&gt;]  [&lt;getter&gt;]  [&lt;setter&gt;]","categories": ["Language"],
        "tags": ["Language_Kotlin"],
        "url": "https://codemcd.github.io/pages/CODEMCD/language/Kotlin-5.%EC%BD%94%ED%8B%80%EB%A6%B0%EB%A7%8C%EC%9D%98%ED%81%B4%EB%9E%98%EC%8A%A4/",
        "teaser":null},{
        "title": "[Kotlin]6. 흐름 제어(control flow)",
        "excerpt":"흐름 제어(control flow) 자바와 동일한 구문   if-else문  while문, for문코틀린 구문 1. when문   when문은 자바의 switch문을 대체하며, 훨씬 더 많은 기능이 추가되었다.  when문은 각각의 branch의 조건문이 만족할 때까지 위에서 부터 순차적으로 인자를 비교한다.  when문 안의 else문은 다른 모든 branch가 조건에 성립하지 않을 때 수행된다.          else문은 필수로 있어야 하며, 없으면 컴파일 에러가 난다.      when문이 식으로 사용된 경우 else문이 없어도 된다는 것을 컴파일러가 입증할 수 있는 경우 생략 가능하다.        var res = when (x) {  true -&gt; \"맞다\"  false -&gt; \"틀리다\"}        사용 예제          기본 예제        when (x) {  1 -&gt; print(\"x == 1\")  2 -&gt; print(\"x == 2\")  else -&gt; { // Note the block    print(\"x is neither 1 nor 2\")  }}              여러 개의 조건이 사용된 경우        when (x) {  0, 1 -&gt; print(\"x == 0 or x == 1\")  else -&gt; print(\"otherwise\")}              조건에 함수나 식이 사용된 경우        when (x) {  parseInt(x) -&gt; print(\"s encodes x\")  1 + 3 -&gt; print(\"4\")  else -&gt; print(\"s does not encode x\")}              범위 연산자 ‘..’, collection에 ‘in’연산자로 범위를 검사하는 경우        val validNumbers = listOf(3, 6, 9)when (x) {  in validNumbers -&gt; print(\"x is valid\")  in 1..10 -&gt; print(\"x is in the range\")  !in 10..20 -&gt; print(\"x is outside the range\")  else -&gt; print(\"none of the above\")}              is 연산자를 이용하여 타입 검사를 하는 경우        //스마트 캐스트가 적용된다.fun hasPrefix(x: Any) = when(x) {  is String -&gt; x.startsWith(\"prefix\")  else -&gt; false}              when문에 인자를 입력하지 않으면 논리 연산을 검사한다. (if-else문 대체 가능)        when {  x.isOdd() -&gt; print(\"x is odd\")  x.isEven() -&gt; print(\"x is even\")  else -&gt; print(\"x is funny\")}      2. 범위 연산자   ..연산자//0부터 10까지, 시작과 끝을 포함하는 범위를 정의한다.val myRange: IntRange = 0..10  until 함수val items: List&lt;String&gt; = ... //항목이 담긴 리스트라고 가정val myRange: IntRage = 0..3//마지막 값을 포함하지 않는 범위, 즉 0, 1, 2, 3 의 인덱스를 나타낸다.val myRange: IntRage = 0 until 4  dounTo() 함수, step() 함수//2씩 감소하는 for문for (i in 5 downTo 1 step 2) {  System.out.print(i)}","categories": ["Language"],
        "tags": ["Language_Kotlin"],
        "url": "https://codemcd.github.io/pages/CODEMCD/language/Kotlin-6.%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4/",
        "teaser":null},{
        "title": "[C++ STL] next_permutation",
        "excerpt":"next_permutation next_permutation 함수는 원래 순서를 다음 사전 순서의 순열로 재배치해주는 함수이다. (사전 순서는 오름차순이라고 볼 수 있다.) 구문 template&lt;class BidirectionalIterator&gt;  bool next_permutation(    BidirectionalIterator _First,    BidirectionalIterator _Last  );//배치 순서를 직접 지정해줄 수 있다.template&lt;class BidirectionalIterator, class BinaryPredicate&gt;  bool next_permutation(    BidirectionalIterator _First,    BidirectionalIterator _Last,    BinaryPredicate _Comp  );  _First: 다음 순열로 배치할 배열의 첫 번째 원소를 가르키는 반복자.  _Last: 다음 순열로 배치할 배열의 마지막 원소를 가르키는 반복자.  _Comp: 두 개의 인수를 사용하여 순서 조건이 만족하면 true, 만족하지 않으면 false를 반환한다.  반환값: 다음 순열이 현재 순열보다 사전 편찬 상 다음 순서이면 true, 사전 편찬 상 가장 작은 순서이면 false를 반환한다.          반환값을 통해 주의할 점은 순열을 구할 초기 배열이 오름차순으로 정렬되어 있다면 모든 순열을 순조롭게 구할 수 있지만, 오름차순이 아니라면 중간에 사전 편찬 상 가장 작은 순서(즉, 오름 차순으로 된 순서)가 발견되면 false를 반환하여 순열을 구하는 반복문을 빠져나갈 수 있다.       코드 분석  위 코드는 algorithm 헤더파일에 있는 next_permutation 함수와 참고자료를 참고하여 만들었으며, int 배열에서만 동작한다. next_permutation 함수는 배열의 뒤에서 부터 탐색하여 사전 편찬 방식에서 그 다음 순열을 찾는다. 시간 복잡도는 (last - first) / 2 swap(reverse 함수의 시간 복잡도) * N(배열의 길이)이다. reference의 설명을 참고하면 O(N)으로 선형적이라고 설명하고 있다. 요구 사항   헤더:   네임스페이스: std예제 코드 #include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(void){\tint arr[4] = { 1, 2, 3, 4 };\tdo {\t\tfor (int i = 0; i &lt; 4; ++i)\t\t\tprintf(\"%d \", arr[i]);\t\tprintf(\"\\n\");\t} while (next_permutation(arr, arr + 4));\treturn 0;}1 2 3 41 2 4 31 3 2 41 3 4 21 4 2 31 4 3 22 1 3 42 1 4 32 3 1 42 3 4 12 4 1 32 4 3 13 1 2 43 1 4 23 2 1 43 2 4 13 4 1 23 4 2 14 1 2 34 1 3 24 2 1 34 2 3 14 3 1 24 3 2 1참고 자료   Microsoft MSDN next_permutation  http://jeonggyun.tistory.com/110","categories": ["Language"],
        "tags": ["Language_CCpp"],
        "url": "https://codemcd.github.io/pages/CODEMCD/language/CC++-next_permutation/",
        "teaser":null},{
        "title": "[Docker] Docker(도커)란?",
        "excerpt":"Docker란?  Docker는 부두 노동자라는 영어 단어로서, Linux 기반의 Container RunTime 오픈소스 가상화 플랫폼이다. 등장 배경 여러 OS와 플랫폼의 등장으로 서버를 관리하는데 비용이 너무나 커졌다. Linux, Windows, Mac과 같이 여러 운영체제가 존재하고 Linux 내에서도 CentOS, Ubuntu 등등 다양하다. 이에 더해 현재에는 클라우드 서비스가 활발하며, 클라우드 역시 AWS, Azure, 구글 클라우드 등 서버를 운영하기 위한 환경이 매우 다양하다. 하나의 서버에서 여러 프로그램을 설치하는 것에는 많은 충돌이 발생한다. 현재에는 위와 같이 여러 환경이 존재하기 때문에 가상머신을 여러 개 사용해야한다. 하지만 가상머신 기술은 전체 운영체제를 설치하는 방식이므로 매우 느리고 관리하기 힘들다. 이를 해결하기 위해 Docker가 등장한다. 가상머신(Virtual Machine) 가상머신은 하드웨어를 소프트웨어적으로 구현해서 그 위에서 운영체제를 작동하도록하는 기술이다. 즉, 리얼머신에서 하나의 운영체제가 동작하고 있는 상황에서 가상머신을 통해 다른 운영체제를 하나 더 사용할 수 있다. 가상화의 방식에는 전가상화(Full-Virtualization)과 반가상화(Para-Virtualization)으로 나뉜다. 전가상화는 하드웨어 자원을 완전히 가상화하는 방식이다. 그러므로 Guest OS를 아무런 수정없이 쉽게 도입이 가능하다. 하지만, CPU의 VT(Virtual Technology)를 이용하므로 오버헤드가 상당히 크다. 전가상화를 사용하는 플랫폼은 VMware, VirtualBox 등이 있다. 반가상화는 게스트 OS를 수정하여 게스트 OS가 가상화되고 있음을 인식하도록 하여 하이퍼바이저(Hyperviser, 가상화를 지원하는 소프트웨어)가 필요할 때만 호출되도록 한다. 반가상화는 게스트 OS를 수정해야 하므로 OS 소스코드에 접근가능해야 하므로 도입이 어렵다. 하지만, 가상화를 호출하는 빈도를 최소화하여 성능을 대폭 향상시킬 수 있다. 반가상화는 대표적으로 Xen이 있다.  가상머신 자체는 완전한 게스트 운영체제를 설치해야 하므로 용량이 크고 반가상화라 할지라도 리얼 머신에 비해 성능이 크게 감소된다. Docker Docker는 반가상화보다도 조금 더 경령화된 방식이다. Docker는 게스트 OS 자체를 설치하지 않고 운영에 필요한 프로그램과 라이브러리만 설치하여 이미지 크기를 대폭 줄였다. 그리고 시스템 콜과 같은 OS 자원은 호스트 OS와 공유한다.  Docker는 하이퍼바이저가 없기 때문에 리얼 머신과 성능이 거의 비슷하다. 아래의 표를 보면 확인할 수 있듯이 CPU, 메모리 접근, 파일 시스템 성능이 거의 똑같이 나오는 것을 볼 수 있고, 네트워크 속도 역시 비슷하게 측정된다고 한다.  Docker 구성 Docker는 크게 컨테이너(Container)와 이미지(Image)로 구성되어 있다. 컨테이너는 리눅스의 컨테이너 기술에서 왔으며, 이미지는 컨테이너 실행에 필요한 파일이다. 리눅스 컨테이너 LXC(Linux Container)는 운영 시스템 레벨의 가상화 방법이다. 단일 호스트 환경에서 여러 개의 고립된 리눅스 시스템(컨테이너)들을 사용하기 위해 만들어졌다. 이를 위해 리눅스 커널안에서 고립된 가상의 공간을 만든다고 볼 수 있다. 컨테이너는 가상머신과 달리 호스트 OS에서 바로 시작하여 훨씬 성능이 좋다. 컨테이너는 자체적인 그룹화를 시행하여 다른 그룹이나 그룹에 속하지 않는 프로세스들과 단절된 공간을 만든다. 컨테이너간 역시 서로 내부를 볼 수 없다. LXC는 리눅스 커널의 cgroups(Control Groups)와 namespaces(Namespace Isolation)를 결합하여 고립된 공간을 만든다. cgroups는 CPU, 메모리, 블록 I/O, 네트워크 등과 같은 자원을 할당한다. namespace isolation은 애플리케이션 입장에서 프로세스 트리, 네트워크, 사용자 ID, 마운트된 파일 등을 호스트와 완전히 격리하여 고립된 운영 환경을 만들고, 이는 cgroups에서 제공한다.  LXC는 리눅스가 제공하는 기술 중 하나인 “chroot”와 비슷하다. chroot는 프로세스의 루트 디렉토리를 변경하는 명령으로, 프로세스가 접근 할 수 있는 디렉트로리를 제한하거나 시스템 라이브러리와 관련 라이브러리를 로드할 수 있다. 하지만 이것만으로는 네트워크와 프로세스를 제어할 수 없었다. 이를 해결하기 위해 더 발전시킨 “jail” 기능이 만들어졌다. LXC는 jail과 유사한 개념으로 여러 자원을 제어 및 격리하는 기능이 구현되어 있다. Docker는 초기에는 LXC기반으로 컨테이너 생성 및 관리 기능 등 다양한 기능을 추가하였다. 버전 0.9 이후로는 libcontainer를 자체적으로 개발하여 사용하고 있으며, 옵션을 통해 LXC와 libcontainer를 선택적으로 사용할 수 있다.  이미지(Image) Docker 이미지는 보통 2가지로 구성되어 있다. 첫 번째는 리눅스 운영체제이다. 어떤 프로그램(예를들어, Nginx, MySQL 등)을 실행하려면 운영체제가 있어야 한다. Docker 이미지에서는 기본적으로 리눅스 배포판을 사용한다. 배포판에는 리눅스 부팅에 필요한 최소한의 실행 파일과 라이브러리가 존재한다. 배포판만으로도 패키징 시스템을 사용할 수 있다. 물론 다른 필요한 기능들을 추가하여 이미지를 만들 수도 있다. 두 번째는 사용할 애플리케이션이다. Docker 이미지 크기는 수메가에서 수기가바이트까지 필요에 따라 다양하지만, 운영체제 하나가 수십기가바이트이므로, 훨씬 작은 크기인 것을 알 수 있다. Docker 이미지는 Docker hub를 통해 대부분 공개되어 있어 필요에 따라 적절한 이미지를 찾아 사용할 수 있고, 자신이 만든 이미지 역시 등록할 수 있다. 컨테이너(Container) 컨테이너는 이미지 파일을 실행한 상태라고 볼 수 있다. 하나의 이미지로 여러 컨테이너를 만들 수 있고, 이들은 모두 독립적이다. 운영체제로 보면 이미지는 실행 파일이고, 컨테이너는 프로세스라고 볼 수 있다. 이미 실행된 컨테이너에서 해당 이미지가 변경된 부분을 바로 새로운 이미지로 만들 수도 있다. Docker layer Docker 이미지를 수정할 때마다 수백메가의 크기를 계속 다시 다운로드받는다면 엄청난 비효율을 가져온다. Docker는 이를 해결하기 위해 레이어(layer)라는 개념을 도입하여 유니온 파일 시스템(Union File System)을 사용한다. 이를 통해 여러 개의 레이어를 하나의 파일 시스템으로 사용할 수 있다. Docker 이미지는 읽기 전용 상태이다. 여기서 내용이 바뀌면 해당 이미지를 수정하지 않고, 쓰기 이미지를 생성한 뒤 수정된 내용만을 기록한다. 이러한 방식을 Union mount라고 한다. 예를 들어, Ubuntu 이미지가 A, B, C로 구성되어 있다. 여기서 웹서비스를 제공하기 위해 Nginx를 설치 한다. 그러면 기존의 Ubuntu에 Nginx라는 새로운 내용이 추가되어 새로운 이미지 (A, B, C), Nginx가 만들어진다. 마지막으로 애플리케시션 소스를 추가하면 최종으로 (A, B, C, Nginx), Source 이미지가 생성된다.  위 그림은 예제를 그림으로 표시한 것이다. 컨테이너를 생성할 때는 읽기/쓰기 레이어(R/W layer)를 기본적으로 추가하여 해당 이미지에서 변경된 내용을 저장한다. 이와 같이 이미지들은 수정될 때마다 새로운 이미지를 만들어내며, 기존의 이미지와 새로 만들어진 이미지 사이에 부모-자식 관계가 만들어진다. 위의 예제를 이러한 의존적 관계로 나타내면 아래 그림과 같다. Docker 이미지를 생성할 때는 바뀐 부분만 생성한 뒤 부모 이미지와 연결한다. 컨테이너를 실행하면 해당 이미지를 불러온 뒤 부모를 계속 참조하는 방식으로 동작한다.  Docker 이미지 파일을 Docker hub에 올릴 때는 부모 이미지들을 모두 포함하여 올린다. Dockerfile FROM node:9.4.0-alpineCOPY app.js .COPY package.json .RUN npm install &amp;&amp;\\    apk update &amp;&amp;\\    apk upgradeEXPOSE  8080CMD node app.jsDocker 이미지를 만들기 위해서는 Dockerfile을 빌드해야 한다. 이 파일은 DSL(Domain Specific Language)를 사용한다. 이 파일은 해당 이미지를 생성하기 위해서 필요한 여러 사전 작업을 명시하여 실행시킨다. 여러 의존성 패키지를 설치하거나 포트를 연결해주는 일 등을 한다. DSL   FROM: 어떤 이미지를 기반으로 할지 설정  MAINTAINER: 이미지 작성자 정보  RUN: 이미지에서 스크립트나 명령 실행  CMD: 컨테이너가 시작되었을 때 스크립트나 명령 실행  ENTRYPOINT: 컨테이너가 시작되었을 때 스크립트나 명령 실행(docker run에서 처리 방식이 다름)  EXPOSE: 호스트와 연결할 포트 번호 설정  ENV: 환경 변수 설정  ADD, COPY: 이미지에 파일 추가  VOLUME: 데이터를 호스트에 저장하도록 설정  USER: 명령을 실행할 사용자 계정 설정  WORKDIR: 명령을 실행할 디렉토리 설정  ONBUILD: FROM으로 이미지가 사용될 때 실행할 명령 설정이미지 만들기 예제 간단하게 웹(web)에 글을 출력하는 이미지 파일을 만들어보자. 이를 위해 아래의 3개의 파일이 필요하고, 해당 디렉토리안에서 명령어를 사용해야 한다.   DockerfileFROM node:9.4.0-alpineCOPY app.js .COPY package.json .RUN npm install &amp;&amp;\\    apk update &amp;&amp;\\    apk upgradeEXPOSE  8080CMD node app.js  app.jsvar express = require('express')var os = require(\"os\");var hostname = os.hostname();var app = express()app.get('/', function(req, res) {  res.send('Hello world from ' + hostname + '! Your app is up and running in a cluster!\\n')})app.listen(8080, function() {  console.log('Sample app is listening on port 8080.')})  package.json{  \"name\": \"hello-world-demo\",  \"private\": false,  \"version\": \"0.0.1\",  \"description\": \"Basic hello world application for Node.js\",  \"dependencies\": {    \"express\": \"3.x\"  }}  이미지 빌드(Build)docker image build -t hello-world:1 .          docker build        -t: tag의 약자로 해당 이미지에 이름을 붙인다.(이름:버전 양식)        이미지 확인docker image ls  이미지 세부 사항docker image inspect hello-world:1  이미지 실행docker container run -d -p 8080:8080 -v /root/date:/date --name hello-world-a hello-world:1          -d: 컨테이너를 백그라운드로 실행한다.      -p Host Port:Container Port: 호스트 포트와 컨테이너 포트를 연결하고 외부에 노출시킨다. http://:8080에 접속하면 컨테이너의 8080번 포트로 접속된다.      -v Host Directory:Container Directory: volume의 약자로 호스트의 디렉토리를 컨테이너 디렉토리에 연결한다. 그러면 호스트의 디렉토리에 파일을 컨테이너에서 사용할 수 있다.(변경사항들도 모두 적용된다.)      --name: 이미지 이름을 설정한다.            컨테이너 확인docker container ls     실행 결과 화면 참고 자료   전가상화와 반가상화  리눅스 컨테이너  Docker  Docker 예제","categories": ["Study"],
        "tags": ["Study_Cloud"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/Docker-WhatIsDocker/",
        "teaser":null},{
        "title": "[Reference]자주쓰는 MathJax 문법",
        "excerpt":"블로그 post를 작성할 때, 수학식을 사용해야할 경우가 있었다. 그래서 구글링을 해본 결과 jekyll에서 MathJax를 사용하는 방법이 있었다. MathJax란? Mathjax는 MathML, LaTeX 및 ASCIIMAthML 마크 업을 사용하여 웹 브라우저에 수학 표기법을 표시하는 크로스 브라우저 JavaScript 라이브러리이다. 그리고 Apache 라이센스에 따라 오픈 소스 소프트웨어이다. (출처: 위키백과) MathJax 사용법 먼저, post에서는 front matter에 use_math: true를 추가하고 MathJax 양식대로 쓰면 자동으로 렌더링하여 표시해준다. MathJax 사용법은 2가지가 있는데, $나 $$를 수식 앞뒤에 선언해주어야 한다. $ 는 수학식을 문장 사이에 넣을 때 사용하고, $$ 는 수학식으로 해당 줄을 모두 채우고 싶은 경우에 사용한다. 자주쓰는 수식 자주 사용하는 수학식을 만드는 MathJax를 모아보았다. 수식 =&gt; 결과 로 표현하였다. 수식을 복사하여 위에 설명한 MathJax 사용법대로 선언하여 사용할 수 있다. 사칙 연산   A + B = C =&gt; $A + B = C$  A - B = C =&gt; $A - B = C$  A * B = C =&gt; $A * B = C$  A \\times B = C =&gt; $A \\times B = C$  A / B = C =&gt; $A / B = C$  A \\div B = C =&gt; $A \\div B = C$지수 표현   e^x =&gt; $e^x$  a_i =&gt; $a_i$  a_i-1 =&gt; $a_i-1$  a_{i-1} =&gt; $a_{i-1}$  x^2 + 2x + 1 =&gt; $x^2 + 2x + 1$  a_i^2 =&gt; $a_i^2$  a_{i-1}^2x+3 =&gt; $a_{i-1}^2x+3$  a_{i-1}^{2x+3} =&gt; $a_{i-1}^{2x+3}$  {a^b}^c =&gt; ${a^b}^c$부등식   A &lt; B =&gt; $A &lt; B$  A \\le B =&gt; $A \\le B$  A &gt; B =&gt; $A &gt; B$  A \\ge B =&gt; $A \\ge B$  A = B =&gt; $A = B$  A \\ne B =&gt; $A \\ne B$…   A_1, A_2, \\ldots, A_{N-1}, A_N =&gt; $A_1, A_2, \\ldots, A_{N-1}, A_N$  A_1 + A_2 + \\cdots + A_{N-1} + A_N =&gt; $A_1 + A_2 + \\cdots + A_{N-1} + A_N$Root   \\sqrt{2} =&gt; $\\sqrt{2}$  \\sqrt{x^2} =&gt; $\\sqrt{x^2}$  \\sqrt[3]{x^2} =&gt; $\\sqrt[3]{x^2}$분수   \\dfrac 은 큰 분수(display), \\cfrac 은 연속 분수(continued)  \\frac{A}{B} =&gt; $\\frac{A}{B}$  \\frac{2}{3} + \\frac{3}{4} =&gt; $\\frac{2}{3} + \\frac{3}{4}$  \\frac{dy}{dx} =&gt; $\\frac{dy}{dx}$  \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} =&gt; $\\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$  x = a_0 + \\cfrac{1}{a_1 + \\cfrac{1}{a_2 + \\cfrac{1}{a_3}}} =&gt; $x = a_0 + \\cfrac{1}{a_1 + \\cfrac{1}{a_2 + \\cfrac{1}{a_3}}}$괄호   괄호 안에 들어가는 수식과 괄호의 길이를 맞춰주려면, 여는 괄호 앞에 \\left, 닫는 괄호 앞에 \\right 를 선언해야한다.  \\left( \\frac{ \\frac{A}{B} }{ \\frac{C}{D} } \\right) =&gt; $\\left( \\frac{ \\frac{A}{B} }{ \\frac{C}{D} } \\right)$  \\lfloor \\frac{x}{2} \\rfloor \\left\\lfloor \\frac{x}{2} \\right\\rfloor =&gt; $\\lfloor \\frac{x}{2} \\rfloor \\left\\lfloor \\frac{x}{2} \\right\\rfloor$  \\lceil \\frac{x}{2} \\rceil \\left\\lceil \\frac{x}{2} \\right\\rceil =&gt; $\\lceil \\frac{x}{2} \\rceil \\left\\lceil \\frac{x}{2} \\right\\rceil$                              |x| \\|x\\| =&gt; $          x          |x|$                    시그마   \\sum {x} =&gt; $\\sum {x}$  \\sum_1^n {x} =&gt; $\\sum_1^n {x}$  \\sum_{i=1}^{\\infty} {i^2} =&gt; $\\sum_{i=1}^{\\infty} {i^2}$  \\prod \\coprod \\bigcup \\bigcap \\bigvee \\bigwedge =&gt; $\\prod \\coprod \\bigcup \\bigcap \\bigvee \\bigwedge$인테그럴   \\int_{a}^{b}{f(x)dx} =&gt; $\\int_{a}^{b}{f(x)dx}$삼각함수   sin(x) =&gt; $sin(x)$  \\sin^{2}{x} =&gt; $\\sin^{2}{x}$로그(Log)   \\log{N} =&gt; $\\log{N}$  \\log_2{N} =&gt; $\\log_2{N}$집합 관계   A \\cap B =&gt; $A \\cap B$  A \\cup B =&gt; $A \\cup B$행렬   \\begin{matrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\end{matrix} =&gt; $\\begin{matrix} 1 &amp; 2 \\ 3 &amp; 4 \\end{matrix}$  \\begin{pmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\end{pmatrix} =&gt; $\\begin{pmatrix} 1 &amp; 2 \\ 3 &amp; 4 \\end{pmatrix}$  \\begin{bmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\end{bmatrix} =&gt; $\\begin{bmatrix} 1 &amp; 2 \\ 3 &amp; 4 \\end{bmatrix}$기타   \\lim_{x \\to 0} {x^2} =&gt; $\\lim_{x \\to 0} {x^2}$  A \\equiv B \\pmod n =&gt; $A \\equiv B \\pmod n$  \\mathbf{알파벳} =&gt; $\\mathbf{A}$","categories": ["Toy"],
        "tags": ["Toy_Blog"],
        "url": "https://codemcd.github.io/pages/CODEMCD/toy/Blog-Reference-%EC%9E%90%EC%A3%BC%EC%93%B0%EB%8A%94-MathJax-%EB%AA%85%EB%A0%B9%EC%96%B4/",
        "teaser":null},{
        "title": "[jsdsLib]라이브러리 분석",
        "excerpt":"List 이 라이브러리의 리스트는 doubly linked list 이다. 구현의 편의성을 위해서 head 와 tail 부분에 dummy 노드를 가르키게 하였다.  Stack 일반적인 배열 스택이다. 배열의 맨 뒤의 데이터가 삽입, 삭제되므로 시작복잡도는 O(1) 을 보장한다. Queue 배열로 만들어진 큐이다. 큐는 맨 앞의 데이터가 삭제되므로, 일반적인 자바스크립트에서 .shift() 매서드를 사용하면 O(N) 으로 성능이 좋지 않다. 맨 앞의 데이터를 삭제하고 나머지 데이터들을 모두 앞으로 한 칸씩 당겨야하기 때문이다. 이를 개선하기 위해서 맨 앞의 데이터를 삭제하지만, 매번 나머지 데이터들을 앞으로 당기지 않도록 한다. 먼저, 코드를 보자. var dequeueData = this._dataArray[this._frontIdx++];if(this._frontIdx * 1.5 &gt; this._dataArray.length) {  this._dataArray = this._dataArray.slice(this._frontIdx);  this._frontIdx = 0;}return dequeueData;위는 실제 라이브러리 dequeue() 함수 부분이다. _frontIdx 변수는 배열의 맨 앞의 데이터를 가르킨다. 맨 앞의 데이터를 삭제하고 이 변수를 한 칸 앞으로 옮겨준다. 이러한 수행에서 시간복잡도는 O(1) 이다. 하지만 삽입, 삭제 연산이 늘어날수록 배열의 크기도 계속 늘어나는 단점이 있다. 이를 보완하기 위해 삭제된 데이터 공간이 일정량 쌓이면, 배열 전체를 인덱스가 0인 기준으로 재배치해준다. Deque Deque(덱, 데크) 는 스택과 큐를 합친 자료구조이다. 여기에 더해 맨 앞에서도 데이터를 추가할 수 있다. 맨 앞의 데이터를 삭제하는 연산을 .shift() 매서드를 쓰지 않고 좀 더 성능을 개선한 방법은 위의 큐에서 설명하였다. 하지만 맨 앞에 데이터를 추가하는 것 역시 일반적인 .unshift() 매서드를 사용한다면 성능이 좋지않다. 이를 개선하기 위해 npm 패키지 중 deque 를 구현한 코드를 참고하였다. 아직까지 완전한 이해를 하지 못하여 추후에 좀 더 분석하여 올릴 예정이다.   참고 코드: https://github.com/petkaantonov/deque/blob/master/src/deque.jsPriority Queue V1.1.0 우선 순위 큐는 일반적인 heap 를 이용하여 구현하였다. 조금의 성능 개선을 위해 데이터를 삽입 또는 삭제한 후의 다시 heap 배열의 우선 순위를 맞추는 연산에서 실제 데이터 사이 교환(swap)을 하지 않고 인덱스만 저장한다. 그리고 최종 인덱스에 데이터를 저장하는 방식으로 구현되어 있다. V1.2.0 Priority Queue 의 성능 향상을 위해 enqueue(), dequeue() 함수를 변경하였다. 배열 힙을 사용한 것과 삽입, 삭제 알고리즘은 변경하지 않았다. 아래의 링크의 코드를 참조하였고, 변경사항은 아래와 같다.   부모, 자식 인덱스 계산을 비트 계산으로 변경하였다.  배열 힙의 첫 인덱스를 1에서 0으로 변경하였다.(이 부분에서 큰 시간 차이가 난 것을 툴을 이용해 확인하였다.)  데이터 삽입, 삭제시 배열 내부 매서드인 push(), pop() 로 실제 힙의 배열 데이터를 조정한다.  참고 코드: https://github.com/mourner/tinyqueue성능 분석 jsdsLib 의 자료구조의 웹 브라우저에서 성능을 확인하기 위해 간단히 툴을 이용하여 실험해보았다. 측정 환경   Tool: jsMatch (네이버 오픈소스, 자바스크립트 성능 측정 도구)  브라우저: chrome  측정 매서드: 각 자료구조에서 데이터를 삽입, 삭제하는 연산을 측정하였다.          List: push_front(), pop_front()      Stack: push(), pop()      Queue: enqueue(), dequeue()      Deque: unshift(), shift()      Priority Queue: push(), pop()        데이터 개수는 각각 삽입 연산, 삭제 연산 분리하여 적용하였다.(예를 들어, 데이터 개수가 100만개라면, 삽입 연산 100만 번, 삭제 연산 100만 번을 수행한다.)V1.1.0 측정 결과 v1.1.0 에서 추가한 5가지 자료구조 List, Stack, Queue, Deque, Priority Queue 의 성능을 측정하였다.                    1,000,000      5,000,000      10,000,000      20,000,000                  List      0.186s      1.35s      2.711s      6.055s              Stack      0.0585s      0.22s      0.472s      0.72s              Queue      0.079s      0.322s      0.458s      1.012s              Deque      0.1225s      0.638s      1.267s      2.818s              Priority Queue      0.279s      1.378s      2.838s      5.72s        데이터 100만 개 결과: http://jindo.dev.naver.com/jsMatch/index.html?d=367&amp;openResult=1  데이터 500만 개 결과: http://jindo.dev.naver.com/jsMatch/index.html?d=368&amp;openResult=1  데이터 1000만 개 결과: http://jindo.dev.naver.com/jsMatch/index.html?d=369&amp;openResult=1  데이터 2000만 개 결과: http://jindo.dev.naver.com/jsMatch/index.html?d=370&amp;openResult=1V1.2.0 측정 결과 V1.2.0 에서 변경된 사항은 Priority Queue 의 성능 향상을 위해 enqueue(), dequeue() 함수를 수정하였다. 성능 향상을 확인하기 위해 위에서 사용한 툴을 이용하여 v1.1.0 Priority Queue 와 v1.2.0 Priority Queue 를 비교 수행하였다. 결과는 아래의 표와 같다.                    1,000,000      5,000,000      10,000,000      20,000,000                  v1.1.0      0.293s      1.456s      2.833s      6.454s              v1.2.0      0.253s      1.264s      2.437s      4.836s        데이터 100만개 결과: http://jindo.dev.naver.com/jsMatch/index.html?d=371&amp;openResult=1데이터 개수가 적을 때는 효과가 적지만 데이터가 많아질수록 수행 시간 차이가 커지는 것을 확인할 수 있다. 자바스크립트   특징  한계: function 내부 private 변수 관련","categories": ["Toy"],
        "tags": ["Toy_jsdsLib"],
        "url": "https://codemcd.github.io/pages/CODEMCD/toy/jsdsLib-jsdsLib-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EB%B6%84%EC%84%9D/",
        "teaser":null},{
        "title": "[jsdsLib]Data Structures Visualizations",
        "excerpt":"이 문서는 오픈소스 Data Structures Visualizations 튜토리얼 부분을 번역한 것입니다.       오타, 잘못된 번역이 많을 수 있습니다. 감안하고 읽어주세요…   원문   https://www.cs.usfca.edu/~galles/visualization/source.htmlSource Code 주의사항   이 소스 코드를 보고 알고리즘을 이해할려고 하지 마십시오. 이 소프트웨어는 알고리즘을 시각화하는 프로퍼티를 만들기 위해 한 두개의 이해하기 힘든 알고리즘을 구현하였습니다. 적절한 소스 코드를 얻을려면 favorte textbook이나 위키디피아를 참고할 것을 추천합니다.  다른 모든 소프트웨어들과 같이 이 프로젝트는 주기적으로 업데이트를 하고 있습니다. 이 프로젝트은 자바 프로젝트로 시작하여, ActionScript3(flash)로 다시 구현되었고, 자바스크립트에 이식하였습니다. 이는 플래시와 자바스크립트를 공부할 수 있는 기회였고, 시간이 지나면서 이미 이 소프트웨어가 반 이상 진행된 후였습니다. 현재까지 코드를 최적화하고 있지만 아직까지 최적화해야할 곳이 어느정도 많이 남아있습니다. 다음 버전에서는 더 발전해 있을 것입니다.Visualization Creation Tutorial 새로운 시각화를 만들기 위해서는 자바스크립트(.js)파일과 HTML(.html) 파일이 필요합니다. HTML 파일은 한 템플릿이 필요하고, 한 두가지 정도 변경되어야 합니다(자바스크립트 파일 이름과 같은 것들). HTML 템플릿의 예제들과 이것을 어떻게 변경할 지에 대해서는 튜토리얼 마지막에 있습니다. 자바스크립트 파일에서는 다음의 기능을하는 function 을 생성합니다.   시각화를 조정할 적절한 control 들을 만든다.(element 를 삽입하거나 삭제하는 기능 등)  시각화를 구현하는 control 들을 위한 콜백 함수를 만든다. 이 시각화는 애니메이션 관리자에게 문자열 배열을 보냄으로서 구현된다. 이 애니메이션 관리자는 애니메이션을 구현할 것이고, 모든 애니메이션 control 을 관리한다.  애니메이션 관리자로부터 undo 이벤트를 위한 listen 함수를 실행하며, undo 이벤트가 감지되면 마지막 작업을 되돌린다. (roll back)Using Algorithm function 해당 라이브러리를 사용하더라도 자바스크립트 function 을 만드는 것은 꽤 복잡합니다. 만약 만들고자 하는 함수가 이 Algorithm 함수(AlgorithmLibrary/Algorithm.js) 하위 클래스로 만든다면, 많은 복잡한 세부사항들을 자동화할 수 있습니다. 압축 파일에 포함되어 있는 “MyAlgorithm”(AlgorithmLibrary/MyAlgorithm.js) 함수들을 기반으로 사용할 수 있습니다. 이 프로젝트는 FreeBSD 라이센스를 따릅니다. 모든 코드 파일에는 아래와 같은 라이선스 세부사항이 표시되어 있습니다. // Copyright 2011 David Galles, University of San Francisco. All rights reserved.//// Redistribution and use in source and binary forms, with or without modification, are// permitted provided that the following conditions are met://// 1. Redistributions of source code must retain the above copyright notice, this list of// conditions and the following disclaimer.//// 2. Redistributions in binary form must reproduce the above copyright notice, this list// of conditions and the following disclaimer in the documentation and/or other materials// provided with the distribution.//// THIS SOFTWARE IS PROVIDED BY David Galles ``AS IS'' AND ANY EXPRESS OR IMPLIED// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND// FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  OR// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.//// The views and conclusions contained in the software and documentation are those of the// authors and should not be interpreted as representing official policies, either expressed// or implied, of the University of San Francisco다음은 알고리즘 정의입니다. 자바스크립트 내에서 일종의 가짜(faked) 상속을 사용하고 있습니다. 이 프로젝트의 함수를 다음과 같이 정의합니다.   함수 프로토타입은 슈퍼 클래스의 프로토타입으로 설정한다.  생성자를 우리 자신의 생성자로 재설정한다.  슈퍼 클래스 프로토타입을 캐시한다.위는 자바의 ‘super’ 호출과 같은 기능을 구현하기 위함입니다. 이렇게 상속을 구현한 것은 생성자가 정상적으로 동작하기 위한 것입니다. 그리고 메인 생성자 함수가 init 함수를 호출하는 것 외에는 어떠한 기능도 하지 않습니다.(이 방법은 슈퍼 클래스의 init 함수를 호출할 수도 있습니다. 하지만 이는 보안적으로 매우 위험합니다.) function MyAlgorithm(am, w, h){\tthis.init(am, w, h);}MyAlgorithm.prototype = new Algorithm();MyAlgorithm.prototype.constructor = MyAlgorithm;MyAlgorithm.superclass = Algorithm.prototype;각 함수는 자신의 생성자를 가지고 있습니다. 일반적으로, 각 자신의 생성자에서 다음과 같은 것들이 필요할 것이라고 예상합니다.   슈퍼 클래스 생성자를 호출한다. 자바스크립트 문법에 따르면, 이것은 약간 이상할 수 있습니다. 그러나 이 프로젝트는 자바스크립트의 전통적인 객체 지향 패러다임에 지향하고 있지만, 이것이 구현에서 조금 어렵고 복잡할 수 있습니다.  필요한 컨트롤러를 추가한다.  메모리 매니저를 초기화한다. 대부분의 경우에는 매우 간단한 메모리 매니저를 사용할 것입니다. – 오래된 파스칼 스타일의 “Never free” 메모리 매니저입니다. 리스트는 0부터 시작해서 새로운 메모리가 필요할 때마다 증가시킵니다.  사용하게 될 자료 구조를 초기화 한다.MyAlgorithm.prototype.init = function(am, w, h){\t// Call the unit function of our \"superclass\", which adds a couple of\t// listeners, and sets up the undo stack\tMyAlgorithm.superclass.init.call(this, am, w, h);\tthis.addControls();\t// Useful for memory management\tthis.nextIndex = 0;\t// TODO:  Add any code necessary to set up your own algorithm.  Initialize data\t// structures, etc.}control 을 추가하는 함수가 있습니다. 여기에는 control 을 추가하는 helper 함수 역시 몇 가지 있습니다. Algorithm.js 파일을 보면 helper 함수에 대한 정보를 알 수 있습니다. MyAlgorithm.prototype.addControls =  function(){\tthis.controls = [];    // Add any necessary controls for your algorithm.    //   There are libraries that help with text entry, buttons, check boxes, radio groups    //    // To add a button myButton:    //     this.mybytton = addControlToAlgorithmBar(\"Button\", \"MyButtonText\");    //     this.mybytton.onclick = this.myCallback.bind(this);    //     this.controls.push(this.mybutton);    //   where myCallback is a method on this function that implemnts the callback    //    // To add a text field myField:    //    this.myField = addControlToAlgorithmBar(\"Text\", \"\");    //    this.myField.onkeydown = this.returnSubmit(this.myField,      //                                               this.anotherCallback.bind(this), // callback to make when return is pressed    //                                               maxFieldLen,                     // integer, max number of characters allowed in field    //                                               intOnly);                        // boolean, true of only digits can be entered.    //    this.controls.push(this.myField);    //    // To add a textbox:    //   \tthis.myCheckbox = addCheckboxToAlgorithmBar(\"Checkbox Label\");    //      this.myCheckbox.onclick = this.checkboxCallback.bind(this);    //      this.controls.push(myCheckbox);    //    // To add a radio button group:    //\t  this.radioButtonList = addRadioButtonGroupToAlgorithmBar([\"radio button label 1\",    //                                                              \"radio button label 2\",    //                                                              \"radio button label 3\"],    //                                                             \"MyButtonGroupName\");    //    this.radioButtonList[0].onclick = this.firstRadioButtonCallback.bind(this);    //    this.controls.push(this.radioButtonList[0]);    //    this.radioButtonList[1].onclick = this.secondRadioButtonCallback.bind(this);    //    this.controls.push(this.radioButtonList[1]);    //    this.radioButtonList[2].onclick = this.thirdRadioButtonCallback.bind(this);    //    this.controls.push(this.radioButtonList[1]);    //    // Note that we are adding the controls to the controls array so that they can be enabled / disabled    // by the animation manager (see enableUI / disableUI below)}매서드를 리셋하기 위한 “override” 가 필요합니다. 애니메이션 매니저가 undo 작업을 할 때 마다 아래와 같은 작업을 수행합니다.   이 리셋 매서드가 호출된다. 이 매서드는 해당 오브젝트의 상태를 리셋합니다. 정확히는 해당 작업이 수행되기 전으로 되돌립니다.  마지막에 진행되었던 모든 작업을 포함한다.(애니메이션 정보가 삭제되어도 상관없습니다.)  우리가 수행했던 마지막 작업 바로 전의 상태로 되돌리고 종료된다.MyAlgorithm.prototype.reset = function(){\t// Reset all of your data structures to *exactly* the state they have immediately after the init\t// function is called.  This method is called whenever an \"undo\" is performed.  Your data\t// structures are completely cleaned, and then all of the actions *up to but not including* the\t// last action are then redone.  If you implement all of your actions through the \"implementAction\"\t// method below, then all of this work is done for you in the Animation \"superclass\"\t// Reset the (very simple) memory manager\tthis.nextIndex = 0;}  콜백 함수//////////////////////////////////////////////// Callbacks://////////////////////////////////////////////////   All of your callbacks should *not* do any work directly, but instead should go through the//   implement action command.  That way, undos are handled by ths system \"behind the scenes\"////   A typical example:////MyAlgorithm.prototype.insertCallback = function(event)//{//\t// Get value to insert from textfield (created in addControls above)//\tvar insertedValue = this.insertField.value;////  // If you want numbers to all have leading zeroes, you can add them like this://\tinsertedValue = this.normalizeNumber(insertedValue, 4);////  // Only do insertion if the text field is not empty ...//\tif (insertedValue != \"\")//\t{//\t\t// Clear text field after operation//\t\tthis.insertField.value = \"\";//      // Do the actual work.  The function implementAction is defined in the algorithm superclass//\t\tthis.implementAction(this.insertElement.bind(this), insertedValue);//\t}//}//  Note that implementAction takes as parameters a function and an argument, and then calls that//  function using that argument (while also storing the function/argument pair for future undos)//////////////////////////////////////////////// Doing actual work////////////////////////////////////////////////   The functions that are called by implementAction (like insertElement in the comments above) need to:////      1. Create an array of strings that represent commands to give to the animation manager//      2. Return this array of commands////    We strongly recommend that you use the this.cmd function, which is a handy utility function that//    appends commands onto the instance variable this.commands////    A simple example:////MyAlgorithm.simpleAction(input)//{//\tthis.commands = [];  // Empty out our commands variable, so it isn't corrupted by previous actions////\t// Get a new memory ID for the circle that we are going to create//\tvar circleID = nextIndex++;//\tvar circleX = 50;//\tvar circleY = 50;////\t// Create a circle//\tthis.cmd(\"CreateCircle\", circleID, \"Label\",  circleX, circleY);//\tcircleX = 100;//\t// Move the circle//\tthis.cmd(\"Move\", circleID, circleX, circleY);//\t// First Animation step done//\tthis.cmd(\"Step\");//\tcircleX = 50;//\tcircleY = 100;//\t// Move the circle again//\tthis.cmd(\"Move\", circleID, circleX, circleY);//\t// Next Animation step done//\tthis.cmd(\"Step\");//\t// Return the commands that were generated by the \"cmd\" calls://\treturn this.commands;//}  UI 사용/사용안함// Called by our superclass when we get an animation started event -- need to wait for the// event to finish before we start doing anythingMyAlgorithm.prototype.disableUI = function(event){\tfor (var i = 0; i &lt; this.controls.length; i++)\t{\t\tthis.controls[i].disabled = true;\t}}// Called by our superclass when we get an animation completed event -- we can/// now interact again.MyAlgorithm.prototype.enableUI = function(event){\tfor (var i = 0; i &lt; this.controls.length; i++)\t{\t\tthis.controls[i].disabled = true;\t}}  시작 스크립트////////////////////////////////////////////////////////////// Script to start up your function, called from the webapge:////////////////////////////////////////////////////////////var currentAlg;function init(){\tvar animManag = initCanvas();\tcurrentAlg = new MyAlgorithm(animManag, canvas.width, canvas.height);}Animation Commands 사용자가 애니메이션 매니저에게 전달하는 명령어는 문자열 리스트(배열) 입니다. 각 문자열은 명령어의 이름(대소문자 구분 안 함)과 함께 &lt;;&gt; 토큰으로 구분된 매개변수 리스트로 시작합니다. 명령어의 첫 번째 매개변수의 대부분은 생성하거나 접근할려는 오브젝트의 ID 입니다. 예를들어, 오브젝트 ID 37 을 (100, 200) 위치로 이동하는 문자열은 아래와 같습니다. \"Move&lt;;&gt;37&lt;;&gt;100&lt;;&gt;120\"명령어는 두 그륩으로 분리됩니다.   애니메이션 오브젝트를 만드는 명령어  이미 만들어진 오브젝트를 조작하는 명령어Object Creation and Deletion Commands 오브젝트 생성 명령어의 첫 번째 매개변수는 생성할 오브젝트의 인덱스를 나타내는 정수를 사용합니다. 이 정수 번호는 현재 시스템에서 활성화중인 다른 오브젝트 번호와 중복되어선 안됩니다.(오브젝트가 삭제가 된다면 삭제된 오브젝트의 번호는 재사용을 할 수 있습니다.) 해당 명령어 역시 다른 모든 명령어와 같이, 필수 매개변수와 옵션 매개변수를 가집니다.   CreateCircle: objectID, label, [initial_x, initial_y]          objectID: ID 번호는 음수가 아닌 정수여야 하고, 다른 활성화된 ID 번호와 중복이 되어서는 안됩니다. 그리고 성능을 위해 가능한 ID 번호의 크기가 작은 것이 좋습니다.      label: 원에 나타날 데이터입니다. 이 데이터는 원 중앙에 표시되고, 문자열이라면 개행 문자(\\n)를 사용할 수 있습니다.      initial_x: (optional, defaults to 0) 원의 초기 x 좌표      initial_y: (optional, defaults to 0) 원의 초기 y 좌표        CreateRectange: objectID, label, width, height, [initial_x, initial_y, xJustify, yJustufy, backgroundColor, foregroundColor]          objectID: ID 번호는 음수가 아닌 정수여야 하고, 다른 활성화된 ID 번호와 중복이 되어서는 안됩니다. 그리고 성능을 위해 가능한 ID 번호의 크기가 작은 것이 좋습니다.      label: 사각형에 나타날 데이터입니다. 이 데이터는 사각형 중앙에 표시되고, 문자열이라면 개행 문자(\\n)를 사용할 수 있습니다.      width: 사각형의 넓이(pixel 단위)      height: 사각형의 높이(pixel 단위)      initial_x: (optional, defaults to 0) 사각형의 초기 x 좌표      initial_y: (optional, defaults to 0) 사각형의 초기 y 좌표      xJustify: (optional, defaults to “center”) 중앙, 오른쪽, 왼쪽 중 위치를 선택할 수 있고 만약 사각형 위치가 (x, y) 이라면, x 는 선택된 위치에 나타납니다.      yJustify: (optional, defaults to “center”). 중앙, 위, 아래 중 위치를 선택할 수 있고 만약 사각형 위치가 (x, y) 이라면, x 는 선택된 위치에 나타납니다.      foregroundColor: HTML 색상의 문자열 표시(“빨간색인 경우 #FF0000”, 녹색인 경우 “#00FF00” 등)를 사용하여 사각형의 전경색(foreground)을 나타내는 초기 색. 기본값: 검은색      backgroundColor: HTML 색상의 문자열 표시(“빨간색인 경우 #FF0000”, 녹색인 경우 “#00FF00” 등)를 사용하여 사각형의 배경을 나타내는 초기 색. 기본값: 흰색        CreateHighlightCircle: objectID, color, [initial_x, initial_y, radius]A highlight circle 은 다른 물체(object) 를 가리지 않기 위해 위해 일반 원과 달리 label과 배경색이 없습니다.          objectID: ID 번호는 음수가 아닌 정수여야 하고, 다른 활성화된 ID 번호와 중복이 되어서는 안됩니다. 그리고 성능을 위해 가능한 ID 번호의 크기가 작은 것이 좋습니다.      color: HTML 색상 표기를 사용한 원의 초기 색      initial_x: (optional, defaults to 0) 원의 초기 x 좌표      initial_y: (optional, defaults to 0) 원의 초기 y 좌표      radius: (optional, defaults to 20) 원의 반지름        CreateLabel: objectID, label, [initial_x, initial_x, centered]          objectID: ID 번호는 음수가 아닌 정수여야 하고, 다른 활성화된 ID 번호와 중복이 되어서는 안됩니다. 그리고 성능을 위해 가능한 ID 번호의 크기가 작은 것이 좋습니다.      label:라벨에 나타날 데이터. 문자열이라면 개행 문자(\\n)를 사용할 수 있습니다.      initial_x: (optional, defaults to 0) 라벨의 초기 x 좌표      initial_y: (optional, defaults to 0) 라벨의 초기 y 좌표      centered: (optional, defaults to true) true(1) 값이라면 중앙에, false(0) 값이면 중앙에 있지 않습니다.        CreateLinkedList: objectID, label, width, height, [initial_x, initial_y, linkPercent, verticalOrientation, linkPosEnd, numLabels]          objectID: ID 번호는 음수가 아닌 정수여야 하고, 다른 활성화된 ID 번호와 중복이 되어서는 안됩니다. 그리고 성능을 위해 가능한 ID 번호의 크기가 작은 것이 좋습니다.      label: 연결된 리스트 원소 내의 레이블(또는 두 개 이상의 레이블이 있는 경우, 그 중 첫 번째 레이블)      width: 연결된 리스트 원소의 넓이(pixel 단위)      height: 연결된 리스트 원소의 높이(pixel 단위)      initial_x: (optional, defaults to 0) 연결된 리스트 원소의 초기 x 좌표      initial_y: (optional, defaults to 0) 연결된 리스트 원소의 초기 y 좌표      linkPercent: (optional, defaults to 0.25) The percentage of the linked list element that the outgoing pointer takes up.      verticalOrientation: (optional, defaults to true). Should the linked list element be vertial (true) or horizontal (false)      linkPosEnd: (optional, defaults to false). Should the poiner appear at the bottom or left of the linked list element (true), or the top or right of the linked list element (false)      numLabels: (optional, defaults to 1). The number of labels that the linked lists element can hold. See the adjacency list implementat of a graph visualization for an example of a linked list element with more than 1 label.        CreateBTreeNode: objectID, widthPerLabel, height, numLabels, inital_x, initial_y, backgroundColor, foregroundColorSomewhat special-purpose animated object created for B-Trees. Single rectangle containing any number of labels, with no dividing lines between the labels. Edges can be attached between each label, and to the left of the leftmost label, and to the right of the rightmost label. See the BTree and B+ Tree visualizations for examples.          objectID: Non-negative integer that represents the ID of this object. Must be different from any ID currently active. Should be as small as posslbe for better performance.      widthPerLabel: The width of the B-Tree node is the number of labels * the width per label. Value is in pixels.      height: Height of the B-Tree node in pixels      numLabels: The number of labels in the BTree node.      initial_x: The initial x position of the B-Tree node      initial_y: The initial y position of the B-Tree node      backgroundColor: The initial color of the background of the rectangle, using HTML colors (#FF0000 for red, #00FF00 for green, and so on)      backgroundColor: The initial color of the forground of the rectangle, using HTML colors (#FF0000 for red, #00FF00 for green, and so on)        Delete: objectID          objectID: The ID of the object to delete. All edges incident on this object will be removed. (If the delete is undone, then all such edges will be restored). Once an Animated Element has been deleted, its ID is free to be used again. Note that overly complicated ID management (which is really memory management, since IDs are just indicies into a “memory array” of active animated objects) is not necessarily recommended, since it can lead to some subtle bugs.      현재 사용중인 objectID 를 생성하려고 하거나 현재 존재하지 않는 objectID 를 삭제하려고 하면 오류가 발생한다. Object Manipulation Commands   Move: objectID, toX, toYMove the object smoothly over the next step from the current position to the new position          objectID: The ID of the object to move. The object must exists, or an exception will be thrown      toX: The new X location to move to      toY: The new Y location to move to        SetPosition: objectID, toX, toYMove the object immediately to the new position at the beginning of the next step          objectID: The ID of the object to move. The object must exists, or an exception will be thrown      toX: The new X location to move to      toY: The new Y location to move to        SetForegroundColor: objectID, colorSets the foreground color (outline color and label color) of an object. Note that if an object has several labels this will set the color of all labels.  objectID: The ID of the object to modify. The object must exists, or an exception will be thrown  color: New foreground color (string representing HTML color, like “#ff0000”)  SetBackgroundColor: objectID, colorSets the background color of current object. Note that if an object has several labels this will set the color of an object.          objectID: The ID of the object to modify. The object must exist, or an exception will be thrown      color: New background color        SetHighlight: objectID, highlightValMark an object as either highlighted or unhighlighted, based on the value of highlightVal. Objects that are highlighted will pulse red. Any object can be highlighted (thought labels are slightly harder to read when highlighted) Note that if an object is left highlighted after an animation is ended, it will not pulse until the animation starts again. Edges can be highlighted using the highlight edge command.          objectID: The ID of the object to modify. The object must exists, or an exception will be thrown      highlightVal: 1 or true, turn on highlighting. 0 or false, turn off highlighting.        SetText: objectID, newText, [textIndex]Sets the value of the label associated with the object (the printing withing a circle, for instance).          objectID: The ID of the object to modify. The object must exists, or an exception will be thrown      newText: The new text of the label      textIndex: (optional, defaults to 0) Index of the text label to change. Only used in objects that have more than one text label (B-Tree nodes, Linked List nodes). If the object does not support multiple labels, this is ignored.        SetAlpha: objectIDSets the alpha (transparency) of the object. 0 is completely transparent, 1 is completely opaque. Works for all objects.          objectID: The ID of the object to modify. The object must exists, or an exception will be thrown.        SetHeight: objectID, newHeightSets the height (in pixels) of the object.          objectID: The ID of the object to modify. The object must exists, or an exception will be thrown      newHeight: The new height of the object.        SetWidth: objectID, newWIdthSets the width (in pixels) of the object.          objectID: The ID of the object to modify. The object must exists, or an exception will be thrown      newWidth: The new width of the object.        SetTextColor: objectID, newColor, [textIndex]Sets the color of the label associated with the object          objectID: The ID of the object to modify. The object must exists, or an exception will be thrown      newColor: The new color to set. As with all colors, should be a html color string      textIndex: (optional, defaults to 0) If the object contain multiple labels (such as a linked-list node, or a B-Tree node) determine which label to change the color of. If the object only has one label, this parameter is ignored.        SetNull: objectID, nullValueCurrently only used for linked-list elements. Should the area set aside for the pointer in the linked list object be drawn as a null pointer (slash through the field)? This should probably be automated (draw the slash if and only if the node is not connected to anything), but for now this must be done manually.          objectID: The ID of the object to modify. The object must exists, or an exception will be thrown      nullValue: 0 or false for do not draw the slash, 1 or true for draw the slash.        SetNumElements: objectID, numElementsCurrently only used for B-Tree nodes. Changes the number of labels stored in this B-tree node. Should probably be extended to at least Linked-list nodes.          objectID: The ID of the object to modify. The object must exists, or an exception will be thrown      numElements: integer, the number of elements this B-Tree node should have        AlignRight: object1ID, object2IDAlign object1 so that it is immediately to the right of object2. Very handy for lining up labels (where you don’t necessarily know the width of the label), but can be used with any two objects.          object1ID: The ID of the object to move. The object must exists, or an exception will be thrown      object2ID: The ID of the object used to align object1. The object must exists, or an exception will be thrown        AlignLeft: object1ID, object2IDAlign object1 so that it is immediately to the left of object2. Very handy for lining up labels (where you don’t necessarily know the width of the label), but can be used with any two objects.          object1ID: The ID of the object to move. The object must exists, or an exception will be thrown      object2ID: The ID of the object used to align object1. The object must exists, or an exception will be thrown        AlignTop: object1ID, object2IDAlign object1 so that it is immediately on top of of object2. Very handy for lining up labels (where you don’t necessarily know the width of the label), but can be used with any two objects.          object1ID: The ID of the object to move. The object must exists, or an exception will be thrown      object2ID: The ID of the object used to align object1. The object must exists, or an exception will be thrown        AlignBottom: object1ID, object2IDAlign object1 so that it is immediately below object2. Very handy for lining up labels (where you don’t necessarily know the width of the label), but can be used with any two objects.          object1ID: The ID of the object to move. The object must exists, or an exception will be thrown      object2ID: The ID of the object used to align object1. The object must exists, or an exception will be thrown      Edge Manipulation Commands Edge 명령어는 edge 를 가진 두 연관된 오브젝트를 조작합니다. Edge 들은 그래픽적으로 방향이 있을 수도 없을 수도 있지만, 후드(hood) 아래에 있는 모든 edge 들은 방향을 가집니다. 그리고 이 방향은 edge가 생성될 때 주어집니다. 한 오브젝트에서 다른 오브젝트로 가는 단 하나의 edge 만 있을 수 있습니다.(오브젝트1 에서 오브젝트2 까지와 오브젝트2 에서 오브젝트 1까지 서로 다른 edge 입니다.) Edge 들은 항상 두 오브젝트 ID(시작 오브젝트 ID, 끝 오브젝트 ID) 에 의해 수행됩니다. 오브젝트는 항상 다른 오브젝트와 연결될 수 있습니다.   Connect: fromID, toID, [linkColor, curve, directed, label, anchorPosition]          fromID: The ID of the object at the tail of the new edge      toID: The ID of the object at the head of the new edge      linkColor: (optional, defaults to “#000000”) The color of the edge      linkColor: (optional, defaults to false) true for a diected edge, false for an undirected edge      curve: (optional, defaults to 0.0) The “curviness” of the edge. 0.0 is perfectly straight, positive values arc to the right, negative values arc to the left.      directed: (optional, defaults to true). True if the edge is directed, false if the edge is undirected      label: (optional, defaults to “”). The label that appears along the edge (useful for things like edge costs in graphs)      anchorPosition: (optional, defaults to 0) If the edge could have more than one attachment postion at the “from” node, (currently only used for B-Tree nodes, but could well be expanded to things like doubly-linked lists) the index of the attachment position to use. Ignored for animated objects that do not have multiple attachment positions        Disconnect: fromID, toIDRemoves an edge between two elements. If there is no edge, then this operation is a no-op.          fromID: The ID of the “From” direction of the edge      toID: The ID of the “To” direction of the edgeNote that even “undirected” edges have a “from” and a “to” – determined by how the edge was created using the Connect command.        SetAlpha: objectIDSets the alpha (transparency) of the object. 0 is completely transparent, 1 is completely opaque          objectID: The ID of the object to modify. The object must exists, or an exception will be thrown        SetEdgeHighlight: fromID, toID, highlightValMark an edge as either highlighted or unhighlighted, based on the value of highlightVal. Edges that are highlighted will pulse red.          fromID: The ID of the “From” direction of the edge      toID: The ID of the “To” direction of the edge      higlightVal: 0 or false, turn of higlighting. 1 or true, turn on highlighting.      Special Commands   Step: The step command allows you to keep everything from happening at once. The way that most animations will work is that you will create a group of objects, then do a step, then do some movements, then do a step, then do more movements, then do a step, and so on. All commands that appear between adjacent steps will happen simultaneously. Each step represents where the animation will pause when it is in single-step mode.  SetLayer objectID, newLayerSets the layer of the object. All objects default to layer 0, and the “shown” layer always defaults to 0. You can change the layers of different objects, and then change the list of which layers are currently shown, to show or hide objects dynamically. (This is often useful for allowing the user to show or hide information, or to alternate between different versions of a representation). An object will only appear if its layer is one of the layers listed to be shown. An edge will only appear of each of the objects that it connect are to be shown. While commands cannot be executed while an animation is running, the global set of visible layers can be changed while an animation is running          objectID: The ID of the object to modify. The object must exists, or an exception will be thrown      layer: The new layer for this object. Each object must live in one and only one layer (though any combination of layers can be shown at any given time)      Simple Stack Example 이제는 정상적으로 수행되는 예제를 볼 것입니다. 간단한 스택(stack) 시각화 예제가 있습니다.   AlgorithmLibrary/SimpleStack.js  실행 결과아래는 초기화 작업을 수행하는 코드중 일부입니다. 시각화 자바스크립트의 시작은 아래의 코드와 같고 이는 언제든지 원하는 기능의 함수로 대체할 수 있습니다. function SimpleStack(am, w, h){\tthis.init(am, w, h);}SimpleStack.prototype = new Algorithm();SimpleStack.prototype.constructor = SimpleStack;SimpleStack.superclass = Algorithm.prototype;다음은 SimpleStack에서 사용하는 상수의 모습입니다. 심볼의 충돌을 피하기 위해 함수의 네임스페이스를 사용하였습니다. SimpleStack.ELEMENT_WIDTH = 30;SimpleStack.ELEMENT_HEIGHT = 30;SimpleStack.INSERT_X = 30;SimpleStack.INSERT_Y = 30;SimpleStack.STARTING_X = 30;SimpleStack.STARTING_Y = 100;SimpleStack.FOREGROUND_COLOR = \"#000055\"SimpleStack.BACKGROUND_COLOR = \"#AAAAFF\"다음은 생성자입니다. 기술적으로, 생성자는 아래와 같이 맨 처음에 위치합니다. function SimpleStack( ...그러나, 해당 생성자는 초기화 작업만을 수행합니다. – 이 방법은 서브 클래스의 생성자들은 효율적으로 그들의 슈퍼 클래스의 생성자들을 호출할 수 있습니다. 이 경우의 초기화 함수를 위해서 간단한 작업이 필요합니다. 이 예제에서는 로드(load) 시간동안 캔버스(canvas)에 어떠한 요소도 추가하지 않습니다. 개발자가 해야할 일은 해당 내부 자료 구조를 설정하는 것뿐입니다. 시스템은 두 배열(실제 스택을 저장하는 배열(stackValues), 스택 요소의 오브젝트 ID를 저장하는 배열(stackID))의 추적을 유지합니다. SimpleStack.prototype.init = function(am, w, h){\t// Call the unit function of our \"superclass\", which adds a couple of\t// listeners, and sets up the undo stack\tSimpleStack.superclass.init.call(this, am, w, h);\tthis.addControls();\t// Useful for memory management\tthis.nextIndex = 0;\tthis.stackID = [];\tthis.stackValues = [];\tthis.stackTop = 0;}다음은 알고리즘 컨트롤과 콜백 함수를 추가하는 매서드입니다. 아래는 어쩔 수 없이 복잡하게 구현한 부분입니다. this.popButton.onclick = this.popCallback이는 콜백 함수를 추가하는 부분입니다. 이것은 함수를 정상적으로 전달하지만, 정상적인 문맥은 전달하지 못합니다. – 기본적으로 이것은 “this” 포인터를 저장하지 않고 함수의 포인터를 넘겨주고 있습니다. 그래서 “this” 포인터를 저장하기 전에 해당 함수에 “this” 포인터를 바인드(bind) 해주어야 합니다. SimpleStack.prototype.addControls =  function(){\tthis.controls = [];    this.pushField = addControlToAlgorithmBar(\"Text\", \"\");    this.pushField.onkeydown = this.returnSubmit(this.pushField,                                                 this.pushCallback.bind(this), // callback to make when return is pressed                                               4,                           // integer, max number of characters allowed in field                                               false);                      // boolean, true of only digits can be entered.\tthis.controls.push(this.pushField);\tthis.pushButton = addControlToAlgorithmBar(\"Button\", \"Push\");\tthis.pushButton.onclick = this.pushCallback.bind(this);\tthis.controls.push(this.pushButton);\tthis.popButton = addControlToAlgorithmBar(\"Button\", \"Pop\");\tthis.popButton.onclick = this.popCallback.bind(this);\tthis.controls.push(this.popButton);}참고로 바인딩 하는 함수는 CustomEvents.js 파일에 구현되어 있고, 아래와 같습니다. Function.prototype.bind = function() {\tvar _function = this;\tvar args = Array.prototype.slice.call(arguments);\tvar scope = args.shift()\treturn function() {\t\tfor (var i = 0; i &lt; arguments.length; i++)\t\t{\t\t\targs.push(arguments[i]);\t\t}\t\treturn _function.apply(scope, args);\t}}다음은 리셋 함수입니다. 모든 시각화는 리셋 매서드를 구현해야 합니다. 이 리셋 매서드는 init 함수를 호출한 직후에 모든 변수를 원래 상태로 되돌려야 합니다. 이 에제에서는 오직 2개의 중요한 변수를 가지고 있습니다. 여기서 stackID 와 stackValues 배열을 다시 만들 수 있지만, 이 경우에는 그럴 필요성이 없습니다. 왜냐하면, 두 배열의 현재 값에 대해 신경 쓸 필요가 없기 때문입니다. – 스택의 top 값이 0인 경우에는 이를 읽기전에는 어떤 값이라도 쓸 수 있습니다. SimpleStack.prototype.reset = function(){\t// Reset the (very simple) memory manager.\t//  NOTE:  If we had added a number of objects to the scene *before* any user\t//         input, then we would want to set this to the appropriate value based\t//         on objects added to the scene before the first user input\tthis.nextIndex = 0;\t// Reset our data structure.  (Simple in this case)\tthis.stackTop = 0;}다음은 콜백입니다. 개발자는 콜백 함수에 대해 직접적으로 어떠한 작업도 할 필요가 없습니다. – 대신에, implementAction 매서드를 사용합니다. 이 매서드는 bound 함수(bind 매서드를 사용하는)와 한 매개변수를 가지고 와서, 이 매개변수를 사용하는 함수를 호출합니다. implementAction 은 또한 현재까지 수행되었던 모든 action 의 리스트를 저장합니다. 이로 인해 쉽게 undo 작업을 수행할 수 있습니다. SimpleStack.prototype.pushCallback = function(){\tvar pushedValue = this.pushField.value;\tif (pushedValue != \"\")\t{\t\tthis.pushField.value = \"\";\t\tthis.implementAction(this.push.bind(this), pushedValue);\t}}SimpleStack.prototype.popCallback = function(){\tthis.implementAction(this.pop.bind(this), \"\");}마지막으로, 지금부터는 시각화를 위한 핵심 코드입니다. – 이 예제 코드는 잘 동작합니다. 대부분 action 을 구현하고 있고, 웹상에 무엇을 하고 있는지 기록하기 위해 cmd 호출을 사용하고 있습니다. SimpleStack.prototype.push = function(pushedValue){\tthis.commands = [];\tthis.stackID[this.stackTop] = this.nextIndex++;\tthis.cmd(\"CreateRectangle\", this.stackID[this.stackTop],\t\t\t                    pushedValue,\t\t\t\t\t\t\t\tSimpleStack.ELEMENT_WIDTH,\t\t\t\t\t\t\t\tSimpleStack.ELEMENT_HEIGHT,\t\t\t\t\t\t\t\tSimpleStack.INSERT_X,\t\t\t                    SimpleStack.INSERT_Y);\tthis.cmd(\"SetForegroundColor\", this.stackID[this.stackTop], SimpleStack.FOREGROUND_COLOR);\tthis.cmd(\"SetBackgroundColor\", this.stackID[this.stackTop], SimpleStack.BACKGROUND_COLOR);\tthis.cmd(\"Step\");\tvar nextXPos = SimpleStack.STARTING_X + this.stackTop * SimpleStack.ELEMENT_WIDTH;\tvar nextYPos = SimpleStack.STARTING_Y;\tthis.cmd(\"Move\", this.stackID[this.stackTop], nextXPos, nextYPos);\tthis.cmd(\"Step\"); // Not necessary, but not harmful either\tthis.stackTop++;\treturn this.commands;}SimpleStack.prototype.pop = function(unused){\tthis.commands = [];\tif (this.stackTop &gt; 0)\t{\t\tthis.stackTop--;\t\tthis.cmd(\"Move\", this.stackID[this.stackTop], SimpleStack.INSERT_X, SimpleStack.INSERT_Y);\t\tthis.cmd(\"Step\");\t\tthis.cmd(\"Delete\", this.stackID[this.stackTop]);\t\tthis.cmd(\"Step\");\t\t// OPTIONAL:  We can do a little better with memory leaks in our own memory manager by\t\t//            reclaiming this memory.  It is recommened that you *NOT* do this unless\t\t//            you really know what you are doing (memory management leads to tricky bugs!)\t\t//            *and* you really need to (very long runnning visualizaitons, not common)\t\t//            Because this is a stack, we can reclaim memory easily.  Most of the time, this\t\t//            is not the case, and can be dangerous.\t\t// nextIndex = this.stackID[this.stackTop];\t}\treturn this.commands;}현재까지 대부분이 완성되었습니다. 아래는 애니메이션이 작동하는 동안 알고리즘 컨트롤을 enable/disable 하는 코드입니다. // Called by our superclass when we get an animation started event -- need to wait for the// event to finish before we start doing anythingSimpleStack.prototype.disableUI = function(event){\tfor (var i = 0; i &lt; this.controls.length; i++)\t{\t\tthis.controls[i].disabled = true;\t}}// Called by our superclass when we get an animation completed event -- we can/// now interact again.SimpleStack.prototype.enableUI = function(event){\tfor (var i = 0; i &lt; this.controls.length; i++)\t{\t\tthis.controls[i].disabled = false;\t}}알고리즘 시각화를 구현하기 위해 SimpleStack 코드에서 필요한 부분을 만들거나 수정하고, 불필요한 부분을 삭제할 수 있습니다. ////////////////////////////////////////////////////////////// Script to start up your function, called from the webapge:////////////////////////////////////////////////////////////var currentAlg;function init(){\tvar animManag = initCanvas();\tcurrentAlg = new SimpleStack(animManag, canvas.width, canvas.height);}HTML Template 이 시각화 시스템은 HTML과 자바스크립트의 조합입니다. 이를 위해 자바스크립트를 삽입할 웹 페이지가 필요하고, 웹 페이지는 아래와 같은 요소들이 필요합니다.   모든 필요한 스크립트 파일들을 로드하기 위해 헤더에 &lt;script&gt; 테그를 추가한다. 이 파일들은 의존도(dependency)에 따라 정확한 순서대로 include 되어야 한다.(자바스크립트가 HTML에 이 모든 파일을 수동으로 삽입하는 것을 방지하는 #include 와 같은 표준 메커니즘을 가지고 있다면 좋을 것입니다. 하지만 그 주변에 자바스크립트 호출을 사용하여 &lt;script&gt; 태그를 동적으로 삽입하는 몇 가지 방법이 있지만 모든 브라우저가 이러한 다소 복잡한 방법으로 동작하지는 않습니다. 순서가 정확하다면, 모든 파일의 탐색은 어디서든 작동할 것입니다.)  알고리즘별 컨트롤을 위치시킬 “algoControlSection” id가 포함된 빈 테이블  애니메이션을 표현할 canvas element  일반적인 애니메이션 컨트롤을 위치시킬 “GeneralAnimationControls” id가 포함된 빈 테이블  시각화를 시작하는 &lt;body&gt; 테그에서의 속성 onload = \"init()\"가장 쉬운 방법은 template.html 파일의 템플릿을 사용하여, 필요에 맞게 값을 바꾸는 것입니다. 아래는 template.html 의 코드이고, Place ... 이 부분을 필요에 맞게 변경할 수 있습니다. &lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;           Place your title here        &lt;/title&gt;        &lt;!-- css sheet for how the page is laid out --&gt;        &lt;link rel=\"stylesheet\" href=\"visualizationPageStyle.css\"&gt;        &lt;!-- jqueury stuff.  Only used for the animation speed slider. --&gt;        &lt;link rel=\"stylesheet\" href=\"ThirdParty/jquery-ui-1.8.11.custom.css\"&gt;        &lt;script src=\"ThirdParty/jquery-1.5.2.min.js\"&gt;&lt;/script&gt;        &lt;script src=\"ThirdParty/jquery-ui-1.8.11.custom.min.js\"&gt;&lt;/script&gt;        &lt;!-- Javascript for the actual visualization code --&gt;        &lt;script type = \"text/javascript\" src = \"AnimationLibrary/CustomEvents.js\"&gt; &lt;/script&gt;        &lt;script type = \"text/javascript\" src = \"AnimationLibrary/UndoFunctions.js\"&gt; &lt;/script&gt;        &lt;script type = \"text/javascript\" src = \"AnimationLibrary/AnimatedObject.js\"&gt; &lt;/script&gt;        &lt;script type = \"text/javascript\" src = \"AnimationLibrary/AnimatedLabel.js\"&gt; &lt;/script&gt;        &lt;script type = \"text/javascript\" src = \"AnimationLibrary/AnimatedCircle.js\"&gt; &lt;/script&gt;        &lt;script type = \"text/javascript\" src = \"AnimationLibrary/AnimatedRectangle.js\"&gt; &lt;/script&gt;        &lt;script type = \"text/javascript\" src = \"AnimationLibrary/AnimatedLinkedList.js\"&gt; &lt;/script&gt;        &lt;script type = \"text/javascript\" src = \"AnimationLibrary/HighlightCircle.js\"&gt; &lt;/script&gt;        &lt;script type = \"text/javascript\" src = \"AnimationLibrary/Line.js\"&gt; &lt;/script&gt;        &lt;script type = \"text/javascript\" src = \"AnimationLibrary/ObjectManager.js\"&gt; &lt;/script&gt;        &lt;script type = \"text/javascript\" src = \"AnimationLibrary/AnimationMain.js\"&gt; &lt;/script&gt;        &lt;script type = \"text/javascript\" src = \"AlgorithmLibrary/Algorithm.js\"&gt; &lt;/script&gt;        &lt;script type = \"text/javascript\" src = \"Place path to your javascript file here\"&gt; &lt;/script&gt;     &lt;/head&gt;    &lt;body onload=\"init();\" class=\"VisualizationMainPage\"&gt;        &lt;div id = \"container\"&gt;            &lt;div id=\"header\"&gt;                  &lt;h1&gt;Place your Header here &lt;/h1&gt;            &lt;/div&gt;            &lt;div = id = \"mainContent\"&gt;                &lt;div id = \"algoControlSection\"&gt;                    &lt;!-- Table for buttons to control specific animation (insert/find/etc) --&gt;                    &lt;!-- (filled in by javascript code specific to the animtion) --&gt;                    &lt;table id=\"AlgorithmSpecificControls\"&gt; &lt;/table&gt;                &lt;/div&gt;                    &lt;!-- Drawing canvas where all animation is done.  Note:  can be resized in code --&gt;                &lt;canvas id=\"canvas\" width=\"1000\" height=\"500\"&gt;&lt;/canvas&gt;                &lt;div id = \"generalAnimationControlSection\"&gt;                    &lt;!-- Table for buttons to control general animation (play/pause/undo/etc) -&gt;                    &lt;!-- (filled in by javascript code, specifically AnimationMain.js)  --&gt;                    &lt;table id=\"GeneralAnimationControls\"&gt;  &lt;/table&gt;                     &lt;/div&gt;            &lt;/div&gt; &lt;!-- mainContent --&gt;            &lt;div id=\"footer\"&gt;                  &lt;p&gt;&lt;a href=\"Algorithms.html\"&gt;Algorithm Visualizations&lt;/a&gt;&lt;/p&gt;            &lt;/div&gt;        &lt;/div&gt;&lt;!-- container --&gt;    &lt;/body&gt;&lt;/html&gt;Quicks and Advanced Techniques Object Display Order 만약 2개의 오브젝트가 겹친다면, 아래의 규칙에 따라 어느 오브젝트가 위에 그려질지 순서가 정해집니다.   non-highlighted 모든 아이템들은 highlighted 아이템들 전에 그려진다.(그래서 highlighted 아이템은 non-highlighted 아이템 위에 나타납니다.)  같은 highlight 상태의 모든 아이템들은 식별자 번호(id) 순서대로 그려진다.(id 번호가 큰 오브젝트가 id 번호가 작은 오브젝트 앞에 그려질 것입니다.)이 시스템은 그리 정교하지는 않지만, 충분히 잘 동작합니다. 만약 오브젝트 A 가 오브젝트 B 앞에 나타나길 원한다면, 오브젝트 A의 id 번호가 B보다 커야합니다. 그리고 더 정교한 시스템을 원하다면, 미래에 수정된 버전이 나올 수도 있습니다. Debugging 자바스크립트를 개발하고 있다면 Firebug는 자바스크립트 디버거로서 매우 괜찮습니다.(무료) 그러나 이 프로그램은 breakpoint(중단점) 에 대한 문제가 있습니다. 이 시스템의 애니메이션은 자바스크립트 setTimeout 명령에 크게 의존합니다. 시간초과(timeout)후에 Firebug의 중단점에 도달하면 시간초과가 손실될 것입니다. 잘못된 코드 부분에 중단점을 설정한다면 애니메이션이 중단될 수 있습니다. ","categories": ["Toy"],
        "tags": ["Toy_jsdsLib"],
        "url": "https://codemcd.github.io/pages/CODEMCD/toy/jsdsLib-jsdsLib-Data-Structure-Visualizations/",
        "teaser":null},{
        "title": "[jsdsLib]jsDelivr",
        "excerpt":"이 문서는 jsDelivr 을 사용하는 방법에 대해 번역한 것입니다.       오타, 잘못된 번역이 많을 수 있습니다. 감안하고 읽어주세요…   원문   jsDelivr 공식 Gitgub공식 사이트   https://www.jsdelivr.com/jsDelivr - Open Source CDN 관련 프로젝트:   jsDelivr API  jsDelivr websitejsDelivr 관계자들은 도와줄 사람을 찾고 있습니다. 위의 링크(repos)를 열어 이슈를 확인해주세요. 해당 이슈에 관한 아이디어가 있으면 댓글을 달아주시고, 새로운 아이디어가 있다면 새로운 이슈를 만들어주세요. Note: jsDelivr 의 백엔드(Back end)가 변경되었습니다. 그에 따라 새로운 jsDelivr 사용방법을 알아야 합니다. jsDelivr 은 무료 오픈소스 파일을 위한 무료 CDN 입니다. jsDelivr 은 Github, npm과 밀접하게 통합되어 있습니다. 그러므로 외부의 대부분 오픈소스 프로젝트에 CDN 서비스를 제공할 수 있고, 이 서비스는 자동화되어 있고 신뢰할만합니다. jsDelivr 은 엄청난 양의 트래픽을 가지고 있는 인기있는 웹사이트 제작에도 사용할 수 있는 안정적인 CDN 서비스를 제공합니다. jsDelivr 은 대역폭(bandwidth)의 제한이나 프리미엄 기능이 없고, 누구나 자유롭게 사용할 수 있습니다. 사용법(Usage) jsDelivr 은 공공 저장소의 모든 npm 패키지에서 모든 파일을 즉시 서비스 할 수 있습니다. npm 으로 배포된 새로운 버전의 패키지 역시 즉시 CDN 을 통해 바로 사용가능합니다. 그리고 사용자 개인의 유지보수를 할 필요가 없습니다. 만약 패키지나 버전, 파일이 npm 에서 제거된다고 해도 jsDelivr 에서는 어떤 웹사이트에도 영향없이 계속 서비스를 제공합니다. 이는 해당 파일들이 jsDelivr 내부 저장소에 영구적으로 저장되어 있기 때문입니다. npm 배포된 npm 패키지를 불러오기 위한 기본 양식 /npm/package@version/file정확한 버전 불러오기 /npm/jquery@3.1.0/dist/jquery.min.js버전의 일부분만 사용하여 불러오기 /npm/jquery@3/dist/jquery.min.js/npm/jquery@3.1/dist/jquery.min.js태그로 불러오기(추천하지 않음) /npm/jquery@beta/dist/jquery.min.js버전을 완전히 생략하거나 “latest”(가장 최신 버전) 로 불러오기(개발 환경에서만 사용할 것) /npm/jquery@latest/dist/jquery.min.js/npm/jquery/dist/jquery.min.js미니 버전이 없는 경우 js/css 파일에 .min 추가한다면 자동적으로 생성됩니다. 그리고 만들어진 모든 파일들은 소스 맵을 제공하고 개발하는 동안 쉽게 사용할 수 있습니다. /npm/github-markdown-css@2.4.1/github-markdown.min.cssGitHub Github release 또는 commit 불러오기 /gh/user/repo@version/file정확한 버전 불러오기 /gh/jquery/jquery@3.1.0/dist/jquery.min.js/gh/jquery/jquery@32b00373b3f42e5cdcb709df53f3b08b7184a944/dist/jquery.min.js정확한 버전 대신 버전 범위 불러오기(반드시 유효한 semver 버전을 사용해야함.) /gh/jquery/jquery@3/dist/jquery.min.js/gh/jquery/jquery@3.1/dist/jquery.min.js버전을 완전히 생략하거나 “latest”(가장 최신 버전) 로 불러오기(개발 환경에서만 사용할 것) /gh/jquery/jquery@latest/dist/jquery.min.js/gh/jquery/jquery/dist/jquery.min.js미니 버전이 없는 경우 js/css 파일에 .min 추가한다면 자동적으로 생성됩니다. 그리고 만들어진 모든 파일들은 소스 맵을 제공하고 개발하는 동안 쉽게 사용할 수 있습니다. /gh/sindresorhus/github-markdown-css@v2.4.1/github-markdown.min.css디렉토리 리스트 가져오기 /gh/jquery/jquery@3.1.0//gh/jquery/jquery@3.1.0/dist/예제   npmjsdsLib 패키지 1.1 버전 불러오기 &lt;head&gt;    &lt;meta charset=\"utf-8\" /&gt;    &lt;script src=\"https://cdn.jsdelivr.net/npm/jsdslib@1.1/dist/List.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;  GithubGithub 에서 cdn 서비스를 이용하기 위해서는 먼저, 코드 깃허브에 올리고 버전 태그(lightweight tag)설정한다.   git tag [version] -&gt; git push origin [version]jsdsLib 1.1 버전 불러오기 &lt;head&gt;    &lt;meta charset=\"utf-8\" /&gt;    &lt;script src=\"https://cdn.jsdelivr.net/gh/CODEMCD/jsdsLib@1.1/dist/List.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;","categories": ["Toy"],
        "tags": ["Toy_jsdsLib"],
        "url": "https://codemcd.github.io/pages/CODEMCD/toy/jsdsLib-jsdsLib-jsDeliver/",
        "teaser":null},{
        "title": "[jsdsLib]npm 패키지",
        "excerpt":"패키지 만들기 npm 패키지를 만들기 위해서는 패키지로 만들 디렉토리가 필요하다. 해당 디렉토리 내부에 패키지할 내용들이 들어 있어야 한다. 그리고 cmd 창을 열어 해당 디렉토리로 이동하고 아래의 순서대로 진행하자.   해당 디렉토리를 패키지화 한다.    npm init        npm init 명령어를 입력하면 package.json 파일을 작성해야한다.          각 항목에서 보여주는 () 안의 값들은 디폴트 값으로, 입력없이 엔터를 누르면 해당 값으로 설정된다.      name: 패키지 이름, 이 이름은 유일해야 한다.      version: 패키지 버전      description: 패키지에 대한 설명      entry point: 패키지를 실행했을 때, 맨 처음 불러오는 파일, package.json 파일에서는 main 으로 표시된다. (일반적으로 main 코드가 있는 파일로 설정한다.)      test command: test script 를 실행할 명령어      git repository: 해당 패키지를 github 에 저장해두었거나, 저장할 계획이라면 설정한다. (github 에서 clone 받은 프로젝트라면, 자동으로 설정되어 있다.)      keywords: 해당 패키지의 태그 역할을 한다. (패키지와 연관된 단어들을 띄어쓰기로 구분하여 입력한다.)      author: 패키지 저자      license: 패키지에 대한 라이선스, 기본값으로 MIT로 설정되어 있다.        npm 공식 사이트 로그인    npm adduser      아이디, 비밀번호, 이메일을 입력한다.   패키지 배포    npm publish      패키지 업데이트 패키지의 package.json 파일에서 version 을 변경하고 npm publish 명령어를 수행한다. (버전이 같으면 오류가 발생한다.) 패키지 사용 패키지를 사용하기 위해서는 해당 디렉토리 역시 패키지화 해야한다. 패키지화를 하지 않으면 package.json 파일을 찾을 수 없다는 에러가 발생한다.   디렉토리 패키지화    npm init        해당 디렉토리를 다시 패키지화한다면 그에 맞게 package.json 정보를 입력하고, 그렇지 않다면 모두 기본값으로 설정해도 무관하다. (어차피 package.json 파일은 언제든지 수정가능하다.)     사용할 패키지 설치    npm install 패키지 이름        대부분의 패키지는 위의 명령어로 설치할 수 있지만, README.md 파일에서 해당 패키지의 설치 방법을 보고 설치하는 것을 추천한다.           설치 명령어에 --save 옵션을 추가하면 현재 패키지와 설치한 패키지 사이에 의존성이 생긴다. 현재 패키지를 설치하면 의존성 관계인 패키지가 같이 설치된다. 의존성 관계는 package.json 파일에서 확인할 수 있다.        이제 패키지 사용방법에 따라 사용할 수 있다.유용한 패키지   uglify-js: 해당 자바스크립트 파일에서 필요없는 데이터를 삭제한다.          띄어쓰기, 탭, 엔터 등을 삭제한다.      -m 플래그를 사용하면 변수 이름을 아주 작은 글자 수로 줄인다.      해당 자바스크립트 파일 데이터를 최소화하여 네트워크 효율성을 극대화하기 위해 사용한다.        underscore: 자바스크립트에서 부족한 배열, 문자열 등의 매서드를 제공한다.          통상 _ 변수를 많이 사용한다.      참고 문헌   생활 코딩 - npm과 모듈  http://sanghaklee.tistory.com/34  https://blog.outsider.ne.kr/829","categories": ["Toy"],
        "tags": ["Toy_jsdsLib"],
        "url": "https://codemcd.github.io/pages/CODEMCD/toy/jsdsLib-jsdsLib-npm-%ED%8C%A8%ED%82%A4%EC%A7%80/",
        "teaser":null},{
        "title": "[Algorithm]비트마스크",
        "excerpt":"비트마스크란 정수의 이진수 표현을 자료 구조로 쓰는 기법을 말한다. 비트마스크는 다음과 같은 특징을 가진다.   더 빠른 수행 시간컴퓨터는 내부적으로 이진수를 사용하기하므로, 이진법 관련 연산들을 매우 빨리 수행할 수 있다. 이를 이용하면 시간복잡도를 O(1) 로 구현할 수 있는 경우가 많다. 물론 비트마스크를 사용할 수 있다는 것은 원소의 수가 많지 않다는 뜻이지만, 이와 같은 연산을 굉장히 여러 번 수행하는 경우에는 큰 속도 향샹을 가져올 수 있다.  더 간결한 코드비트마스크를 사용하면 다양한 집합 연산들을 반복문 없이 한 줄에 쓸 수 있으므로 훨씬 짧은 코드로 작성할 수 있다.  더 작은 메모리 사용량비트마스크를 이용하는 코드들은 같은 데이터를 더 적은 메모리를 사용해 표현할 수 있다. 더 적은 데이터를 사용한다는 것은 더 많은 데이터를 미리 계산해서 저장해 둘 수 있다는 뜻이고, 이는 프로그램 속도 향샹과 캐시 효율을 높일 수 있다.  연관 배열을 배열로 대체boolean 을 키로 갖는 연관 배열 객체 map&lt;vector&lt;bool&gt;, int&gt; 를 사용하고 있다고 하자. 이 경우에 비트마스크를 사용하여 같은 정보를 정수 변수로 나타내면 단순하게 int[] 배열로 표현할 수 있다. 많은 경우 이 기법은 시간과 메모리에서 큰 차이를 불러옵니다.비트 연산자 비트 연산자는 정수 변수를 비트별로 조작할 수 있는 연산자입니다. AND, OR, XOR 비트별 AND, OR, XOR 연산의 결과는 아래의 표와 같다. 그리고 괄호안은 C++ 기준 표현 방식이다.             bit 1      bit 2      AND(&amp;)      OR(      )      XOR(^)                  0      0      0      0      0                     1      0      0      1      1                     0      1      0      1      1                     1      1      1      1      0               예제 NOT 비트별 NOT 연산은 켜져 있는 비트는 끄고, 꺼져 있는 비트는 켠 결과를 반환한다. C++ 기준 정수 a의 비트별 NOT 연산을 수행하려면 ~a 로 표현한다.   예제 shift 시프트(shift) 연산자는 정수 a 의 비트들을 왼쪽 또는 오른쪽으로 원하는 만큼 움직인다. C++ 기준 정수 a 를 왼쪽으로 b 비트 시프트 수행은 a &lt;&lt; b이고, 오른쪽으로 b 비트 시프트 수행은 a &gt;&gt; b 로 표현한다.   예제 유의할 점   비트 연산자 우선순위C++ 이나 Java 에서는 &amp;, |, ^ 등의 비트 연산자의 우선순위는 ==, != 등의 비교 연산자의 우선순위보다 낮다. 즉 아래와 같은 코드는 원하지 않는 결과가 나온다.int c = (6 &amp; 4 == 4);이러한 실수를 줄이기 위해서는 비트 연산자를 사용할 때는 반드시 괄호를 추가하는 습관을 들이는 것이 좋다.   오버플로64비트 정수를 비트마스크로 사용할 때 아래의 코드는 문제가 발생할 확률이 높다.bool isBitSet(unsigned long long a, int b) {  return (a &amp; (1 &lt;&lt; b)) &gt; 0;}위의 코드는 부호 없는 64비트 비트마스크 a 의  b 번 비트가 켜져 있는지 확인하는 코드이다. 여기서 문제점은 1 이라는 수이다. C++ 에서 1 은 기본적으로 부호 있는 32비트 상수이다. 만약 b 가 32 이상이면 오버플로가 발생한다. 이를 해결하기 위해서는 1 앞에 ull 을 붙여 64비트 정수로 형변환을 해야 한다.   부호부호 있는 정수형에서 최상위 비트는 부호를 나타낸다. 최상위 비트가 켜져있으면 음수를 표현하는 것이다. 이와 같이 부호가 있는 32비트 정수형에서 모든 비트를 사용한다면 자잘한 버그가 난다. 만약 해당 비트를 모두 사용하고 싶은 경우에는 부호가 없는 정수형을 써야한다.비트마스크를 이용한 집합 구현 비트마스크의 가장 중요한 사용 사례는 집합을 구현하는 것이다. 이 표현에서 N 비트 정수 변수는 0 부터  N - 1 까지의 정수 원소를 가질 수 있는 집합이 된다. 이때 원소 i 가 집합에 속해 있는지 여부는 $2^i$ 을 나타내는 비트가 켜져있는지를 확인해야한다. 예를 들어 여섯 개의 원소를 갖는 집합 {1, 4, 5, 6, 7, 9} 를 표현하는 정수는 754 이다. 피자집 예제 고객들이 원하는 토핑을 골라 주문할 수 있는 피자집의 주문 시스템을 만들다고 하자. 이 피자집에는 0 부터 19 까지의 번호를 갖는 20 가지의 토핑이 있고, 주문시 토핑을 넣기/넣지 않기를 선택할 수 있다. 그러면 한 피자의 정보는 20 종류의 원소만을 가지는 집합이 되고, 비트마스크를 이용해 표현할 수 있다.(물론, 크기 20 의 불린 값 배열을 사용할 수도 있다.)   공집합과 꽉 찬 집합 구하기공집합은 간단히 상수 0 으로 나타낼 수 있다. 꽉 찬 집합은 아래의 코드와 같이 표현한다.int fullPizza = (1 &lt;&lt; 20) - 1;// (1 &lt;&lt; 20) = 000100000000000000000000// (1 &lt;&lt; 20) - 1 = 000011111111111111111111  원소 추가집합의 가장 기초적인 연산은 원소를 추가하고 삭제하는 것이다. 비트마스크를 사용하는 집합에서 원소를 추가한다는 것은 해당 비트를 켠다는 것이다. 토핑 p 를 집합에 추가하는 코드는 아래와 같다.toppings |= (1 &lt;&lt; p);  원소의 포함 여부 확인집합 toppings에 토핑 p 가 추가되었는지 확인하는 코드는 아래와 같다.if (toppings &amp; (1 &lt;&lt; p)) cout &lt;&lt; \"topping p is in\" &lt;&lt; endl;주의할 점은 &amp; 연산의 결과값은 0 또는 (1 « p) 이다. 대부분의 논리 연산처럼 0(false) 혹은 1(true) 값이 반환된다고 생각하면 안된다. 예를 들어 p = 3 인 경우에서, p 가 토핑에 들어있다면 위의 조건문은 8 을 반환하고, 들어있지 않다면 0 을 반환한다.   원소 삭제토핑 p 를 삭제하는 경우에는 간단하게 아래의 코드를 생각할 수 있다.toppings -= (1 &lt;&lt; p);하지만 위 코드는 토핑 p 가 반드시 toppings 집합에 포함되어 있어야 한다는 조건이 있다. 그러므로, 원소가 포함되어 있는지 여부와 상광없이 정상적으로 삭제하고 싶다면 다음 코드를 사용할 수 있다. toppings &amp;= ~(1 &lt;&lt; p);  원소 토글(toggle)원소 토글은 해당 비트가 켜져 있으면 끄고, 꺼져 있으면 켜는 동작을 수행한다. 이것은 간단히 XOR 연산을 사용할 수 있다.toppings ^= (1 &lt;&lt; p);  두 집합에 대해 연산하기두 개의 토핑 집합 a 와 b 의 집합 연산은 다음과 같이 구할 수 있다.int added = (a | b);           // a 와 b 의 합집합int intersection = (a &amp; b);    // a 와 b 의 교집합int removed = (a &amp; ~b);        // a 에서 b 를 뺀 차집합   int toggled = (a ^ b);         // a 와 b 중 하나에만 포함된 원소들의 집합이 코드의 수행 시간은 원소 하나에 대해 수행하는 것과 같다.   집합의 크기 구하기비트마스크를 사용할 때 집합에 포함된 원소의 수를 구하는 간단한 방법은 딱히 없다. 따라서 각 비트를 순회하면서 켜져 있는 비트의 수를 직접 세어야 한다.int bitCount (int x) {  if (x == 0) return 0;  return x % 2 + bitCount(x / 2);}이 외에도 여러 프로그래밍 환경에서 위의 동작을 수행하는 내장 명령어를 제공한다. 다음은 32비트 부호 없는 정수 toppings 에 켜진 비트의 수를 구하는 명령어들이다.             gcc/g++      __builtin_popcount(toppings)                  Visual C++      __popcnt(toppings)              Java      Integer.bitCount(toppings)      이 명령어들은 다양한 최적화를 통해 매우 빠르게 동작한다.   최소 원소 찾기최소 원소는 최하위 비트에서 시작하여 가장 처음 켜져 있는 비트를 말한다. 즉, 최소 원소부터 최하위 비트까지 0 의 개수를 통해 해당 최소 원소의 번호를 반환한다. 이 동작 역시 내장 명령어로 제공한다. 다음은 32비트 부호없는 정수 toppings에서 켜져 있는 최하위 비트의 위치를 구하는 명령어이다.            gcc/g++      __builtin_ctz(toppings)                  Visual C++      _BitScanForward(&amp;index, toppings)              Java      Integer.numberOfTrailingZeros(toppings)      이 연산들 역시 매우 빠르게 동작한다. 그리고 g++ 의 내장 함수인 __buitin_ctz() 는 입력으로 0 이 주어졌을 때의 결과가 정의되어 있지 않기 때문에 주의해야 한다. 최하위 비트의 번호 대신 해당 비트를 직접 구할 수도 있다. 예를 들어 40이 주어질 경우 3 대신 &amp;2^3$ 을 구하고 싶은 것이다. int firstTopping = (toppings &amp; -toppings);이는 컴퓨터가 음수를 표현하는 2의 보수를 사용한다. 2의 보수를 사용하는 시스템에서는 음수 -toppings 를 표현하기 위해 toppings 에 비트별 NOT 연산을 적용하고 그 결과에 1을 더한다. 예를 들어 toppings 의 값이 160 이라고 하자. 그러면 아래와 같은 계산 과정을 가진다.        toppings      = 1010 0000      -toppings      = 0110 0000toppings &amp; -toppings = 0010 0000  최소 원소 지우기최소 원소를 구하지 않고도 최소 원소를 지울 수도 있다.toppings &amp;= (toppings - 1);이는 toppings - 1 의 이진수 표현을 생각해보면 쉽게 알 수 있다. toppings - 1 의 이진수 표현은 toppings 의 켜져 있는 최하위 비트를 끄고 그 밑의 비트들을 전부 켠 것이다. 예를 들어 위와 같이 toppings 값이 160 이라고 하자.        toppings           = 1010 0000       toppings - 1       = 1001 1111toppings &amp; (toppings - 1) = 1000 0000이 방법은 어떤 정수가 2의 거듭제곱 값인지 확인할 때도 유용하다. 2의 거듭제곱 갑들은 이진수 표현에서 켜진 비트가 1개 밖에 없으므로, 위 코드의 결과값은 0이 된다.   모든 부분 집합 순회하기비트마스크를 사용하면 for 문 하나로 간단히 모든 부분 집합을 순회할 수 있다. 예를 들어 pizza 가 {a, b, c} 라면 {a}, {b}, {c}, {a, b}, {a, c}, {b, c}, {a, b, c} 가 나온다. 이의 코드는 다음과 같다.for (int subset = pizza; subset; subset = ((subset - 1) &amp; pizza)) {  //subset 은 pizza 의 부분집합}이 for 문은 subset = 0 인 시점에서 종료하므로, 공집합은 방문하지 않는다는 것에 주의해야 한다. 참고문헌   프로그래밍 대회에서 배우는 알고리즘 문제해결전략, 인사이트, 구종만 지음","categories": ["Algorithm"],
        "tags": ["Algorithm_Algorithm"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-%EB%B9%84%ED%8A%B8%EB%A7%88%EC%8A%A4%ED%81%AC/",
        "teaser":null},{
        "title": "[C/C++]문자열 상수와 문자열 변수",
        "excerpt":"C/C++ 에서 문자열을 특히 char 형으로 다룰 때 문자열 상수와 문자열 변수를 구분해서 사용해야 한다. 그렇지 않으면 수 많은 에러때문에 고생할 수 있다. 먼저, C/C++ 의 메모리 구조를 보자.  메모리는 총 3가지로 구분되고, 위와 같이 구성되어 있다. 데이터 영역에서 코드 영역과 나누어 구분하기도 한다. 이제 문자열 상수와 문자열 변수의 예제를 보자. char *c = \"apple\";      //문자열 상수char v[10] = \"apple\";    //문자열 변수문자열 상수는 포인터 변수를 선언하여 문자열을 대입하고, 문자열 변수는 배열을 선언하여 대입한다. 여기서 각각 메모리를 차지하는 영역을 보자.  그림에서 보듯이, 문자열 상수에서 문자열은 데이터 영역이고, 문자열 변수는 스택 영역에 위치해 있다. 이름에서도 알 수 있듯이, 문자열 상수는 읽기만 가능하고 바꿀 수는 없다. 문자열을 바꾸기 위해서는 새로운 문자열 주소를 할당해야 한다. 즉, 포인터 변수가 바뀐다. 반면에, 문자열 변수는 읽고, 쓰기가 가능하다. 문자열을 바꿀려면 해당 인덱스에 접근하여 바꿀 수 있다. 하지만 위와 같은 배열 선언은 포인터 상수이다. 즉, 포인터는 바뀔 수 없다. 그렇다면, 문자열 상수와 변수의 데이터가 “apple” 에서 “banana”로 변경하려면 어떻게 해야 할까?   문자열 상수char *c = \"apple\";c = \"banana\";             // banana//strcpy(c, \"banana\");    // Runtime Error!  문자열 변수char v[10] = \"apple\";//v = \"banana\";           // syntax error!strcpy(v, \"banana\");      // banana위의 코드와 같이 수행해야 한다. 위에서 설명하였듯이, 문자열 상수는 “banana” 라는 새로운 문자열 주소를 가르키게 하였고, 문자열 변수는 인덱스에 접근하여 하나 하나 변경해주었다. strcpy 함수를 잠깐 보자면 간단하게 아래와 같이 구현되어 있다. char *strcpy(char *dest, const char *src){\tchar *cp = dest;\twhile (*(cp++) = *(src++))\t\t;\treturn dest;}그리고, 서로 반대로 변경할려고 하면 에러가 발생한다. 이렇게 바뀐 모습을 그림으로 보면 아래와 같다.  문자열 상수와 변수의 특징을 정리하면 다음과 같다.   문자열 상수          실제 문자열은 데이터 영역에 저장된다.      읽기만 가능하다.(배열 인덱스로 접근하여 읽을 수는 있지만, 값은 변경할 수 없다.)      문자열을 변경하려면 포인터를 바꿔주어야 한다.(포인터 변수)        문자열 변수          실제 문자열은 스택 영역에 저장된다.      배열 인덱스로 접근하여 읽고 쓰기가 가능하다.      문자열을 변경하려면 배열 인덱스 하나 하나에 접근하여 바꿔준다.(포인터 상수)      동적 할당에서 문자열 동적 할당에서는 문자열을 상수로 초기화하면 문자열 상수처럼 사용해야 하고, 변수로 선언하면 문자열 변수처럼 사용해야 한다. 아래에도 잠깐 살펴보겠지만 동적 할당을 제대로 사용하는 것은 문자열 변수로 사용하는 것이다. 다음과 같은 예제를 보자. //초기화 1 문자열 상수char *str1 = new char[10];str1 = \"apple\";str1 = \"banana\";             // banana//strcpy(str1, \"banana\");    // Runtime Error!//초기화 2 문자열 변수char *str2 = new char[10];strcpy(str2, \"apple\");//str2 = \"banana\";           // Runtime error!strcpy(str2, \"banana\");      // banana하지만 동적 할당을 문자열 상수로 사용하면 메모리 해제 문제가 발생하는 것으로 보인다. 생각해보면 당연한 것 같다. 위의 예제서도 보이듯이 동적으로 10개의 char 형을 할당받았는데 문자열 상수를 사용하면 할당받은 메모리를 사용하는 것이 아니라 선언된 포인터 변수만을 사용하는 것이 된다. ","categories": ["Language"],
        "tags": ["Language_CCpp"],
        "url": "https://codemcd.github.io/pages/CODEMCD/language/CC++-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%83%81%EC%88%98%EC%99%80-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%B3%80%EC%88%98/",
        "teaser":null},{
        "title": "[운영체제] # 1 운영체제 서론",
        "excerpt":"운영체제란? 운영체제(Operating System)는 사용자가 컴퓨터를 사용하기 위해 필요한 소프트웨어이다. 우리가 일반적으로 컴퓨터를 사용하면서 실행한 모든 프로그램들은 운영체제에서 관리하고 제어한다. 대표적인 운영체제는 Windows, Linux, Mac OSX, iOS 등이 있다. 운영체제 목적 운영체제를 사용하는 가장 주된 목적은 컴퓨터의 하드웨어를 관리 하는 것이다. 컴퓨터에는 수 많은 하드웨어가 존재한다. CPU, 메모리, 디스크, 키보드, 마우스, 모니터, 네트워크 등이 있으며 이를 잘 관리해주어야 컴퓨터를 효율적으로 사용할 수 있다. 운영체제의 성능이 좋을수록 컴퓨터의 성능 역시 좋아진다고 할 수 있다. 운영체제는 사용자에게 편의를 제공 하는 목적도 가지고 있다. 운영체제가 없다면 위에서 말한 하드웨어에 관한 모든 관리를 사용자가 해야한다는 점과 같이 컴퓨터를 사용하는데 매우 불편함을 겪을 것이다. 하지만 현재 많은 발전을 거쳐온 운영체제가 설치된 컴퓨터는 사용하기에 매우 편리하다는 것을 느낄 수 있다. 대표적으로 스마트폰이 있다. 스마트폰 역시 컴퓨터의 일종이고 운영체제가 설치되어 있다. 그리고 스마트폰은 남녀노소 누구나 할 것 없이 사용법을 빠르게 익힐 수 있다. 정리하면 운영체제는 컴퓨터의 성능을 높이고(performance), 사용자에게 편의성 제공(Convenience)을 목적으로 하는 컴퓨터 하드웨어 관리하는 프로그램 이다. 부팅(Booting) 컴퓨터의 구조를 단순화하면 아래의 그림과 같다.  Processor는 일반적으로 CPU를 말한다. main memory를 보면 ROM과 RAM으로 나누어져 있다.   ROM: 비휘발성 으로 메모리에서 극히 일부를 차지한다.(수 KB)  RAM: 휘발성 으로 메모리의 대부분을 차지하며 실제 프로그램이 할당되는 곳이다.(수 MB ~ 수 GB)ROM은 하드디스크와 같이 비휘발성으로 전원이 꺼져도 그 안의 내용이 계속 유지된다. RAM은 휘발성이므로 전원이 꺼지면 메모리안의 모든 내용이 지워진다. 컴퓨터의 전원이 켜지면 프로세서(CPU)에서 ROM에 있는 내용을 읽는다. ROM안에는 POST(Power-On Self-Test), 부트 로더(boot loader)가 저장되어 있다. POST는 전원이 켜지면 가장 처음에 실행되는 프로그램으로 현재 컴퓨터의 상태를 검사한다.  POST 작업이 끝나면 부트 로더가 실행된다. 부트 로더는 하드디스크에 저장되어 있는 운영체제를 찾아서 메인 메모리(RAM)에 가지고 온다. 이러한 부트 로더의 과정을 부팅 이라고 한다.  위 그림은 부트 로더가 진행하는 모습이다. 위와 같은 상태가 되면 운영체제가 수행할 준비를 마친 것이다. 운영체제가 종료하는 시점은 컴퓨터의 전원이 꺼지는 시점이다. 운영체제는 크게 커널(kernel) 과 명령어 해석기(Command interpreter, shell) 로 나뉜다.  커널은 말그대로 운영체제의 핵심으로 운영체제가 수행하는 모든 것 이 저장되어있다. 명령어 해석기는 사용자가 커널(운영체제)에 요청하는 명령어를 해석하여 커널에 요청하고 그 결과를 출력 한다. 사용자는 GUI(Graphical User Interface)나 CLI(Command Line Interface) 같은 방식으로 운영체제에 명령을 요청할 수 있는데, 예를 들어 현재 디렉토리의 파일 리스트 불러오기, 프로그램 실행하기, 디스크 용량 확인 등 다양하게 존재한다. 운영체제의 위치 사용자 프로그램(Application) 은 특정 운영체제에 맞춰서 만든다. 그러므로 한 애플리케이션은 서로 다른 운영체제에서 수행할 수 없다.(하드웨어가 같은 것은 전혀 상관이 없다.) 예를 들면 Windows에서 수행하는 프로그램을 그대로 Linux에 옮기면 수행되지 않는다.  애플리케이션은 위의 그림과 같이 운영체제 위에서 수행한다. 즉, 하드웨어 자원을 직접적으로 사용하지 않고 운영체제가 제공하는 자원만을 사용할 수 있다. 운영체제는 실제 세상의 정부(Goverment)와 유사하다. 정부가 하는 일은 다음과 같다.   국토, 인력, 예산과같은 자원이 존재하며 이를 효율적으로 사용해야한다.  효율적인 자원 관리를 위해 행정부, 국토부, 교육부, 국방부 등 부서로 나눠 관리한다.  각 부서들은 국민들에게 자원을 요청받고 적절히 배분한다.운영체제가 하는 일은 다음과 같다.   프로세스, 메모리, 하드디스크 등 하드웨어 자원이 존재하고, 이를 효율적으로 사용해야한다.  자원 관리를 위해 프로세스 관리, 메모리 관리, 디스크 관리, 네트워크, 보안 등 기능이 나눠져 있다.  애플리케이션들의 요청에 따라 각 기능들이 수행하여 적절히 자원을 분배한다.","categories": ["Study"],
        "tags": ["Study_OperatingSystem"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-1%EC%9E%A5-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%84%9C%EB%A1%A0/",
        "teaser":null},{
        "title": "[운영체제] # 2 운영체제 역사",
        "excerpt":"초기 컴퓨터 운영체제는 컴퓨터가 발전하면서 같이 발전하게 되었다. 초기 컴퓨터는 크게 3가지로 구성되었다. 카드 리더, 프로세서, 프린터이다. 카드 리더는 입력기이다. 입력은 종이에 입력할 코드에 맞는 구멍을 뚫어서 넣어주는 방식이었다. 프로세서는 현재와 비슷한 계산하는 역할이었고, 프린터는 입력에 대한 결과를 종이에 찍어서 보여주었다. 이 시기에는 운영체제도 존재하지 않았으므로, 오퍼레이터(operator)라는 컴퓨터를 사용하는 직업이 따로 있었고, 컴퓨터의 크기 또한 너무 커서 건물 전체를 사용해야할 정도였다. Batch processing system(일괄 처리 시스템) 위에서 초기 컴퓨터의 상황을 살펴보았는데, 프로그램을 수행할 때마다 컴파일-&gt;링크-&gt;로딩 순서를 오퍼레이터가 직접 입력해주었다. 이러한 과정을 자동화 한 것이 batch processing system 이다. 위 과정을 하나의 프로그램으로 작성하여 프로세서의 메모리안에 할당해주었는데, 이 프로그램을 resident monitor라고 불렀다. resident는 “거주” 라는 의미로 이 프로그램이 항상 프로세서안에서 거주한다는 의미로 이러한 이름을 사용하였다. 그리고 이것이 최초의 운영체제로 알려져 있다. Multiprogramming system(다중 프로그래밍) 과거에는 컴퓨터가 매우 비싼 장비였다. 그리고 초창기 메모리의 상태는 resident monitor를 제외하고 단 하나의 애플리케이션만을 할당하여 사용하였다. 하지만 이는 매우 비효율적인 방법이었다. 프로그램을 수행하는 도중에는 계산을 하는 CPU 외에도 입출력을 담당하는 I/O장치가 수행한다. 즉, CPU와 I/O장치가 교대로 동작 하는데 I/O장치가 수행하는 동안에는 CPU가 아무것도 할 일이 없었다. CPU가 아무일도 안하는 상태를 idle 상태라고 말한다. 그리고 I/O장치는 CPU에 비해 매우 느리기때문에 idle 상태의 비율이 너무 높았다. 이러한 비효율적인 수행을 해결하기 위해 multiprogramming system이 나왔다. Multiprogramming system은 메모리에 여러 애플리케이션(프로그램)을 올리는 시스템이다. 예를 들어 user1, user2 두 개의 애플리케이션이 있을 떄, 처음에는 user1에서 CPU 수행을 하다가 I/O장치 수행으로 넘어간다. 이 순간 CPU는 idle 상태에 있지 않고 user2가 있다는 것을 보고 user2의 CPU 수행을 시작한다. 이렇게 idle상태의 시간을 최대한 줄이고자 하였다. 하지만 메모리에 여러 프로그램을 올리면서 많은 문제점이 발생했다. 가장 큰 문제점은 CPU가 어느 프로그램을 수행해야하는지 선택하는 것이다. 이러한 작업을 CPU 스케줄링 이라고 하며, 이는 운영체제의 중요한 역할 중 하나이다. 그리고 새로 들어온 프로그램을 어느 메모리 공간에 할당해야하는지도 큰 문제였다. 이 역시 운영체제 역할 중 하나이다. Time-sharing system(시분할 시스템) 시간이 지나 모니터와 키보드를 사용하면서 사용자와 컴퓨터 사이에 대화 형식 이 가능해졌다. 하지만 여전히 컴퓨터 자체가 너무 비쌌기 때문에 아래와 같이 단말기(terminal) 형태로 사용하였다.  각 사용자(User)들은 모니터와 키보드만을 가지고, 실제 프로세서는 하나의 단말기에 존재하여 이를 공유하여 사용하였다. 멀티프로그래밍에서는 이와 같은 단말기 형태에서 문제가 생긴다. 예를 들어, 단말기 메모리에 User1 프로그램, User2 프로그램, User3 프로그램이 할당되어 있고 User1이 먼저 CPU를 사용한다고 하자. 멀티프로그래밍에서는 User1이 CPU를 수행하고 있는 도중에는 다른 사용자는 CPU자체를 사용할 수 없다. (CPU가 하나인 환경) 그러므로 다른 사용자들은 User1이 CPU수행을 모두 마칠 때까지(또는 I/O를 만날 때까지) 기다려야한다. 하지만 이는 매우 비효율적이다. 이를 해결하기 위해 나온 것이 time-sharing system이다. 시분할 시스템은 CPU가 하나의 프로그램을 수행하는 시간을 제한 하는 것이다. 예를 들어, User1 프로그램을 일정 시간 수행하면 반드시 다음 프로그램으로 넘어가서(스위칭, switching) 또 다시 일정 시간을 수행한다. 이렇게 일정 시간을 두어 프로그램들을 번갈아 수행하면서 모든 프로그램이 공평하게 수행이 되도록 한다. 그리고 이 일정 시간은 매우 짧은 시간(ms)이므로 CPU가 한 개인 환경에서도 여러 사용자가 동시에 사용하는 듯한 효과를 가져온다. 시분할 시스템을 사용하면서 여러 사용자(프로세스)간에 통신이 가능해졌다. 하지만 여기서도 역시 멀티프로그래밍에서와 같은 스케줄링과 메모리 문제가 있었다. 이를 해결하기 위해 동기화 기술, 가상 메모리 등이 이후에 나왔다. 인터럽트 기반 시스템(Interrupt based system) 현대 운영체제는 인터럽트 기반 시스템이다. 그렇다면 인터럽트는 무엇인가? 인터럽트 컴퓨터에 전원이 들어오면 위에서 말했듯이 부팅이 시작된다. 먼저, POST과정이 시작되고 그 후에 부트 로더가 하드 디스크에 있는 운영체제 프로그램을 RAM에 가져와 할당한다. 할당된 운영체제는 컴퓨터의 전원이 꺼질 때까지 상주(resident)한다. 부팅이 끝나고 운영체제가 동작하는 동안 수 많은 인터럽트가 발생할 수 있다. 예를 들어, 사용자가 마우스를 움직인다고 가정하자. 이 동작을 컴퓨터는 어떻게 알 수 있을까? 바로 인터럽트 를 통해 알 수 있다. 마우스를 움직이는 순간, 마우스에서 인터럽트 전기 신호가 발생하여 이를 CPU에게 보낸다. CPU는 이를 감지하고, 자신이 하던 일을 멈춘 후에 이 인터럽트 신호를 처리하기 위해 운영체제 내부에 있는 인터럽트를 처리하는 코드(interrupt service routine, ISR) 로 이동한다. 이 곳에 마우스가 움직일 때 어떻게 동작해야하는지가 내포되어 있어 이를 수행한다. 마우스 뿐만 아니라 키보드 역시 동일하게 동작한다. 이러한 하드웨어에서 발생한 인터럽트를 하드웨어 인터럽트(Hardwore Interrupt) 라고 한다. 인터럽트라고 하면 기본적으로 하드웨어 인터럽트를 말하지만, 소프트웨어에서도 인터럽트를 요청을 할 수 있다. 이를 소프트웨어 인터럽트(Software Interrupt) 라고 한다. 소프트웨어 인터럽트는 명령어로 직접 인터럽트 전기 신호를 CPU에게 보낼 수 있다. 즉, 프로그램에서 swi, int 와 같은 어셈블리어 명령어를 수행하는 것이다.(명령어는 운영체제마다 다르다.) 예를 들어, 마우스로 워드 작성 프로그램을 실행시킨다고 하자. 워드 작성 프로그램을 실행시키는 것까지는 하드웨어 인터럽트가 수행된다.(마우스가 이동하여 더블 클릭으로 실행하는 경우이다.) 이 프로그램에서 사용자가 하드디스크에 있는 다른 워드 파일을 읽고 싶은 경우, 소프트웨어 인터럽트를 발생시킨다. 소프트웨어 인터럽트 역시 하드웨어 인터럽트와 동일하게 운영체제 내부에 해당 인터럽트를 처리하는 코드(ISR)가 존재하여 이 곳으로 이동한다. 여기서 하드디스크에서 읽을 파일을 찾아서 반환해주는 수행을 처리하는 것이다. 마지막으로 내부 인터럽트(Internal Interrupt) 가 있다. 내부 인터럽트는 프로그램을 수행하는 도중에 발생하는 예외 상황을 처리한다. 대표적인 예로 0으로 나누는 동작이다. 프로그램의 내부에 result = a / 0; 이와 같은 코드가 있을 때, CPU는 내부 인터럽트를 발생시켜 운영체제안에 있는 ISR로 이동한다. 이 경우에는 DividedByZero 라는 ISR로 이동한다. 여기서 잘못된 동작을 수행한 프로그램을 강제로 종료시킨다. 운영체제는 평소에는 대기 상태에 있으면서 인터럽트가 발생하는 순간 작업을 수행한다. 그 인터럽트의 종류에 따라 운영체제 내부에 위치한 ISR로 이동하여 그에 맞는 처리를 한다. 위에서 설명한 하드웨어 인터럽트 과정을 그림으로 간단히 표현하면 아래와 같다.  사용자 애플리케이션을 실행하기 위해 하드웨어를 사용하는 모습이다. 애플리케이션이 실행하는 중에도 계속해서 인터럽트는 발생한다. 워드 작성 프로그램을 예를 들면 키보드로 글을 작성하는 경우, 하드디스크에 있는 파일을 불러오는 경우 모두 인터럽트가 발생한다. 그러므로 CPU는 애플리케이션과 운영체제 내부를 교대로 수행 하는 모습을 볼 수 있다. 정리하면, 인터럽트는 CPU에게 보내는 전기 신호로서 인터럽트가 발생하면 CPU는 하던 일을 중지하고 해당 인터럽트를 처리하기 위해 운영체제 내부에 있는 ISR로 이동하여 수행한다. 그리고 수행이 끝나면 원래 위치로 돌아간다. 인터럽트는 하드웨어 인터럽트, 소프트웨어 인터럽트, 내부 인터럽트로 총 세 가지가 존재한다. ","categories": ["Study"],
        "tags": ["Study_OperatingSystem"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-2%EC%9E%A5-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%97%AD%EC%82%AC/",
        "teaser":null},{
        "title": "[운영체제] # 3 이중모드와 보호",
        "excerpt":"현재 컴퓨터 환경은 여러 사람이 동시에 한 컴퓨터를 사용하는 경우가 많다.(서버 컴퓨터) 그리고 그 외에도 한 컴퓨터내에서 여러 프로그램을 수행하는 것이 일반적이다. 이 때 한 컴퓨터나 한 프로그램에서 잘못된 동작으로 인해 다른 컴퓨터(프로그램)가 영향을 받는다면 이는 매우 위험하다. 예를 들어, 한 프로그램에서 고의 또는 실수로 STOP, HALT, RESET 과 같은 명령어로 전체 컴퓨터의 동작이 멈추거나 꺼지는 경우가 있다. 이런 문제점을 해결하기 위해 일반 사용자가 위와 같은 치명적인 명령어들을 요청하는 것을 막을 필요가 생겼다. 여기서 이중 모드 라는 것이 나왔다. 이중 모드(Dual mode) 이중 모드는 말 그대로 모드를 아래와 같이 둘로 나누는 것이다.   사용자(User) 모드  관리자(Supervisor) 모드 = 시스템(system) 모드 = 모니터(monitor) 모드 = 특권(privileged) 모드특권 모드에서만 내릴 수 있는 명령을 특권 명령(privileged instruction) 이라고 하며, STOP, HALT, RESET, SET_TIMER 등이 있다. 만약 사용자 모드에서 특권 명령을 사용하려고 하면 CPU에서 내부 인터럽트를 발생시켜 해당 명령어를 요청한 프로그램을 강제로 종료시킨다. 이중 모드는 CPU 내부의 레지스터(register)의 비트(bit)를 활용하여 플래그(flag)로 나타낸다. 예를 들어 특권 모드일 때는 비트 값이 0 이고, 사용자 모드일 때는 비트  값을 1 로 설정하여 구분한다. 컴퓨터가 켜진 뒤에 한 사용자 애플리케이션을 실행시키는 동안 모드가 어떻게 변하는지 살펴보자.   컴퓨터 부팅 과정            - 관리자 모드  애플리케이션 실행 과정      - 관리자 모드  애플리케이션 실행중         - 사용자 모드  인터럽트 발생 후 처리 과정  - 관리자 모드  인터럽트 처리 후            - 사용자 모드사용자가 하드웨어의 자원에 접근하는 것은 매우 위험한 동작이다. 그러므로 이러한 경우에는 모두 관리자 모드로 운영체제에서 처리하도록 한다. (프로그램에서 소프트웨어 인터럽트를 발생시켜 운영체제에 위임한다.) 위의 4번 과정을 하드웨어 인터럽트로 가정하고 자세히 살펴보면 아래와 같다.   하드웨어 인터럽트 발생 후 CPU로 인터럽트 신호 요청 (사용자 모드)  CPU에서 모드 플래그를 관리자 모드 값으로 설정  해당 하드웨어 인터럽트 서비스 루틴(ISR)으로 이동 (관리자 모드)  인터럽트 처리 (관리자 모드)  인터럽트 처리 완료 후 CPU의 모드 플래그를 다시 사용자 모드 값으로 설정  원래의 애플리케이션 위치로 복귀 (사용자 모드) 애플리케이션이 실행하는 동안에는 위와 같은 모드 변경이 반복적으로 일어나는 것을 볼 수 있다. 대부분의 CPU는 이중 모드를 지원한다. 하드웨어 보호 이중 모드는 운영체제 기능 중에서 보호에 해당된다. 운영체제에서 보호할 대상은 입출력 장치, 메모리, CPU 총 세 가지가 존재한다. 입출력 장치 보호 여러 정보들은 입출력 장치를 통해 컴퓨터로 입력되고, 외부 장치로 출력이 된다. 여기서 크게 두 가지의 문제점이 발생한다.   여러 입출력 장치의 사용으로 인한 혼선  사용자가 자신의 데이터가 아닌 다른 사용자의 데이터에 입출력을 하는 일위와 같이 입출력 장치에 여러 사용자의 데이터가 뒤엉켜서 들어오거나 다른 사용자의 데이터에 접근하려는 경우를 막아야 한다.이를 해결하기 위해 in, out 과 같은 입출력 명령을 특권 명령으로 설정하는 것이다. 즉, 사용자 애플리케이션에서 입출력을 사용하려면 운영체제를 통해서 수행해야한다.(소프트웨어 인터럽트) 여러 프로그램이 동시에 입출력을 사용하려고 하면 운영체제 내부에서 순서를 정하여 혼선을 막아줄 수 있다. 만약 A, B 사용자가 있는 상황에서 A가 B의 데이터를 읽기 위해 운영체제에게 소프트웨어 인터럽트를 발생하였다고 하자. 그러면 운영체제 내부의 해당 ISR로 이동하게 되는데, 여기서 현재 사용자가 해당 데이터가 접근할 수 있는 여부를 판단하는 과정이 있으므로 이는 거부된다. 메모리 보호 메모리에는 운영체제뿐만 아니라 여러 개의 사용자 애플리케이션이 존재한다. 한 애플리케이션이 자신의 메모리 영역이 아닌 운영체제나 다른 애플리케이션의 메모리 영역에 침범하려하면 매우 위험하다.  메모리는 일반적으로 위와 같이 구성되어 있을 것이다. 여기서 user1이 OS나 user2, user3에 접근하는 것을 막아야 한다. CPU는 address bus를 통해 메모리 주소에 접근하게 되는데, user1 프로그램이 실행되는 동안에는 user1이 할당되어 있는 메모리 주소 범위 안인 경우에만 접근하면 될 것이다. 이를 address bus에서 검사하는 것이 가장 효율적일 것이다.  위의 생각으로 나온 것이 MMU(Memory Management Unit) 이다. MMU는 위의 그림처럼 address bus 중간에 설치된 하드웨어 칩으로서 두 개의 레지스터를 통해 해당 프로그램의 주소 범위를 저장한다. 예를 들어, User1의 시작 주소는 1024, 끝 주소는 4048이라고 하자. User1이 수행되는 동안 운영체제는 해당 프로그램의 주소 범위를 MMU에 설정(특권 명령)하는데, base는 1024, limit는 4048이 될 것이다. 결과적으로 user1이 수행되는 동안에는 이 범위 안의 주소값인 경우에만 address bus를 통과시킨다. 만약 해당 프로그램의 주소 범위 밖의 주소값이 MMU에 들어온다면, MMU에서 내부 인터럽트 를 발생시켜 CPU에 신호를 준다. 그러면 CPU는 그에 맞는 ISR로 이동하여 해당 프로그램을 강제로 종료시킨다. 이과 같은 잘못된 메모리 접근을 Segment violation 이라 한다. CPU 보호 CPU 보호는 사용자의 실수 또는 고의로 인한 CPU 독점을 방지해야 한다. 하나의 프로그램이 CPU를 독점하게 되면 다른 프로그램은 수행되지 못한다. while(n = 1){  // ...}CPU를 독점하는 가장 대표적인 예는 무한 반복 이다. 위의 코드를 보면 while문의 조건문이 잘못된 것을 볼 수 있다. 비교 연산자가 아닌 대입 연산자를 사용하여 n값이 1이 되므로 while문의 조건은 TRUE가 된다. 이는 n값이 변하지 않는 이상 무한으로 반복된다. 이를 해결하는 방법은 Timer를 두어 일정 시간이 지나면 타이머 인터럽트 를 발생시킨다. 인터럽트가 발생하면 반드시 운영체제 내의 ISR로 이동하므로, 해당 ISR에서 각 프로그램의 CPU 점유 시간을 측정하여 적절히 분배되도록 조정한다. 예를 들어, 한 프로그램의 CPU 점유 시간이 비정상적으로 오래 걸리는 경우, 강제로 다른 프로그램으로 CPU를 전환시켜 줄 수 있다. ","categories": ["Study"],
        "tags": ["Study_OperatingSystem"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-3%EC%9E%A5-%EC%9D%B4%EC%A4%91%EB%AA%A8%EB%93%9C%EC%99%80-%EB%B3%B4%ED%98%B8/",
        "teaser":null},{
        "title": "[운영체제] # 4 운영체제 서비스",
        "excerpt":"운영체제의 주요 서비스는 하드웨어 자원을 각 사용자 애플리케이션에 적절히 분배해주는 것이다. 하드웨어 자원은 CPU, 메인 메모리, 하드디스크, 키보드, 마우스, 프린터 등이 존재한다. 이러한 하드웨어 자원을 사용자 애플리케이션이 요구하거나 운영체제 내의 규칙에 의해 적절히 분배하여 컴퓨터의 성능을 최대한 효율적으로 사용해야 한다. 이를 실현하기 위해 운영체제 내에서는 각 하드웨어를 관리하는 기능을 다음과 같이 나눈다.   프로세스 관리  주기억장치 관리  파일 관리  보조기억장치 관리  입출력 장치 관리  네트워킹  보호  기타…프로세스 관리(Process management) 프로세스 관리는 운영체제 기능 중 가장 중요한 기능 중 하나이다. 프로세스와 프로그램은 기본적으로 구분된다. 프로세스는 실제 메인 메모리에서 실행 중인 프로그램(program in execution) 을 말한다. 프로그램은 하드디스크와 같은 보조기억장치에서 아무런 동작을 하지 않는 상태 이다. 이를 어떠한 요청에 의해 메인 메모리에 할당하여 CPU를 사용하면서 실행하게 되는데 이를 프로세스라 부른다. 프로세스 관리의 주요 기능은 다음과 같다.   프로세스의 생성과 소멸(creation, deletion)  프로세스 활동 일시 중지, 활동 재게(suspend, resume)  프로세스간 통신(interprocess communication: IPC)  프로세스간 동기화(synchronization)  교착상태 처리(deadlock handling)주기억장치 관리(Main memory management) 주기억장치 즉, 메인 메모리는 프로그램이 실행되기 위한 공간이다. CPU는 오직 메인 메모리에 있는 프로그램(프로세스)하고만 소통할 수 있다. 주기억장치 관리에서는 메인 메모리를 효율적으로 사용하도록 관리한다.   프로세스에게 메모리 공간 할당(allocation)  메모리의 어느 부분이 어느 프로세스에게 할당되었는가 추적 및 감시  프로세스 종료 시 메모리 회수(deallocation)  메모리의 효과적 사용  가상 메모리: 물리적 실제 메모리보다 큰 용량을 사용할 수 있다.파일 관리(File management) Track과 sector로 물리적으로 구성된 디스크를 파일이라는 논리적 관점으로 바라보고 이를 관리하는 것이다.파일은 OS가 실행되는 컴퓨터에서 자주 볼 수 있는데, 이는 복잡한 과정으로 하드디스크에 저장되어 있는 것을 사용자가 편리하게 사용할 수 있도록 파일 이라는 논리적 형태로 운영체제에서 관리하여 보여준다.   파일의 생성과 삭제(file creation, deletion)  디렉토리(Directory)의 생성과 삭제  기본 동작 지원: open, close, read, write, create, delete  Track/sector - file 간의 매핑(mapping)  백업(Backup)보조기억장치 관리(Secondary storage management) 보조기억장치는 대표적으로 하드 디스크, 플래시 메모리(주로 스마트폰에 사용)가 있다. 하드 디스크를 예로 들면, 하드 디스크에서 아무 것도 저장되어 있지 않는 공간을 block이라 하는데, 보조기억장치 관리는 이를 관리하는 것이다.   빈 공간 관리(Free space management)  저장공간 할당(Storage allocation)  디스크 스케줄링(Disk scheduling)입출력 장치 관리(I/O device management) 입출력 장치에는 키보드, 마우스, 프린터, 스피커, 마이크 등이 있다. 입출력 장치 관리는 이와 같은 여러 입출력 장치를 사용하기 위해 존재한다.   장치 드라이브(Device drivers)  입출력 장치의 성능향상: buffering, caching, spooling시스템 콜(System call) 시스템 콜은 유저 프로세스에서 운영체제 서비스를 필요로 할 때 이를 받기 위해 사용하는 호출이다.  위는 process1에서 프로세스 관리에 시스템 콜을 요청한 모습이다. 프로세스가 실행하는 중간에 운영체제 서비스가 필요하면 시스템 콜을 통해 운영체제 안의 해당 코드로 점프할 수 있다. 주요 시스템 콜   Process: end(정상 종료), abort(강제 종료), load, execute, create, terminate, get/set, attributes, wait event, signal event  Memory: allocate, free  File: create, delete, open, close, read, write, get/set attributes  Device: request, release, read, write, get/set attributes, attach/detach devices  information: get/set time, get/set system data  Communication: socket, send, receive","categories": ["Study"],
        "tags": ["Study_OperatingSystem"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-4%EC%9E%A5-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%84%9C%EB%B9%84%EC%8A%A4/",
        "teaser":null},{
        "title": "[운영체제] # 5 프로세스 관리",
        "excerpt":"프로세스(Process) 프로세스는 메인 메모리에 할당되어 실행중인 상태 인 프로그램을 말한다. 프로그램은 일반적으로 하드디스크(보조기억장치)에 저장되어 아무 일도 하지 않는 상태이다. 프로세스는 실행하면서 stack pointer, data, text, register 등이 끊임없이 변한다. 프로세스는 job, task 등으로 불리기도 한다. 프로세스 상태   New: 프로그램이 메인 메모리에 할당된다.  Ready: 할당된 프로그램이 초기화와 같은 작업을 통해 실행되기 위한 모든 준비를 마친다.  Running: CPU가 해당 프로세스를 실행한다.  Waiting: 프로세스가 끝나지 않은 시점에서 I/O로 인해 CPU를 사용하지 않고 다른 작업을 한다. (해당 작업이 끝나면 다시 CPU에 의해 실행되기 위해 ready 상태로 돌아가야 한다.)  Terminated: 프로세스가 완전히 종료된다. 위 그림은 프로세스 상태 전이도의 모습이다. new에서부터 프로세스가 어떤 작업에 의해 상태가 변하는지 나타낸다. running에서 ready로 변할 때는 time sharing system에서 해당 프로세스가 CPU시간을 모두 소진하였을 때 인터럽트에 의해 강제로 ready상태로 변하고, CPU는 다른 프로세스를 실행시킨다. PCB(Process Control Block) PCB는 프로세스에 대한 모든 정보 가 모여있는 곳으로, Task Control Block(TCB) 이라고도 한다. PCB안에는 프로세스의 상태, 프로세스 번호(PID), 해당 프로세스의 program counter(pc), register값, MMU정보, CPU점유 시간 등이 포함되어 있다. PCB는 운영체제 내부의 프로세스를 관리하는 코드 부분에 저장되어 있다.  CPU는 한 프로세스가 종료될 때까지 수행하는 것이 아니라 여러 프로세스를 중간 중간에 바꿔가면서 수행한다. 그러므로 CPU는 수행중인 프로세스를 나갈 때, 이 프로세스의 정보를 어딘가에 저장하고 있어야 다음에 이 프로세스를 수행할 때 이전에 수행한 그 다음부터 이어서 작업할 수 있다. 이러한 정보를 저장하는 곳이 PCB이다. 프로세스 큐(Queue) 프로세스는 수행하면서 상태가 여러 번 변하는데 이에 따라 서비스를 받아야하는 곳이 다르다. 그리고 프로세스는 일반적으로 여러 개가 한 번에 수행되므로 그에 따른 순서가 필요하다. 이러한 순서를 대기하는 곳을 큐(queue) 라고 부른다.    Job Queue: 하드디스크에 있는 프로그램이 실행되기 위해 메인 메모리의 할당 순서를 기다리는 큐이다.  Ready Queue: CPU 점유 순서를 기다리는 큐이다.  Device Queue: I/O를 하기 위한 여러 장치가 있는데, 각 장치를 기다리는 큐가 각각 존재한다.위와 같이 여러 큐가 존재하는데, 각 큐 내부에 저장된 실제 데이터는 각 프로세스의 PCB 가 저장되어 있다. 그리고 이러한 순서를 기다리는 공간이 있다면 이 순서를 정해주는 알고리즘이 있어야 한다. 이러한 알고리즘을 스케줄링(Scheduling) 이라 한다.   Job Queue - Job Scheduler(Long-term scheduler)  Ready Queue - CPU Scheduler(Short-term scheduler)  Device Queue - Device SchedulerJob queue의 순서를 정해주는 job scheduler를 long-term scheduler라고도 하는데, 이는 이 스케줄링이 발생하는 시간이 비교적 오래걸리기 때문이다.(대략 초~분) 반면에 ready queue의 스케줄러를 short-term scheduler라고도 하는데, 이는 스케줄링이 발생하는 시간이 매우 짧기 때문이다. CPU scheduling은 말 그대로 프로세스가 CPU를 점유하는 순서를 정해주는데 이는 매우 빠른 시간안에 이루어져야한다. 현대 컴퓨터가 여러 프로그램을 동시에 사용하는 것과 같은 효과를 주는 이유가 이 스케줄링 속도가 매우 빠르게 이루어지기 때문이다. 멀티프로그래밍(Multiprogramming) 멀티프로그래밍은 단일 프로세서(CPU) 환경에서 여러 개의 프로세스가 동시에 실행 되는 것을 말한다.(실제로 동시에 실행되지는 않음) 여러 프로세스가 실행되려면 이 프로세스들은 모두 메인 메모리에 존재하고 있어야 한다. 멀티프로그래밍에 관한 몇 가지 용어와 개념에 대해 살펴보자. Degree of multiprogramming Degree of multiprogramming 는 현재 메모리에 할당되어 있는 프로세스 개수를 말한다. I/O bound process VS CPU bound process 프로세스는 I/O bound process 와 CPU bound process 로 나뉜다.   I/O bound process: 해당 프로세스에서 I/O(입출력) 작업이 차지는 비중이 높은 프로세스를 말한다.  CPU bound process: 해당 프로세스에서 CPU 작업(계산)이 차지는 비중이 높은 프로세스를 말한다.운영체제, 정확히 말하면 job scheduler 는 I/O bound process와 CPU bound process를 적절히 분배해서 메모리에 할당해주어야 한다. Medium-term scheduler Medium-term scheduler는 말그대로 short-term보다는 덜 발생하지만, long-term보다는 자주 발생하는 scheduler이다. 하는 일은 운영체제가 실행하는 동안 주기적으로 메인 메모리에 있는 전체 프로세스를 검사하여 보조기억장치로 옮길 프로세스를 찾아 옮긴다. 옮기는 기준은 여러가지 있겠지만 대표적으로 장기간 사용하지 않는 프로세스가 있다. 이 기준으로 동작하는 것이 Swapping 이다. 이는 메인 메모리에서 장시간 사용하지 않는 프로세스를 하드디스크(Swap device = Backing store, 일반적으로 하드디스크는 File system + Backing store 로 구성되어 있다.)로 옮겨주고(Swap out), 나중에 이 프로세스가 다시 사용되려고 하면 하드디스크에서 해당 프로세스를 다시 메인 메모리에 할당해준다.(Swap in) Swap out을 통해 메인 메모리의 공간이 생기므로 이를 더욱 효율적으로 사용할 수 있다. 만약 swap out된 프로세스가 다시 swap in으로 메인 메모리에 할당하려고 할 때 이전의 공간으로 할당되는 것을 보장하지는 않는다. 왜냐하면 위에 말했듯이 swap out으로 생긴 메모리 공간은 다른 프로세스가 사용할 수 있기 때문이다. Context Switching(문맥 전환) Context switching은 CPU가 한 프로세스에서 다른 프로세스로 옮겨가는 것을 말한다. 즉, 한 프로세스가 실행중인 것을 멈추고 다른 프로세스가 실행되는 것이다.   Scheduler: 여기서 스케줄러는 CPU Scheduler를 말하며, CPU가 어느 프로세스를 선택할지 정한다.  Dispatcher: 실제 context switching이 발생하면 CPU의 내부 데이터를 이전 프로세스 데이터에서 새로 시작되는 데이터로 바꿔준다. 다시 말해서 현재 CPU 데이터는 이전 프로세스의 PCB에 갱신하고, 새로 시작되는 프로세스의 PCB 데이터를 CPU로 복원(restore) 해준다.  Context switching overhead: Context switching이 발생할 때마다, dispatcher에서 수행하는 작업을 매번 수행해야하며 이 모든 것은 overhead이다. 그리고 문맥 전환은 매우 자주 발생하는 작업이므로 overhead를 줄이기 위해서는 dispatcher를 구현하는 코드에 대한 효율을 최대한 높여주어야한다.","categories": ["Study"],
        "tags": ["Study_OperatingSystem"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-5%EC%9E%A5-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EA%B4%80%EB%A6%AC/",
        "teaser":null},{
        "title": "[운영체제] # 6 CPU 스케줄링",
        "excerpt":"CPU가 하나의 프로세스 작업이 끝나면 다음 프로세스 작업을 수행해야 한다. 이때 다음 프로세스가 어느 프로세스인지를 선택하는 알고리즘을 CPU Scheduling 알고리즘이라고 한다. 간단히 생각해보면 먼저 온 프로세스가 먼저 실행되는 것이 가장 좋을 것이라 생각할 수 있다. 하지만 여러 상황에서 사용되는 컴퓨터 환경에서 꼭 이러한 방법이 좋다고 할 수 없다.(단순한 환경에서도 이 방법이 반드시 빠른 것도 아니다.) 그러므로 CPU 스케줄링에는 여러가지 방법이 존재한다. Preemptive VS Non-preemptive Preemptive Preemptive(선점)은 프로세스가 CPU를 점유하고 있는 동안 I/O나 인터럽트가 발생한 것도 아니고 모든 작업을 끝내지도 않았는데, 다른 프로세스가 해당 CPU를 강제로 점유 할 수 있다. 즉, 프로세스가 정상적으로 수행중인 가운데 다른 프로세스가 CPU를 강제로 점유하여 실행할 수 있는 것이다. Non-preemptive Non-preemptive(비선점)은 말 그대로 preemptive와 반대이다. 한 프로세스가 한 번 CPU를 점유했다면, I/O나 인터럽트 발생 또는 프로세스 종료가 될 때까지 다른 프로세스가 CPU를 점유하지 못하는 것이다. Scheduling criteria Scheduling criteria(척도)는 스케줄링의 효율을 분석하는 기준들이다.   CPU Utilization(이용률, %): CPU가 수행되는 비율  Throughput(처리율, jobs/sec): 단위시간당 처리하는 작업의 수(처리량)  Turnaround time(반환시간): 프로세스의 처음 시작 시간부터 모든 작업을 끝내고 종료하는데 걸린 시간이다.(CPU, waiting, I/O 등 모든 시간을 포함한다.) 반환시간은 짧을 수록 좋다.  Waiting time(대기시간): CPU를 점유하기 위해서 ready queue에서 기다린 시간을 말한다.(다른 큐에서 대기한 시간은 제외한다.)  Response time(응답시간): 일반적으로 대화형 시스템에서 입력에 대한 반응 시간을 말한다.CPU Scheduling Algorithms First-Come, First-Served(FCFS) FCFS는 먼저 온 프로세스가 먼저 CPU를 점유하는 방식이다. 이는 매우 단순하고 많이 사용하는 방법이지만, 모든 부분에서 효율적인 것은 아니다. Gantt Chart             Process      Burst Time(msec)                  P1      24              P2      3              P3      3       첫 번째 표는 3개의 프로세스와 각 프로세스가 CPU를 사용한 시간(burst time)을 나타낸다. 이를 간트 차트로 표현하면 표 아래의 그림과 같다.(도착시간은 모두 0초라고 가정한다.) 평균 대기시간을 계산하면 아래와 같다.   Average Waiting Time = $\\frac{0 + 24 + 27}{3} = 17msec$만약, 프로세스가 들어온 순서가 P3, P2, P1 이라면 간트 차트는 아래 그림과 같이 바뀔 것이다.    Average Waiting Time = $\\frac{6 + 3 + 0}{3} = 3msec$두 예제에서 모든 프로세스가 끝난 시간은 30msec로 같지만, 평균 대기시간으로 봤을 때는 위의 예제는 17msec이고 아래는 3msec로 차이가 난다. 즉, 들어온 순서로 수행한다고 해도 반드시 효율적인 것은 아닌 것을 알 수 있다. 위 예제처럼 P1, P2, P3 순서로 들어온 것을 Convoy Effect 라고 한다. 이는 CPU 시간을 오래 사용하는 프로세스가 먼저 수행하는 동안 나머지 프로세스들은 그 만큼 오래 기다리는 것을 말한다. P1이 수행되는 동안 P2, P3는 오래 기다려야 하는 예제에서 이를 볼 수 있다. 이는 FCFS의 단점 중 하나이다. 그리고 FCFS는 Non-preemptive 이다. 하나의 프로세스가 끝나기 전에는 다른 프로세스가 중간에 끼어들 수 없다. Shortest-Job-First(SJF) SJF는 이름에서도 나타나듯이 가장 짧게 수행되는 프로세스가 가장 먼저 수행되는 것을 말한다. FCFS에서 보았듯이 수행 시간이 짧은 프로세스가 먼저 오는 것이 평균 대기시간이 짧은 것을 알 수 있었다. 이를 이용한 것이 SJF이다. Gantt Chart             Process      Burst Time(msec)                  P1      6              P2      8              P3      7              P4      3       위 간트 차트는 SJF를 사용하여 나타낸 것이다. 여기서 평균 대기시간을 계산하면 다음과 같다.   Average Waiting Time(AWT) = $\\frac{3 + 16 + 9 + 0}{4} = 7msec$위 표를 FCFS를 사용해서 간트 차트를 나타내보자.    Average Waiting Time(AWT) = $\\frac{0 + 6 + 14 + 21}{4} = 10.25msec$SJF와 FCFS의 평균 대기시간을 살펴보면 SJF가 더 짧은 것을 볼 수 있다. SJF가 평균 대기시간 기준으로 어떠한 방법보다 짧은 것은 이미 수학적으로 증명되어 있다. 그러므로 어떠한 예제를 보더라도 SJF가 AWT는 가장 짧다. 이를 보면 SJF가 가장 효율적인 CPU 스케줄링 방법으로 이를 쓰면 될 것 같지만, 사실은 이 스케줄링 방법은 매우 비현실적 이다. 왜냐하면 현실적인 컴퓨터 환경에서는 프로세스의 CPU 점유 시간(burst time)을 알 수 없다. 왜냐하면 한 프로세스가 실행 중에는 많은 변수가 존재하기 때문에 CPU 점유 시간을 알려면 실제로 수행하여 측정하는 수 밖에 없다. 실제 측정한 시간으로 예측해서 SJF를 사용할 수도 있지만, 이는 오버헤드가 매우 큰 작업으로 잘 사용되지 않는다. SJF는 preemptive와 non-preemptive 둘 다 사용가능 하다. 먼저, 아래의 표를 보자.             Process      Arrival Time      Burst Time(msec)                  P1      0      8              P2      1      4              P3      2      9              P4      3      5      기존의 예제와 달리 도착시간(arrival time)이 추가되었다. 첫 번째로 non-preemptive의 간트 차트를 보자.  가장 먼저 도착한 P1이 수행되는 동안 P2, P3, P4 모두 도착하지만, non-preemptive이므로 이미 수행중인 프로세스가 끝날 때까지 기다려야 한다.   Average Waiting Time(AWT) = $\\frac{0 + 7 + 15 + 9}{4} = 7.75msec$두 번째는 preemptive SJF를 살펴보자.  이번에는 preemptive이므로 프로세스가 도착할 때마다, 어느 프로세스가 가장 짧은 것인지 선택해야 한다. 주목할 점은 P2 프로세스가 도착했을 때, 현재 남은 burst time 중 가장 짧은 프로세스 가 P2이므로 P1을 수행하던 것을 멈추고 P2가 수행을 시작한다.   Average Waiting Time(AWT) = $\\frac{9 + 0 + 15 + 2}{4} = 6.5msec$Preemptive SJF는 예제에서 살펴보았듯이 현재 남아있는 시간 중 가장 짧은 프로세스를 선택하므로 Shortest-Remaining-Time-First(최소잔여시간 우선) 이라 불리기도 한다. Priority Priority 스케줄링은 말그대로 우선순위가 높은 프로세스가 먼저 선택되는 스케줄링 알고리즘이다. 운영체제에서 일반적으로 우선순위는 정수값으로 나타내며, 작은 값이 우선순위가 높다.(Unix/Linux 기준) Gantt Chart             Process      Burst Time(msec)      Priority                  P1      10      3              P2      1      1              P3      2      4              P4      1      5              P5      5      2       표에서 우선순위 값이 가장 낮은 순서대로 수행한 모습을 간트 차트로 나타내었다.   Average Waiting Time(AWT) = $\\frac{6 + 0 + 16 + 18 + 1}{5} = 8.2msec$우선순위를 정하는 방법은 크게 내부적인 요소와 외부적인 요소 두 가지로 나뉜다.   Internal: time limit, memory requirement, I/O to CPU burst(I/O작업은 길고, CPU 작업은 짧은 프로세스 우선) 등  External: amount of funds being paid, political factors 등Priority 스케줄링 역시 preemprive 와 non-preemptive 두 방식 모두 사용할 수 있다. Priority 스케줄링의 문제점은 Starvation(기아) 이 있다. Starvation은 말 그대로 CPU의 점유를 오랫동안 하지 못하는 현상을 말한다. Priority 스케줄링 방식에서 우선순위가 매우 낮은 프로세스가 ready queue에서 대기하고 있다고 가정해보자. 이 프로세스는 아무리 오래 기다려도 CPU를 점유하지 못할 가능성이 매우 크다. 실제 컴퓨터 환경에서는 새로운 프로세스가 자주 ready queue에 들어온다. 이러한 프로세스가 모두 우선순위가 높은 상태라면 이미 기다리고 있던 우선순위가 낮은 프로세스는 하염없이 기다리고만 있는 상태로 남아있을 수 있다. 이를 해결하는 방법 중 하나는 aging 이 있다. 이 방식은 ready queue에서 기다리는 동안 일정 시간이 지나면 우선순위를 일정량 높여주는 것이다. 그러면 우선순위가 매우 낮은 프로세스라 하더라도, 기다리는 시간이 길어질수록 우선순위도 계속 높아지므로 수행될 가능성이 커진다. Round-Robin(RR) Round-Robin은 원 모양으로 모든 프로세스가 돌아가며 스케줄링하는 것을 말한다. 이는 시분할 시스템에서 주로 사용하는 방식이다. 일정 시간을 정하여 하나의 프로세스가 이 시간동안 수행하고 다시 대기 상태로 돌아간다. 그리고 다음 프로세스가 역시 같은 시간동안 수행한 후 대기한다. 이러한 작업을 모든 프로세스가 돌아가면서 하며, 마지막 프로세스가 끝나면 다시 처음 프로세스로 돌아와서 반복한다. 위에서 말한 일정 시간을 Time Quantum(Time Slice) 이라 부른다. Time Quantum은 일반적으로 10 ~ 100msec 사이의 범위를 갖는다. Round-Robin은 기본적으로 preemptive 이다. 한 프로세스가 종료되기 전에 time quantum이 끝나면 다른 프로세스로 CPU를 넘겨주기 때문이다. Gantt Chart             Process      Burst Time(msec)                  P1      24              P2      3              P3      3        Time Quantum = 4msec Round-Robin 방식에서는 time quantum이 끝나면 CPU는 현재 프로세스를 대기상태로 보내고 다음 프로세스를 수행한다. 예제에서 P1이 0msec에 수행을 시작하여 종료되기 전에 time quantum 시간이 끝나여 P2가 수행되는 모습을 볼 수 있다. 그리고 P2, P3는 time quantum이 끝나기전에 수행이 끝났고, 마지막 남은 P1은 다른 프로세스가 없으므로 time quantum이 끝나더라도 종료될 때까지 계속해서 수행하는 모습이다.   Average Waiting Time(AWT) = $\\frac{6 + 4 + 7}{3} = 5.66msec$RR방식은 time quantum 크기에 따라 AWT와 같은 스케줄링 척도가 바뀐다. 그러므로 RR 방식은 time quantum에 매우 의존적 인 것을 알 수 있다. 만약 time quantum 크기가 무한에 가깝게 설정한다면 FCFS와 동일하게 동작한다. 반대로 time quantum 크기를 0에 가깝게 설정하면 switching overhead가 매우 증가하여 비효율적이다. 결과적으로 time quantum 은 적당한 크기로 설정해주어야 하는데, 일반적으로 위에서 말했듯이 10 ~ 100msec 으로 정한다. Multilevel Queue Multilevel Queue를 살펴보기 전에 프로세스 그룹에 대해 살펴보자. 프로세스는 기준에 따라 여러 그룹으로 나눌 수 있다.   System processes: 운영체제 커널 수준의 프로세스  Interactive processes: 유저 수준의 대화형 프로세스  Interactive editing processes  Batch processes: 대화형 프로세스의 반대인 것으로 일정량을 한 번에 처리하는 프로세스(Ex, 컴파일러)  Student processes위와 같이 여러 성격에 따라 프로세스 그룹을 나눌 수 있는데 이를 하나의 큐에 사용하는 것은 비효율적이라고 판단하였다. 그래서 각 그룹에 따라 큐를 두어 여러 개의 큐를 사용하는 것이 Muitilevel Queue 방식이다.  위 그림은 각 그룹에 따라 큐를 나눈 것이다. 그리고 각 큐마다 다른 규칙을 지정할 수도 있다. 먼저, 큐마다 우선순위를 지정해줄 수 있다. 프로세스 그룹을 보면 System process는 커널 수준에서 중요한 작업이므로 우선순위가 높은 그룹이라 볼 수 있다. 위 그림에서 System process, Interactive process, Batch process 순으로 우선순위가 높은 순서이다. Batch 프로세스는 운영체제의 개입이 매우 적으므로 우선순위가 가장 낮다고 볼 수 있다. 위의 방식 이외에도 큐에 따라 여러 기준을 둘 수 있다. 큐마다 CPU 시간을 다르게 줄 수도 있고, 큐마다 다른 스케줄링 방식을 사용할 수도 있다. Multilevel Feedback Queue Multilevel Feedback Queue도 Multilevel Queue와 같이 여러 개의 큐를 사용한다는 점에서 유사하다. 먼저, 그림을 통해 살펴보자.  위 그림을 보면 먼저 모든 프로세스는 가장 위의 큐에서 CPU의 점유를 대기한다. 이 상태로 진행하다가 이 큐에서 기다리는 시간이 너무 오래 걸린다면 아래의 큐로 프로세스를 옮긴다. 이와 같은 방식으로 대기 시간을 조정할 수 있다. 그리고 Multilevel Feedback Queue에서도 각 큐마다 다른 스케줄링, 다른 우선순위 등을 사용할 수 있다. 만약 우선순위순으로 큐를 사용하는 상황에서 우선순위가 낮은 아래의 큐에 있는 프로세스에서 starvation 상태가 발생하면 이를 우선순위가 높은 위의 큐로 옮길 수도 있다. 대부분의 상용 운영체제는 여러 개의 큐를 사용하고 각 큐마다 다른 스케줄링 방식을 사용한다. 프로세스의 성격에 맞는 스케줄링 방식을 사용하여 최대한 효율을 높일 수 있는 방법을 선택한다. ","categories": ["Study"],
        "tags": ["Study_OperatingSystem"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-6%EC%9E%A5-CPU%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81/",
        "teaser":null},{
        "title": "[운영체제] # 7 프로세스와 쓰레드",
        "excerpt":"프로세스와 생성과 종료 프로세스는 프로세스에 의해 만들어진다. 컴퓨터가 부팅이 되면 운영체제가 메모리에 올라오는데 운영체제가 처음으로 수행하는 일 중에 하나는 최초의 프로세스를 생성 하는 것이다. 이렇게 처음 만들어진 프로세스가 다른 프로세스를 만들고 그 프로세스가 또 다른 프로세스를 만드는 과정을 반복한다.  위와 같이 최초의 프로세스는 Init 이다. 이 이름은 운영체제마다 다르고, init은 UNIX 운영체제 기준 이름이다. 여기서 여러 다른 프로세스들이 생성되면 위와 같은 그림처럼 트리 모양 으로 나타낼 수 있다.여기서 프로세스를 생성한 쪽을 부모 프로세스, 만들어진 프로세스를 자식 프로세스 라고 한다. 같은 부모를 갖는 자식 프로세스 끼리는 서로 Sibling(형제) 프로세스라고 한다. 프로세스는 각각 고유의 번호를 갖는데 이를 PID(Process Identifirer) 라고 한다. PID는 일반적으로 정수형(integer)으로 표현한다. PPID는 부모의 PID를 말한다. 프로세스 생성 새로운 프로세스를 만드는 시스템 콜이 존재하는데, 이는 fork() 라 한다. 만들어진 프로세스에서 어떠한 파일을 실행하려면 exec() 시스템 콜을 사용한다. 프로세스 종료 프로세스를 종료하는 시스템 콜은 exit() 이다. 한 프로세스가 종료되면 해당 프로세스가 사용한 모든 자원(메모리, 파일, I/O 등)을 회수해야한다. 이러한 회수된 자원과 권한은 모두 운영체제로 되돌아가야한다. 쓰레드(Thread) 쓰레드는 프로그램 내부의 흐름(맥) 이다. int main(void){  int n = 0;  int m = 10;  printf(\"%d\\n\", n * m);  while(n &lt; m)    n++;  printf(\"END\\n\");}위와 같은 코드는 하나의 흐름을 가지고 있고 이를 쓰레드라고 부른다. 일반적으로 하나의 프로그램은 하나의 쓰레드를 갖는다. 다중 쓰레드(Mulitithreads) 하나의 프로그램에 쓰레드가 2개 이상 이 존재하는 것을 다중 쓰레드라고 한다. 이렇게 한 프로그램에 여러 개의 쓰레드 즉 흐름이 있을 수 있는 이유는 쓰레드가 빠른 시간 간격으로 스위칭되기 때문이다. 이러한 동작으로 사용자는 여러 쓰레드가 동시에 실행되는 것처럼 보인다. 이처럼 CPU가 하나인 환경에서 여러 쓰레드가 스위칭에 의해 동시에 수행되는 효과를 concurrent 라 한다. 반면에 여러 CPU 환경에서 여러 쓰레드가 실제로 동시에 수행되는 것은 simultaneous 라고 한다. 다중 쓰레드를 사용하는 대표적인 예는 Web browser 이다. 화면을 출력하는 쓰레드와 데이터를 읽어오는 쓰레드가 기본적으로 따로 수행하고 있다. 그 외에도 Word processor, Media player 등 현재 대부분의 프로그램은 다중 쓰레드로 동작한다. 이전의 CPU 스케줄링에서 하나의 프로세스가 수행하다가 다른 프로세스로 넘어간다고 하였는데, 이는 예전의 방식이다. 현재 운영체제에서는 대부분 다중 쓰레드를 지원하기 때문에 하나의 프로세스 안에서 여러 쓰레드를 수행하다가 다른 프로세스로 넘어가서 그 프로세스의 쓰레드를 수행한다. 그러므로 현대 운영체제의 context switching 단위는 프로세스가 아닌 쓰레드 단위 이다. Thread VS Precess 한 프로세스에는 기본적으로 하나의 쓰레드가 존재한다. 프로세스는 code, data 메모리 공간이 존재하는데, 이는 여러 쓰레드가 공유한다. 이외에도 프로세스의 자원인 file, I/O 등은 여러 쓰레드가 공유하지만, 각 쓰레드가 고유하게 가지고 있는 것은 PC(Program Counter), SP(Stack Pointer), registers, stack 등이 있다. ","categories": ["Study"],
        "tags": ["Study_OperatingSystem"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-7%EC%9E%A5-%EC%93%B0%EB%A0%88%EB%93%9C/",
        "teaser":null},{
        "title": "[운영체제] # 8 프로세스 동기화 - 1",
        "excerpt":"현대 컴퓨터의 메모리에는 여러 프로세스가 존재하는데, 이러한 프로세스들이 하나의 공유 메모리나 또 다른 프로세스에 접근할 때는 매우 신중해야 한다. 이처럼 한 프로세스가 다른 프로세스에게 영향을 받거나 주는 프로세스를 Cooperating process 라한다. 반대로 아무런 영향을 미치지 않는 독립적인 프로세스는  Independent process 이다. 현대 컴퓨터 환경에는 cooperating process 가 훨씬 많이 존재하고, 이들은 서로 영향을 미치기 때문에 데이터나 흐름에 대한 동기화 가 매우 중요하다. 프로세스 사이에 동기화를 하는 것을 프로세스 동기화(Process Synchronization) 라 한다.(현재에는 대부분 쓰레드 기준으로 스위칭을 하므로, Thread synchronization 으로 많이 불린다.) 예를 들어, 기차표 예매가 대표적이다. 어느 시간에 한 좌석의 기차표는 반드시 하나만 존재해야한다. 그런데 이를 예매하려는 사용자(프로세스)는 여러 명이다. 이 사용자들이 동시에 하나의 좌석 기차표를 구매하려고 하면 어떠한 일이 발생할까? 실제 환경에서는 당연하게도 동기화 문제를 해결한 시스템이므로 한 사람만이 기차표를 예매할 수 있을 것이다. 만약 동기화에 문제가 발생한다면 한 기차표를 여러 사람이 예매하는 불상사가 발생할 수 있다. 프로세스 동기화는 여러 프로세스가 공유하는 자원의 일관성 을 유지하는 것이다. 가령 여러 프로세스가 동시에 하나의 공유된 자원에 접근하려고 할 때 이 프로세스들의 순서를 정하여 데이터의 일관성을 유지시켜주어야 한다. Bank Account Problem(은행 계좌 문제) 동기화 문제 중에서 대표적인 은행 계좌 문제를 살펴보자. 은행에는 하나의 계좌에 입금, 출금을 할 수 있다. 여기서 계좌는 공유하는 자원 이고, 입금과 출금은 각각 프로세스라고 볼 수 있다. 이를 자바로 구현한 코드는 아래와 같다. // Test.javaclass Test {\tpublic static void main(String[] args)\t\tthrows InterruptedException {\t\tBankAccount b = new\t\tBankAccount();\t\tParent p = new Parent(b);\t\tChild c = new Child(b);\t\tp.start();   // start(): 쓰레드를 실행하는 메서드\t\tc.start();\t\tp.join();    // join(): 쓰레드가 마치기를 기다리는 메서드\t\tc.join();\t\tSystem.out.println(\"\\nbalance = \" + b.getBalance());\t}}// 계좌class BankAccount {\tint balance;\tvoid deposit(int amount) {\t\tbalance = balance + amount;\t}\tvoid withdraw(int amount) {\t\tbalance = balance - amount;\t}\tint getBalance() {\t\treturn balance;\t}}// 입금 프로세스class Parent extends Thread {\tBankAccount b;\tParent(BankAccount b) {\t\tthis.b = b;\t}\tpublic void run() {   // run(): 쓰레드가 실제로 동작하는 부분(치환)\t\tfor (int i=0; i&lt;100; i++)\t\tb.deposit(1000);\t}}// 출금 프로세스class Child extends Thread {\tBankAccount b;\tChild(BankAccount b) {\t\tthis.b = b;\t}\tpublic void run() {\t\tfor (int i=0; i&lt;100; i++)\t\tb.withdraw(1000);\t}}위의 코드를 실행시키면 대부분 아래와 같은 결과를 얻을 수 있다. balance = 0이 결과는 정상적이다. 100번 1,000원을 입금하고, 100번 1,000원을 출금하면 잔액은 0원이 남는다. 위 코드는 매우 간단한 코드 이므로 2개의 쓰레드가 동작하고 있지만 동기화 문제가 발생할 확률은 매우 낮다. 이를 조금 더 실제 상황과 비슷하게 만들기 위해 시간 지연 을 시켜보도록 하자. // 계좌class BankAccount {\tint balance;  void deposit(int amount) {\t\tint temp = balance + amount;\t\tSystem.out.print(\"+\");\t\tbalance = temp;\t}\tvoid withdraw(int amount) {\t\tint temp = balance - amount;\t\tSystem.out.print(\"-\");\t\tbalance = temp;\t}\tint getBalance() {\t\treturn balance;\t}}위 코드는 입금, 출금 기능을 담당하는 BankAccount 클래스에서 입금과 출금을 수행하는 동작에 약간의 시간 지연을 추가하였다.(화면에 출력하는 동작, 변수 대입 동작 추가) 그리고 입출금 횟수를 100에서 1000으로 늘려주었다. 이 코드를 실행시키면 결과는 다음과 같다. ++++++++++++++++++++++++++++++++++------------------------------------------------------------------------------------------------------------------------+++++++++----------------------------------------------++++++++++++++++++++++++++++++++----+++++++-+++++----+++--------------------------------------------------------+++++++-++++-+++++++++-------++++++++++++++++++++++++++++++++++++++++++++++++++++++++---------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-++++++++++++-------------------++++++++++++++++++++-++++++++++++++++++++++++++++++++-+-------------------------------------------------------------------------+++++++++++-+++++++----------------------------------------+-------+------------+------+------------------------------------------------------------------------+-------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------+-------+----------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------+--------------------------+-------------------------------------------------------------------------------++---------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++balance = 1000000+는 입금을 한 경우, -는 출금을 한 경우이고, 주목할 점은 balance값이 0이 아닌 1000000이라는 알 수 없는 값이 출력되었다. 약간의 시간 지연을 준 것만으로도 여러 쓰레드가 하나의 공유 자원을 사용하는 프로그램은 망가지게 된다. 이는 동기화 문제를 해결하지 못하였기 때문에 생기는 문제점이다. +, - 출력되는 결과는 운영체제에서 쓰레드를 스위칭하는 패턴이 매번 다르므로 수행할 때마다 다르게 출력될 수 있다. 이러한 문제가 발생하는 원인은 공통변수(common variable)에 대한 동시 업데이트(concurrent update) 때문이다. 위 예제에서 공통 변수는 계좌의 잔액이다. 이에 접근하는 프로세스의 코드를 보면 다음과 같다. balance = balance + amount;   // 입금balance = balance - amount;   // 출금이는 자바 문법에서는 한 줄이라 문제가 없어 보이지만, 로우 레벨(어셈블리어)로 내려가면 여러 줄로 구현된다. 위 코드를 사용한 예제에서는 문제가 발생할 확률이 매우 낮았지만, 두 번째로 본 예제와 같이 공통변수에 접근하는 공간에서 조금만 시간 지연을 발생시켜도 비정상적인 결과값이 나온 것을 확인하였다. 해결 방법은 공통변수에 접근하는 쓰레드는 하나만 존재하도록 관리해야 한다. 이러한 공통변수 구역을 임계구역 이라한다. 임계구역(Critical section) 문제 임계구역은 여러 개의 쓰레드가 수행되는 시스템에서 각 쓰레드들이 공유하는 데이터(변수, 테이블, 파일 등)를 변경하는 코드 영역 을 말한다. 이는 동기화에서 중요한 문제 중 하나이다. void deposit(int amount) {  balance = balance + amount;}void withdraw(int amount) {  balance = balance - amount;}위 코드는 은행계좌 문제에서의 임계구역이다. 임계구역을 해결하기 위해서는 3가지 조건이 만족해야한다.   Mutual exclusion(상호배타): 오직 한 쓰레드만이 진입 가능하다. 한 쓰레드가 임계구역에서 수행 중인 상태에서는 다른 쓰레드는 절대 이 구역에 접근할 수 없다.  Progress(진행): 한 임계구역에 접근하는 쓰레드를 결정하는 것은 유한 시간 이내에 이루어져야한다.  Bounded waiting(유한대기): 임계구역으로 진입하기 위해 대기하는 모든 쓰레드는 유한 시간 이내에 해당 임계구역으로 진입할 수 있어야 한다.프로세스/쓰레드 동기화 프로세스(쓰레드) 동기화를 통해 이루고자 하는 목적은 다음과 같다.   원하는 결과값을 도출하도록 임계구역 문제를 해결 한다.  프로세스의 실행 순서 를 원하는대로 제어한다.  Busy wait 등과 같은 비효율성을 제거한다.Semaphore(세마포) 세마포는 동기화를 해결하기위 만들어진 소프트웨어로서, 대표적인 동기화 도구 이다. 사전적 의미로는 역이나 군대에서 사용하는 수신호라는 뜻이다. 세마포는 두 가지 동작이 존재하는데, 초기에는 P, V로 불렸다.(네덜란드에서 만들어져 네덜란드어의 약자이다.) 현재에는 P는 test를 의미하며 acquire() 로 사용하고, V는 increment를 의미하며 release() 로 사용한다. 자바를 통해 세마포 구조를 간단히 살펴보면 아래와 같다. class Semaphore {  int value;      // number of permits  Semaphore(int value) {    // ...  }  void acquire() {    value--;    if (value &lt; 0) {      add this process/thread to list;      block;    }  }  void release() {    value++;    if (value &lt;= 0) {      remove a process P from list;      wakeup P;    }  }}위 코드에서 acquire() 는 value값을 감소시키고 만약 value값이 0보다 작으면 이미 해당 임계구역에 어느 프로세스가 존재한다는 의미이므로 현재 프로세스는 접근하지 못하도록 막아야한다. 이를 list라는 기다리는 줄에 추가한 뒤 block을 걸어준다.(list는 일반적으로 큐로 되어있다.) release() 는 value값을 증가시키고, 만약 value값이 0보다 같거나 작으면 임계구역에 진입하려고 대기하는 프로세스가 list에 남아있다는 의미이므로 그 중에서 하나를 꺼내어 임계구역을 수행할 수 있도록 해주어야 한다.  세마포를 그림으로 나타내면 위와 같다. list는 실제로 큐 로 볼 수 있다. acquire()에 의해 block되는 프로세스는 세마포 내부에 있는 큐에 삽입된 후, 다른 프로세스가 임계구역을 나오면서 release()를 호출하여 세마포 큐에 있는 프로세스를 깨워주어야 한다.(다시 ready queue로 보낸다.) 위에서 살펴본 것처럼 세마포는 일반적으로 Mutual exclusion 을 위해 사용된다. Bank Account Problem(은행 계좌 문제) 처음에 살펴본 은행계좌 문제에 세마포를 적용해보자. 위에서 임계구역은 BankAccount 클래스 내부의 입출력하는 부분인 것을 보았다. 여기에 세마포를 적용해보면 아래와 같다. import java.util.concurrent.Semaphore;  // 세마포를 사용하기 위해 파일 가장 위에 추가해야 한다.class BankAccount {\tint balance;\tSemaphore sem;\tBankAccount() {   // BankAccount 클래스의 생성자가 호출되면 세마포를 만든다.\t\tsem = new Semaphore(1);  // value 값을 1로 초기화한다.\t}\tvoid deposit(int amount) {\t\ttry {\t\tsem.acquire();   // 임계구역에 들어가기를 요청한다.\t\t} catch (InterruptedException e) {}    /* 임계 구역 */  \t\tint temp = balance + amount;\t\tSystem.out.print(\"+\");\t\tbalance = temp;\t\tsem.release();   // 임계구역에서 나간다.\t}\tvoid withdraw(int amount) {\t\ttry {\t\tsem.acquire();\t\t} catch (InterruptedException e) {}    /* 임계 구역 */  \t\tint temp = balance - amount;\t\tSystem.out.print(\"-\");\t\tbalance = temp;\t\tsem.release();\t}\tint getBalance() {\t\treturn balance;\t}}value 값은 임계구역에 몇 개의 프로세스를 접근할 것인지 정하는 것과 같다. 지금은 임계 구역에 하나의 프로세스만 접근가능하기 때문에 1로 초기화 한다.(위 코드를 제외한 부분은 동일하다.) 이 코드를 수행하면 아래와 같은 결과가 나온다. // +,- 출력 생략balance = 0정상적으로 잔액이 0원이 나온 것을 확인할 수 있다. 이 코드는 임계구역의 문제를 해결하였으므로 몇 번을 수행하여도 같은 결과값이 출력된다. Ordering 세마포는 mutual exclusion뿐 아니라 ordering을 하기 위해서도 사용한다. 즉, 프로세스의 실행 순서를 원하는 순서로 설정 할 수 있다. 예를 들어, 프로세스가 P1, P2 두 개가 있다고 가정하자. 원하는 순서는 P1, P2 순으로 실행하기를 원한다. 그러면 아래와 같이 설정해줄 수 있다.   sem value = 0;            P1      P2                         sem.acquire()              Section1      Section2              sem.release()             먼저, 세마포로 감싼 구역에 들어갈 수 있는 프로세스 개수를 정하는 value값을 0으로 설정한다.   P1이 먼저 실행된 경우          Section1에 이전에 아무런 동작이 없으므로 바로 수행한다.      sem.release() 를 만나면 value값을 1 증가시키고, 세마포 큐에 있는 프로세스를 깨워주는데 현재에는 큐에 프로세스가 없으므로 아무 동작도 하지 않는다.      P2가 실행된다.      P2의 sem.acquire() 를 만나면 현재 value값은 1이고 이를 1감소시키면 0이 된다. value = 0이면 block을 하지 않으므로, 무사히 Section2가 수행된다.        P2가 먼저 실행된 경우          Section2 이전에 sem.acquire() 가 있으므로 이를 수행하는데, 현재 value값은 0이고 이를 1 감소 시키면 -1이된다. value값이 음수면 해당 프로세스를 block시킨다.(세마포 큐에 삽입한다.)      P1이 실행되면 Section1이 바로 수행된다.      sem.release() 를 만나면 value값을 1증가시키고, 세마포 큐에 있는 P2 프로세스를 깨워준다.(현재 value = 0)      P2의 Section2가 수행된다.      위에서 두 가지 경우를 살펴보았듯이, P1, P2 둘 중 어느 것을 먼저 실행하여도 결과적으로 P1 -&gt; P2 순서로 수행하는 것을 알 수 있다. 입금 출금 순서로 은행계좌 문제 해결하기 위에서 계속 살펴봤던 은행계좌 문제에서 ordering을 적용해보자. 프로세스의 실행 순서는 반드시 입금, 출금 순서로 수행해야한다. class BankAccount {\tint balance;\tSemaphore sem, semOrder;\tBankAccount() {\t\tsem = new Semaphore(1);\t\tsemOrder = new Semaphore(0);   // Ordeing을 위한 세마포\t}\tvoid deposit(int amount) {\t\ttry {\t\tsem.acquire();\t\t} catch (InterruptedException e) {}\t\tint temp = balance + amount;\t\tSystem.out.print(\"+\");\t\tbalance = temp;\t\tsem.release();\t\tsemOrder.release();   // block된 출금 프로세스가 있다면 깨워준다.\t}\tvoid withdraw(int amount) {\t\ttry {\t\tsemOrder.acquire();   // 출금을 먼저하려고 하면 block한다.\t\tsem.acquire();\t\t} catch (InterruptedException e) {}\t\tint temp = balance - amount;\t\tSystem.out.print(\"-\");\t\tbalance = temp;\t\tsem.release();\t}\tint getBalance() {\t\treturn balance;\t}}위처럼 코드를 수정할 수 있다. Ordering을 위한 semOrder 세마포 변수를 선언하고, 출금하는 동작 앞에 acquire(), 입금하는 동작 뒤에 release() 를 추가하였다. +++++++++++++++++++++++++------------+++++-----+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++----------------------------------------------------------------------------------balance = 0실행 결과는 위와 같다. +(입금)가 맨 앞에서 실행한 모습을 볼 수 있다.(입금, 출금 횟수는 100번으로 줄였다.) 만약, 입금, 출금, 입금, 출금, … 교대로 출력하도록 하려면 세마포를 두 개 사용하여 아래와 같이 구현할 수 있다. Semaphore sem, semDeposit, semWithraw;BankAccount() {\tsem = new Semaphore(1);\tsemDeposit = new Semaphore(0);\tsemWithraw = new Semaphore(0);}void deposit(int amount) {\ttry {\tsem.acquire();\tint temp = balance + amount;\tSystem.out.print(\"+\");\tbalance = temp;\tsem.release();\tsemWithraw.release();\tsemDeposit.acquire();   // 입금후에는 반드시 출금을 해야 하므로 자신을 block한다.\t} catch (InterruptedException e) {}}void withdraw(int amount) {\ttry {\tsemWithraw.acquire();  // 입금보다 먼저 수행하는 것을 막는다.\tsem.acquire();\t} catch (InterruptedException e) {}\tint temp = balance - amount;\tSystem.out.print(\"-\");\tbalance = temp;\tsem.release();\tsemDeposit.release();  // 출금 수행이 완료되면 block되었던 입금 프로세스를 깨워준다.}int getBalance() {\treturn balance;}+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-balance = 0","categories": ["Study"],
        "tags": ["Study_OperatingSystem"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-8%EC%9E%A5-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-1/",
        "teaser":null},{
        "title": "[운영체제] # 9 프로세스 동기화 - 2",
        "excerpt":"전통적 동기화 예제(Classical Synchronization Problems) Producer-Consumer Problem 생산자-소비자 문제는 생산자가 데이터를 생산하면 소비자는 그 데이터를 소비하는 형태의 문제이다. 컴퓨터 환경에서 예를 보면, 컴파일러 -&gt; 어셈블러, 웹 서버 -&gt; 웹 클라이언트 등이 있다. 컴파일러에서 생성한 어셈블리어는 어셈블러에서 이를 소비하여 기계어를 만든다.  생산자-소비자 관계를 간단히 그림으로 나타내면 위와 같다. 이 관계의 대부분은 생산자에서 생산한 데이터 양을 소비자가 한 번에 소비하는 경우는 드물다. 생산한 데이터는 중간의 buffer 라는 저장 공간(메모리 공간)에 저장해두고 소비자는 여기서 필요한 만큼 가져간다. 버퍼의 크기는 현실적으로 유한하다. 그러므로 생산자는 버퍼 공간이 가득 차면 더 이상 저장할 수 없다. 소비자는 버퍼가 비어 있으면 가져올 수 없다. 이러한 유한한 버퍼 크기를 bounded buffer 라고 한다. Bounded buffer를 가진 생산자-소비자 문제를 자바 코드를 통해 살펴보자. class Test {\tpublic static void main(String[] arg) {\t\tBuffer b = new Buffer(100);\t\tProducer p = new Producer(b, 10000);\t\tConsumer c = new Consumer(b, 10000);\t\tp.start();\t\tc.start();\t\ttry {\t\t\tp.join();\t\t\tc.join();\t\t} catch (InterruptedException e) {}\t\tSystem.out.println(\"Number of items in the buf is \" + b.count);\t}}class Buffer {\tint[] buf;\tint size;\tint count;\tint in;\tint out;\tBuffer(int size) {\t\tbuf = new int[size];\t\tthis.size = size;\t\tcount = in = out = 0;\t}\tvoid insert(int item) {\t\t/* check if buf is full */\t\twhile (count == size)\t\t\t;\t\t/* buf is not full */\t\tbuf[in] = item;\t\tin = (in+1)%size;\t\tcount++;\t}\tint remove() {\t\t/* check if buf is empty */\t\twhile (count == 0)\t\t\t;\t\t/* buf is not empty */\t\tint item = buf[out];\t\tout = (out+1)%size;\t\tcount--;\t\treturn item;\t}}/****** 생산자 ******/class Producer extends Thread {\tBuffer b;\tint N;\tProducer(Buffer b, int N) {\t\tthis.b = b; this.N = N;\t}\tpublic void run() {\t\tfor (int i=0; i&lt;N; i++)\t\t\tb.insert(i);\t}}/****** 소비자 ******/class Consumer extends Thread {\tBuffer b;\tint N;\tConsumer(Buffer b, int N) {\t\tthis.b = b; this.N = N;\t}\tpublic void run() {\tint item;\tfor (int i=0; i&lt;N; i++)\t\titem = b.remove();\t}}Buffer 클래스의 멤버 변수를 보면   buf: Bounded buffer  size: 버퍼 크기  count: 버퍼에 저장된 데이터 개수  in: 생산한 데이터를 담을 버퍼 인덱스  out: 소비할 데이터를 가리키는 버퍼 인덱스만약 생성자가 데이터를 계속 생성하여 버퍼의 마지막 인덱스로 가면 그 다음은 처음으로 되돌아간다.(circular buffer) 소비하는 것도 마찬가지이다. main을 보면 크기가 100인 버퍼를 생성하고 2개의 쓰레드가 각각 생산자와 소비자 역할을 하여 각각 10000번씩 생산하고 소비한다. 정상적인 결과는 count값이 0이 출력되야 한다. 하지만 실제 코드를 수행하면 무한 루프에 빠지거나, count값에 전혀 예상하지 않은 값이 출력된다. 이 문제 역시, 동기화 문제이다. 생산자와 소비자가 동시에 접근하는 공통 변수인 buf, count 를 두 프로세스가 동시에 업데이트하기 때문이다. 다시 말하면 임계구역에 동시에 접근 한 것이다. 해결방법은 앞서 배웠던 세마포를 사용하여 mutual exclusion을 보장하는 것이다. 임계구역을 동시에 접근하는 것을 방지하고 하나의 프로세스만 허용해야한다. class Buffer {\tint[] buf;\tint size;\tint count;\tint in;\tint out;\tSemaphore mutex;   // 세마포 선언\tBuffer(int size) {\t\tbuf = new int[size];\t\tthis.size = size;\t\tcount = in = out = 0;\t\tmutex = new Semaphore(1);\t}\tvoid insert(int item) {\t\t/* check if buf is full */\t\twhile (count == size)\t\t\t;\t\t/* buf is not full */\t\ttry {\t\tmutex.acquire();\t\tbuf[in] = item;\t\tin = (in+1)%size;\t\tcount++;\t\tmutex.release();\t\t} catch(InterruptedException e) {}\t}\tint remove() {\t\t/* check if buf is empty */\t\twhile (count == 0)\t\t\t;\t\t/* buf is not empty */\t\ttry {\t\tmutex.acquire();\t\tint item = buf[out];\t\tout = (out+1)%size;\t\tcount--;\t\tmutex.release();\t\treturn item;\t\t} catch(InterruptedException e) {}\t\treturn -1;\t}}위는 임계구역에 세마포를 추가한 코드이다. 임계구역은 위에서 말했듯이 buf, count 에 접근하는 영역이므로 insert(), remove() 함수 내부에 선언한 것을 볼 수 있다. 하지만 여기서 한 가지 더 문제점이 있다. 바로 busy waiting 이다. 위에서 busy waiting은 생산과 소비하기 전에 버퍼가 가득 찼는지 비어 있는지 확인하는 무한 반복문을 말한다. 이는 아무 일도 하지 않으면서 무한으로 반복하여 CPU를 점유하고 있으므로 매우 비효율적이다. 이를 해결할 수 있는 것도 세마포이다. class Buffer {\tint[] buf;\tint size;\tint count;\tint in;\tint out;\tSemaphore mutex, full, empty;\tBuffer(int size) {\t\tbuf = new int[size];\t\tthis.size = size;\t\tcount = in = out = 0;\t\tmutex = new Semaphore(1);\t\tfull = new Semaphore(0);\t\tempty = new Semaphore(size);\t}\tvoid insert(int item) {\t\ttry {\t\tempty.acquire();    // 버퍼의 비어있는 공간을 1 감소시킨다.(비어있는 공간이 없으면 block)\t\tmutex.acquire();\t\tbuf[in] = item;\t\tin = (in+1)%size;\t\tcount++;\t\tmutex.release();\t\tfull.release();    // 버퍼의 찬 공간을 1 증가시킨다.\t\t} catch(InterruptedException e) {}\t}\tint remove() {\t\ttry {\t\tfull.acquire();    // 버퍼의 찬 공간을 1 감소시킨다.(버퍼가 모두 비어있으면 block)\t\tmutex.acquire();\t\tint item = buf[out];\t\tout = (out+1)%size;\t\tcount--;\t\tmutex.release();\t\tempty.release();   // 버퍼의 비어있는 공간을 1 증가시킨다.\t\treturn item;\t\t} catch(InterruptedException e) {}\t\treturn -1;\t}}busy waiting을 없애기 위해 두 개의 세마포를 더 추가하였다.   empty: 버퍼에서 비어있는 공간의 개수(초기값 size)  full: 버퍼에서 차있는 공간의 개수(초기값 0)추가한 세마포 변수는 위와 같고, empty는 초기화할 때 버퍼는 모두 비어있으므로 버퍼의 크기로 초기화하고 full은 초기 버퍼에는 아무런 데이터가 없으므로 0으로 초기화한다. 데이터를 생성하기 전에 비어있는 공간이 있는지 확인한다. 없다면 empty세마포의 value값이 -1이 되므로 block이 되고, 있다면 임계구역 내부로 진입하여 데이터를 생성한다. 생성이 완료되면 full세마포의 value값을 1 증가시킨다.(소비자는 반대로 동작한다고 볼 수 있다. 코드참고) 이 코드를 실행시켜보면 정상적으로 결과값이 0이 출력되는 것을 확인할 수 있다. Readers-Writers Problem Readers-Writers 문제는 대표적으로 공통 데이터베이스에 접근하는 경우가 있다. 하나의 데이터베이스에 여러 프로세스(readers, writers)가 접근하므로, 데이터베이스는 임계구역으로 설정해야한다. 즉, 한 번에 한 개의 프로세스만 접근가능하도록 해야하는데 이는 매우 비효율적이다. 비효율을 해결하기 위해 데이터베이스에 접근하는 프로세스 종류를 reader와 writer로 나눈다. 그리고 reader는 데이터베이스 내의 정보를 바꾸지 않고 읽기만 하는 프로세스 이므로, 여러 reader 프로세스가 동시에 데이터베이스를 접근하는 것을 허용한다. writer는 데이터베이스 내용을 바꾸는 프로세스이므로 당연히 mutual exclusion 을 보장해야한다. Readers-Writers 문제는 우선순위에 따라 여러 경우로 나눌 수 있다.       The first R/W problem (readers-preference): 이 방법은 reader 프로세스에 우선권을 주는 것이다. 만약, 한 reader 프로세스가 데이터베이스를 읽고 있는 동안 writer 프로세스가 오면 당연히 접근하지 못하고 기다린다. 이 상황에서 다른 reader 프로세스가 들어온다면, writer 프로세스가 기다리는 것을 무시하고 데이터베이스에 접근하여 읽는다. 그 결과, 두 reader가 동시에 데이터베이스를 읽는 상황이 된다.         The second R/W problem (writers-preference): 위 방법과 반대로 writer 프로세스가 기다리는 상황에서 다른 reader 프로세스가 들어온다면, 기존의 writer 프로세스 다음 순서로 기다려야한다.         The third R/W problem: 아무에게도 우선순위를 주지 않는다.   Dining Philosopher Problem 식사하는 철학자 문제는 원형 테이블에 5명의 철학자와 5개의 젓가락이 있는 상황이 있다고 하자. 각 철학자는 생각하고 식사하고 생각하고 식사하고를 반복한다. 단, 식사를 하기 위해서는 2개의 젓가락이 필요하다.  이 상황을 프로그래밍을 해보자. 젓가락은 한 철학자가 가져가면 다른 철학자는 이 젓가락을 사용할 수 없다. 즉, 한 젓가락에 동시에 접근할 수 있는 철학자는 한 명 뿐이므로 젓가락은 세마포로 만들 수 있다.(number of permit = 1) 한 철학자가 식사를 하려고 하면, 왼쪽 젓가락과 오른쪽 젓가락 순서로 가져가고, 식사가 끝나면 동일하게 왼쪽 젓가락, 오른쪽 젓가락 순서로 내려놓는다. 이를 자바 코드로 구현하면 아래와 같다. import java.util.concurrent.Semaphore;class Philosopher extends Thread {\tint id; // philosopher id\tSemaphore lstick, rstick; // left, right chopsticks\tPhilosopher(int id, Semaphore lstick, Semaphore rstick) {\t\tthis.id = id;\t\tthis.lstick = lstick;\t\tthis.rstick = rstick;\t}\tpublic void run() {\t\ttry {\t\t\twhile (true) {\t\t\t\tlstick.acquire();\t\t\t\trstick.acquire();\t\t\t\teating();\t\t\t\tlstick.release();\t\t\t\trstick.release();\t\t\t\tthinking();\t\t\t}\t\t}catch (InterruptedException e) { }\t}\tvoid eating() {\t\tSystem.out.println(\"[\" + id + \"] eating\");\t}\tvoid thinking() {\t\tSystem.out.println(\"[\" + id + \"] thinking\");\t}}class Test {\tstatic final int num = 5; // number of philosphers &amp; chopsticks\tpublic static void main(String[] args) {\tint i;\t/* chopsticks */\tSemaphore[] stick = new Semaphore[num];\tfor (i=0; i&lt;num; i++)\t\tstick[i] = new Semaphore(1);\t/* philosophers */\tPhilosopher[] phil = new Philosopher[num];\tfor (i=0; i&lt;num; i++)\t\tphil[i] = new Philosopher(i, stick[i], stick[(i+1)%num]);\t/* let philosophers eat and think */\tfor (i=0; i&lt;num; i++)\t\tphil[i].start();\t}}5개의 젓가락 세마포와 5명의 철학자 쓰레드를 생성한다. 각 철학자 쓰레드에는 무한 반복문으로 왼쪽 젓가락과 오른쪽 젓가락을 순서대로 집은 후 식사를 하고(몇 번 철학자가 식사했다는 것을 화면에 출력), 다시 왼쪽 젓가락, 오른쪽 젓가락 순으로 내려놓고 생각을 한다. 단순히 코드를 봐서는 문제점이 없어보인다. 하지만 이를 수행하면 중간에 멈추고 더이상 실행되지 않는다.이는 대표적인 starvation 문제중 하나이다. 모든 철학자가 식사를 하지 못하고 굶어죽는 상황이라고 할 수 있다. 이는 매우 드문 상황으로 모든 철학자가 동시에 식사를 하려고 왼쪽 젓가락을 집었다고 하자. 그러면 5명의 철학자가 5개의 젓가락을 모두 집어든 상황이다. 그 결과, 남아있는 젓가락은 더 이상없고 모든 철학자가 반대편 젓가락을 들기 위해 기다리고 있다. 하지만 식사할 수 있는 철학자는 없으므로 아무도 젓가락은 내려놓지 않고 하염없이 기다리고 있다. 이러한 상황을 교착상태(deadlock) 라고 한다. ","categories": ["Study"],
        "tags": ["Study_OperatingSystem"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-9%EC%9E%A5-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-2/",
        "teaser":null},{
        "title": "[운영체제] # 10 프로세스 동기화 - 3",
        "excerpt":"Deadlock(교착상태) 프로세스는 실행을 위해 CPU, 메모리, 파일 등 여러 하드웨어 자원이 필요하다. 이를 운영체제에서 프로세스가 요구하는 자원을 적절히 분배해준다. 예를 들어, 한 프로세스가 A 자원을 가지고 있는 상태에서 B 자원을 요구하고 있다. 하지만 B 자원은 다른 프로세스 역시 요구하고 있는 자원인데, 이러한 상황에서 자원을 분배하는 순서가 잘못되면 교착상태에 빠지게 된다. 교착상태 필요 조건(Necessary Conditions) 교착상태가 일어나기 위한 필요 조건이 네 가지가 존재한다. 이는 필요 조건 이므로, 네 가지가 모두 해당된다고 해서 반드시 교착상태가 일어나는 것은 아니고, 일어날 확률이 생기는 것이다.   Mutual exclusion (상호배타): 한 프로세스가 자원을 사용하고 있다면, 다른 프로세스는 이 자원을 사용할 수 없다. (젓가락은 한 철학자가 사용하고 있으면 이 젓가락은 사용할 수 없으므로 상호배타적이다.)  Hold and wait (보유 및 대기): 한 프로세스가 자원을 가지고 있는 상태에서 대기한다. (철학자는 왼쪽 젓가락을 가지고 있는 상태에서 오른쪽 젓가락을 집기 위해 대기한다.)  No Preemption (비선점): 한 프로세스가 자원을 수행하는 중에는 다른 프로세스가 중간에 끼어들 수 없다. (한 철학자가 젓가락을 집은 상태에서 다른 철학자가 이 젓가락을 뺏을 수 없다.)  Circular wait (환형대기): 프로세스가 요구하는 자원의 방향이 원형을 이룬다. (모든 철학자는 왼쪽 젓가락부터 집을 수 있다.)교착상태는 위 네 가지 조건을 모두 만족하더라도 매우 드물게 일어나는 현상이지만, 한 번 교착상태에 빠지면 프로세스가 무한 루프에 빠져 수행하지 못하고 해당 프로세스가 가지고 있는 자원은 아무도 사용하지 못하므로 전체 컴퓨터 환경에 매우 치명적 이다. 그리고 교착상태에 의한 오류를 해결하기는 매우 힘들다. 자원(Resources) 하드웨어 자원은 여러 개가 존재하고 동일한 형식(type)의 자원이 존재할 수 있다. 예를 들어, 같은 CPU가 2개있는 환경이 있다. 이러한 자원 하나하나를 instance라고 한다. 자원은 프로세스가 직접적으로 사용할 수 없고, 운영체제에 요청(request) 하면 운영체제가 제공해준다. 그 후 프로세스는 이 자원을 사용(use) 하고 모든 사용이 끝나면 이를 반납(release) 한다. 자원 할당도(Resource Allocation Graph) 자원 할당도는 어떤 자원이 어떤 프로세스에 할당되었는지 또는 어느 프로세스가 어느 자원을 할당 받으려고 기다리는지를 그림 으로 나타낸 것이다.   자원: 사각형  instance: 점  프로세스: 원  할당: 화살표 위 그림은 R1은 P1에 할당되어 있는 상태이고, P2는 R1을 요청하고 있는 상태이다  자원 할당도를 사용하는 이유는 교착상태의 필요조건을 한 눈에 볼 수 있기 때문이다. 자원 할당도를 분석할 때 mutual exclusion과 no-preemption은 기본으로 적용 된다. Hold and wait는 화살표를 통해 한 프로세스가 인스턴스를 할당받았고 다른 자원을 가리키고 있다면, 이 상황은 Hold and wait인 상태이다. Circular wait 역시 화살표 방향이 원형을 이루고 있다면 이는 환형대기인 상태이다.  위 그림은 식사하는 철학자 문제를 자원 할당도로 표현한 것이다. 그림을 보면 한 눈에 Circular wait 조건을 만족한 것을 알 수 있다. 그리고 모든 철학자(프로세스)는 한 젓가락(자원)을 할당(파란색 화살표)받고, 다른 젓가락을 요청(검은색 화살표)하고 있으므로 Hold and wait 조건 역시 만족한다. 그러면 위에서 살펴본 식사하는 철학자 문제를 해결하기 위해 Circular wait 조건을 없애보자. 물론, 여러 가지 방법이 존재하지만, 간단하게 circular wait 조건을 없애기 위해 짝수 번호 철학자는 왼쪽 젓가락, 오른쪽 젓가락 순서로 홀수 번호 철학자는 반대인 오른쪽 젓가락, 왼쪽 젓가락 순서로 집는다고 하자.  // Philosopher Thread run functionpublic void run() {  try {    while (true) {      if (id % 2 == 0) {        lstick.acquire();        rstick.acquire();      }      else {        rstick.acquire();        lstick.acquire();      }      eating();      lstick.release();      rstick.release();      thinking();    }  }catch (InterruptedException e) { }}첫 번째 그림은 circular wait 조건을 없앤 식사하는 철학자 문제의 자원 할당도이다. 화살표가 원형을 만들지 않는 것을 볼 수 있다. 두 번째 코드는 철학자 쓰레드의 run 함수에서 젓가락을 집는 코드를 바꾼 모습이다. 위와 같이 코드를 변경하고 실제로 수행하면 무한 반복문이 끝나지않고 정상적으로 계속되는 것을 확인할 수 있다. 교착상태 처리 1. 교착상태 방지 (Deadlock Prevention) 교착상태 방지는 위에서 살펴본 교착상태 필요조건 네 가지 중 최소 한 가지를 만족시키지 않도록 만드는 것이다.   상호배타(Mutual exclusion): 상호배타를 없애기 위해서는 자원을 공유 가능하게 만들어야 한다. 하지만 현실적으로 이러한 방법이 불가능 한 경우가 많다.  보유 및 대기(Hold &amp; Wait): 이 조건을 없애려면 자원을 가지고 있는 상태에서 다른 자원을 기다리지 않도록 만든다. 만약 여러 개의 자원이 필요하다면 필요한 모든 자원을 얻을 수 있는 경우에만 해당 자원을 요청한다. 또는 필요한 자원 중 일부만 가지는 경우 할당받은 자원을 모두 운영체제에 반납한다. 하지만 이와 같은 방법은 자원의 활용률을 저하시키고, starvation 현상이 발생하는 단점 이 있다.  비선점(No preemption): 비선점을 없애러면 반대로 선점이 가능하도록 만들어야 한다. 이 역시 대부분의 자원에게는 불가능 한 방법이다. CPU는 강제로 스위칭하는 것이 가능한 경우가 있지만, 프린터를 수행하는 중간에 다른 프로세스가 이를 선점하는 것은 불가능하다고 볼 수 있다.  환형대기(Circular wait): 이 조건을 없애는 것은 위 세 가지 조건보다는 할 수 있는 확률이 높다. 대표적인 예는 모든 자원에 번호를 부여하여 이 번호에 대한 오름차순 으로 자원을 요청하는 것이다. 이 역시 자원의 활용률을 저하 시키는 단점이 있다.네 가지 방법을 살펴본 결과 가장 현실적인 방법은 hold &amp; wait나 circular wait 조건을 없애는 것이다. 하지만 둘 다 자원을 비효율적으로 사용하게 되는 단점을 가지고 있다. 그래서 이와 같이 교착상태를 사전에 방지하는 것은 군사, 우주, 의료와 같은 크리티컬한 곳에서 사용하는 것이 좋다. 2. 교착상태 회피 (Deadlock Avoidance) 교착상태 회피와 방지의 차이점은 교착상태를 다르게 접근하는 것이다. 교착상태 회피에서는 교착상태를 자원 요청에 대한 잘못된 승인 으로 판단한다. 따라서, 교착상태 회피에서는 안전한 할당(Safe allocation) 과 불안정한 할당(Unsafe allocation) 두 가지로 나뉜다. 먼저 안전한 할당에 대한 예제를 보자. 현재 운영체제에는 magnetic tape 자원이 총 12개가 있고, 이를 요청하는 3개의 프로세스가 있다.             Process      Max needs      Current needs                  P0      10      5              P1      4      2              P2      9      2      3개의 프로세스가 요청하는 magnetic tape의 양은 위 표와 같다. Current needs는 한 프로세스가 한 번 요청을 할 때 요구하는 개수이고, Max needs는 프로세스를 정상적으로 끝내기 위해 필요한 총 개수이다. 운영체제 입장에서 3개의 프로세스가 모두 수행될 때까지 자원을 분배해보자.   P0에게 5개를 할당한다.(5/10) =&gt; 현재 magnetic tape 개수: 7  P1에게 2개를 할당한다.(2/4) =&gt; 현재 magnetic tape 개수: 5  P2에게 2개를 할당한다.(2/9) =&gt; 현재 magnetic tape 개수: 3  다시 P0가 5개를 요구하지만 현재 magnetic tape 개수는 3개이므로 할당해줄 수 없다.  P1에게 2개를 할당한다.(4/4) =&gt; 현재 magnetic tape 개수: 1  P1은 필요한 4개의 magnetic tape을 받았으므로, 정상적으로 프로세스를 종료하고 사용한 자원을 반납한다. =&gt; 현재 magnetic tape 개수: 5  대기하고 있던 P0에게 5개를 할당한다.(10/10) =&gt; 현재 magnetic tape 개수: 0  P0 역시 필요한 자원을 모두 할당받았으므로, 종료 후 자원을 반납한다. =&gt; 현재 magnetic tape 개수: 10  P2는 현재 필요한 magnetic tape 개수가 7개이고, 현재 남아있는 magnetic tape 개수 10개이므로 정상적으로 수행가능하다.이 예제에서는 3개의 프로세스가 모두 정상적으로 자원을 할당받고 종료할 수 있었다. 이를 안전한 할당이라 한다. 다음 예제를 보자.             Process      Max needs      Current needs                  P0      10      5              P1      4      2              P2      9      3      이 예제 역시 운영체제가 보유하고 있는 총 magnetic tape 개수는 12개이고, 3개의 프로세스가 존재한다. 자원을 분배해보자.   P0에게 5개를 할당한다.(5/10) =&gt; 현재 magnetic tape 개수: 7  P1에게 2개를 할당한다.(2/4) =&gt; 현재 magnetic tape 개수: 5  P2에게 3개를 할당한다.(3/9) =&gt; 현재 magnetic tape 개수: 2  다시 P0가 5개를 요구하지만 현재 magnetic tape 개수는 2개이므로 할당해줄 수 없다.  P1에게 2개를 할당한다.(4/4) =&gt; 현재 magnetic tape 개수: 0  P1은 필요한 자원을 모두 할당받았으므로, 정상적으로 프로세스를 종료하고 사용한 자원을 반납한다. =&gt; 현재 magnetic tape 개수: 4  대기하고 있던 P0는 아직 할당받으르 수 없다.  P2에게 3개를 할당한다.(6/9) =&gt; 현재 magnetic tape 개수: 1  현재 남아있는 magnetic tape 개수는 1개이고, P0가 요구하는 개수는 5개, P2는 3개이므로 두 프로세스 모두 할당받을 수 없다.이 예제에서 남은 magnetic tape 개수가 요구하는 개수보다 적으므로 자원을 할당해줄 수 없다. 그러므로 P0, P2 프로세스는 자원을 하염없이 기다리게 된다. 이를 불안전한 할당이라 하고, 그 결과 교착상태에 빠지게 된다. 교착상태 회피는 마치 대출전문 은행과 유사하게 동작하므로, 해결 방법을 Banker’s Algorithm 이라 한다. 3. 교착상태 검출 및 복구 (Deadlock Detection &amp; Recovery) 1번과 2번 방법은 사전에 교착상태를 일어나지 않도록 하는 방법이지만, 교착상태 검출 및 복구 방법은 교착상태가 일어나는 것을 허용한다. 그 대신, 교착상태가 일어났을 때 이를 인지하고 복구를 해야 한다. 교착상태가 일어나는 것을 감지하기 위해 운영체제 내부에서 주기적으로 교착상태가 발생하였는지 검사 해야한다. 그 주기의 길이가 짧으면 그 만큼 오버헤드가 크고, 주기가 길면 오버헤드는 줄일 수 있지만 복구 가능성이 낮아진다. 복구하는 방법은 교착상태가 발생하는지 주기적으로 검사하듯이 메모리의 상태를 주기적으로 메모리에 저장해놓고 만약 교착상태가 발생하면 그 이전 상태로 되돌리는 방법이 있다. 그 외에도 일부 프로세스를 강제로 종료하거나 자원을 강제로 선점하여 프로세스에게 할당해주는 방법 등이 있다. 교착상태 검출 및 복구는 교착상태 자체가 매우 드문 현상이므로 자유롭게 자원을 분배하다가 교착상태가 발생하면 이를 정상적인 상태로 복구하는 것이다. 하지만 복구를 제대로 하지 못할 수도 있고, 검출을 위해 추가적인 오버헤드가 발생한다는 단점이 있다. 4. 교착상태 무시 교착상태의 필요조건 네 가지를 모두 만족하더라도 교착상태가 반드시 일어나는 것이 아니라고 했듯이, 교착상태는 매우 드문 상황이다. 그러므로 이를 위해 오버헤드를 감수하는 것이 비효율적인 환경도 존재한다. 그러한 환경은 교착상태에 대한 아무런 조치를 하지 않는 방법도 있다. ","categories": ["Study"],
        "tags": ["Study_OperatingSystem"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-10%EC%9E%A5-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-3/",
        "teaser":null},{
        "title": "[운영체제] # 11 모니터",
        "excerpt":"세마포는 실제로 매우 오래된 동기화 도구이다. 현재에는 모니터(monitor)라는 동기화 도구를 주로 사용하며, 이는 좀 더 고수준의 동기화 기능을 제공한다. 모니터 구조  위는 모니터의 구조는 간단히 나타낸 그림이다. 모니터는 공유 자원 + 공유 자원 접근함수 로 이루어져 있고, 2개의 큐를 가지고 있다. 각각 mutual exclusion(상호배타) queue, conditional synchronization(조건동기) queue 이다. 상호배타 큐는 말그대로 공유 자원에 하나의 프로세스만 진입하도록 하기 위한 큐이다. 조건동기 큐는 이미 공유자원을 사용하고 있는 프로세스가 특정한 호출(wait())을 통해 조건동기 큐로 들어갈 수 있다. 조건동기 큐에 들어가 있는 프로세스는 공유자원을 사용하고 있는 다른 프로세스에 의해 깨워줄 수 있다. 이 역시 깨워주는 프로세스에서 특정한 호출(notify())을 해주며, 깨워주더라도 이미 공유자원을 사용하고 있는 프로세스가 해당 구역을 나가야 비로소 큐에 있던 프로세스가 실행된다. 자바 모니터 자바는 모니터를 제공하는 대표적인 언어이며, 자바의 모든 개체는 모니터가 될 수 있다. 그렇다면 자바를 통해 모니터에 대한 예제를 살펴보자. class C {  private int value, ...;     // 공유 변수  synchronized void Foo() {   // 배타동기    // ...  }  synchronized void Goo() {    // ...  }  void H() {    // ...  }}위 코드는 모니터를 사용하고 있는 클래스이다. value와 같은 변수들은 여러 쓰레드가 공유하고 있는 변수로 볼 수 있고, synchronized 키워드는 배타동기 를 수행하는 함수를 말한다. 즉, 해당 함수에는 단 하나의 쓰레드만 접근할 수 있다. Foo함수와 Goo함수는 synchronized 키워드를 통해 상호배타 함수로 선언하였는데, 이는 둘 다 같은 임계구역을 같는다 는 의미이다. 다시 말해서, Foo함수에 한 쓰레드가 수행 중이라면, Foo함수뿐 아니라 Goo함수에도 다른 쓰레드는 접근할 수 없다. 반면에 H함수는 일반 함수인데, 이 함수에서는 공통 변수에 대한 업데이트를 하지 않는다는 것을 예상할 수 있다.(여러 쓰레드가 동시에 접근가능하다.) 조건동기는 특정한 메서드 호출로 사용할 수 있다.   wait(): 호출한 쓰레드를 조건동기 큐에 삽입한다.  notify(): 조건동기 큐에 있는 하나의 쓰레드를 깨워준다.  notifyAll(): 조건동기 큐에 있는 모든 쓰레드를 깨워준다.모니터 역시, 세마포에서 할 수 있는 기능인 Mutual exclusion, Ordering을 모두 할 수 있다. 예제를 통해 이를 살펴보자. BankAccount Problem 이전에 세마포에서 살펴본 은행계좌 문제를 통해 세마포 대신 모니터를 사용해서 Mutual exclusion, Ordering을 구현해보자. 1. Mutual Exclusion class Test {\tpublic static void main(String[] args)\tthrows InterruptedException {\t\tBankAccount b = new\t\tBankAccount();\t\tParent p = new Parent(b);\t\tChild c = new Child(b);\t\tp.start();\t\tc.start();\t\tp.join();\t\tc.join();\t\tSystem.out.println( \"\\nbalance = \" + b.getBalance());\t}}class BankAccount {\tint balance;\tsynchronized void deposit(int amt) {\t\tint temp = balance + amt;\t\tSystem.out.print(\"+\");\t\tbalance = temp;\t}\tsynchronized void withdraw(int amt) {\t\tint temp = balance - amt;\t\tSystem.out.print(\"-\");\t\tbalance = temp;\t}\tint getBalance() {\t\treturn balance;\t}}class Parent extends Thread {\tBankAccount b;\tParent(BankAccount b) {\t\tthis.b = b;\t}\tpublic void run() {\t\tfor (int i=0; i&lt;100; i++)\t\t\tb.deposit(1000);\t}}class Child extends Thread {\tBankAccount b;\tChild(BankAccount b) {\t\tthis.b = b;\t}\tpublic void run() {\t\tfor (int i=0; i&lt;100; i++)\t\t\tb.withdraw(1000);\t}}위 코드에서 볼 수 있듯이, 세마포를 사용할 때보다 모니터를 사용하면 매우 간결하게 코드를 구현할 수 있다. 세마포를 선언하고 number of permit값을 설정하는 대신, synchronized 키워드 하나로 이를 대체한 것을 볼 수 있다. +++++++++++++++++++++++------------------------------------------+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++----------------------------------------------------------balance = 0실행 결과는 위와 같고, balance값이 정상적으로 0을 출력하는 것을 볼 수 있다. 2. Ordeing 은행계좌 문제를 살펴보기전에, ordering을 하기 위해 모니터를 어떻게 사용하는지 보자.             P1      P2                         wait()              Section1      Section2              notify()             위 구조는 프로세스 순서를 P1, P2 순서로 실행하기 원하는 경우이며, 이는 세마포와 매우 유사한 것을 알 수 있다. 그러면 은행계좌 문제를 모니터로 구현하는데, 입금 먼저 수행, 출금 먼저 수행, 입금 출금 반복 수행 3가지를 각각 구현해보자. 그리고 위 코드에서 수정하는 부분은 순서를 정하는 입금, 출금함수이므로 이 부분만 보여줄 것이다.   입금 먼저 수행하기class BankAccount {\tint balance;\tsynchronized void deposit(int amt) {\t\tint temp = balance + amt;\t\tSystem.out.print(\"+\");\t\tbalance = temp;\t\tnotify();\t}\tsynchronized void withdraw(int amt) {\t\twhile (balance &lt;= 0)\t\t\ttry {\t\t\t\twait();\t\t\t} catch (InterruptedException e) {}\t\tint temp = balance - amt;\t\tSystem.out.print(\"-\");\t\tbalance = temp;\t}\tint getBalance() {\t\treturn balance;\t}}++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++----------------------------------------------------------------------------------------------------balance = 0  출금 먼저 수행하기class BankAccount {\tint balance;\tsynchronized void deposit(int amt) {\t\twhile (balance == 0)\t\t\ttry {\t\t\t\twait();\t\t\t} catch (InterruptedException e) {}\t\tint temp = balance + amt;\t\tSystem.out.print(\"+\");\t\tbalance = temp;\t}\tsynchronized void withdraw(int amt) {\t\tint temp = balance - amt;\t\tSystem.out.print(\"-\");\t\tbalance = temp;\t\tnotify();\t}\tint getBalance() {\t\treturn balance;\t}}----------------------------------------------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++balance = 0  입금 출금 반복 수행하기class BankAccount {\tint balance;\tboolean p_turn = true;\tsynchronized void deposit(int amt) {\t\tint temp = balance + amt;\t\tSystem.out.print(\"+\");\t\tbalance = temp;\t\tnotify();\t\tp_turn = false;\t\ttry {\t\t\twait();\t\t} catch (InterruptedException e) {}\t}\tsynchronized void withdraw(int amt) {\t\twhile (p_turn)\t\t\ttry {\t\t\t\twait();\t\t\t} catch (InterruptedException e) {}\t\tint temp = balance - amt;\t\tSystem.out.print(\"-\");\t\tbalance = temp;\t\tnotify();\t\tp_turn = true;\t}\tint getBalance() {\t\treturn balance;\t}}+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-balance = 0전통적 동기화 문제 1. Producer-Consumer Problem class Buffer {    int[] buf;    int size, count, in, out;    Buffer(int size) {        buf = new int[size];        this.size = size;        count = in = out = 0;    }    synchronized void insert(int item) {        while (count == size)            try {                wait();            } catch (InterruptedException e) {}        buf[in] = item;        in = (in+1)%size;        notify();        count++;    }    synchronized int remove() {        while (count == 0)            try {                wait();            } catch (InterruptedException e) {}        int item = buf[out];        out = (out+1)%size;        count--;        notify();        return item;    }}class Producer extends Thread {    Buffer b;    int N;    Producer(Buffer b, int N) {        this.b = b; this.N = N;    }    public void run() {        for (int i=0; i&lt;N; i++)            b.insert(i);    }}class Consumer extends Thread {    Buffer b;    int N;    Consumer(Buffer b, int N) {        this.b = b; this.N = N;    }    public void run() {        int item;        for (int i=0; i&lt;N; i++)            item = b.remove();    }}class Test {    public static void main(String[] arg) {        Buffer b = new Buffer(100);        Producer p = new Producer(b, 10000);        Consumer c = new Consumer(b, 10000);        p.start();        c.start();        try {            p.join();            c.join();        } catch (InterruptedException e) {}        System.out.println(\"Number of items in the buf is \" + b.count);    }}Number of items in the buf is 02. The Dining Philosopher Problem class Philosopher extends Thread {    int id; // philosopher id\tChopstick lstick, rstick;    Philosopher(int id, Chopstick lstick, Chopstick rstick) {        this.id = id;        this.lstick = lstick;        this.rstick = rstick;    }    public void run() {        try {            while (true) {                lstick.acquire();                rstick.acquire();                eating();                lstick.release();                rstick.release();                thinking();            }        }catch (InterruptedException e) { }    }    void eating() {        System.out.println(\"[\" + id + \"] eating\");    }    void thinking() {        System.out.println(\"[\" + id + \"] thinking\");    }}class Chopstick {    private boolean inUse = false;    synchronized void acquire() throws InterruptedException {        while (inUse)            wait();        inUse = true;    }    synchronized void release() {        inUse = false;        notify();    }}class Test {    static final int num = 5; // number of philosphers &amp; chopsticks    public static void main(String[] args) {        int i;        /* chopsticks */        Chopstick[] stick = new Chopstick[num];        for (i=0; i&lt;num; i++)            stick[i] = new Chopstick();        /* philosophers */        Philosopher[] phil = new Philosopher[num];        for (i=0; i&lt;num; i++)            phil[i] = new Philosopher(i, stick[i], stick[(i+1)%num]);        /* let philosophers eat and think */        for (i=0; i&lt;num; i++)            phil[i].start();    }}이 코드는 교착상태를 해결하지 않은 상태이다. ","categories": ["Study"],
        "tags": ["Study_OperatingSystem"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-11%EC%9E%A5-%EB%AA%A8%EB%8B%88%ED%84%B0/",
        "teaser":null},{
        "title": "[운영체제] # 12 주기억장치 관리",
        "excerpt":"메모리는 CPU 자원만큼 컴퓨터를 사용하는데 매우 중요한 자원 중 하나이다. 이전에는 운영체제에서 CPU 자원을 관리하는 프로세스 관리에 대해 살펴보았고, 지금부터는 메인 메모리를 관리하는 기능에 대해 살펴볼 것이다. 특히, 과거에는 메모리가 매우 비싼 자원이었고 크기 또한 작았기 때문에, 운영체제에서 메모리에 대한 관리가 지금보다 더 중요하였다. 현재에는 과거보다 훨씬 큰 메모리를 저렴하게 사용하지만, 지금도 메모리는 부족하다. 메모리가 커져온 만큼 프로그램의 크기와 처리하는 데이터의 크기는 그보다 더욱 빠른 속도로 커져왔다. 그러므로 현재에도 여전히 메모리를 최대한 효율적으로 사용하기 위해 여러 방법들이 연구되고 있고, 운영체제 기능에서도 매우 중요한 위치를 차지하고 있다. 메모리에 프로그램 할당하기 메모리는 기본적으로 주소(Address) 와 데이터(Data) 로 구성되어 있다.  CPU와 메모리는 양방향으로 위 그림과 같이 주고 받는다. CPU는 주소를 가지고 메인 메모리에 요청을하거나 해당 주소에 계산 결과를 저장하고, 메모리는 요구하는 주소에 저장되어 있는 데이터를 CPU에게 전달한다. 프로그램을 빌드하는 과정은 소스파일, 목적파일, 실행파일 순서로 생성된다.   소스파일(Source file): 고수준언어 또는 어셈블리어  목적파일(Object file): 컴파일 또는 어셈블 결과  실행파일(Executable file): 링크 결과 위 그림은 프로그램이 만들어지는 과정을 그림으로 표현한 것이다. 소스파일은 컴파일러(compiler)에 의해 컴파일 수행 결과로 목적 파일을 생성한다.(어셈블리어는 어셈블러가 어셈블을 수행하여 기계어로 변환한다.) 프로그래밍을 하면서 외부의 라이브러리를 사용할 때가 빈번한데, 컴파일 단계에서는 이를 추가하지 않기 때문에 목적파일에는 이에 대한 정보가 없다. 그대신 위 그림에서 보이듯이, 링크 단계에서 하드디스크에서 프로그래머가 추가한 라이브러리를 찾아 정보를 추가하여, 실행 파일을 만든다.(링크 단계는 링커(linker)가 수행한다.) 이 프로그램을 실행하면 로더(loader)에 의해 메인 메모리에 할당된다. 그리고 생성된 프로그램은 code, data, stack 영역으로 나뉘어져 있다. 단순히 생성된 프로그램에는 code와 data영역만 존재하며, 메모리에 적재되었을 때는 실제로 실행을 해야하므로 stack영역에 추가되어야 한다. 그러면, 프로그램을 실제로 메모리에 올리기 위해서는 좀 더 복잡한 과정이 필요하다. 먼저, 이 프로그램은 메모리에 몇 번지에 할당될까? 이 질문은 운영체제가 없다면, 프로그래머가 직접 이를 처리해주어야 할 것이다. 하지만 운영체제가 존재하므로 실제 프로그래머는 이를 신경쓸 필요가 없다. 그러므로 프로그래밍을 할 때 주소를 사용하는 경우가 있는데, 프로그램이 메모리에 올라가는 주소를 고려하지 않고 프로그래밍이 가능한 것이다.(고수준언어에서는 직접 주소를 다루지 않는 경우가 많다.) 또한, 다중 프로그래밍 환경에서는 여러 프로그램이 메모리에 올라가고 내려가고를 반복하기 때문에, 한 프로그램은 고정적인 공간을 사용할 수 없다. 이러한 여러 고려 사항을 해결해주는 것이 전에도 살펴봤던 MMU이다. 그리고 MMU에는 프로그램이 메모리에 할당될 때마다 다른 주소공간을 사용하기 때문에 재배치 레지스터(Relocation register) 가 별도로 존재한다.  위 그림은 MMU의 모습이다. 프로그램은 메인 메모리에 해당 주소를 사용할 수 있는지 여부를 생각하지 않고 주소를 사용한다. 만약 해당 프로그램이 사용하는 시작주소가 0번지라고 할 때, 실제 메인 메모리에서는 할당되는 주소가 유동적이기 때문에 0번지이라는 주소를 실제 할당된 주소로 변경해주어야 한다. 이때 재배치 레지스터를 이용한다. 만약, 프로그램이 메인 메모리 500번지에 할당되어 재배치 레지스터값이 500으로 설정되었다면, CPU에서 프로그램의 0번지를 사용할 때 MMU를 통과하면 재배치 레지스터에 의해 500번지로 변경된다. 그 결과 CPU는 0번지를 사용하는 것으로 알고 있지만, 실제 메모리에서는 MMU에 의해 500번지를 사용하고 있는 것이다. MMU(Memory Management Unit)의 기능을 살펴보면, 이전에 메모리 보호를 위해 base와 limit 레지스터가 있었다. 이는 CPU에서 주소를 사용하는데 이 주소가 해당 프로그램의 base나 limit 범위를 벗어나면 인터럽트가 발생하여 그 프로그램을 강제로 종료시킨다. MMU는 이 기능 이외에도 재배치 레지스터를 사용해서 프로그램이 어느 주소를 사용하더라도 실제 메인 메모리에 할당된 주소를 찾아갈 수 있도록 address translation 동작을 수행한다. 즉, CPU는 프로그램에 설정된 주소를 계속 사용하고 메모리에 명령을 보내지만, MMU에 의해 실제로 프로그램이 할당된 메모리 주소로 변환해서 사용할 수 있는 것이다. 그 결과, 프로그램의 실제 메모리 주소 공간의 위치는 CPU에 전혀 영향을 미치지 않고 정상적으로 사용할 수 있는 것이다.  MMU에 의해 위 그림과 같이 주소는 두 가지로 구분된다. CPU에서 사용하는 주소는 논리 주소(logical address) 라고 하고, 메모리가 사용하는 주소는 물리 주소(physical address) 라고 한다. 메모리 낭비 방지 운영체제는 메모리를 효율적으로 사용하기 위해 메모리 공간을 낭비하지 않는 것이 중요하다. 동적 적재(Dynamic Loading) 동적 적재는 프로그램이 실행하는데 반드시 필요한 루틴/데이터만 적재(load) 하는 것이다. 프로그램의 전체 코드에서 모든 루틴이 다 사용되는 것은 아니다. 대표적으로 오류 처리 구문이다. 오류 처리 구문은 if문과 같이 오류가 발생할 때만 해당 내부 코드가 실행되는 것을 말한다. 그러므로 동적 적재를 수행하면 프로그램의 실제 메모리에는 이러한 오류 구문을 제외하고 적재한다. 이러한 상태에서 실행하다가 오류가 발생하면 그 때 해당 오류 구문을 찾아 메모리에 올린다. 데이터도 마찬가지다. 모든 데이터가 반드시 사용되는 것이 아니기 때문에, 특히 배열과 클래스의 경우는 필요한 부분만 메모리에 올려두고, 실행 도중 필요할 때마다 해당 부분을 찾아 메모리에 올려준다. 반대로, 모든 루틴과 데이터를 적재하는 것을 정적 적재(static loading)이라고 한다. 현대 운영체제는 대부분 동적 적재를 사용한다. 동적 연결(Dynamic Linking) 동적 연결은 여러 프로그램에 공통으로 사용되는 라이브러리를 중복으로 메모리에 올리는 것이 아니라 하나 만 올리도록 하는 것이다. 예를 들어, 아래와 같은 코드의 P1, P2 프로세스가 있다고 하자. // P1int a = 1;int b = 2;printf(\"%d\\n\", a + b);// P2int a = 1;int b = 2;printf(\"%d\\n\", a * b);이 두 소스파일을 컴파일하면 목적파일이 생성되고, 여기서 사용된 라이브러리를 링크하여 실행파일을 만든 다음 메모리에 적재한다. 두 프로세스가 적재되었을 때, printf() 를 사용하는 라이브러리는 메모리에 중복되어서 적재되어있다. 이와 같이, 똑같은 라이브러리를 사용하는 프로그램은 흔히 볼 수 있다. 이러한 같은 라이브러리를 하나만 메모리에 올린 후, 이를 사용하는 프로그램이 하나의 메모리에 접근하도록 하면 메모리 낭비를 줄일 수 있다. 동적 연결은 같은 라이브러리가 중복으로 메모리에 올라가는 것을 방지하기 위해 프로그램이 메모리에 적재된 후에 링크(link) 작업을 수행한다. 기존에는 실행 파일이 만들어지기 전에 링크 과정을 수행하였는데, 이를 정적 연결이라고 한다.  위 그림은 예제에서 살펴 본 P1, P2 프로세스가 동적 연결을 통해 공통 라이브러리(printf() 라이브러리)를 연결한 모습을 볼 수 있다. 이러한 라이브러리를 Linux에서는 공유 라이브러리(Shared Library), Windows에서는 동적 연결 라이브러리(Dynamic Linking Library, DLL) 라고 부른다. Swapping Swapping은 메모리에 적재되어 있는 프로세스 중에서 오랫동안 사용하지 않은 프로세스를 프로세스 이미지 형태로 만든 후 하드디스크(Backing store)에 내려보낸다. 메모리에서 Backing store로 가는 것을 swap-out, 다시 Backing store에서 메모리로 가는 것을 swap-in 이라고 한다. 여기서, 프로세스 이미지는 해당 프로그램이 메모리에 적재된 후 실행되면서 데이터를 추가하거나 변경하는 등의 과정을 거치는데, 현재 데이터의 상태를 프로세스 이미지라고 부른다. 그러므로 이는 단순히, 하드디스크에 존재하는 프로그램(exe파일)과는 전혀 다른 데이터이므로, 따로 저장해야한다. 이와 같은 swapping 과정으로 인한 프로세스 이미지를 저장하기 위해 하드디스크의 일부분을 분리하여 사용하는데, 이를 backing store 또는 swap device 라고 부른다. Backing store의 크기는 대략 메인 메모리 크기 정도로 예상할 수 있다. 메모리의 모든 프로세스가 쫓겨난다고 해도 메인 메모리 크기를 넘지 않기 때문이다. 메인 메모리 크기가 크지 않는 PC나 스마트폰은 하드디스크의 일부를 backing store로 사용하지만, 메모리 크기가 크다면 따로 하드디스크 자체를 backing store로 사용하는 경우도 있다. Swap-out된 프로세스는 다시 swap-in을 할 때, 이전의 메모리 주소 공간이 아닌 새로운 주소 공간으로 갈 수도 있다. 이는 해당 프로세스가 backing store에 있는 동안 다른 프로세스가 해당 주소 공간을 사용할 수 있기 때문에다. 하지만 이는 MMU의 재배치 레지스터로 인해 어디에 적재되는지 상관없이 정상적으로 수행할 수 있다. 현재는 프로세스의 크기가 커지고, 하드디스크는 메인 메모리보다 속도면에서 매우 느리므로 swapping 동작의 오버헤드는 크다고 볼 수 있다. 하지만 이로 인해 얻는 이득이 더 많으므로 대부분 운영체제는 이를 사용하고 있고, 속도가 중요한 서버 컴퓨터나 슈퍼 컴퓨터는 backing store를 하드디스크가 아닌 좀 더 빠른 저장 장치를 사용하기도 한다. 연속 메모리 할당(Contiguous Memory Allocation) 과거에는 메모리에 프로세스가 하나만 올라가는 형태였다. 하지만 현재에는 메모리에 여러 프로세스가 할당되는 다중 프로그래밍 환경이 되었다. 부팅 직후에 메모리 상태를 살펴보면, 운영체제만 할당되어 있고 비어있는 상태일 것이다. 이러한 비어있는 공간을 hole 이라 부른다. 즉, 부팅 직후에는 운영체제와 big single hole이 있는 상태이다. 시간이 지나면서 프로세스가 생성되고 종료하고를 반복하면, 여러 곳에 서로 다른 크기의 홀(hole)이 존재할 것이다. 이러한 상태를 scattered holes라고 한다.  위 그림은 부팅 직후 상태에서 시간이 경과하면서 프로세스들이 생성, 종료를 반복한 후의 상태이다. 이와 같이 hole들이 불연속하게 흩어져 있는 상태를 메모리 단편화(Memory fragmentation) 라고 한다. 메모리 단편화로 인해서 여러 곳에 hole이 흩어져 있는 상태에서 하나의 프로세스가 메모리에 할당되려하면 문제가 발생할 수 있다. 예를 들어, hole이 3개가 있고 각 크기는 50byte, 50byte, 80byte이다. 그런데 할당하려는 프로세스의 크기는 150byte이다. 각 hole들을 하나로 합치면 230byte로 이 프로세스를 할당할 수 있는데 실재로는 나누어져 있으므로 할당되지 못한다. 이러한 현상을 외부 단편화(External fragmentation) 라고 한다. 외부 단편화를 줄이기 위해서는 어떤 해결 방법이 있을까? 연속 메모리 할당 방식 외부 단편화의 해결방법을 살펴보기 전에 연속 메모리 할당 방식을 먼저 살펴보자. 연속 메모리 할당 방식에는 3가지가 있다. First-fit, Best-fit, Worst-fit 이 있다.   First-fit(최초 적합): 최초 적합은 할당할 프로세스 크기보다 크거나 같은 hole을 탐색하는 순서 중에서 가장 먼저 찾은 hole에 프로세스를 할당하는 것이다.  Best-fit(최적 적합): 최적 적합은 할당할 프로세스 크기와 hole 크기의 차이가 가장 작은 hole에 프로세스를 할당하는 것이다.(hole크기는 프로세스 크기보다 반드시 커야 한다.)  Worst-fit(최악 적합): 최적 적합과 반대로, 할당할 프로세스 크기와 hole 크기의 차이가 가장 큰 hole에 프로세스를 할당하는 것이다.그러면 예제를 살펴보자. Hole은 100KB, 500KB, 600KB, 300KB, 200KB 총 5개가 있고, 프로세스는 P1, P2, P3, P4 총 4개가 있는데 각 크기는 212KB, 417KB, 112KB, 426KB이다.   First-fit   Best-fit   Worst-fit 각 3가지 방식대로 프로세스를 할당한 모습을 볼 수 있다. 예제의 결과를 보면 Best-fit은 4개의 프로세스를 모두 할당할 수 있었고, 나머지 2개는 마지막 P4를 할당하지 못했다. 모든 hole을 합치면 P4를 할당할 수 있지만, hole들은 각각 나눠져 있기 때문에 할당할 수 없었다.(외부 단편화) 각 할당 방식의 일반적인 성능을 비교해보면, 속도면에서는 first-fit이 가장 빠르다. 메모리 이용률면에서는 first-fit, best-fit이 비슷한 성능을 낸다고 알려져있다. 하지만 여러 실험을 통해 best-fit을 사용하더라도 외부 단편화로 인해 전체 메모리의 1/3 정도를 낭비 한다고 한다. 이는 거의 사용이 불가능한 수준이다. 이를 해결하는 방법 중 하나는 Compaction 이다. compaction은 여러 곳에 흩어져있는 hole들을 강제로 하나로 합치는 것이다. 하지만 hole을 옮기는 오버헤드가 너무 크고, 어느 hole을 옮겨야 빠르게 합칠 수 있는지에 대한 최적 알고리즘이 존재하지 않는 큰 단점이 존재한다. ","categories": ["Study"],
        "tags": ["Study_OperatingSystem"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-12%EC%9E%A5-%EC%A3%BC%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98-%EA%B4%80%EB%A6%AC/",
        "teaser":null},{
        "title": "[운영체제] # 13 페이징",
        "excerpt":"페이징(Paging) 외부 단편화로 인한 메모리 낭비는 매우 심하다는 것을 살펴보았다. Compaction을 사용하면 외부 단편화는 해결할 수 있지만, 그로 인해 발생하는 오버헤드와 비효율적인 성능으로 사용하기는 어렵다. 그 이후에 연구를 통해 나온 것이 페이징 이다. 페이징은 hole을 가지고 해결하려 한 것이 아니라 프로세스를 작은 크기로 나눠서 외부 단편화를 해결하려고 하였다. 페이징은 프로세스를 일정한 작은 크기로 나누는데, 프로세스뿐아니라 hole도 같은 크기로 나눈다. 이러한 작은 조각들의 크기를 맞춰서 메모리에 할당한다. 하지만, 하나의 프로세스는 연속적인 동작을 수행하는데 이를 작은 조각으로 나누어서 여기저기 흩어진다면 프로세스가 정상적으로 동작할까? 메모리상에 여러 곳에 흩어진 프로세스를 수행하기 위해 CPU를 속여야한다. 이전 다중프로그래밍을 살펴봤을 때 MMU를 통해 논리 주소와 물리 주소를 나눠서 사용한다고 했었다. 이역시 CPU를 속이는 행동이다. 실제 메모리는 전혀 연속적이지 않는데, CPU는 연속적으로 사용하고 있다는 것을 보장받으며 정상적으로 수행한다. 페이징으로 작은 크기로 나눈 것도 위와 같은 방법으로 할 수 있다. 만약 50byte 크기의 프로세스가 있다고 하자. 페이징의 크기는 각 10byte로 나눈다.  위 그림과 같이 프로세스 P1은 5개의 페이지로 나눌 수 있다. 이를 메인 메모리 5곳에 나눠서 할당하였다. CPU는 논리 주소로 프로그램이 설정한대로 연속적인 주소값으로 명령을 내리고 이는 메모리로 가기전에 각 페이지의 실제 메모리 주소가 저장되어 있는 테이블에서 물리 주소로 변경되어야 한다. 프로세스를 나눈 조각을 page 라 하고, 메모리를 나눈 조각을 frame 이라 한다. 프로세스는 페이지의 집합이고, 메모리는 프레임의 집합이다. 프로세스를 정상적으로 사용하기 위해 MMU의 재배치 레지스터를 여러개 사용해서 위의 그림과 같이 각 페이지의 실제 주소로 변경해준다. 이러한 여러 개의 재배치 레지스터를 페이지 테이블(Page Table) 이라 한다. 주소 변환(Address Translation) 페이징 기법을 사용하기 위해서는 여러 개로 흩어진 페이지에 CPU가 접근하기 위해서 페이지 테이블을 통해 주소를 변환해야 한다.   논리 주소(Logical address)CPU가 내는 주소는 2진수로 표현되고 이를 m비트가 있다고 가정하자. 여기서 하위 n비트는 오프셋(offset) 또는 변위(displacement)라고 한다. 그리고 상위 m-n 비트는 페이지의 번호에 해당한다.(n = d, m-n = p)논리주소를 물리주소(physical address)로 변환하기 위해서 페이지 번호(p)는 페이지 테이블의 인덱스 값이고, p에 해당되는 테이블 내용은 메모리의 프레임 번호이다. 변위(d)는 변하지 않는 값이다. 이 규칙에 대한 예제를 살펴보자.   Page size = 16bytes  Page Table: 5, 3, 2, 8, 1, 4  논리 주소 50번지는 물리주소 몇 번지인가? 위 그림은 프로세스 P가 메모리에 할당된 모습이다. CPU가 50번지에 접근하려고 한다. 그러면 페이지 테이블의 정보를 읽기 위해 논리 주소를 p와 d값으로 나눠야 한다. d는 페이지 크기에 따라 달라지는데, 현재 페이지 크기는 16byte이다. 이는 2^4이므로 d = 4 이다. p는 d를 제외한 나머지 크기이다. 그러면 실제로 p, d를 계산해보자. 현재 논리 주소는 50이며, 이진수로 나타내면 110010이다. 먼저 d는 4이므로 이 이진수의 뒤에서 4칸이 d이다. d를 제외한 나머지 2칸이 p가 된다. 50 = 110010p = 11d = 0010p는 이진수로 11이고, 십진수로 3이다. 즉, 페이지 테이블의 페이지 번호 3번을 가리킨다. 페이지 3번에 해당하는 프레임 번호는 8번이므로, 물리주소를 구성하는 f값은 8이 된다. f = 1000d = 0010물리주소 = 10000010최종적으로 물리주소는 f와 d로 구성되어 있으므로 물리주소는 이진수로 10000010 이 되고, 십진수로 130 번지 가 된다. 즉, 변위는 2이므로 8번째 프레임의 시작주소는 128번지(16 * 8)가 된다. 연속 메모리 할당을 하면서 외부 단편화가 발생하여 이를 해결하기 위해 페이징 기법이 나왔다. 하지만 페이징은 외부 단편화가 아닌 내부 단편화 가 발생한다. 내부단편화(Internal Fragment) 내부단편화는 프로세스 크기가 페이지 크기의 배수가 아닐 경우, 마지막 페이지는 한 프레임을 다 채울 수 없다. 이로 인해 발생하는 공간은 결국 메모리 낭비로 이어진다. 예를 들어, 15bytes 크기의 프로세스 P가 있다. 페이지 크기(프레임 크기)는 4bytes로 P를 페이지로 나누면 4, 4, 4, 3 의 크기로 총 4개의 페이지가 만들어진다. 여기서 마지막 3bytes 페이지는 프레임 크기보다 1byte작으므로, 이 만큼 메모리 공간이 비게 된다. 이렇게 비어진 공간은 프로세스 P에서도 쓰지 않고, 다른 프로세스에서도 쓰지 못하는 낭비되는 공간이 된다. 내부단편화는 해결할 방법이 없다. 하지만 내부단편화는 외부단편화에 비해 낭비되는 메모리 공간은 매우 적다. 내부단편화의 최대 낭비되는 크기는 page size - 1 이 된다.(외부 단편화는 최대 전체 메모리의 1/3이 낭비된다고 이전에 살펴봤다.) 이는 무시할 정도로 작은 크기이다. 페이지 테이블 만들기 페이지 테이블을 만드는 방법은 여러 가지가 있다. 먼저, CPU 내부에 페이지 테이블을 만들 수 있다. CPU 내부의 기억장치는 레지스터로, 여러 개의 레지스터로 페이지 테이블을 만드는 것이다. CPU 내부에 페이지 테이블을 만들면, 장점은 주소 변환 속도가 빠르다. 하지만 단점은 CPU 내부에 사용할 수 있는 레지스터는 한정되어 있으므로 페이지 테이블의 크기가 매우 제한된다. 반대로, 페이지 테이블을 메모리 내부에서 만들 수도 있다. 메모리 내부에 만드는 것의 장단점은 CPU와 정 반대이다. 즉, 장점은 페이지 테이블의 크기에 제한이 없는 것이고, 단점은 주소 변환 속도가 느리다는 것이다. CPU는 프로세스의 주소에 접근하기 위해서 메모리에 위치한 페이지 테이블에 한 번, 실제 주소로 접근하는데 한 번해서 메모리에 총 2번 접근해야하므로 속도 역시 2배로 느려진다. 페이지 테이블을 CPU에 만들 때나 메모리에 만들 때 둘 다 장단점이 확실하기 때문에, 이를 해결하기 위해 페이지 테이블도 캐시로 만들어 해결하였다. 페이지 테이블을 별도의 칩(SRAM)으로 만들어서 CPU와 메모리 사이에 위치시키는 것이다. 이러한 테이블을 TLB(Translation Look-aside Buffer) 라고 부른다. 이는 CPU보다 변환 속도는 느리고 메모리보다 테이블 크기는 작지만, CPU보다 테이블 크기가 크고 메모리보다 변환 속도가 빠르다. TLB는 캐시와 역할이 동일하므로, 실제 전체 페이지 테이블은 메모리에 위치해 있고 테이블의 일부를 TLB에 가져와서 사용한다. 그러므로 TLB에 유효한 페이지가 있을 때와 없을 때의 속도 차이가 발생한다. 그렇다면, TLB의 효율을 알아보기 위해 Effective Memory Access Time을 계산해보자.   메모리를 읽는 시간(Tm) = 100ns  TLB를 읽는 시간(Tb) = 20ns  TLB에 유효한 페이지 엔트리가 있을 확률(hit ratio) = 80%먼저, EMAT의 정형화된 식을 보자. EMAT = h(Tb + Tm) + (1 - h)(Tb + Tm + Tm), h는 hit ratio실제 유효한 메모리에 접근하는 시간은 위와 같다. TLB에 유효한 페이지가 있다면 TLB를 읽는 시간과 실제 메모리를 읽는 시간만 있으면 된다. 하지만, TLB에 유효한 페이지가 없다면 이를 다시 메모리에서 가져와야 하므로 메모리를 총 2번 읽어야 한다. 예제를 계산해보면, 0.8 * (20 + 100) + 0.2 * (20 + 100 + 100) = 140ns 이다. hit ratio는 실제로 평균 95%이상이므로 충분히 효율적으로 동작한다고 볼 수 있다. 보호와 공유 보호(Protection) 모든 주소는 페이지 테이블을 경유하므로, 테이블을 이용해서 보호 기능을 수행할 수 있다. 대표적으로 페이지 테이블마다 r(read), w(write), x(execute) 비트를 두어, 해당 비트가 켜져있을 때 그 수행이 가능하도록한다.  위 그림은 페이지 테이블에 r,w,x 비트를 추가한 모습이다. 만약, 1번 페이지 엔트리처럼 쓰기 비트가 꺼져있는 페이지에 쓰기 작업을 시도하면 CPU에 인터럽트가 발생하여 ISR에서 강제로 해당 프로세스를 종료시킨다. 공유(Sharing) 공유는 메모리 낭비를 방지하기 위함이다. 같은 프로그램을 쓰는 복수 개의 프로세스가 있다면, 프로세스의 메모리는 code + data + stack 영역으로 나뉘는데 프로그램이 같다면 code 영역은 같을 것이다. 그러므로 하나의 code 영역을 복수 개의 프로세스가 공유하여 메모리 낭비를 줄이는 것이다. 단, code가 공유되려면 code가 변하지 않는 프로그램이어야 한다. 이를 non-self-modifying code = reentrant code(재진입가능 코드) = pure code 라고 한다. ","categories": ["Study"],
        "tags": ["Study_OperatingSystem"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-13%EC%9E%A5-%ED%8E%98%EC%9D%B4%EC%A7%95/",
        "teaser":null},{
        "title": "LCS 알고리즘",
        "excerpt":"LCS 알고리즘은 총 2가지로 나뉜다.   LCS(Longest Common Substring): 최장 공통 부분 문자열  LCS(Longest Common Subsequence): 최장 공통 부분 수열이 둘의 차이점은 1번은 연속적 이고, 2번은 비연속적이다. 하지만 1번과 2번 모두 동적 계획법 으로 해결할 수 있다는 공통점을 가지고 있다. 먼저, 예를 보자.ABCDEFGHIBCDGHD위 예제에서 1번과 2번의 결과는 아래와 같다.   BCD  BCDGH최장 공통 부분 문자열은 연속적이어야 하기 때문에 총 2가지 경우가 있다. BCD와 GH이다. 여기서 BCD가 더 길기때문에 답이 된다. 최장 공통 부분 수열은 비연속적이기 때문에 문자가 서로 떨어져 있다고 해도 같다면 같은 수열에 속한다. 따라서, 답은 BCDGH이 된다. 하지만 대부분 LCS 알고리즘이라고 하면 Longest Common Subsequence 로 즉, 최장 공통 부분 수열을 말한다. Longest Common Substring 최장 공통 부분 문자열은 최장 공통 부분 수열보다 간단하다. 연속적인 부분만 보면 되므로 O(N^2)으로 해결할 수 있다. 접근법은 위에서 말했듯이 동적 계획법으로 접근한다. DP[i][j] = 문자열 S1의 위치 i, 문자열 S2의 위치 j일 때, 최장 공통 부분 문자열의 길이for (int i = 1; i &lt;= S1.size(); ++i) {  for (int j = 1; j &lt;= S2.size(); ++j) {    if (S1[i - 1] == S2[i - 1]) {       DP[i][j] = DP[i - 1][j - 1] + 1;       if (LCS &lt; DP[i][j])        LCS = DP[i][j];    }  }}Longest Common Subsequence 최장 공통 부분 수열은 연속적이지 않은 부분을 모두 고려해야 하므로 최장 공통 부분 문자열보다 복잡하다. 하지만 이 역시 동적 계획법으로 해결 가능하며 DP(cache)배열의 역할 역시 같다. DP[i][j] = 문자열 S1의 위치 i, 문자열 S2의 위치 j일 때, 최장 공통 부분 문자열의 길이Bottom-up 방식 먼저, 반복문을 사용하는 Bottom-up 방식의 동적 계획법을 살펴보자. 여기서 점화식은 아래와 같다. if i == 0 or j == 0  DP[i][j] = 0else if S1[i] == S2[j]  DP[i][j] = DP[i - 1][j - 1] + 1else if S1[i] != S2[j]  DP[i][j] = max(DP[i][j - 1], DP[i - 1][j])위의 점화식에서 DP배열의 첫 번째에 0값을 삽입하는 것은 구현의 편의를 위해서이다. 이를 적용하여 아래의 예제를 풀어보자. ACAYKPCAPCAK                   0      A      C      A      Y      K      P                  0      0      0      0      0      0      0      0              C      0      0      1      1      1      1      1              A      0      1      1      2      2      2      2              P      0      1      1      2      2      2      3              C      0      1      2      2      2      2      3              A      0      1      2      3      3      3      3              K      0      1      2      3      3      4      4      위 예제를 점화식을 적용하여 직접 모두 풀어보면 위와 같은 2차원 배열을 얻을 수 있다. 위 예제의 LCS는 두 문자열의 끝이므로 답은 4인 것을 볼 수 있다. // DP 배열 0으로 초기화for (int i = 1; i &lt;= S1.size(); ++i) {  for (int j = 1; j &lt;= S2.size(); ++j) {    if (S1[i] == S2[j])      DP[i][j] = DP[i - 1][j - 1] + 1;    else      DP[i][j] = max(DP[i - 1][j], DP[i][j - 1]);  }}Top-down 방식 이번에는 재귀를 사용하여 해결해보자. 재귀를 이용할 때는 대부분 완전탐색의 코드에서 최적화를 해나아가는 방식을 사용한다. 그러면 먼저 완전 탐색 코드를 보자. void BruteForce(int i, int j, int lcs){\tif (i == s1.size() || j == s2.size()) {\t\tans = max(ans, lcs);\t\treturn;\t}\tif (s1[i] == s2[j])\t\tBruteForce(i + 1, j + 1, lcs + 1);\tBruteForce(i + 1, j, lcs);\tBruteForce(i, j + 1, lcs);}위 코드는 S1, S2 문자열이 있을 때, S1 문자열의 위치부터 옮기면서 진행하며 만약 현재 S1, S2 문자열의 위치에서 해당 문자가 서로 같다면, 두 문자열 모두 위치를 한 칸 옮긴다. 그리고 다시 한 문자열의 위치를 옮겨나간다.(S1 문자열의 위치를 끝까지 옮긴 후에는 S2를 한 칸 옮기고 다시 S1의 위치를 옮기는 방식으로 동작한다.) 완전 탐색으로는 문자열의 길이가 조금만 길어져도 시간이 매우 오래 걸린다. 그리고 위 코드를 직접 트리로 표현하면 수 많은 중복이 발생한다는 것을 알 수 있다. 이 때 사용하는 최적화가 동적 계획법이다. 메모이제이션을 사용한 코드는 아래와 같다. int cache[MAX_LEN][MAX_LEN];int Memoization(int i, int j){\tif (i == s1.size() || j == s2.size())\t\treturn 0;\tif (s1[i] == s2[j]) return solve(i + 1, j + 1) + 1;\tint&amp; ret = cache[i][j];\tif (cache[i][j] != -1) return ret;\treturn ret = max(solve(i + 1, j), solve(i, j + 1));}","categories": ["Algorithm"],
        "tags": ["Algorithm_Algorithm"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-LCS%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/",
        "teaser":null},{
        "title": "[Reference] Blog에 post 올리기",
        "excerpt":"      이 자료는 해당 블로그 전용입니다. 다른 블로그와 설정이 다를 수 있씁니다.   POST Jekyll 블로그에서 post란 일반적으로 블로그에서 쓰는 글이다. 하지만 jekyll에서는 post가 마크다운(Markdown) 으로 작성되고, 기본적으로 몇 가지 규칙이 있다.   모든 post는 _posts 파일안에 있어야 한다.  모든 post의 파일 이름은 YYYY-MM-DD-TITLE.md 양식을 따라야한다. 예를 들어 2018-07-15-test.md로 쓸 수 있다.Front matter Front matter(머리말) 은 jekyll이 마크다운을 해석할 때, 사용하는 메타 정보이다. 이는 반드시 아래와 같이 2가지를 지켜서 사용해야 한다.   post 가장 맨 첫 부분에 위치해야한다.  시작과 끝을 3개의 대쉬(—)로 감싸주어야 한다.Front matter 은 YAML 형식이고, 비워도 상관없다.Front matter 설정 title: \"POST 제목\"excerpt: \"POST 설명\"date: YYYY-MM-DD hh:mm:sscategories:  - category1tags:  - tag1search: truesidebar_main: trueuse_math: truetoc: trueFront matter 의 예시는 위와 같다. 현재 사용중인 옵션을 모두 보여준 것이다.   title: POST의 제목  excerpt: POST의 간단한 설명 (현재는 최신 업데이트 날짜로 통일하였다.)  date: 포스트를 작성 및 업데이트한 날짜  categories: 카테고리를 설정 (여러 개를 적을 수도 있다.)  tags: 테그를 설정  search: 현재 POST를 검색이 가능하도록 할지 설정하는 부분이다. true 값을 넣으면 해당 POST를 검색할 수 있다.  sidebar_main: 현재 POST에서 사이드바를 표시할지 설정하는 부분이다.  use_math: 현재 POST에서 MathJax 기능을 사용할지 설정하는 부분이다.  toc: POST 맨 첫 부분에 해당 POST의 각 header(‘#’, ‘##’, …)에 바로 가는 기능을 사용할지 설정하는 부분이다.Category와 Tag 현재 블로그 post를 원하는 방식으로 분류하기 위해 카테고리와 테그 설정을 고정적으로 설정하였다. 먼저, 카테고리는 3개로 정하였다.   Toy: 토이 프로젝트  Algorithm: 알고리즘, PS  Study: 각종 프로그래밍 관련 공부위와 같이, 카테고리는 3개만 가능하고 테그 양식은 Category_Tag 로 사용해야 한다. 예를 들어, 토이 프로젝트의 블로그 개발 관련 post를 작성하였다면 카테고리는 Toy, 테그는 Toy_Blog 와 같이 작성하여야 한다. 실제 블로그에서 테그는 앞의 카테고리는 나타나지 않게 설정하였다. 즉, “Blog” 라는 글자만 볼 수 있다. ","categories": ["Toy"],
        "tags": ["Toy_Blog"],
        "url": "https://codemcd.github.io/pages/CODEMCD/toy/Blog-Reference-Blog%EC%97%90-post-%EC%98%AC%EB%A6%AC%EA%B8%B0/",
        "teaser":null},{
        "title": "LIS(Longest Increasing Subsequence) 알고리즘",
        "excerpt":"LIS 알고리즘은 가장 긴 증가하는(최장증가) 부분 수열 이다. 아래의 그림 처럼 부분 수열이므로 연속적이지 않아도 된다. (2번 째 배열의 노란색 박스가 LIS이다.)  LIS 알고리즘을 해결하는 방법은 시간복잡도가 O(N^2)과 O(NlogN) 두 가지 방법이 대표적이다. 해결 방법1: 동적 계획법 동적 계획법을 이용한 해결 방법은 시간복잡도 O(N^2)에 속한다. 동적 계획법에서도 Bottom-up 방식과 Top-down 방식 두 가지 모두 알아보자. DP[i] = i 번째 위치일 때, 최장 증가 부분 수열의 개수 (cache 배열도 동일)Bottom-up Bottom-up은 반복문을 사용하는 동적 계획법이다. 현재 위치 이전의 값들을 차례대로 순회하면서 현재 위치에서 최장증가 부분 수열의 개수를 갱신한다. 이는 말보다 코드로 이해하는 것이 쉽다. // num[]: 숫자 배열// n: num 배열의 크기// lis: 가장 긴 증가하는 부분 수열의 개수 (0으로 초기화)DP[0] = 1;for (int i = 1; i &lt; n; ++i) {  dp[i] = 1;  // 0 ~ i - 1 위치까지 반복  for (int j = 0; j &lt; i; ++j) {    // 1) 현재 위치의 값보다 작고,    // 2) 최장증가부분 수열 개수가 1개 증가했을 때, 현재 가지고 있는 수열 개수보다 크다면    if(num[i] &gt; num[j] &amp;&amp; dp[i] &lt; dp[j] + 1) {      dp[i] = dp[j] + 1;    }  }  lis = max(lis, dp[i]);}Top-down Top-down은 재귀를 사용한 메모이제이션 방식이다. 이 방식은 대부분 완전탐색에서 최적화한 모습이므로 완전탬색 코드와 유사한 로직을 가진다. 여기서는 전체 배열을 탐색하는 구현을 간단히 하기 위해 -1 부터 시작한다. // cache[]: -1으로 초기화// 가장 긴 증가하는 부분 수열의 개수 반환(start 초기값은 -1)int Memoization(int start){  int&amp; ret = cache[start + 1];  if (ret != -1) return ret;  ret = 0;  for (int next = start + 1; next &lt; n; ++next) {    if (start == -1 || num[start] &lt; num[next]) {      int candidate = Memoization(next) + 1;      if (candidate &gt; ret)        ret = candidate;    }  }  return ret;}해결 방법2: 이분 탐색 LIS는 이분 탐색을 사용하여 시간복잡도 O(NlogN)으로 해결할 수 있다. 이는 lower_bound 를 사용하는 것으로, lower_bound는 찾으려는 값과 같으면 그 위치를 반환하고 없다면 이 값보다 큰 수 중 가장 작은 값의 위치를 반환한다. 이는 이분 탐색으로 찾기 때문에 O(logN)의 시간복잡도는 가지고 있다. 그러면 예제를 살펴보자. 10, 20, 10, 30, 20, 50위 예제에서 처음 위치부터 끝까지 순회하면서 해당 숫자의 위치를 vector에 저장한다. 이를 계산한 표를 살펴보자.             i/num[]      10      20      10      30      20      50                  0      10                                                 1      10      20                                          2      10      20                                          3      10      20      30                                   4      10      20      30                                   5      10      20      30      50                      i = 0: 처음 위치는 바로 vector에 삽입한다.  i = 1: 숫자 20은 vector안에 존재하는 10보다 크므로 그 뒤에 삽입한다.  i = 2: 숫자 10은 vector안에 이미 존재하므로 이를 대체한다.(무시하는 것과 같다.)  i = 3: 숫자 30은 vector안에 존재하는 마지막 숫자 20보다 크므로 그 뒤에 삽입한다.  i = 4: 숫자 20은 vector안에 이미 존재하므로 이를 대체한다.  i = 5: 숫자 50은 vector안에 존재하는 마지막 숫자 30보다 크므로 그 뒤에 삽입한다.위처럼 배열 크기만큼 순회하면서 그 때마다 해당 숫자의 위치를 lower_bound로 탐색하므로 시간복잡도 O(NlogN)을 보장한다. lis.push_back(num[0]);vector&lt;int&gt;::iterator it;for (int i = 1; i &lt; n; ++i) {\t\tit = lower_bound(lis.begin(), lis.end(), num[i]);\t\tif (it == lis.end())\t\t\tlis.push_back(num[i]);\t\telse\t\t\t*it = num[i];}","categories": ["Algorithm"],
        "tags": ["Algorithm_Algorithm"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-LIS%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/",
        "teaser":null},{
        "title": "다익스트라(Dijkstra) 알고리즘",
        "excerpt":"다익스트라 알고리즘은 단일 시작점 최단 경로 알고리즘 으로, 시작 정점 s에서부터 다른 정점들까지의 최단 거리를 계산한다. 하지만 이 알고리즘은 음수 간선이 있는 그래프(특히, 음수 사이클)에 대해서는 최단거리를 계산하지 못한다. 만약 음수 간선이 사이클을 이루지 않는다면, 계산을 할 수 있는 경우가 있지만 시간복잡도는 지수적으로 증가한다.       이에 대한 부분은 https://www.acmicpc.net/board/view/19865 이 링크에서 자세하게 토론을 하고 있다. 한 번 읽어보면 좋을 듯 하다.   기본적인 다익스트라 알고리즘 다익스트라 알고리즘은 너비 우선 탐색(BFS)처럼 시작점에서 가까운 순서대로 정점을 방문한다. BFS와 다른 점은 가중치가 있는 그래프에 적용하며, BFS로는 아래와 같은 그래프에서 최단 거리를 찾을 수 없다.  위 그래프에서 최단 경로는 s-a-b-c 이다. 하지만 BFS를 사용하면 시작점과 인접한 정점을 방문하므로 b정점을 통한 최단 경로를 계산할 수 없다. 이러한 경우 다익스트라 알고리즘을 사용할 수 있다. 그러면 기본적으로 다익스트라 알고리즘이 어떻게 동작하는지 예제를 통해 살펴보자.  위 그래프에서 시작점은 1번 정점으로 하여 모든 정점에 대해서 최단 거리를 구해보자. 다익스트라 알고리즘은 위에서 말했듯이 BFS와 같이 인접한 정점에서 가장 가까운 정점을 선택한다. 그리고 그 정점 중 최단 거리를 갱신해나아간다. 그러기 위해 시작점을 제외한 아직 방문하지 않은 정점은 가장 큰 수(INF) 로 초기화 한다. 따라서 초기 모습은 다음과 같다.             횟수/정점      1      2      3      4      5      6                  0      0      INF      INF      INF      INF      INF      표에서 확정된 정점의 최단 거리는 진한 검정색 으로 표시한다. 그리고 인접한 정점까지의 거리와 현재 표의 거리 중 더 짧은 거리로 갱신한다. 그 다음 확정되지 않은 정점 중 가장 짧은 정점으로 이동한다.   1번 정점과 인접한 정점 (정점, 거리)          (2, 0 + 7),   min(INF, 7) = 7      (3, 0 + 9),   min(INF, 9) = 9      (6, 0 + 14),  min(INF, 14) = 14      1번 정점과 인접한 정점까지 거리를 계산하여 표와 비교한 후 더 짧은 거리로 갱신한다. 그 다음 확정되지 않은 정점 중 가장 짧은 거리를 가진 정점으로 이동한다. 선택된 정점은 시작점과 최단 거리임을 확정하고 그 정점에서 위와 같이 인접한 정점과 거리 계산 과정을 반복한다.             횟수/정점      1      2      3      4      5      6                  0      0      INF      INF      INF      INF      INF              1      0      7      9      INF      INF      14        2번 정점과 인접한 정점          (3, 7 + 10),   min(9, 17) = 9      (4, 7 + 15),   min(INF, 22) = 22                  횟수/정점      1      2      3      4      5      6                  0      0      INF      INF      INF      INF      INF              1      0      7      9      INF      INF      14              2      0      7      9      22      INF      14      그 결과, 최단 거리로 확정되지 않은 정점 중 3번 정점이 가장 짧으므로 이를 확정시키고 3번 정점과 인접한 정점을 계산한다. 이와 같은 계산 과정을 모든 정점이 최단 거리로 확정될 때까지 반복한다. 모든 결과를 표로 나타내면 다음과 같다.             횟수/정점      1      2      3      4      5      6                  0      0      INF      INF      INF      INF      INF              1      0      7      9      INF      INF      14              2      0      7      9      22      INF      14              3      0      7      9      20      INF      11              4      0      7      9      20      20      11              5      0      7      9      20      20      11      하지만 이 방법은 확정되지 않은 정점 중 가장 짧은 거리의 정점을 찾기 위해 시간복잡도 O(N)으로 순차적으로 탐색한다. 이를 최적화하기 위해 우선 순위 큐 를 사용하여 가장 짧은 거리의 정점을 시간복잡도 O(logN) 으로 찾을 수 있다. 우선 순위 큐를 이용한 다익스트라 알고리즘 우선 순위 큐를 사용하더라도 알고리즘 로직은 바뀌지 않는다. 다만, 확정할 정점을 찾는데 소요되는 시간을 O(N)에서 O(logN)으로 줄인 것이다. 그러면 이를 구현한 코드를 살펴보자. //정점의 개수int V;//그래프의 인접 리스트 (연결된 정점 번호, 간선 가중치) 쌍을 담는다.vector&lt;pair&lt;int, int&gt;&gt; adj[MAX_V];//다익스트라, 최단 거리 배열을 반환한다.vector&lt;int&gt; dijkstra(int src) {\t//INF: 매우 큰 값\tvector&lt;int&gt; dist(V, INF);\tdist[src] = 0;\t//(해당 정점까지 최단 거리, 해당 정점)쌍  \t//STL내부에서 pair의 첫번째 원소부터 크기 비교를 하기 때문에, 거리값을 첫 원소로 해야 한다.\tpriority_queue&lt;pair&lt;int, int&gt;&gt; pq;\tpq.push(make_pair(0, src));\twhile (!pq.empty()) {    \t\tint here = pq.top().second;\t\tint cost = -pq.top().first;\t\tpq.pop();\t\t//만약 지금 꺼낸 것보다 더 짧은 경로를 알고 있다면 지금 꺼낸 것을 무시한다.\t\tif (dist[here] &lt; cost) continue;\t\t//인접한 정점들을 모두 검사한다.\t\tfor (int i = 0; i &lt; adj[here].size(); ++i) {\t\t\tint there = adj[here][i].first;\t\t\tint nextDist = cost + adj[here][i].second;\t\t\t//더 짧은 경로를 발견하면, dist[]를 갱신하고 우선순위 큐에 넣는다.\t\t\tif (dist[there] &gt; nextDist) {\t\t\t\tdist[there] = nextDist;\t\t\t\tpq.push(make_pair(-nextDist, there));\t\t\t}\t\t}\t}  return dist;}코드를 살펴보면 dist[]은 매개변수로 전달받은 시작점 src 정점에서 모든 정점까지 최단 거리를 저장한 배열이다. 그리고 구현의 편의성을 위해 몇가지 사용한 방법이 있다.   C++ STL pair는 첫 번째 원소를 비교하므로 (거리, 정점) 쌍으로 저장한다.  C++ STL 우선순위 큐는 기본적으로 내림차순이므로 거리의 부호를 바꾸는 것으로 간단하게 사용할 수 있다.  중복된 정점의 계산을 피하기 위해 현재 거리보다 긴 경우는 모두 무시한다.(따라서, 저장할 때 정점 중복 검사는 하지 않아도 된다.)시간복잡도 간선의 개수를 E라고 할 때, 각 정점마다 인접한 간선들을 모두 검사하는 작업은 O(E) 이고, 우선 순위 큐에 추가 및 삭제하는 연산은 O(logE)이다. 따라서 전체 시간복잡도는 O(ElogE) 이다. 여기서 대부분의 그래프에서 간선의 개수는 정점의 개수(V) 제곱보다 작으므로 최대 원소의 개수가 전체 간선의 수가 아닌 전체 정점의 수로 볼 수 있다. 따라서, 시간복잡도를 O(ElogV) 로 계산할 수도 있다.   O(VlogV) 다익스트라 알고리즘중복 원소를 우선순위 큐에 넣지 않도록 수정하면 시간복잡도는 O(VlogV)로 만들 수 있다. 이를 위해 피보나치 힙이나 이진 검색 트리를 사용해서 우선 순위 큐를 구현하면 중복 원소를 제거할 수 있지만, 구현이 복잡하고 실제로 시간이 더 오래 걸리는 경우가 많다. ","categories": ["Algorithm"],
        "tags": ["Algorithm_Algorithm"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/",
        "teaser":null},{
        "title": "[운영체제] # 14 세그먼테이션(Segmentation)",
        "excerpt":"지금까지 살펴본 페이징은 프로세스를 물리적으로 일정한 크기로 나눠서 메모리에 할당하였다. 반면에 세그먼테이션은 프로세스를 논리적 내용을 기반 으로 나눠서 메모리에 배치하는 것을 말한다. 세그먼테이션은 프로세스를 세그먼트(segment)의 집합으로 만들고, 각 세그먼트의 크기는 일반적으로 같지 않다. 프로세스를 code + data + stack 으로 나누는 것 역시 세그먼테이션의 모습이다. 물론 code, data, stack 각각 내부에서 더 작은 세그먼트로 나눌 수도 있다. 세그먼트를 메모리에 할당할 때는 페이지를 할당하는 것과 동일하다. 하지만 테이블은 조금 다른데, 세그먼테이션을 위한 테이블은 세그먼트 테이블 이라고한다. 그리고 세그먼트 테이블은 세그먼트 번호와 시작 주소(base), 세그먼트 크기(limit)를 엔트리로 갖는다. 세그먼트에서 주소변환 역시, 페이징과 유사하다. 한 가지 주의할 점은 세그먼트의 크기는 일정하지 않기 때문에, 테이블에 limit 정보가 주어진다. 그리고 CPU에서 해당 세그먼트의 크기를 넘어서는 주소가 들어오면 인터럽트가 발생해서 해당 프로세스를 강제로 종료시킨다. 그러면 세그먼트 주소변환 예제를 하나 살펴보자.  위 그림은 세그먼트 테이블과 프로세스가 할당된 메모리의 모습이다. 페이징 주소변환과 동일하게 d는 논리주소와 물리주소가 동일하다. 물리주소 a는 base[s] + d 로 계산된다.   논리주소 (2, 100) =&gt; 물리주소 4400번지  논리주소 (1, 500) =&gt; 인터럽트로 인해 프로세스 강제 종료(범위를 벗어남)세그먼테이션에서 보호와 공유 먼저, 결론부터 말하면 페이징보다 세그먼테이션에서의 보호와 공유는 더 효율적이다. 보호에서는 세그먼테이션 역시 r, w, x 비트를 테이블에 추가하는데, 세그먼테이션은 논리적으로 나누기 때문에 해당 비트를 설정하기 매우 간단하고 안전하다. 페이징은 code + data + stack 영역이 있을 때 이를 일정한 크기로 나누므로 두 가지 영역이 섞일 수가 있다. 그러면 비트를 설정하기가 매우 까다롭다. 공유에서도 마찬가지다. 페이징에서는 code 영역을 나눈다해도 다른 영역이 포함될 확률이 매우 높다. 하지만 세그먼테이션은 정확히 code 영역만 나누기 때문에 더 효율적으로 공유를 수행할 수 있다. 세그먼테이션과 페이징 세그먼테이션은 페이징과 유사하고 보호와 공유에서는 더 나은 성능을 보여주었지만, 현재 대부분은 페이징 기법을 사용한다. 그 이유는 세그먼테이션에는 치명적인 단점이 있기 때문이다. 메모리 할당을 처음 시작할 때 다중 프로그래밍에서의 문제는 크기가 서로 다른 프로세스로 인해 여러 크기의 hole이 발생한다. 이로 인해 어느 hole에 프로세스를 할당하는 것에 대한 최적화 알고리즘이 존재하지 않고, 외부 단편화로 인해 메모리 낭비가 크다고 했었다. 세그먼테이션도 똑같은 문제점이 발생한다. 왜냐하면 세그먼테이션은 논리적인 단위로 나누기 때문에 세그먼트의 크기가 다양하다. 이로 인해 다양한 크기의 hole이 발생하므로 같은 문제가 발생한다. 결론적으로 세그먼테이션은 보호와 공유에서 효율적이고, 페이징은 외부 단편화 문제를 해결할 수 있다. 그러므로 두 가지를 합쳐서 사용하는 방법이 나왔다. 두 장점을 합치기 위해서는 세그먼트를 페이징 기법으로 나누는 것이다.(Paged segmentation) 하지만 이 역시 단점이 존재한다. 세그먼트와 페이지가 동시에 존재하기 때문에 주소 변환도 두 번해야한다. 즉 CPU에서 세그먼트 테이블에서 주소 변환을 하고, 그 다음 페이지 테이블에서 또 주소 변환을 해야한다. ","categories": ["Study"],
        "tags": ["Study_OperatingSystem"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-14%EC%9E%A5-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98/",
        "teaser":null},{
        "title": "[운영체제] # 15 가상메모리(Virtual Memory)",
        "excerpt":"가상 메모리는 물리 메모리 크기의 한계를 극복하기 위해 나온 기술이다. 즉, 물리 메모리보다 큰 프로세스를 수행하기 위해 가상 메모리를 사용한다. 예를 들어, 100MB 메모리 크기에서 200MB 크기의 프로세스를 수행할 수 있도록 하는 것이다. 이러한 방식이 어떻게 가능할까? 앞서 메모리 낭비 방지의 동적 할당에서도 봤듯이, 필요한 부분만 메모리에 적재하는 것이다. 프로세스를 실행할 때, 실행에 필요한 부분만 메모리에 올리는 것이다. 이러한 프로세스의 일부분은 페이지 단위일 수도 있고, 세그먼트 단위일 수도 있지만 현재 대부분은 페이지 단위를 사용한다. 이처럼 현재 필요한(요구되어지는) 페이지만 메모리에 올리는 것을 Demanding Paging(요구 페이징) 이라고 한다. Demanding Paging  위 그림은 요구 페이징의 모습이다. 두 프로세스 P1, P2는 각각 필요한 페이지만 메모리에 할당하였다. 여기서 위 그림의 테이블은 P1이 수행 중일 때의 페이지 테이블이다. 기존의 페이지 테이블과 다른 점은 valid bit 가 추가된 모습이다. 이는 현재 메모리에 페이지가 있는지 없는지를 나타내는 비트이다. 현재 페이지가 메모리에 있다면 1, 없다면 0값을 갖는다. 만약, CPU에서 P1의 3번째 페이지에 접근하는데, valid bit값이 0이다. 그러면 CPU에 인터럽트 신호를 발생하여 운영체제 내부의 ISR로 점프 한다. 여기서 디스크 내부의 프로세스 P1에 있는 2번째 페이지를 메모리에 할당하는 작업을 처리한다.  위 그림은 P1의 3번째 페이지를 메모리에 올린 후 모습이다. 가상 메모리를 만드는 방법은 대표적으로 두 가지가 존재하지만, 대부분 요구 페이징을 사용 하므로 가상 메모리와 요구 페이징을 같은 용어로 사용하는 경우가 많다. Page Fault(페이지 부재) 페이지 부재는 위에서 살펴본 CPU가 접근하려는 페이지가 메모리에 없는 경우 이다. 즉, 페이지 테이블의 valid bit값이 0인 경우이다.  위 그림은 page fault가 발생했을 때 처리하는 과정을 나타낸 것이다.   해당 페이지가 메모리에 있는지 valid bit를 확인한다.  valid bit가 0이라면 CPU에 인터럽트 신호를 보내어 운영체제 내부 해당 ISR로 점프한다.  해당 ISR에서 backing store(디스크)를 탐색하여 해당 프로세스의 페이지를 찾는다.  해당 페이지를 비어있는 프레임에 할당한다.  페이지 테이블을 갱신한다.(프레임 번호 설정, valid bit 1로 변경)  다시 명령어로 돌아가서 실행한다.Pure Demanding Paging Pure Demanding Paging은 프로세스가 최초로 실행될 때는 어떤 페이지가 필요한지 알 수 없으므로, 아무 페이지도 올리지 않는다. 그러므로 프로그램을 실행하자마자 page fault가 발생한다. 즉, 순수하게 필요한 페이지만 올리는 것을 말한다. Pure Demanding Paging의 장점은 메모리를 최대한 효율적으로 사용할 수 있다. 하지만 시작부터 page fault가 발생하므로 속도면에서 느리다. Prepaging Prepaging은 pure demanding paging과 반대대는 개념이다. 프로그램을 실행할 때 필요할 것이라 판단되는 페이지를 미리 올리는 것 이다. 이것의 장점은 page fault가 발생할 확률이 적으므로 속도면에서 빠르지만, 단점으로 미리 올라간 페이지를 사용하지 않는다면 메모리가 낭비된다. Swapping VS Demanding Paging Swapping와 Demanding Paging의 공통점은 둘 다 메모리와 backing store 사이를 서로 오고 가는 기능을 수행하지만, Swapping은 프로세스 단위 로 이동하고 Demanding Paging은 페이지 단위 로 이동하는 차이점이 있다. 유효 접근 시간(Effective Access Time) Demending Paing은 페이지 테이블에 해당 페이지가 없으면 backing store에서 메모리로 가져오는 과정이 있으므로, 페이지 테이블에 해당 페이지가 있을 때와 없을 때 시간 차이가 발생한다. 이러한 시간 차이를 고려하여 평균적으로 어느정도 소요되는지 계산하는 것을 유효 접근 시간이라 한다.   p: 페이지 부재 확률(probability of a page fault = page fault rate)  Tm: 메모리를 읽는 시간  Tp: Page fault가 발생했을 때 소요되는 시간(대부분 backing store(하드디스크)를 읽는 시간이 차지한다.)  T = (1-p)Tm + pTp예제를 살펴보자.   Tm = 200nsec (DRAM)  Tp = 8msec (seek time + rotational delay + transfer time)  T = (1-p) * 200 + p * 8,000,000 = 200 + 7,999,800 * p  p = 1/1,000 =&gt; T = 8.2usec (40배 정도 느림)  p = 1/399,990 =&gt; T = 220nsec (10% 정도 느림)위의 예제를 보았을 때, page fault는 매우 적은 확률로 발생해야 효율적이다. 그러면 현실적으로 페이지 부재는 어느정도로 발생할까? 이는 지역성의 원리(Locality of reference) 로 인해 페이지 부재 확률은 매우 낮다. 지역성의 원리는 메모리 접근은 시간적 지역성과 공간적 지역성을 가진다 는 의미이다. 시간적 지역성은 CPU는 어느 메모리 공간을 읽은 후, 시간이 지나도 그 공간을 다시 읽을 확률이 매우 높다는 것을 말한다. 공간적 지역성은 CPU가 메모리 공간을 읽을 때는 인접한 범위 내에서 읽는다는 의미이다. 시간적 지역성의 대표적인 예는 반복문이다. 반복문은 하나의 코드 공간을 여러 번 읽는다. 공간적 지역성은 프로그램은 대부분 절차적으로 구현되어 있으므로 순서대로 읽는 경우가 빈번한다. 이와 같이 페이지 부재가 현실적으로 발생할 확률은 매우 낮으므로 예제와 같이 40배로 느려지는 일을 거의 없다. 여기서 더 효율적으로 사용하기 위해서는 페이지 부재일 때 소요되는 시간을 줄일 수 있는데, backing store로 HDD를 사용하기 보다는 더욱 빠르게 동작하는 SSD나 저가 DRAM과 같은 것을 사용하는 방법이 있다. 페이지 교체(Page Replacement) Demanding Paging은 요구되어지는 페이지만 backing store에서 가져온다. 하지만 프로그램들이 계속 실행함에 따라 요구 페이지도 계속 늘어나고, 언젠가는 메모리가 가득 차게 될 것이다.(memory full) 여기서 다른 프로그램이 새로 실행되거나 실행중인 프로세스가 다른 페이지를 요구한다면 이미 메모리에 있는 페이지 중 하나를 다시 backing store에 보내고(page-out), 새로운 페이지를 메모리에 올려야한다.(page-in) 이를 페이지 교체라고 한다. 여기서 backing store로 page-out이 된 페이지를 victim page 라고 한다. Victim Page(희생양 페이지) 희생양 페이지는 어떤 페이지로 하는 것이 좋을까? 먼저 생각할 수 있는 것은 메모리에 올라가 있는 페이지 중 CPU에 수정(modify)되지 않는 페이지 를 고르는 것이 효율적으로 보인다. 수정되지 않은 페이지는 page-out이 될 때 backing store에 쓰기(write) 연산을 할 필요가 없기 때문이다. backing store는 읽는 시간도 느리지만, 거기에 더해 쓰기 작업까지 한다면 더욱 비효율적일 것이다. 그러면 해당 페이지가 수정되었는지 안되었는지를 판단할 수 있어야 하는데, 이를 위해 페이지 테이블에 modified bit(=dirty bit) 를 추가하여 이를 검사한다. 해당 페이지가 수정되었다면 이 비트를 1로 두고, 수정되지 않으면 0으로 둔다. 이를 이용해서 victim page는 최대한 수정되지 않은 페이지를 선택한다.  위 그림은 modified bit를 추가한 페이지 테이블의 모습이다. 여기서 수정되지 않은 페이지는 0, 2, 3번 3개의 페이지가 존재하는데 이 중에서는 어떤 페이지를 선택해야 할까? 제일 간단한 방법은 랜덤하게 선택하는 것이지만, 이는 성능을 보장할 수 없다. 그 다음은 가장 먼저 메모리에 올라온 페이지를 희생양 페이지로 선택하는 것이다. 이는 아주 유명한 FIFO(First-In First-Out) 방식이다. 이 외에도 여러가지 방법이 존재한다. ","categories": ["Study"],
        "tags": ["Study_OperatingSystem"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-15%EC%9E%A5-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC/",
        "teaser":null},{
        "title": "[운영체제] # 16 페이지 교체 알고리즘(Page Replacement Algorithm)",
        "excerpt":"페이지 교체 알고리즘을 살펴보기 전에 Page reference string 이라는 용어를 알아야 한다. CPU가 내는 주소는 이진수 단위이지만, 페이지 교체 알고리즘을 계산하기 위해서는 이진수 주소 단위가 아닌 페이지 단위로 계산해야한다. 예를 들어, CPU가 내는 주소를 간단히 십진수로 표현하여 {100, 101, 102, 432, 612, 103, 104, 611, 612} 라고 하자. 만약 페이지 크기가 100bytes라면, 위 주소를 페이지 번호로 나타내면 {1, 1, 1, 4, 6, 1, 1, 6, 6} 이다. 주소 100번지는 1번 페이지에서 offset이 0인 위치이고, 101은 1번 페이지의 offset 1인 위치라고 볼 수 있다. 마지막으로 페이지 번호로 나타낸 것을 page reference string으로 나타내면 {1, 4, 6, 1, 6}이다. 이는 간단히 말하면 연속된 페이지는 생략하고 하나의 페이지 번호만 나타낸 것으로 볼 수 있다. 이 이유는 연속된 페이지를 참조할 때는 한 번 page fault가 발생하면 같은 페이지를 사용하는 동안에는 절대 page fault가 발생할 수 없기 때문이다. 정리하면, page size = 100bytes 일때 CPU 주소              = {100, 101, 102, 432, 612, 103, 104, 611, 612}Page 번호             = {1, 1, 1, 4, 6, 1, 1, 6, 6}Page reference string = {1, 4, 6, 1, 6}First-In First-Out(FIFO) FIFO은 가장 간단한 알고리즘이다. 가장 먼저 page-in 한 페이지를 먼저 page-out 시킨다. 이를 사용한 이유는 초기화 코드가 더 이상 사용되지 않을 것이라는 아이디어에서 시작되었다.   예제페이지 참조열(page reference string): {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 7, 0, 1}프레임 개수(number of frame): 3조건은 위와 같고 최초의 메모리는 비어있는 상태이다.            1      2      3      4      5      6      7      8      9      10      11      12      13      14      15      16      17      18      19                  7      0      1      2      0      3      0      4      2      3      0      3      2      1      2      0      7      0      1        프레임 상태: {}  Page-in: 7 =&gt; 프레임 상태: {7}        Page fault 수: 1                First Page: 7  Page-in: 0 =&gt; 프레임 상태: {7, 0}     Page fault 수: 2                First Page: 7  Page-in: 1 =&gt; 프레임 상태: {7, 0, 1}  Page fault 수: 3                First Page: 7  Page-in: 2 =&gt; 프레임 상태: {2, 0, 1}  Page fault 수: 4   Page-out: 7  First Page: 0  Page-in: 0 =&gt; 프레임 상태: {2, 0, 1}  Page fault 수: 4                First Page: 0  Page-in: 3 =&gt; 프레임 상태: {2, 3, 1}  Page fault 수: 5   Page-out: 0  First Page: 1  Page-in: 0 =&gt; 프레임 상태: {2, 3, 0}  Page fault 수: 6   Page-out: 1  First Page: 2  Page-in: 4 =&gt; 프레임 상태: {4, 3, 0}  Page fault 수: 7   Page-out: 2  First Page: 3  Page-in: 2 =&gt; 프레임 상태: {4, 2, 1}  Page fault 수: 8   Page-out: 3  First Page: 1  Page-in: 3 =&gt; 프레임 상태: {4, 2, 3}  Page fault 수: 9   Page-out: 1  First Page: 4  Page-in: 0 =&gt; 프레임 상태: {0, 2, 3}  Page fault 수: 10  Page-out: 4  First Page: 2  Page-in: 3 =&gt; 프레임 상태: {0, 2, 3}  Page fault 수: 10               First Page: 2  Page-in: 2 =&gt; 프레임 상태: {0, 2, 3}  Page fault 수: 10               First Page: 2  Page-in: 1 =&gt; 프레임 상태: {0, 1, 3}  Page fault 수: 11  Page-out: 2  First Page: 3  Page-in: 2 =&gt; 프레임 상태: {0, 1, 2}  Page fault 수: 12  Page-out: 3  First Page: 0  Page-in: 0 =&gt; 프레임 상태: {0, 1, 2}  Page fault 수: 12               First Page: 0  Page-in: 7 =&gt; 프레임 상태: {7, 1, 2}  Page fault 수: 13  Page-out: 0  First Page: 1  Page-in: 0 =&gt; 프레임 상태: {7, 0, 2}  Page fault 수: 14  Page-out: 1  First Page: 2  Page-in: 1 =&gt; 프레임 상태: {7, 0, 1}  Page fault 수: 15  Page-out: 2  First Page: 7결과는 최종 page fault 수는 15이다. 예제를 수행하면서, 이전에 page-out한 페이지를 그 다음 바로 page-in을 하려한다면 다시 page fault가 발생하기 때문에 비효율적인 모습을 볼 수 있다. Belady’s Anomaly 프레임 수가 증가하면(= 메모리 용량이 증가하면) page fault 수가 줄어드는 것이 정상적이지만, 특정한 페이지 참조열에 대해서는 프레임 수가 증가해도 page fault 수가 오히려 증가하는 이상 현상이 발생한다. 이를 Belady’s Anomaly라 한다.  Optimal(OPT) OPT는 말그대로 가장 효율적인 페이지 교체 알고리즘이다. 이 알고리즘은 가장 오랫동안 사용되지 않을 페이지를 희생양 페이지로 선택한다.   예제페이지 참조열(page reference string): {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 7, 0, 1}프레임 개수(number of frame): 3여기서 가장 오랫동안 사용되지 않을 페이지를 계산하기 위해 현재 시점 에서 그 이후에 최초로 나타나는 시점의 거리 를 dist로 둔다. 이 값이 가장 큰 페이지가 가장 오랫동안 사용되지 않은 페이지로 정한다.(해당 페이지가 이후에 나오지 않는 경우는 INF로 가장 큰 값으로 한다.)            1      2      3      4      5      6      7      8      9      10      11      12      13      14      15      16      17      18      19                  7      0      1      2      0      3      0      4      2      3      0      3      2      1      2      0      7      0      1        프레임 상태: {}  Page-in: 7 =&gt; 프레임 상태: {7}        Page fault 수: 1                dist: {15}  Page-in: 0 =&gt; 프레임 상태: {7, 0}     Page fault 수: 2                dist: {14, 3}  Page-in: 1 =&gt; 프레임 상태: {7, 0, 1}  Page fault 수: 3                dist: {13, 2, 11}  Page-in: 2 =&gt; 프레임 상태: {2, 0, 1}  Page fault 수: 4   Page-out: 7  dist: {5, 1, 10}  Page-in: 0 =&gt; 프레임 상태: {2, 0, 1}  Page fault 수: 4                dist: {4, 2, 9}  Page-in: 3 =&gt; 프레임 상태: {2, 0, 3}  Page fault 수: 5   Page-out: 1  dist: {3, 1, 4}  Page-in: 0 =&gt; 프레임 상태: {2, 0, 3}  Page fault 수: 5                dist: {2, 4, 3}  Page-in: 4 =&gt; 프레임 상태: {2, 4, 3}  Page fault 수: 6   Page-out: 0  dist: {1, INF, 2}  Page-in: 2 =&gt; 프레임 상태: {2, 4, 3}  Page fault 수: 6                dist: {4, INF, 1}  Page-in: 3 =&gt; 프레임 상태: {2, 4, 3}  Page fault 수: 6                dist: {3, INF, 2}  Page-in: 0 =&gt; 프레임 상태: {2, 0, 3}  Page fault 수: 7   Page-out: 4  dist: {2, 5, 1}  Page-in: 3 =&gt; 프레임 상태: {2, 0, 3}  Page fault 수: 7                dist: {1, 4, INF}  Page-in: 2 =&gt; 프레임 상태: {2, 0, 3}  Page fault 수: 7                dist: {2, 3, INF}  Page-in: 1 =&gt; 프레임 상태: {2, 0, 1}  Page fault 수: 8   Page-out: 3  dist: {1, 2, 5}  Page-in: 2 =&gt; 프레임 상태: {2, 0, 1}  Page fault 수: 8                dist: {INF, 1, 4}  Page-in: 0 =&gt; 프레임 상태: {2, 0, 1}  Page fault 수: 8                dist: {INF, 2, 3}  Page-in: 7 =&gt; 프레임 상태: {7, 0, 1}  Page fault 수: 9   Page-out: 2  dist: {INF, 1, 2}  Page-in: 0 =&gt; 프레임 상태: {7, 0, 1}  Page fault 수: 9                dist: {INF, INF, 1}  Page-in: 1 =&gt; 프레임 상태: {7, 0, 1}  Page fault 수: 9                dist: {INF, INF, INF}OPT의 결과는 총 9번의 page fault가 발생했다. 이는 FIFO의 15번보다 크게 줄어든 모습을 볼 수 있다. 하지만 OPT의 방법은 현실적으로 불가능하다. 실제 컴퓨터에서는 미래에 어떤 프로세스가 사용되는지 알 수 없다. 그러므로 어느 프로세스가 가장 오래 사용안되는 지를 계산할 수 없다. Least-Recently-Used(LRU) OPT는 최적해를 구할 수 있지만 미래를 알 수 없으므로 현실적으로 불가능한 방법이었는데, 최적의 해는 아니더라도 근사의 해를 구하기 위해서 LRU가 나왔다. LRU는 최근에 사용되지 않으면 나중에도 사용되지 않을 것 이라는 개념으로 과거의 페이지 기록을 통해 희생양 페이지를 선태한다.   예제LRU는 근사 해를 구하므로 OPT보다는 page fault가 많이 발생하지만, FIFO보다는 일반적으로 적게 일어난다. 그러므로 현재 대부분 환경에서는 LRU를 사용하고 있다. ","categories": ["Study"],
        "tags": ["Study_OperatingSystem"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-16%EC%9E%A5-%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/",
        "teaser":null},{
        "title": "[운영체제] # 17 프레임 할당(Allocation of Frames)",
        "excerpt":"Global VS Local Replacement   Global Replacement: 메모리 상의 모든 프로세스 페이지에 대한 교체 작업을 수행한다.  Local Replacement: 메모리 상의 자기 자신의 프로세스 페이지에 대해서만 교체 작업을 수행한다.메모리 사용 효율은 일반적으로 Global Replacement이 좋다.프레임 할당(Allocation of Frames) 쓰레싱(Thrashing) 일반적으로 메모리에 올라가는 프로세스 개수가 증가할수록 CPU의 이용률은 올라갈 것이라 예상한다. 왜냐하면 프로세스가 많을 수록 CPU의 할 일 역시 증가하기때문이다. 이는 일정 범위까지는 맞는 예상이지만, 그 범위를 넘어서면 오히려 CPU 이용률이 감소하는 현상 이 나타난다.  위 그림은 이러한 현상을 그래프로 나타낸 것이다. 이와 같은 현상이 발생하는 이유는 프로세스가 증가할수록 메인 메모리의 비어있는 프레임 개수는 줄어들게 되고 결국 모든 프레임이 가득 차게 된다. 그 후에도 계속 프로세스가 증가한다면 메모리와 backing store 사이에 page in/out 작업 이 발생하는데, 프로세스가 많아질수록 이 작업 역시 증가한다. page in/out은 디스크 I/O 작업으로 CPU를 사용하지 않는 작업이다. 그러므로 이 작업이 많아질수록 CPU는 그동안 아무것도 하지 않게 된다. 위 그래프에서도 나와있듯이, I/O 작업이 증가하여 CPU 이용률이 떨어지는 현상을 Thrashing 이라 한다. 쓰레싱을 해결하는 방법은 크게 두 가지가 있다.   Global Replacement보다 Local Replacement를 사용하는 것이다. 하지만 이 경우에는 메모리 사용 효율이 떨어지는 단점이 있다.  프로세스당 충분한/적절한 수의 프레임(메모리)을 할당 한다.그렇다면, 적절한 프레임의 수는 어떻게 정하는 것일까? 프레임 할당은 크게 정적 할당과 동적 할당으로 나뉜다.   정적 할당(Static Allocation)          동일 할당(Equal Allocation): 모든 프로세스에게 똑같은 수의 프레임을 할당한다. 이 방식은 프로세스의 크기에 따라 매우 비효율적이다.      비례 할당(Proportional Allocation): 프로세스의 크기에 따라 프레임을 할당한다. 이 방식 역시 단점이 있다. 프로세스 크기가 크더라도 모든 기능을 사용하지 않기 때문에 이 방식 또한 비효율적이다.      이처럼 정적 할당은 한계가 뚜렷하다. 이를 해결하기 위한 방법은 실행 중에 프레임을 할당하는 동적 할당 이다. 동적 할당(Dynamic Allocation) Working Set Model 프로세스가 실행 중일 때 어느 페이지를 사용하는지 실험한 결과에서 Locality 성질이 성립한다는 것을 발견할 수 있었다.  위 그래프는 프로세스가 실행 중에 어떤 프로세스를 사용하는지 표시한 것으로, 특정 시간에는 일정 범위의 페이지를 주로 참조하는 것을 알 수 있다. 이러한 성질은 캐시에서도 볼 수 있다. 이를 통해 특정 시간에 따라 사용하는 페이지의 개수만큼 프레임을 할당해줄 수 있다. 이 방법 역시 치명적인 단점이 있다. 바로 프로세스를 미리 수행해봐야 할 수 있다는 것이다. 그리고 프로세스를 수행할 때마다 사용하는 기능이 달라질 수 있으므로, Locality를 이용하는 방법은 비현실적이다. 이를 해결하기 위해 나온 것이 working set 이다. working set은 위의 locality의 방식과 유사한데, 미래가 아닌 과거를 보는 것이다.  위 그림은 working set을 사용하는 모습이다. working set은 현재 시간에서 일정 시간(△) 이전동안 사용되었던 페이지의 집합 이다. △(델타)는 운영체제 내부에서 정하는 기준에 따라 다르며, 이를 working set window 라 한다. 마지막으로 working set의 개수만큼 프레임을 할당한다. 만약 현재 시간이 t1이라면 working set = {1, 2, 5, 6, 7}이다. 이 때 working set의 개수는 총 5개이므로 프레임 역시 5개를 할당해주면 된다. Page-Fault Frequency(PFF) 페이지 부재의 비율은 프로세스에 할당된 프레임의 수에 반비례한다. 즉, 할당된 프레임의 수가 적을수록 페이지 부재 비율은 늘어난다.  위 그림은 이와 같은 현상을 그래프로 나타낸 것이다. 세로축은 페이지 부재 비율이고, 가로축은 할당된 프레임의 수이다. 여기서 운영체제 내부에서 해당 프로세스의 페이지 부재 횟수를 계속 검사한다. 그러면 위와 같은 그래프처럼 나오는데, 여기서 상한선(upper bound)과 하한선(lower bound)를 설정 한다. 만약 상한선보다 많은 페이지 부재가 발생하면 프레임을 더 많이 할당해주고, 하한선보다 적게 페이지 부재가 발생하면 할당된 프레임 개수를 줄여준다. 페이지 크기 현재 페이지의 일반적인 크기는 4KB ~ 4MB 이다. 이는 과거에서부터 점점 커져왔고, 현재에도 메모리 크기가 증가하면서 커지고 있다. 페이지 크기에 따라 성능에는 어떤 영향을 미치는지 알아보자.   내부단편화: 내부단편화를 줄이려면 페이지 크기는 작은 것이 좋다.  Page-in, page-out 시간: 페이지의 in/out 시간을 결정하는 가장 큰 요인은 하드디스크 기준으로 하드디스크의 헤더가 움직이는 시간이다.(seek time) 페이지 크기가 크면 클수록 한 번의 seek time마다 큰 페이지를 읽을 수 있으므로, 페이지 부재 빈도가 줄어든다.(데이터를 읽는 시간은 크기에 따라 차이가 매우 적다.)  페이지 테이블 크기: 페이지 크기가 클수록 페이지 개수가 줄어들기 때문에 그만큼 페이지 테이블 크기도 줄일 수 있다.  Memory resolution(해상도): Memory resolution은 해당 메모리에 필요한 데이터가 있는 확률이다. 이는 페이지 크기가 작을수록 resolution을 높일 수 있다. 만약 페이지 크기가 크면 다른 필요없는 부분이 있을 확률이 크기 때문이다.  Page fault 발생 확률: Page fault 발생 확률을 줄이려면 페이지 크기가 큰 것이 좋다. 이는 locality 성질과도 관련이 있는데, 대부분 프로세스는 필요한 부분이 일정 범위 이내인 경우가 많으므로 페이지 크기가 클수록 필요한 부분이 있을 확률이 크다.페이지 테이블 반도체 기술의 발달로 TLB 역시 CPU의 내장 칩 형태로 만들어져있다. ","categories": ["Study"],
        "tags": ["Study_OperatingSystem"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-17%EC%9E%A5-%ED%94%84%EB%A0%88%EC%9E%84-%ED%95%A0%EB%8B%B9/",
        "teaser":null},{
        "title": "[운영체제] # 18 파일 할당(Allocation of Files)",
        "excerpt":"컴퓨터 시스템 자원 중 가장 중요한 것은 CPU이다. CPU 자원 관리에 대해서는 맨 처음 부분에서 다루었으며 CPU 스케줄링, 프로세스 동기화 등에 대해서 배웠다. CPU 다음으로 중요한 자원은 메인 메모리와 같은 주기억장치이다. 메인 메모리 관리에 대한 주요 이슈는 페이징, 가상 메모리(요구 페이징) 등이 있었다. CPU, 주기억장치 다음 중요한 컴퓨터 시스템 자원은 하드디스크와 같은 보조기억장치이다. 하드디스크가 데이터를 관리하는 방식은 파일 시스템 이다. 파일은 컴퓨터에서 운영체제를 사용해본 사용자라면 매우 익숙한 단어일 것이다. 대표적인 windows 운영체제를 보면 폴더(디렉토리) 내부에 또 다른 폴더 또는 어떠한 파일이 존재한다. 이러한 폴더 및 파일은 트리 구조를 이루어 관리할 수 있다. 이번 장에서는 보조기억장치 중 컴퓨터에서 주로 사용하는 하드디스크의 파일이 할당되는 방법에 대해서 살펴볼 것이다.  위 그림은 하드디스크의 구조이다.   platter: 실제 데이터를 기록하는 자성을 가진 원판이다. platter는 그림과 같이 여러 개가 존재하고 앞뒤로 사용할 수 있다. 한 platter는 여러 개의 track으로 이루어져 있다.  track: platter의 동심원을 이루는 하나의 영역이다.  sector: 하나의 track을 여러 개로 나눈 영역을 sector라 한다. sector size는 일반적으로 512 bytes이며 주로 여러 개를 묶어서 사용한다.  cylinder: 한 cylinder는 모든 platter에서 같은 track 위치의 집합을 말한다.앞서 sector는 여러 개로 묶어서 사용한다고 했는데, 이를 블록(block) 이라 한다. 하드디스크는 블록 단위로 읽고 쓰기 때문에 block device 라고 불리기도 한다. 하드디스크가 블록 단위로 읽고 쓰는 것을 확인할 수 있는 간단한 방법은 메모장 프로그램에서 알파벳 a만을 적고 저장해보자. a는 character로 1byte 크기를 갖는데, 실제 저장된 텍스트 파일의 속성을 확인하면 디스크에 4KB(하나의 block size) 가 할당되는 것을 확인할 수 있다.(실제 디스크 할당 크기는 운영체제마다 다르다.) 따라서 디스크는 비어있는 블록들의 집합이라고 볼 수 있다.(pool of free blocks) 그렇다면 운영체제는 각각의 파일에 대해 free block 을 어떻게 할당할까? 파일 할당  위 그림은 pool of free blocks를 논리적인 그림으로 나타낸 모습이고 블록마다 인덱스 번호를 설정하였다. 블록들이 위와 같이 있을 때 파일을 할당하는 방법은 크게 연속 할당, 연결 할당, 색인 할당 세 가지가 존재한다. 연속 할당 (Contiguous Allocation) 연속 할당은 말그대로 연속된 블록에 파일을 할당 하는 것이다. 예를 들어, 블록 크기가 1KB이고, 할당할 파일은 f1, f2, f3 3개가 있고 각각의 크기는 5KB, 3KB, 4KB이다.  앞선 예제로 연속 할당을 수행하면 위의 그림과 같은 모습이 나온다. 연속 할당의 장점은 디스크 헤더의 이동을 최소화 할 수 있어 I/O 성능을 높일 수 있다. 이 방식은 예전의 IBM에서 사용하던 방법이며 주로 동영상, 음악, VOD 등에 적합하다. 또한, 연속 할당에는 두 가지 특징이 있다.   순차 접근(Sequential Access) 이 가능하다.이는 말그대로 순서대로 파일을 읽을 수 있다는 의미이다.  직접 접근(Direct Access) 이 가능하다.운영체제는 파일의 정보를 디렉토리(directory) 라는 테이블에 저장한다. 디렉토리에서 사용자가 접근가능한 정보는 파일의 이름, 크기, 날짜 등이 있고, 운영체제 내부에서 접근하는 정보는 해당 파일의 시작 블록 번호 와 같은 것이 있다. 예를 들어, 위 예제의 f1 파일의 디렉토리 정보는 아래와 같다.file name: f1file size: 5 bytes...-----------------block number: 0연속 할당은 순차적으로 저장되어 있으므로 운영체제는 디렉토리에서 얻은 시작 블록 번호로 원하는 블록에 바로 접근할 수 있다. 예를 들어, 위 예제에서 f1 파일의 3번째 블록에 접근하고 싶다고 가정하자. 운영체제는 f1의 시작 블록 번호가 0번인 것을 알고 있기 때문에 2번 블록에 접근하면 f1의 3번째 블록이라는 것을 알 수 있다. 연속 할당은 현재에는 거의 사용하지 않는 방식인데, 이 방법에는 큰 단점이 존재하기 때문이다. 파일을 할당하고 지우고를 반복하다보면 중간 중간에 빈 공간(hole)이 생기는데 연속 할당은 연속된 공간을 찾아야 하기 때문에 이전 메인 메모리 할당에서 살펴본 것과 같이 외부 단편화 문제가 발생한다. 외부 단편화로 인해 디스크 공간의 낭비가 매우 심해진다. 이전 메모리 할당에서 외부 단편화로 인해 메모리의 약 1/3을 낭비한다고 하였는데, 디스크의 연속 할당도 같은 낭비가 발생한다. 또 다른 문제는 파일을 저장할 때 실제 크기를 알 수 없다. 특히, 계속해서 사용하는 파일의 경우 크기가 계속 증가 할 수 있기 때문에 이를 지속해서 연속적으로 할당하기에는 매우 부적절하다. 연결 할당 (Linked Allocation) 연결 할당은 연속 할당의 문제점을 해결하기 위해 나온 방법으로, 연속적으로 할당하는 것이 아니라 링크드 리스트(linked list) 와 같은 방식으로 파일을 할당한다.  위 그림은 block 크기가 1 byte, 파일 f1의 크기가 5 bytes 일 때 연결 할당을 수행한 모습이다. 각 블록의 마지막에 주소를 저장하는 포인터 공간(4bytes) 이 존재하며, 여기서 다음 블록을 가리키고 있다. 마지막 블록의 포인터 공간에는 끝임을 나타내는 값이 저장되어 있다. 이러한 파일을 linked list of data blocks 라고 하며, f1의 파일 디렉토리 정보는 아래와 같다. file name: f1file size: 5 bytes...-----------------block number: 6연결 할당을 사용해서 새로운 파일을 할당할 때는 비어있는 임의의 블록을 첫 블록으로 선택하며, 만약 파일이 커지는 경우 다른 블록을 할당해서 기존의 블록과 연결만 해주면 된다. 연결 할당은 위치와 상관없이 할당이 가능하므로 외부 단편화 문제가 없다. (= 디스크 낭비가 없다.) 하지만, 연결 할당 역시 여러 문제점을 가지고 있다.   순차 접근은 가능하지만 직접 접근은 불가능하다. : 파일의 블록들은 모두 흩어져 있으므로 시작 블록 번호를 가지고는 원하는 위치의 블록에 바로 접근할 수는 없다.  포인터를 저장하는 4 bytes 이상의 손해가 발생한다.  낮은 신뢰성 : 중간 블록의 포인터가 끊어지면 그 이후의 모든 블록에 접근하지 못한다.  느린 속도 : 블록이 모두 흩어져 있으므로 디스크 헤더의 움직임이 그 만큼 많이 발생한다.위 문제점을 개선하기 위해 나온 것이 같은 연결 할당 방식인 FAT(File Allocation Table) 시스템 이다. FAT 시스템은 다음 블록으르 가리키는 포인터들만 모아서 하나의 테이블(FAT) 을 만들어 한 블록에 저장한다.  위 그림은 앞선 예제의 f1 파일을 FAT 파일 시스템 방식으로 저장한 모습이다. 0번 블록에 저장된 FAT를 보면 테이블의 인덱스는 전체 디스크의 블록 번호이며, 각 인덱스마다 다음 블록 번호를 저장 하고 있다. FAT 시스템을 사용하면 기존의 연결 할당의 문제점 대부분을 해결할 수 있다. FAT를 한 번만 읽으면 직접 접근이 가능 하고, FAT만 문제가 없다면 중간 블록에 문제가 생겨도 FAT를 통해 그 다음 블록은 여전히 읽을 수 있다. 그리고 FAT는 일반적으로 메모리 캐싱을 사용하여 블록 위치를 찾는데는 빠르지만 실제 디스크 헤더가 움직는 것은 블록이 흩어져 있으므로 여전히 느리다고 볼 수 있다. 마지막으로 FAT는 매우 중요한 정보이므로 손실 시 복구를 위해 이중 저장 을 한다. FAT의 각 인덱스 크기는 전체 블록의 개수를 저장할 만큼의 크기를 가지고 있어야 하는데, 현재는 일반적으로 32bit 크기를 사용한다. 이를 FAT32라고 부른다.(이전에는 FAT16, FAT12 등이 있었다.) 색인 할당 (Indexed Allocation) 색인 할당 역시 연결 할당과 같이 데이터를 랜덤한 블록 번호에 할당하지만 할당된 블록 번호(포인터)를 하나의 블록에 따로 저장한다. 이러한 블록을 인덱스 블록 이라고 부르며, 파일 당 하나의 인덱스 블록이 존재한다. 색인 할당은 디렉토리 정보가 다른 할당과 다른데, 시작 블록 번호를 저장하는 것이 아니라 인덱스 블록 번호를 저장한다.   예제block size = 1 byte, f1 = 5 bytes, f2 = 2 bytes file name: f1file size: 5 bytes...-----------------index block number: 11file name: f2file size: 2 bytes...-----------------index block number: 27색인 할당은 인덱스 블록에 할당된 블록을 순서대로 저장하기 때문에 직접 접근이 가능하다. 그리고 연속적으로 할당할 필요가 없으므로 외부 단편화 문제 또한 발생하지 않는다. 색인 할당은 Unix/Linux에서 주로 사용한다. 색인 할당의 단점은 작은 크기의 파일인 경우에도 하나의 블록을 인덱스 블록으로 사용하기 때문에 저장 공간이 손실된다. 그리고 하나의 인덱스 블록을 가지고는 크기가 큰 파일을 저장할 수 없다. 예를 들어, 하나의 블록 크기가 512 bytes인 블록은 최대 저장할 수 있는 블록 인덱스 개수는 512 / 4 bytes(포인터 크기) = 128개이다. 즉 파일의 최대 크기는 128 * 512bytes = 64KB로 아주 작은 크기이다. 블록 크기가 1KB이라 하더라도 최대 인덱스 개수는 256개(1000/4)이고 최대 파일의 크기는 256KB(256*1KB)이다. 이를 해결하기 위한 여러 가지 방법이 있다.   Linked: 이 방식은 인덱스 블록을 여러 개 만들어 연결 할당을 하는 것과 같다. 즉, 각 인덱스 블록의 마지막은 다음 인덱스 블록을 가리키는 포인터가 저장되어 있다.   Multilevel index: 이 방식은 계층을 두는 방법으로 하나의 인덱스 블록의 모든 포인터 가 다른 인덱스 블록을 가리킨다. 만약 이것으로 부족하면 계층을 더 만들어 간다.   Combined: 이 방식은 Linked와 Multilevel index를 합친 방법으로 한 인덱스 블록의 포인터들은 데이터 블록과 또 다른 인덱스 블록 둘 다 가리킬 수 있다.(리눅스는 combined 방식을 사용한다.)","categories": ["Study"],
        "tags": ["Study_OperatingSystem"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-18%EC%9E%A5-%ED%8C%8C%EC%9D%BC-%ED%95%A0%EB%8B%B9/",
        "teaser":null},{
        "title": "[운영체제] # 19 디스크 스케줄 알고리즘(Disk Schedule Algorithm)",
        "excerpt":"디스크 스케줄링 보조기억장치는 현재 여러 가지 존재하지만 아직까지는 하드 디스크가 주로 사용된다.  하드 디스크의 구조는 앞서 살펴봤듯이 위 그림과 같다. 디스크에 접근하는 시간은 Seek time(탐색 시간) + rotational delay + transfer time 으로 계산할 수 있는데, 이 중에서 seek time(head를 움직이는 시간)이 가장 크다. 현재 컴퓨터 환경은 대부분 다중 프로그래밍 환경이다. 그러므로 여러 프로세스가 메인 메모리에서 실행 중에 있는데, 이러한 여러 프로세스가 동시에 디스크를 읽으려는 요청이 올 수 있다. 이와 같은 요청이 오면 디스크 역시 CPU와 같이 디스크 큐(dist queue) 에서 요청을 저장해두고 이를 처리해야 한다. 여기서 컴퓨터의 성능을 위해 여러 요청들을 효율적으로 처리해야 한다. 디스크를 읽는 시간은 매우 오래 걸리는 작업이고 특히 탐색 시간이 오래걸리므로 최대한 이 시간을 줄이는 것이 중요하다. 이러한 방법들을 디스크 스케줄링 알고리즘이라 한다. FCFS(First-Come First-Served) 이 방법은 어느 스케줄링 알고리즘에서도 존재하는 가장 간단하고 가장 공평한 방법이다. 바로 예제를 살펴보자.   예제200 cylinder dist: 0, 1, 2, …, 199Disk queue: 98, 183, 37, 122, 14, 124, 65, 67현재 헤드가 가리키는 실린더(cylinder) 위치: 53 예제를 그림으로 나타내면 위 그림과 같다. 가로축은 0번부터 199번까지 실린더의 위치를 나타낸다. 여기서 파란색 선이 dist queue를 FCFS 방법으로 처리한 결과이다. 헤드가 움직인 총 거리 = (98 - 53) + (183 - 98) + (183 - 37) + (122 - 37) + (122 - 14) + (124 - 14) + (124 - 65) + (67 - 65) = 640 cylinders 위 그림의 결과를 본 것처럼 큐에 들어온 순서가 큰 값, 작은 값이 반복한다면 헤드가 움직이는 거리가 매우 커짐을 알 수 있다. SSTF(Shortest-Seek-Time-First) SSTF 스케줄링 알고리즘은 가장 짧은 탐색 시간을 먼저 선택하는 것이다. 다시 말하면 현재 헤드가 다음 요청을 처리하기 위해 움직여야 하는 거리가 가장 짧은 것을 선택하는 것이다.   예제200 cylinder dist: 0, 1, 2, …, 199Disk queue: 98, 183, 37, 122, 14, 124, 65, 67현재 헤드가 가리키는 실린더(cylinder) 위치: 53 위 예제는 FCFS 스케줄링에서 본 예제와 같은 것이다. 처음 헤드 위치 53을 시작으로 dist queue에 있는 실린더 번호 중 53과 가장 가까운 65번 실린더를 선택한다. 65번에서는 가장 가까운 67번을 선택하고 같은 과정을 반복한다. 헤드가 움직인 총 거리 = (65 - 53) + (67 - 65) + (67 - 37) + (37 - 14) + (98 - 14) + (122 - 98) + (124 - 122) + (183 - 124) = 236 cylinders SSTF 스케줄링 알고리즘의 결과는 위 예제에서 FCFS 스케줄링보다 훨씬 적은 수의 실린더를 움직이는 것을 볼 수 있다. 하지만 SSTF 스케줄링의 큰 단점은 기아(starvation) 가 발생할 수 있다. dist queue에는 지속적으로 새로운 프로세스의 요청이 들어오기 때문에 헤드와 멀리 떨어져 있는 실린더는 끝내 수행하지 못하는 현상이 발생하는데, 이를 starvation이라고 한다. 그리고 SSTF 스케줄링이 현재와 가장 가까운 실린더를 선택한다고 해서 최적의 알고리즘은 아니다. 위 예제에서도 가장 처음 위치인 53번 실린더에서 65번이 아닌 37번으로 이동한 후에 SSTF 알고리즘을 수행하면 208 cylinders 가 나온다. Scan Scan 스케줄링은 말그대로 헤드가 지속적으로 디스크를 앞뒤로 검사하는 것이다. 그래서 헤드가 앞으로 스캔할 때(번호가 작은 실린더 방향)와 뒤로 스캔할 때(번호가 큰 실린더 방향) 선택하는 실린더가 서로 다르다.   예제200 cylinder dist: 0, 1, 2, …, 199Disk queue: 98, 183, 37, 122, 14, 124, 65, 67현재 헤드가 가리키는 실린더(cylinder) 위치: 53스캔 방향: 0번 방향으로 움직임(번호가 작은 실린더 방향)  위 결과에서 볼 수 있듯이 스캔 방향이 0번 실린더 방향이므로 53번에서 작은 번호의 실린더로 향한 후에 큰 번호 실린더로 움직인 것을 볼 수 있다. 헤드가 움직인 총 거리 = (53 - 37) + (37 - 14) + (14 - 0) + (65 - 0) + (67 - 65) + (98 - 67) + (122 - 98) + (124 - 122) + (183 - 124) = 236 cylinders 여기서 한 가지 생각해 볼 점은 일반적으로 프로세스들이 디스크에 요청할 때 그 위치를 종합해보면 실린더에 골고루 퍼져있다. 그러므로 Scan 스케줄링 알고리즘처럼 앞뒤로 움직이는 것이아니라 처음부터 한 방향으로 끝까지 움직이고 다시 처음으로 되돌아가서 같은 방향으로 끝까지 움직이는 것이 더욱 효과적이다.(눈 오는 날 운동장에 눈을 치우는 것을 생각하면 이해하기 쉬울 것이다.) 이러한 아이디어에서 나온 것이 Circular Scan 스케줄링 알고리즘이다. Scan Variants C-Scan 이 방식은 위에서 말한 Circular Scan 스케줄링 알고리즘이다. 즉 한 방향으로 계속 움직이는 것이 마치 원형으로 움직인 것과 같은 모습이다. 움직이는 거리는 더 길어질 수 있지만 다시 처음 위치로 되돌아갈 때는 데이터를 읽지 않으므로 더 빠른 속도로 움직일 수 있다. Look 이 알고리즘은 위 Scan 스케줄링 예제에서 0번 실린더가 존재하지 않지만 0번까지 가는 모습을 보았다. 이러한 비효율적인 움직임을 없애기 위해 존재하는 실린더의 최소와 최대 범위 만 움직이는 알고리즘을 Look 스케줄링 알고리즘이라고 한다. 하지만 이 범위를 알기 위해서 미리 큐를 검사해야한다. C-Look C-Look은 Circular Look 을 말한다. Look은 위에서 Scan 스케줄링이 0번 부터 끝 실린더까지 움직이지 않고 존재하는 실린더의 최소에서 최대 범위를 움직인다고 하였는데, C-Look은 이 범위에서 C-Scan과 같이 한 방향으로만 움직이는 것을 말한다. 즉, 최대 실린더에서 최소 실린더 방향으로 움직인다고 할 때 최소 범위에 도달하면 다시 최대 범위로 되돌아가서 같은 방향으로 움직인다. Elevator Algorithm Elevator Algorithm은 Scan과 파생되어 나온 알고리즘(C-scan, Look, C-Look)을 부르는 다른 용어이다. 위 Scan 스케줄링 알고리즘 예제 그림을 90도로 회전하면 엘리베이터의 모습과 유사하여 붙여진 이름이다. ","categories": ["Study"],
        "tags": ["Study_OperatingSystem"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/OperatingSystem-19%EC%9E%A5-%EB%94%94%EC%8A%A4%ED%81%AC-%EC%8A%A4%EC%BC%80%EC%A4%84-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/",
        "teaser":null},{
        "title": "플로이드(Floyd)의 모든 쌍 최단 거리 알고리즘",
        "excerpt":"플로이드 알고리즘의 특징   모든 쌍의 최단 거리를 구할 수 있다.          알고리즘이 간단하기 때문에, 모든 정점에서 다익스트라나 벨만-포드 알고리즘을 수행하는 것보다 훨씬 효율적이다.        실제 경로를 계산할 수 있다.  가중치없는 그래프에서 각 정점 간의 도달 가능성 여부를 계산할 수 있다.          너비 우선 탐색보다 구현이 간단하여 자주 사용한다.      경유점   두 정점 u, v를 잇는 어떤 경로가 있을 때, 이 경로는 u, v외에도 다른 정점을 경유해서 가는 경로가 더 짧을 수도 있다.  위와 같이 경로가 거쳐가는 정점들을 경유점이라고 한다.   위의 그림에서 볼 수 있듯이, 정점 u에서 v까지 가장 짧은 경로는 u -&gt; a -&gt; b -&gt; v인 것을 볼 수 있다.          여기서 경유점은 정점 a, b이다.        플로이드 알고리즘은 시작 정점과 도착 정점 사이의 모든 경로점을 고려하는 것을 시각적으로 이해하기 쉽고 간단하게 구현된 알고리즘이다.플로이드 알고리즘 최적화 과정 1. 시간 복잡도: O(|V|^3), 공간 복잡도: O(|V|^3)   어떤 정점 집합 S에 포함된 정점만을 경유점으로 사용해 u에서 v로 가는 최단 경로를 계산한다고 가정하자.  어떤 정점 x에 대해 2가지를 생각할 수 있다.          경로가 x를 경유하지 않는다: 이 경로는 S - {x} 에 포함된 정점들만을 경유점으로 사용한다.      경로가 x를 경유한다.: 이 경로는 u에서 x의 구간과 x에서 v로 가는 구간으로 나눌 수 있다. 이 두개의 부분 경로는 각각 최단 경로임이 확실하며 x를 경유하지 않는다. 따라서 위와 같이 S - {x}에 포함된 정점들만을 경유점으로 사용한다.        이를 활용하여, S = { 0, 1, 2, ..., k }라 하고 C_k(u, v)는 정점 0번 부터 k번 정점까지만을 경유점을 썼을 때 u에서 v까지 가는 최단 경로의 길이라고 두면 다음과 같은 재귀적인 식이 만들 수 있다.    C_k(u, v) = min(C_k-1(u, k) + C_k-1(k, v), C_k-1(u, v))        C_k는 C_k-1에만 의존하기 때문에, 동적 계획법으로 구현할 수 있다. (C[k][u][v]배열로 메모이제이션)2. 시간 복잡도: O(|V|^3), 공간 복잡도: O(|V|^2)   1번 알고리즘의 문제는 시간 복잡도보다 공간 복잡도이다.          정점의 개수가 1000개라고 가정하면, 시간은 10초가량 소요되지만, 배열 용량은 4GB가 정도가 필요하다.        공간 복잡도를 줄이기 위해서는 위에서 세운 식의 문제점을 파악하면 쉽게 해결가능하다.          C_k-1(u, k) = 시작점으로부터 k-1번 정점까지를 경유점으로 이용해 u에서 k로 가는 최단 경로의 길이      C_k(u, k) = 시작점으로부터 k번 정점까지를 경유점으로 이용해 u에서 k로 가는 최단 경로의 길이      위의 두 식을 보면, 출발점이나 도착점이 k번 정점일 때, 사용가능한 경유점의 목록에 k가 추가되는 것은 아무런 의미가 없다.      즉, 1번에서 C배열의 k가 전혀 필요하지 않다는 것이다.        구현          별도의 배열 C를 만들지 않고, 인접 행렬adj에 직접 최단 거리를 계산한다.      //정점의 개수int V;//그래프의 인접 행렬 표현//adj[u][v] = u에서 v로 가는 가선의 가중치, 간선이 없으면 아주 큰 값으로 초기화int adj[MAX_V][MAX_V];//플로이드의 모든 쌍 최단 거리 알고리즘void floyd() {\tfor (int i = 0; i &lt; V; ++i) adj[i][i] = 0;\tfor (int k = 0; k &lt; V; ++k)\t\tfor (int i = 0; i &lt; V; ++i)\t\t\tfor (int j = 0; j &lt; V; ++j)\t\t\t\tadj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j]);}3. 시간 복잡도 최적화   플로이드 알고리즘의 3중 for문 중 2번째 for문 바로 다음에 i에서 k로 가는 경로가 실제 있는지를 확인한다.  i에서 k로 가는 경로가 없다면 j에 대한 for문은 수행할 필요가 없다.  이는 실제로 그래프에 간선이 적을수록 효과가 좋으며, 경우에 따라 10% ~ 20% 정도의 수행 시간으르 단축시킬 수 있다.실제 경로 계산하기   플로이드 알고리즘에서 실제 경로를 계산하기 위해서는 adj[u][v]를 갱신했을 때 사용했던 k의 값을 저장해두면 된다.          u에서 v로 가는 최단 거리를 정점 w일 때 갱신되었다면, u에서 w로 가는 최단 거리 경로점을 찾고 w에서 v로 가는 최단 거리를 경로점을 찾아 둘을 합치면 최종적으로 u에서 v로 가는 최단 경로를 찾을 수 있다.        구현//정점의 개수int V;//그래프의 인접 행렬 표현//adj[u][v] = u에서 v로 가는 가선의 가중치, 간선이 없으면 아주 큰 값으로 초기화int adj[MAX_V][MAX_V];//via[u][v] = u에서 v까지 가는 최단 경로가 경유하는 점 중 가장 번호가 큰 정점//-1로 초기화한다.int via[MAX_V][MAX_V];//플로이드의 모든 쌍 최단 거리 알고리즘void floyd() {\tfor (int i = 0; i &lt; V; ++i) adj[i][i] = 0;\t//via배열 초기화\tmemset(via, -1, sizeof(via));\tfor (int k = 0; k &lt; V; ++k)\t\tfor (int i = 0; i &lt; V; ++i)\t\t\tfor (int j = 0; j &lt; V; ++j)\t\t\t\tif (adj[i][j] &gt; adj[i][k] + adj[k][j]) {\t\t\t\t\tvia[i][j] = k;\t\t\t\t\tadj[i][j] = adj[i][k] + adj[k][j];\t\t\t\t}}//u에서 v로 가는 최단 경로를 계산해 path에 저장한다.void reconstruct(int u, int v, vector&lt;int&gt; &amp;path) {\t//기저 사례\tif (via[u][v] == -1) {\t\tpath.push_back(u);\t\tif (u != v) path.push_back(v);\t}\telse {\t\tint w = via[u][v];\t\treconstruct(u, w, path);\t\tpath.pop_back(); //w가 중복으로 들어가므로 지워준다.\t\treconstruct(w, v, path);\t}}도달 가능성 확인하기   C_k(u, v): 0번부터 k번 정점까지를 경유점으로 사용한다.  u에서 v로 가는 경로가 있는지 여부를 나타내는 식은 다음과 같다.    C_k(u, v) = C_k-1(u, v) || (C_k-1(u ,k) &amp;&amp; C_k-1(k, v))      ","categories": ["Algorithm"],
        "tags": ["Algorithm_Algorithm"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/",
        "teaser":null},{
        "title": "[데이터베이스] 트랜잭션(Transaction)",
        "excerpt":"트랜잭션은 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 논리적인 단위 로 일련의 연산들의 집합이다. 예를 들어, 계좌 간의 자금 이체가 있다. 입금 할 때, 데이터베이스 내부의 상대방 계좌 정보를 검색하고 자신과 상대방의 계좌 금액을 변경하는 등 여러 가지 연산이 필요하다. 하지만 이러한 작업의 중간 단계에서 멈추거나 오류가 발생하면 데이터에 매우 큰 영향을 미친다. 그러므로 이러한 작업은 정상적으로 전체 작업이 완료되거나 그럴 수 없는 경우 아무 것도 실행하지 않은 처음 상태로 되돌려져야 한다. 이러한 작업 단위를 트랜잭션이라 하고 이는 사람이 정하는 기준에 따라 달라 질 수 있다. 트랜잭션 특징 트랜잭션의 특징은 4 가지가 있다. 일반적으로 ACID 성질이라고 하며, 다음과 같다.   Atomicity(원자성): 트랜잭션의 모든 연산들이 정상적으로 수행 완료되거나 아니면 어떠한 연산도 수행되지 않은 상태를 보장해야 한다. 입금 과정에서 트랜잭션이 실패하여 어느 한 계좌에만 작업이 적용되거나 하는 경우가 발생하면 안되기 때문에, 실패하면 어느 작업도 적용되지 않고 트랜잭션이 수행되기 전의 상태로 유지되어야 한다.  Consistency(일관성): 트랜잭션의 수행이 데이터베이스의 일관성을 유지해야 한다. 즉, 성공적으로 수행된 트랜잭션은 정당한 데이터들만을 데이터베이스에 반영해야 한다. 트랜잭션이 수행이 보존해야할 일관성은 기본 키, 외래 키 제약과 같은 명시적인 무결성 제약 조건 과 자금 이체에서 두 계좌 간의 잔고 합은 이체 전후가 같아야 한다는 비명시적인 일관성 조건 들도 있다.  Isolation(독립성): 여러 트랜잭션이 동시에 수행되더라도 각각의 트랜잭션은 다른 트랜잭션의 수행에 영향을 받지 않고 독립적으로 수행되어야 한다. 이는 한 트랜잭션의 중간 결과가 다른 트랜잭션에게는 숨겨져야 한다는 의미이며, 이러한 성질이 보장되지 않으면 트랜잭션이 원래 상태로 되돌아갈 수 없게 된다.  Durability(지속성): 트랜잭션이 성공적으로 완료되어 커밋(commit)되고 나면, 해당 트랜잭션에 의한 모든 변경은 향후 어떠한 소프트웨어나 하드웨어 장애가 발생되더라도 보존되어야 한다.","categories": ["Study"],
        "tags": ["Study_Database"],
        "url": "https://codemcd.github.io/pages/CODEMCD/study/Database-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/",
        "teaser":null},{
        "title": "벨만-포드(Bellman-Ford)의 최단 경로 알고리즘",
        "excerpt":"벨만-포드 알고리즘은 다익스트라 알고리즘과 같은 단일 시작점 최단 경로 알고리즘 이지만, 음수 간선 이 있는 그래프에서도 최단 경로를 찾을 수 있다. 그리고 그래프에 음수 사이클이 있어서 최단 경로를 찾을 수 없는 경우에도 이를 알려줄 수 있다.  위 그래프는 다익스트라 알고리즘으로 최단 경로를 찾을 수 없는 경우이다. 정점 b까지 최단 경로는 s-&gt;a-&gt;b로 거리는 7이다. 하지만 다익스트라 알고리즘은 정점 s에서 a, b 정점 중 최소 거리를 선택하여 이를 확정하는데 12보다 10이 작으므로 정점 b로 간다. 따라서, 다익스트라 알고리즘은 정점 b까지 최단 거리를 10으로 확정한다. (다익스트라 알고리즘은 가중치가 모두 음수가 아니라고 가정하므로 음수가 없다면 10으로 가는 것은 당연하다. 거리가 더 큰 쪽으로 가서 다른 정점을 경우한다 해도 모두 양수이므로 거리가 멀어질 수 밖에 없기 때문이다.) 벨만-포드 알고리즘 동작 과정 벨만-포드 알고리즘은 시작점에서 각 정점까지 가는 최단 거리의 상한 을 적당히 예측한 뒤, 예측 값과 계산된 실제 최단 거리 사이의 오차를 반복적으로 줄여가는 방식으로 동작한다. 각 정점까지 최단 거리의 상한을 담는 배열을 upper[] 라고 하자. 시작점 s는 upper[s] = 0 으로 초기화하고, 나머지 정점들은 모두 아주 큰 수로 초기화한다. 최단 거리는 다음과 같은 특성을 가지고 있다. dist[v] &lt;= dist[u] + w(u, v)- dist[v]: 현재 v까지 최단 거리- dist[u]: 현재 u까지 최단 거리- w(u, v): 정점 u에서 정점 v까지 거리이는 시작점에서 정점 v까지 최단 경로는 시작점에서 정점 u까지 최단 경로와 정점 u에서 정점 v까지 거리를 더한 값보다 같거나 작아야 한다. 이를 이용하면 아래와 같은 식이 나온다. upper[v] &gt; upper[u] + w(u, v)시작점에서 정점 u까지 가는 최단 경로는 항상 upper[u]보다 작거나 같다.(upper배열은 상한을 저장하는 배열이기 때문) 여기서 정점 u에서 정점 v까지 가는 최단 경로는 더하면 upper[u] + w(u, v)이며, 이 거리가 upper[v]보다 짧으면 이를 갱신한다. 이러한 과정을 통해 upper[v]를 감소하는 작업을 (u, v)에 따라 완화(relax)한다고 한다. 벨만-포드 알고리즘은 이와 같은 완화 과정을 모든 간선에 대해 반복적으로 수행한다. 음수 사이클이 없는 그래프에서 최단 경로는 한 정점을 두 번 지난 일이 없으므로, V개의 정점 그래프에서 최단 경로를 나타내는 간선의 개수는 V - 1개 이다. 따라서, 모든 간선에 대한 완화 과정은 V - 1번 수행하면 시작점을 제외한 모든 정점까지 최단 경로를 계산할 수 있다. 음수 사이클 판정 음수 사이클이 존재하는 그래프는 최단 거리를 구할 수 없다.(무한히 거리가 작아지기 때문이다.) 그러므로 벨만-포드 알고리즘은 음수 사이클이 존재한다면 의미없는 값을 반환해야 한다. 그러면 음수 사이클이 있는지 어떻게 판단할까? 위에서 완화 과정은 V - 1번 수행하면 모든 최단 경로를 찾을 수 있다고 하였다. 하지만 음수 사이클이 존재한다면 이 이후에도 계속 거리가 줄어들어 완화가 진행될 것이다. 따라서, 벨만-포드 알고리즘은 음수 사이클이 존재하는지 판단하기 위해 총 V번 동안 모든 간선에 대해 완화 과정을 수행한다. 벨만-포드 알고리즘 예제  벨만-포드 알고리즘은 최대 V - 1번 모든 간선에 대해 완화 작업을 수행한다. 위 그래프에서 초기 상태는 다음과 같다.             횟수/정점      1      2      3      4      5                  0      0      INF      INF      INF      INF      첫 번째로 모든 간선에 대해 완화 작업을 수행하면 아래와 같은 결과가 나온다. 아래의 표의 각 행은 upper[] 배열이다.             횟수/정점      1      2      3      4      5                  0      0      INF      INF      INF      INF              1      0      -8      4      5      -2      계산 과정을 살펴보자. 먼저, 시작 정점인 1번 정점과 연결된 모든 간선을 살펴보자. u -&gt; v: upper[v] &gt; upper[u] + w(u, v)  1 -&gt; 3: INF &gt; 0 + 4 =&gt; upper[3] = 4 갱신  1 -&gt; 4: INF &gt; 0 + 10 =&gt; upper[4] = 10 갱신  1 -&gt; 5: INF &gt; 0 + (-2) =&gt; upper[5] = -2 갱신2번 정점과 연결된 간선은 없으므로 넘어가고, 3 ~ 5번 정점과 연결된 모든 간선을 살펴보자.   3 -&gt; 5: -2 &gt; 4 + (-5) =&gt; false이므로 갱신하지 않음  4 -&gt; 2: INF &gt; 10 + (-3) =&gt; upper[2] = 7 갱신  5 -&gt; 2: 7 &gt; (-2) + (-6) =&gt; upper[2] = -8 갱신  5 -&gt; 4: 10 &gt; -2 + 7 =&gt; upper[4] = 5 갱신위 계산 과정이 첫 번째 반복이며, 이를 음수 사이클 확인까지 총 V번 반복한다. 그러면 두 번째 완화 작업 결과를 보자.             횟수/정점      1      2      3      4      5                  0      0      INF      INF      INF      INF              1      0      -8      4      5      -2              2      0      -8      4      5      -2      위를 보면 완화된 정점이 없는 것을 알 수 있다. 따라서, 이후에는 계속 완화가 없을 것이라 예상할 수 있고, 현재 상태가 최단 경로를 모두 구한 상태로 볼 수 있다. 구현 벨만-포드 알고리즘 구현은 음수 사이클을 판단하기 위해 최대 V번 반복하며, 음수 사이클이 있는 경우 빈 upper[] 배열을 반환한다. 그리고 완화 과정 중간에 더 이상 완화된 정점이 없는 경우 모든 최단 경로를 구한 것이므로 바로 반복문을 빠져나간다. // 정점의 개수int V;// 그래프의 인접 리스트, (연결된 정점 번호, 간선 가중치)쌍을 담는다.vector&lt;pair&lt;int, int&gt;&gt; adj[MAX_V];// 음수 사이클이 있을 경우 텅 빈 배열을 반환한다.vector&lt;int&gt; bellmanFord(int src) {\t// 시작점을 제외한 모든 정점까지의 거리 상한을 INF로 초기화한다.\tvector&lt;int&gt; upper(V, INF);\tupper[src] = 0;\tbool updated;\t// V번 순회한다.\tfor (int iter = 0; iter &lt; V; ++iter) {\t\tupdated = false;    // 모든 간선을 살펴본다.\t\tfor (int here = 0; here &lt; V; ++here) {\t\t\tfor (int i = 0; i &lt; adj[here].size(); ++i) {\t\t\t\tint there = adj[here][i].first;\t\t\t\tint cost = adj[here][i].second;\t\t\t\t//(here, there)간선을 따라 완화를 시도한다.\t\t\t\tif (upper[there] &gt; upper[here] + cost) {\t\t\t\t\t//성공\t\t\t\t\tupper[there] = upper[here] + cost;\t\t\t\t\tupdated = true;\t\t\t\t}\t\t\t}\t\t}\t\t// 모든 간선에 대해 완화가 실패했을 경우 V-1번도 수행할 필요 없이 곧장 종료한다.    // 확인 필요(벨만-포드 문제에서 이 부분에서 오류)\t\tif (!updated) break;\t}\t// V번째 순회에서도 완화가 성공했다면 음수 사이클이 있다.\tif (updated) upper.clear();\treturn upper;}시간복잡도 시간복잡도는 간단히 구할 수 있다. 총 V번 완화 과정을 수행하며, 완화 과정은 모든 간선을 살펴본다. 따라서, 시간복잡도는 O(VE) 이다. ","categories": ["Algorithm"],
        "tags": ["Algorithm_Algorithm"],
        "url": "https://codemcd.github.io/pages/CODEMCD/algorithm/Algorithm-%EB%B2%A8%EB%A7%8C-%ED%8F%AC%EB%93%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/",
        "teaser":null}]
