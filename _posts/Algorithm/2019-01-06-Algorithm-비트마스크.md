---
title: "[Algorithm]비트마스크"
excerpt: "비트 연산"
categories:
  - Algorithm
tags:
  - Algorithm_Algorithm
search: true
toc: true
sidebar_main: true
use_math: true
---

비트마스크란 정수의 이진수 표현을 자료 구조로 쓰는 기법을 말한다. 비트마스크는 다음과 같은 특징을 가진다.

- 더 빠른 수행 시간
컴퓨터는 내부적으로 이진수를 사용하기하므로, 이진법 관련 연산들을 매우 빨리 수행할 수 있다. 이를 이용하면 시간복잡도를 O(1) 로 구현할 수 있는 경우가 많다. 물론 비트마스크를 사용할 수 있다는 것은 원소의 수가 많지 않다는 뜻이지만, 이와 같은 연산을 굉장히 여러 번 수행하는 경우에는 큰 속도 향샹을 가져올 수 있다.
- 더 간결한 코드
비트마스크를 사용하면 다양한 집합 연산들을 반복문 없이 한 줄에 쓸 수 있으므로 훨씬 짧은 코드로 작성할 수 있다.
- 더 작은 메모리 사용량
비트마스크를 이용하는 코드들은 같은 데이터를 더 적은 메모리를 사용해 표현할 수 있다. 더 적은 데이터를 사용한다는 것은 더 많은 데이터를 미리 계산해서 저장해 둘 수 있다는 뜻이고, 이는 프로그램 속도 향샹과 캐시 효율을 높일 수 있다.
- 연관 배열을 배열로 대체
boolean 을 키로 갖는 연관 배열 객체 ```map<vector<bool>, int>``` 를 사용하고 있다고 하자. 이 경우에 비트마스크를 사용하여 같은 정보를 정수 변수로 나타내면 단순하게 ```int[]``` 배열로 표현할 수 있다. 많은 경우 이 기법은 시간과 메모리에서 큰 차이를 불러옵니다.

## 비트 연산자
비트 연산자는 정수 변수를 비트별로 조작할 수 있는 연산자입니다.

### AND, OR, XOR
비트별 AND, OR, XOR 연산의 결과는 아래의 표와 같다. 그리고 괄호안은 C++ 기준 표현 방식이다.

| bit 1 | bit 2 | AND(&) | OR(|) | XOR(^) |
|:-----:|:-----:|:------:|:-----:|:------:|
| 0 | 0 | 0 | 0 | 0 |
| 1 | 0 | 0 | 1 | 1 |
| 0 | 1 | 0 | 1 | 1 |
| 1 | 1 | 1 | 1 | 0 |

- 예제

![and_or_xor](https://user-images.githubusercontent.com/34755287/50885283-98706800-1430-11e9-9084-d7926d174b0f.JPG)

### NOT
비트별 NOT 연산은 켜져 있는 비트는 끄고, 꺼져 있는 비트는 켠 결과를 반환한다. C++ 기준 정수 a의 비트별 NOT 연산을 수행하려면 ```~a``` 로 표현한다.

- 예제

![not](https://user-images.githubusercontent.com/34755287/50885284-9908fe80-1430-11e9-9f17-dfe129362777.JPG)

### shift
시프트(shift) 연산자는 정수 a 의 비트들을 왼쪽 또는 오른쪽으로 원하는 만큼 움직인다. C++ 기준 정수 a 를 왼쪽으로 b 비트 시프트 수행은 ```a << b```이고, 오른쪽으로 b 비트 시프트 수행은 ```a >> b``` 로 표현한다.

- 예제

![shift](https://user-images.githubusercontent.com/34755287/50885285-9908fe80-1430-11e9-9577-f03d826eb059.JPG)

## 유의할 점
1. 비트 연산자 우선순위
C++ 이나 Java 에서는 &, |, ^ 등의 비트 연산자의 우선순위는 ==, != 등의 비교 연산자의 우선순위보다 낮다. 즉 아래와 같은 코드는 원하지 않는 결과가 나온다.

```cpp
int c = (6 & 4 == 4);
```
이러한 실수를 줄이기 위해서는 비트 연산자를 사용할 때는 반드시 괄호를 추가하는 습관을 들이는 것이 좋다.

2. 오버플로
64비트 정수를 비트마스크로 사용할 때 아래의 코드는 문제가 발생할 확률이 높다.

```cpp
bool isBitSet(unsigned long long a, int b) {
  return (a & (1 << b)) > 0;
}
```

위의 코드는 부호 없는 64비트 비트마스크 a 의  b 번 비트가 켜져 있는지 확인하는 코드이다. 여기서 문제점은 1 이라는 수이다. C++ 에서 1 은 기본적으로 부호 있는 32비트 상수이다. 만약 b 가 32 이상이면 오버플로가 발생한다. 이를 해결하기 위해서는 1 앞에 ```ull``` 을 붙여 64비트 정수로 형변환을 해야 한다.

3. 부호
부호 있는 정수형에서 최상위 비트는 부호를 나타낸다. 최상위 비트가 켜져있으면 음수를 표현하는 것이다. 이와 같이 부호가 있는 32비트 정수형에서 모든 비트를 사용한다면 자잘한 버그가 난다. 만약 해당 비트를 모두 사용하고 싶은 경우에는 부호가 없는 정수형을 써야한다.

## 비트마스크를 이용한 집합 구현
비트마스크의 가장 중요한 사용 사례는 집합을 구현하는 것이다. 이 표현에서 N 비트 정수 변수는 0 부터  N - 1 까지의 정수 원소를 가질 수 있는 집합이 된다. 이때 원소 i 가 집합에 속해 있는지 여부는 $2^i$ 을 나타내는 비트가 켜져있는지를 확인해야한다. 예를 들어 여섯 개의 원소를 갖는 집합 {1, 4, 5, 6, 7, 9} 를 표현하는 정수는 754 이다.

$$2^1 + 2^4 + 2^5 + 2^6 + 2^7 + 2^9 = 10 1111 0010_2 = 754$$

### 피자집 예제
고객들이 원하는 토핑을 골라 주문할 수 있는 피자집의 주문 시스템을 만들다고 하자. 이 피자집에는 0 부터 19 까지의 번호를 갖는 20 가지의 토핑이 있고, 주문시 토핑을 넣기/넣지 않기를 선택할 수 있다. 그러면 한 피자의 정보는 20 종류의 원소만을 가지는 집합이 되고, 비트마스크를 이용해 표현할 수 있다.(물론, 크기 20 의 불린 값 배열을 사용할 수도 있다.)

- 공집합과 꽉 찬 집합 구하기
공집합은 간단히 상수 0 으로 나타낼 수 있다. 꽉 찬 집합은 아래의 코드와 같이 표현한다.

```cpp
int fullPizza = (1 << 20) - 1;
// (1 << 20) = 000100000000000000000000
// (1 << 20) - 1 = 000011111111111111111111
```

- 원소 추가
집합의 가장 기초적인 연산은 원소를 추가하고 삭제하는 것이다. 비트마스크를 사용하는 집합에서 원소를 추가한다는 것은 해당 비트를 켠다는 것이다. 토핑 p 를 집합에 추가하는 코드는 아래와 같다.

```cpp
toppings |= (1 << p);
```

- 원소의 포함 여부 확인
집합 toppings에 토핑 p 가 추가되었는지 확인하는 코드는 아래와 같다.

```cpp
if (toppings & (1 << p)) cout << "topping p is in" << endl;
```

주의할 점은 & 연산의 결과값은 0 또는 (1 << p) 이다. 대부분의 논리 연산처럼 0(false) 혹은 1(true) 값이 반환된다고 생각하면 안된다. 예를 들어 p = 3 인 경우에서, p 가 토핑에 들어있다면 위의 조건문은 8 을 반환하고, 들어있지 않다면 0 을 반환한다.

- 원소 삭제
토핑 p 를 삭제하는 경우에는 간단하게 아래의 코드를 생각할 수 있다.

```cpp
toppings -= (1 << p);
```

하지만 위 코드는 토핑 p 가 반드시 toppings 집합에 포함되어 있어야 한다는 조건이 있다. 그러므로, 원소가 포함되어 있는지 여부와 상광없이 정상적으로 삭제하고 싶다면 다음 코드를 사용할 수 있다.

```cpp
toppings &= ~(1 << p);
```

- 원소 토글(toggle)
원소 토글은 해당 비트가 켜져 있으면 끄고, 꺼져 있으면 켜는 동작을 수행한다. 이것은 간단히 XOR 연산을 사용할 수 있다.

```cpp
toppings ^= (1 << p);
```

- 두 집합에 대해 연산하기
두 개의 토핑 집합 a 와 b 의 집합 연산은 다음과 같이 구할 수 있다.

```cpp
int added = (a | b);           // a 와 b 의 합집합
int intersection = (a & b);    // a 와 b 의 교집합
int removed = (a & ~b);        // a 에서 b 를 뺀 차집합   
int toggled = (a ^ b);         // a 와 b 중 하나에만 포함된 원소들의 집합
```

이 코드의 수행 시간은 원소 하나에 대해 수행하는 것과 같다.

- 집합의 크기 구하기
비트마스크를 사용할 때 집합에 포함된 원소의 수를 구하는 간단한 방법은 딱히 없다. 따라서 각 비트를 순회하면서 켜져 있는 비트의 수를 직접 세어야 한다.

```cpp
int bitCount (int x) {
  if (x == 0) return 0;
  return x % 2 + bitCount(x / 2);
}
```

이 외에도 여러 프로그래밍 환경에서 위의 동작을 수행하는 내장 명령어를 제공한다. 다음은 32비트 부호 없는 정수 toppings 에 켜진 비트의 수를 구하는 명령어들이다.

| gcc/g++ | __builtin_popcount(toppings) |
|:----------:|:----------------------------:|
| Visual C++ | __popcnt(toppings) |
| Java | Integer.bitCount(toppings) |

이 명령어들은 다양한 최적화를 통해 매우 빠르게 동작한다.

- 최소 원소 찾기
최소 원소는 최하위 비트에서 시작하여 가장 처음 켜져 있는 비트를 말한다. 즉, 최소 원소부터 최하위 비트까지 0 의 개수를 통해 해당 최소 원소의 번호를 반환한다. 이 동작 역시 내장 명령어로 제공한다. 다음은 32비트 부호없는 정수 toppings에서 켜져 있는 최하위 비트의 위치를 구하는 명령어이다.

| gcc/g++ | __builtin_ctz(toppings) |
|:----------:|:---------------------------------------:|
| Visual C++ | _BitScanForward(&index, toppings) |
| Java | Integer.numberOfTrailingZeros(toppings) |

이 연산들 역시 매우 빠르게 동작한다. 그리고 g++ 의 내장 함수인 ```__buitin_ctz()``` 는 입력으로 0 이 주어졌을 때의 결과가 정의되어 있지 않기 때문에 주의해야 한다.

최하위 비트의 번호 대신 해당 비트를 직접 구할 수도 있다. 예를 들어 40이 주어질 경우 3 대신 &2^3$ 을 구하고 싶은 것이다.

```cpp
int firstTopping = (toppings & -toppings);
```

이는 컴퓨터가 음수를 표현하는 2의 보수를 사용한다. 2의 보수를 사용하는 시스템에서는 음수 -toppings 를 표현하기 위해 toppings 에 비트별 NOT 연산을 적용하고 그 결과에 1을 더한다. 예를 들어 toppings 의 값이 160 이라고 하자. 그러면 아래와 같은 계산 과정을 가진다.

```
       toppings      = 1010 0000
      -toppings      = 0110 0000
toppings & -toppings = 0010 0000
```

- 최소 원소 지우기
최소 원소를 구하지 않고도 최소 원소를 지울 수도 있다.

```cpp
toppings &= (toppings - 1);
```

이는 toppings - 1 의 이진수 표현을 생각해보면 쉽게 알 수 있다. toppings - 1 의 이진수 표현은 toppings 의 켜져 있는 최하위 비트를 끄고 그 밑의 비트들을 전부 켠 것이다. 예를 들어 위와 같이 toppings 값이 160 이라고 하자.

```
       toppings           = 1010 0000
       toppings - 1       = 1001 1111
toppings & (toppings - 1) = 1000 0000
```

이 방법은 어떤 정수가 2의 거듭제곱 값인지 확인할 때도 유용하다. 2의 거듭제곱 갑들은 이진수 표현에서 켜진 비트가 1개 밖에 없으므로, 위 코드의 결과값은 0이 된다.

- 모든 부분 집합 순회하기
비트마스크를 사용하면 for 문 하나로 간단히 모든 부분 집합을 순회할 수 있다. 예를 들어 pizza 가 {a, b, c} 라면 {a}, {b}, {c}, {a, b}, {a, c}, {b, c}, {a, b, c} 가 나온다. 이의 코드는 다음과 같다.

```cpp
for (int subset = pizza; subset; subset = ((subset - 1) & pizza)) {
  //subset 은 pizza 의 부분집합
}
```

이 for 문은 subset = 0 인 시점에서 종료하므로, 공집합은 방문하지 않는다는 것에 주의해야 한다.


## 참고문헌
- 프로그래밍 대회에서 배우는 알고리즘 문제해결전략, 인사이트, 구종만 지음
