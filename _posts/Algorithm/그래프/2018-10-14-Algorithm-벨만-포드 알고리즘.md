---
title: "벨만-포드(Bellman-Ford)의 최단 경로 알고리즘"
excerpt: "최신 업데이트 날짜: 2019-05-06"
date: 2019-05-06 10:36:00
categories:
  - Algorithm
tags:
  - Algorithm_Algorithm
search: true
toc: true
sidebar_main: true
---

벨만-포드 알고리즘은 다익스트라 알고리즘과 같은 **단일 시작점 최단 경로 알고리즘** 이지만, **음수 간선** 이 있는 그래프에서도 최단 경로를 찾을 수 있다. 그리고 그래프에 음수 사이클이 있어서 최단 경로를 찾을 수 없는 경우에도 이를 알려줄 수 있다.

<그림>

위 그래프는 다익스트라 알고리즘으로 최단 경로를 찾을 수 없는 경우이다. 정점 b까지 최단 경로는 s->a->b로 거리는 7이다. 하지만 다익스트라 알고리즘은 정점 s에서 a, b 정점 중 최소 거리를 선택하여 이를 확정하는데 12보다 10이 작으므로 정점 b로 간다. 따라서, 다익스트라 알고리즘은 정점 b까지 최단 거리를 10으로 확정한다. (다익스트라 알고리즘은 가중치가 모두 음수가 아니라고 가정하므로 음수가 없다면 10으로 가는 것은 당연하다. 거리가 더 큰 쪽으로 가서 다른 정점을 경우한다 해도 모두 양수이므로 거리가 멀어질 수 밖에 없기 때문이다.)

## 벨만-포드 알고리즘 동작 과정
벨만-포드 알고리즘은 시작점에서 각 정점까지 가는 최단 거리의 **상한** 을 적당히 예측한 뒤, 예측 값과 계산된 실제 최단 거리 사이의 오차를 반복적으로 줄여가는 방식으로 동작한다.

각 정점까지 최단 거리의 상한을 담는 배열을 ```upper[]``` 라고 하자. 시작점 s는 ```upper[s] = 0``` 으로 초기화하고, 나머지 정점들은 모두 아주 큰 수로 초기화한다. 최단 거리는 다음과 같은 특성을 가지고 있다.
```
dist[v] <= dist[u] + w(u, v)
- dist[v]: 현재 v까지 최단 거리
- dist[u]: 현재 u까지 최단 거리
- w(u, v): 정점 u에서 정점 v까지 거리
```
이는 시작점에서 정점 v까지 최단 경로는 시작점에서 정점 u까지 최단 경로와 정점 u에서 정점 v까지 거리를 더한 값보다 같거나 작아야 한다. 이를 이용하면 아래와 같은 식이 나온다.
```
upper[v] > upper[u] + w(u, v)
```
시작점에서 정점 u까지 가는 최단 경로는 항상 upper[u]보다 작거나 같다.(upper배열은 상한을 저장하는 배열이기 때문) 여기서 정점 u에서 정점 v까지 가는 최단 경로는 더하면 upper[u] + w(u, v)이며, **이 거리가 upper[v]보다 짧으면 이를 갱신한다.** 이러한 과정을 통해 upper[v]를 감소하는 작업을 **(u, v)에 따라 완화(relax)한다고** 한다.

벨만-포드 알고리즘은 이와 같은 완화 과정을 모든 간선에 대해 반복적으로 수행한다. 음수 사이클이 없는 그래프에서 최단 경로는 한 정점을 두 번 지난 일이 없으므로, V개의 정점 그래프에서 최단 경로를 나타내는 간선의 개수는 **V - 1개** 이다. 따라서, 모든 간선에 대한 완화 과정은 V - 1번 수행하면 시작점을 제외한 모든 정점까지 최단 경로를 계산할 수 있다.

### 음수 사이클 판정
음수 사이클이 존재하는 그래프는 최단 거리를 구할 수 없다.(무한히 거리가 작아지기 때문이다.) 그러므로 벨만-포드 알고리즘은 음수 사이클이 존재한다면 의미없는 값을 반환해야 한다. 그러면 음수 사이클이 있는지 어떻게 판단할까? 위에서 완화 과정은 V - 1번 수행하면 모든 최단 경로를 찾을 수 있다고 하였다. 하지만 **음수 사이클이 존재한다면 이 이후에도 계속 거리가 줄어들어 완화가 진행될 것이다.** 따라서, 벨만-포드 알고리즘은 음수 사이클이 존재하는지 판단하기 위해 총 **V번** 동안 모든 간선에 대해 완화 과정을 수행한다.

## 벨만-포드 알고리즘 예제

<그림>

벨만-포드 알고리즘은 최대 V - 1번 모든 간선에 대해 완화 작업을 수행한다. 위 그래프에서 초기 상태는 다음과 같다.

| 횟수/정점 | 1 | 2 | 3 | 4 | 5 |
|:---------:|:-:|:---:|:---:|:---:|:---:|
| 0 | 0 | INF | INF | INF | INF |

첫 번째로 모든 간선에 대해 완화 작업을 수행하면 아래와 같은 결과가 나온다. 아래의 표의 각 행은 ```upper[]``` 배열이다.

| 횟수/정점 | 1 | 2 | 3 | 4 | 5 |
|:---------:|:-:|:---:|:---:|:---:|:---:|
| 0 | 0 | INF | INF | INF | INF |
| 1 | 0 | -8 | 4 | 5 | -2 |

계산 과정을 살펴보자. 먼저, 시작 정점인 1번 정점과 연결된 모든 간선을 살펴보자.
```
u -> v: upper[v] > upper[u] + w(u, v)
```
- **1 -> 3**: ```INF > 0 + 4``` => upper[3] = 4 갱신
- **1 -> 4**: ```INF > 0 + 10``` => upper[4] = 10 갱신
- **1 -> 5**: ```INF > 0 + (-2)``` => upper[5] = -2 갱신

2번 정점과 연결된 간선은 없으므로 넘어가고, 3 ~ 5번 정점과 연결된 모든 간선을 살펴보자.
- **3 -> 5**: ```-2 > 4 + (-5)``` => false이므로 갱신하지 않음
- **4 -> 2**: ```INF > 10 + (-3)``` => upper[2] = 7 갱신
- **5 -> 2**: ```7 > (-2) + (-6)``` => upper[2] = -8 갱신
- **5 -> 4**: ```10 > -2 + 7``` => upper[4] = 5 갱신

위 계산 과정이 첫 번째 반복이며, 이를 음수 사이클 확인까지 총 V번 반복한다. 그러면 두 번째 완화 작업 결과를 보자.

| 횟수/정점 | 1 | 2 | 3 | 4 | 5 |
|:---------:|:-:|:---:|:---:|:---:|:---:|
| 0 | 0 | INF | INF | INF | INF |
| 1 | 0 | -8 | 4 | 5 | -2 |
| 2 | 0 | -8 | 4 | 5 | -2 |

위를 보면 완화된 정점이 없는 것을 알 수 있다. 따라서, 이후에는 계속 완화가 없을 것이라 예상할 수 있고, 현재 상태가 최단 경로를 모두 구한 상태로 볼 수 있다.

## 구현
벨만-포드 알고리즘 구현은 음수 사이클을 판단하기 위해 최대 V번 반복하며, 음수 사이클이 있는 경우 빈 upper[] 배열을 반환한다. 그리고 완화 과정 중간에 더 이상 완화된 정점이 없는 경우 모든 최단 경로를 구한 것이므로 바로 반복문을 빠져나간다.

```cpp
// 정점의 개수
int V;
// 그래프의 인접 리스트, (연결된 정점 번호, 간선 가중치)쌍을 담는다.
vector<pair<int, int>> adj[MAX_V];
// 음수 사이클이 있을 경우 텅 빈 배열을 반환한다.
vector<int> bellmanFord(int src) {
	// 시작점을 제외한 모든 정점까지의 거리 상한을 INF로 초기화한다.
	vector<int> upper(V, INF);
	upper[src] = 0;
	bool updated;
	// V번 순회한다.
	for (int iter = 0; iter < V; ++iter) {
		updated = false;
    // 모든 간선을 살펴본다.
		for (int here = 0; here < V; ++here) {
			for (int i = 0; i < adj[here].size(); ++i) {
				int there = adj[here][i].first;
				int cost = adj[here][i].second;
				//(here, there)간선을 따라 완화를 시도한다.
				if (upper[there] > upper[here] + cost) {
					//성공
					upper[there] = upper[here] + cost;
					updated = true;
				}
			}
		}
		// 모든 간선에 대해 완화가 실패했을 경우 V-1번도 수행할 필요 없이 곧장 종료한다.
    // 확인 필요(벨만-포드 문제에서 이 부분에서 오류)
		if (!updated) break;
	}
	// V번째 순회에서도 완화가 성공했다면 음수 사이클이 있다.
	if (updated) upper.clear();
	return upper;
}
```

### 시간복잡도
시간복잡도는 간단히 구할 수 있다. 총 V번 완화 과정을 수행하며, 완화 과정은 모든 간선을 살펴본다. 따라서, 시간복잡도는 **O(VE)** 이다.
