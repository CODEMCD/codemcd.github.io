---
title: "[Algorithm]벨만-포드 알고리즘"
excerpt: "최단 경로 알고리즘"
search: true
categories:
  - Algorithm
tags:
  - Algorithm_Algorithm
toc: true
sidebar_main: true
---

# 벨만-포드(Bellman-Ford)의 최단 경로 알고리즘
- 다익스트라 알고리즘과 똑같은 단일 시작점 최단 경로 알고리즘이지만, 음수 간선이 있는 그래프에서도 최단 경로를 찾을 수 있다.
- 그래프에서 음수 사이클이 있어서 최단 경로를 찾을 수 없는 경우에도 이를 알려줄 수 있다.

## 벨만-포드의 동작 과정
- 벨만-포드 알고리즘은 시작점에서 각 정점까지 가는 최단 거리의 상한을 적당히 예측한 뒤, 예측 값과 실제 최단 거리 사이의 오차를 반복적으로 줄여가는 방식으로 동작한다.
- ```upper[]```: 각 정점까지의 최단 거리의 상한을 담은 배열
- 시작점 s의 ```upper[s] = 0```으로 초기화하고, 나머지 원소들은 모두 아주 큰 수로 초기화 한다.
- 이 배열의 예측 값을 실체 최단 거리에 더 가깝게 갱신하기 위해 다음과 같은 최단 거리의 특성을 이용한다.
  - ```dist[v] <= dist[u] + w(u, v)```
- 위 속성을 이용하여 ```upper[u] + w(u, v) < upper[v]```인 상황을 예를 들어 보자.
  - u까지 가는 최단 거리는 항상 ```upper[u]```이거나 그보다 짧다.
  - 그 뒤에 (u, v)를 붙인 경로의 길이는 최대 ```upper[u] + w(u, v)```이다.
  - 따라서, ```upper[v]```를 ```upper[u] + w(u, v)```로 줄일 수 있다.
  - 위 과정을 통해 ```upper[v]```를 감소하는 작업을 (u, v)를 따라 완화(relax)한다고 한다.
- 벨만-포드 알고리즘은 위와 같은 완화 과정을 모든 간선에 대해 반복적으로 실시한다.
  - 음수 사이클이 없는 그래프에서 최단 경로가 한 정점을 두 번 지나는 일이 없으므로, V개의 정점 그래프에서 최단 경로를 나타내는 간선의 개수는 |V| - 1개 이다.
  - 따라서, 모든 간선에 대한 완화 과정은 전체 |V| - 1번 수행하면 된다는 것을 알 수 있다.
  - 음수 사이클만 없다면 음수 간선이 있더라도, 최단 경로를 찾을 수 있다.

## 음수 사이클 판정
- 음수 사이클이 존재하는 그래프에서는 최단 거리를 구할 수 없으므로, 벨만-포드 알고리즘 역시 의미없는 값을 반환한다.
- 위에서 말했듯이, 벨만-포드의 동작은 음수 사이클이 없는 그래프에서 |V| - 1번만 수행하면 되며 그 이후의 완화는 모두 실패한다.
- 하지만, 음수 사이클이 있는 그래프에서는 |V| - 1번의 수행 이후에도 완화가 계속 성공적으로 이루어 진다.
  - 음수 사이클을 지날 때는 계속해서 거리 값이 작아지므로, 이를 쉽게 알 수 있다.
- 결과적으로 음수 사이클을 판정하기 위해서는 |V|번 동작에서 완화가 성공하는지, 실패하는지로 알 수 있다.

## 구현
- 해당 구현에서 벨만=포드 알고리즘은 |V|번 반복하며, 마지막 |V|번째의 완화가 성공하면 음수 사이클이 있는 것으로 판단하고 빈 배열을 반환한다.
- 시간 복잡도
  - |V|번 반복과 모든 간선 순회하므로 ```O(|E|)```이다.
  - 따라서, 전체 시간 복잡도는 ```O(|V||E|)```가 된다.

```cpp
//정점의 개수
int V;
//그래프의 인접 리스트, (연결된 정점 번호, 간선 가중치)쌍을 담는다.
vector<pair<int, int>> adj[MAX_V];
//음수 사이클이 있을 경우 텅 빈 배열을 반환한다.
vector<int> bellmanFord(int src) {
	//시작점을 제외한 모든 정점까지의 거리 상한을 INF로 초기화한다.
	vector<int> upper(V, INF);
	upper[src] = 0;
	bool updated;
	//V번 순회한다.
	for (int iter = 0; iter < V; ++iter) {
		updated = false;
		for (int here = 0; here < V; ++here) {
			for (int i = 0; i < adj[here].size(); ++i) {
				int there = adj[here][i].first;
				int cost = adj[here][i].second;
				//(here, there)간선을 따라 완화를 시도한다.
				if (upper[there] > upper[here] + cost) {
					//성공
					upper[there] = upper[here] + cost;
					updated = true;
				}
			}
		}
		//모든 간선에 대해 완화가 실패했을 경우 V-1번도 수행할 필요 없이 곧장 종료한다.
		if (!updated) break;
	}
	//V번째 순회에서도 완화가 성공했다면 음수 사이클이 있다.
	if (updated) upper.clear();
	return upper;
}
```
