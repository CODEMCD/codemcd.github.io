---
title: "[Algorithm]플로이드 알고리즘"
excerpt: "최단 경로 알고리즘"
search: true
categories:
  - Algorithm
tags:
  - Algorithm_Algorithm
toc: true
sidebar_main: true
---

# 플로이드(Floyd)의 모든 쌍 최단 거리 알고리즘

## 플로이드 알고리즘의 특징
- 모든 쌍의 최단 거리를 구할 수 있다.
  - 알고리즘이 간단하기 때문에, 모든 정점에서 다익스트라나 벨만-포드 알고리즘을 수행하는 것보다 훨씬 효율적이다.
- 실제 경로를 계산할 수 있다.
- 가중치없는 그래프에서 각 정점 간의 도달 가능성 여부를 계산할 수 있다.
  - 너비 우선 탐색보다 구현이 간단하여 자주 사용한다.

## 경유점
- 두 정점 u, v를 잇는 어떤 경로가 있을 때, 이 경로는 u, v외에도 다른 정점을 경유해서 가는 경로가 더 짧을 수도 있다.
- 위와 같이 경로가 거쳐가는 정점들을 경유점이라고 한다.

![floyd1](https://user-images.githubusercontent.com/34755287/46916177-ef150400-cff1-11e8-90e1-9f75b37313ec.JPG)

- 위의 그림에서 볼 수 있듯이, 정점 u에서 v까지 가장 짧은 경로는 ```u -> a -> b -> v```인 것을 볼 수 있다.
  - 여기서 경유점은 정점 a, b이다.
- 플로이드 알고리즘은 시작 정점과 도착 정점 사이의 모든 경로점을 고려하는 것을 시각적으로 이해하기 쉽고 간단하게 구현된 알고리즘이다.

## 플로이드 알고리즘 최적화 과정
### 1. 시간 복잡도: ```O(|V|^3)```, 공간 복잡도: ```O(|V|^3)```
- 어떤 정점 집합 S에 포함된 정점만을 경유점으로 사용해 u에서 v로 가는 최단 경로를 계산한다고 가정하자.
- 어떤 정점 x에 대해 2가지를 생각할 수 있다.
  - 경로가 x를 경유하지 않는다: 이 경로는 S - {x} 에 포함된 정점들만을 경유점으로 사용한다.
  - 경로가 x를 경유한다.: 이 경로는 u에서 x의 구간과 x에서 v로 가는 구간으로 나눌 수 있다. 이 두개의 부분 경로는 각각 최단 경로임이 확실하며 x를 경유하지 않는다. 따라서 위와 같이 S - {x}에 포함된 정점들만을 경유점으로 사용한다.
- 이를 활용하여, ```S = { 0, 1, 2, ..., k }```라 하고 ```C_k(u, v)```는 정점 0번 부터 k번 정점까지만을 경유점을 썼을 때 u에서 v까지 가는 최단 경로의 길이라고 두면 다음과 같은 재귀적인 식이 만들 수 있다.
```
C_k(u, v) = min(C_k-1(u, k) + C_k-1(k, v), C_k-1(u, v))
```
- C_k는 C_k-1에만 의존하기 때문에, 동적 계획법으로 구현할 수 있다. (```C[k][u][v]```배열로 메모이제이션)

### 2. 시간 복잡도: ```O(|V|^3)```, 공간 복잡도: ```O(|V|^2)```
- 1번 알고리즘의 문제는 시간 복잡도보다 공간 복잡도이다.
  - 정점의 개수가 1000개라고 가정하면, 시간은 10초가량 소요되지만, 배열 용량은 4GB가 정도가 필요하다.
- 공간 복잡도를 줄이기 위해서는 위에서 세운 식의 문제점을 파악하면 쉽게 해결가능하다.
  - ```C_k-1(u, k)``` = 시작점으로부터 k-1번 정점까지를 경유점으로 이용해 u에서 k로 가는 최단 경로의 길이
  - ```C_k(u, k)``` = 시작점으로부터 k번 정점까지를 경유점으로 이용해 u에서 k로 가는 최단 경로의 길이
  - 위의 두 식을 보면, 출발점이나 도착점이 k번 정점일 때, 사용가능한 경유점의 목록에 k가 추가되는 것은 아무런 의미가 없다.
  - 즉, 1번에서 C배열의 k가 전혀 필요하지 않다는 것이다.
- 구현
  - 별도의 배열 C를 만들지 않고, 인접 행렬adj에 직접 최단 거리를 계산한다.

```cpp
//정점의 개수
int V;
//그래프의 인접 행렬 표현
//adj[u][v] = u에서 v로 가는 가선의 가중치, 간선이 없으면 아주 큰 값으로 초기화
int adj[MAX_V][MAX_V];
//플로이드의 모든 쌍 최단 거리 알고리즘
void floyd() {
	for (int i = 0; i < V; ++i) adj[i][i] = 0;

	for (int k = 0; k < V; ++k)
		for (int i = 0; i < V; ++i)
			for (int j = 0; j < V; ++j)
				adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j]);
}
```

### 3. 시간 복잡도 최적화
- 플로이드 알고리즘의 3중 for문 중 2번째 for문 바로 다음에 i에서 k로 가는 경로가 실제 있는지를 확인한다.
- i에서 k로 가는 경로가 없다면 j에 대한 for문은 수행할 필요가 없다.
- 이는 실제로 그래프에 간선이 적을수록 효과가 좋으며, 경우에 따라 10% ~ 20% 정도의 수행 시간으르 단축시킬 수 있다.

## 실제 경로 계산하기
- 플로이드 알고리즘에서 실제 경로를 계산하기 위해서는 ```adj[u][v]```를 갱신했을 때 사용했던 k의 값을 저장해두면 된다.
  - u에서 v로 가는 최단 거리를 정점 w일 때 갱신되었다면, u에서 w로 가는 최단 거리 경로점을 찾고 w에서 v로 가는 최단 거리를 경로점을 찾아 둘을 합치면 최종적으로 u에서 v로 가는 최단 경로를 찾을 수 있다.
- 구현

```cpp
//정점의 개수
int V;
//그래프의 인접 행렬 표현
//adj[u][v] = u에서 v로 가는 가선의 가중치, 간선이 없으면 아주 큰 값으로 초기화
int adj[MAX_V][MAX_V];
//via[u][v] = u에서 v까지 가는 최단 경로가 경유하는 점 중 가장 번호가 큰 정점
//-1로 초기화한다.
int via[MAX_V][MAX_V];
//플로이드의 모든 쌍 최단 거리 알고리즘
void floyd() {
	for (int i = 0; i < V; ++i) adj[i][i] = 0;
	//via배열 초기화
	memset(via, -1, sizeof(via));
	for (int k = 0; k < V; ++k)
		for (int i = 0; i < V; ++i)
			for (int j = 0; j < V; ++j)
				if (adj[i][j] > adj[i][k] + adj[k][j]) {
					via[i][j] = k;
					adj[i][j] = adj[i][k] + adj[k][j];
				}
}

//u에서 v로 가는 최단 경로를 계산해 path에 저장한다.
void reconstruct(int u, int v, vector<int> &path) {
	//기저 사례
	if (via[u][v] == -1) {
		path.push_back(u);
		if (u != v) path.push_back(v);
	}
	else {
		int w = via[u][v];
		reconstruct(u, w, path);
		path.pop_back(); //w가 중복으로 들어가므로 지워준다.
		reconstruct(w, v, path);
	}
}
```

## 도달 가능성 확인하기
- ```C_k(u, v)```: 0번부터 k번 정점까지를 경유점으로 사용한다.
- u에서 v로 가는 경로가 있는지 여부를 나타내는 식은 다음과 같다.
```
C_k(u, v) = C_k-1(u, v) || (C_k-1(u ,k) && C_k-1(k, v))
```
