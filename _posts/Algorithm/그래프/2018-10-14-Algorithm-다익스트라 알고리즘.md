---
title: "다익스트라(Dijkstra) 알고리즘"
excerpt: "최신 업데이트 날짜: 2019-05-03"
date: 2019-05-03 12:06:00
categories:
  - Algorithm
tags:
  - Algorithm_Algorithm
search: true
toc: true
sidebar_main: true
---

다익스트라 알고리즘은 **단일 시작점 최단 경로 알고리즘** 으로, 시작 정점 s에서부터 다른 정점들까지의 최단 거리를 계산한다. 하지만 이 알고리즘은 음수 간선이 있는 그래프(특히, 음수 사이클)에 대해서는 최단거리를 계산하지 못한다. 만약 음수 간선이 사이클을 이루지 않는다면, 계산을 할 수 있는 경우가 있지만 시간복잡도는 지수적으로 증가한다.
>> 이에 대한 부분은 https://www.acmicpc.net/board/view/19865 이 링크에서 자세하게 토론을 하고 있다. 한 번 읽어보면 좋을 듯 하다.

## 기본적인 다익스트라 알고리즘
다익스트라 알고리즘은 너비 우선 탐색(BFS)처럼 시작점에서 가까운 순서대로 정점을 방문한다. BFS와 다른 점은 가중치가 있는 그래프에 적용하며, BFS로는 아래와 같은 그래프에서 최단 거리를 찾을 수 없다.

<그림>

위 그래프에서 최단 경로는 **s-a-b-c** 이다. 하지만 BFS를 사용하면 시작점과 인접한 정점을 방문하므로 b정점을 통한 최단 경로를 계산할 수 없다. 이러한 경우 다익스트라 알고리즘을 사용할 수 있다. 그러면 기본적으로 다익스트라 알고리즘이 어떻게 동작하는지 예제를 통해 살펴보자.

<그림>

위 그래프에서 시작점은 1번 정점으로 하여 모든 정점에 대해서 최단 거리를 구해보자. 다익스트라 알고리즘은 위에서 말했듯이 BFS와 같이 인접한 정점에서 가장 가까운 정점을 선택한다. 그리고 그 정점 중 최단 거리를 갱신해나아간다. 그러기 위해 시작점을 제외한 아직 방문하지 않은 정점은 **가장 큰 수(INF)** 로 초기화 한다. 따라서 초기 모습은 다음과 같다.

| 횟수/정점 | 1 | 2 | 3 | 4 | 5 | 6 |
|:---------:|:-:|:---:|:---:|:---:|:---:|:---:|
| 1 | **0** | INF | INF | INF | INF | INF |

표에서 확정된 정점의 최단 거리는 **진한 검정색** 으로 표시한다. 그리고 인접한 정점까지의 거리와 현재 표의 거리 중 **더 짧은 거리로 갱신한다.** 그 다음 확정되지 않은 정점 중 가장 짧은 정점으로 이동한다.
- 1번 정점과 인접한 정점 (정점, 거리)
  - (2, 0 + 7),   ```min(INF, 7) = 7```
  - (3, 0 + 9),   ```min(INF, 9) = 9```
  - (6, 0 + 14),  ```min(INF, 14) = 14```
1번 정점과 인접한 정점까지 거리를 계산하여 표와 비교한 후 더 짧은 거리로 갱신한다. 그 다음 **확정되지 않은 정점 중 가장 짧은 거리를 가진 정점으로 이동한다.** 선택된 정점은 시작점과 최단 거리임을 확정하고 그 정점에서 위와 같이 인접한 정점과 거리 계산 과정을 반복한다.

| 횟수/정점 | 1 | 2 | 3 | 4 | 5 | 6 |
|:---------:|:-:|:---:|:---:|:---:|:---:|:---:|
| 1 | **0** | INF | INF | INF | INF | INF |
| 2 | **0** | **7** | 9 | INF | INF | 14 |

- 2번 정점과 인접한 정점
  - (3, 7 + 10),   ```min(9, 17) = 9```
  - (4, 7 + 15),   ```min(INF, 22) = 22```

| 횟수/정점 | 1 | 2 | 3 | 4 | 5 | 6 |
|:---------:|:-:|:---:|:---:|:---:|:---:|:---:|
| 1 | **0** | INF | INF | INF | INF | INF |
| 2 | **0** | **7** | 9 | INF | INF | 14 |
| 3 | **0** | **7** | **9** | 22 | INF | 14 |

그 결과, 최단 거리로 확정되지 않은 정점 중 3번 정점이 가장 짧으므로 이를 확정시키고 3번 정점과 인접한 정점을 계산한다. 이와 같은 계산 과정을 모든 정점이 최단 거리로 확정될 때까지 반복한다. 모든 결과를 표로 나타내면 다음과 같다.

| 횟수/정점 | 1 | 2 | 3 | 4 | 5 | 6 |
|:---------:|:-:|:---:|:---:|:---:|:---:|:---:|
| 1 | **0** | INF | INF | INF | INF | INF |
| 2 | **0** | **7** | 9 | INF | INF | 14 |
| 3 | **0** | **7** | **9** | 22 | INF | 14 |
| 4 | **0** | **7** | **9** | 20 | INF | **11** |
| 5 | **0** | **7** | **9** | **20** | 20 | **11** |
| 6 | **0** | **7** | **9** | **20** | **20** | **11** |

하지만 이 방법은 확정되지 않은 정점 중 가장 짧은 거리의 정점을 찾기 위해 시간복잡도 O(N)으로 순차적으로 탐색한다. 이를 최적화하기 위해 **우선 순위 큐** 를 사용하여 가장 짧은 거리의 정점을 시간복잡도 O(logN) 으로 찾을 수 있다.

## 우선 순위 큐를 이용한 다익스트라 알고리즘
우선 순위 큐를 사용하더라도 알고리즘 로직은 바뀌지 않는다. 다만, 확정할 정점을 찾는데 소요되는 시간을 O(N)에서 O(logN)으로 줄인 것이다. 그러면 이를 구현한 코드를 살펴보자.

```cpp
//정점의 개수
int V;
//그래프의 인접 리스트 (연결된 정점 번호, 간선 가중치) 쌍을 담는다.
vector<pair<int, int>> adj[MAX_V];
//다익스트라, 최단 거리 배열을 반환한다.
vector<int> dijkstra(int src) {
	//INF: 매우 큰 값
	vector<int> dist(V, INF);
	dist[src] = 0;
	//(해당 정점까지 최단 거리, 해당 정점)쌍
  	//STL내부에서 pair의 첫번째 원소부터 크기 비교를 하기 때문에, 거리값을 첫 원소로 해야 한다.
	priority_queue<pair<int, int>> pq;
	pq.push(make_pair(0, src));
	while (!pq.empty()) {
    		int here = pq.top().second;
		int cost = -pq.top().first;
		pq.pop();
		//만약 지금 꺼낸 것보다 더 짧은 경로를 알고 있다면 지금 꺼낸 것을 무시한다.
		if (dist[here] < cost) continue;
		//인접한 정점들을 모두 검사한다.
		for (int i = 0; i < adj[here].size(); ++i) {
			int there = adj[here][i].first;
			int nextDist = cost + adj[here][i].second;
			//더 짧은 경로를 발견하면, dist[]를 갱신하고 우선순위 큐에 넣는다.
			if (dist[there] > nextDist) {
				dist[there] = nextDist;
				pq.push(make_pair(-nextDist, there));
			}
		}
	}
  return dist;
}
```

코드를 살펴보면 ```dist[]```은 매개변수로 전달받은 시작점 ```src``` 정점에서 모든 정점까지 최단 거리를 저장한 배열이다. 그리고 구현의 편의성을 위해 몇가지 사용한 방법이 있다.
- C++ STL pair는 첫 번째 원소를 비교하므로 (거리, 정점) 쌍으로 저장한다.
- C++ STL 우선순위 큐는 기본적으로 내림차순이므로 거리의 부호를 바꾸는 것으로 간단하게 사용할 수 있다.
- 중복된 정점의 계산을 피하기 위해 현재 거리보다 긴 경우는 모두 무시한다.(따라서, 저장할 때 정점 중복 검사는 하지 않아도 된다.)

### 시간복잡도
간선의 개수를 E라고 할 때, 각 정점마다 인접한 간선들을 모두 검사하는 작업은 O(|E|) 이고, 우선 순위 큐에 추가 및 삭제하는 연산은 O(log|E|)이다. 따라서 전체 시간복잡도는 **O(|E|log|E|)** 이다. 여기서 대부분의 그래프에서 **간선의 개수는 정점의 개수(V) 제곱보다 작으므로** 최대 원소의 개수가 전체 간선의 수가 아닌 전체 정점의 수로 볼 수 있다. 따라서, 시간복잡도를 **O(|E|log|V|)** 로 계산할 수도 있다.

- O(|V|log|V|) 다익스트라 알고리즘
중복 원소를 우선순위 큐에 넣지 않도록 수정하면 시간복잡도는 O(|V|log|V|)로 만들 수 있다. 이를 위해 피보나치 힙이나 이진 검색 트리를 사용해서 우선 순위 큐를 구현하면 중복 원소를 제거할 수 있지만, 구현이 복잡하고 실제로 시간이 더 오래 걸리는 경우가 많다.
