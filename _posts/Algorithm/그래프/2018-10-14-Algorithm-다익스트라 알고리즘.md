---
title: "[Algorithm]다익스트라 알고리즘"
excerpt: "최단 경로 알고리즘"
search: true
categories:
  - Algorithm
tags:
  - 그래프
toc: true
sidebar_main: true
---

# 다익스트라(Dijkstra) 최단 경로 알고리즘
- 다익스트라 알고리즘은 단일 시작점 최단 경로 알고리즘으로, 시작 정점 s에서부터 다른 정점들까지의 최단거리를 계산한다.
- 다익스트라 알고리즘은 음수 간선이 있는 그래프(특히, 음수 사이클)에 대해서는 정답을 계산하지 못한다.
  - 음수 간선이 사이클을 이루지 않는다면, 계산을 할 수 있는 경우가 있지만 시간복잡도는 지수적으로 증가한다.

## 우선순위 큐를 사용하는 너비 우선 탐색으로 구현
- 다익스트라 알고리즘은 너비 우선 탐색처럼 시작점에서 가까운 순서대로 정점을 방문한다.
- 다익스트라 알고리즘은 가중치가 있는 그래프에 적용하기 때문에 너비 우선 탐색을 그대로 사용할 수는 없다.
  - 가중치 그래프에서 너비 우선 탐색으로 최단 거리를 차지 못하는 예

  ![dijkstra1](https://user-images.githubusercontent.com/34755287/46916074-76617800-cff0-11e8-897f-47bcb7a8e3d3.JPG)

  - 위 그림에서 최단 경로는 ```s-a-b-c```이다.
  - 하지만, 너비 우선 탐색을 사용하면 각 정점을 순서대로 방문해야 하기 때문에 위와 같은 최단 경로를 찾을 수 없다.
    - b정점을 늦게 발견하더라도 먼저 방문할 수 있어야 한다.
- 위의 문제를 해결하기 위해 우선순위 큐를 활용하여 너비 우선 탐색을 사용한다.

### 구현
- ```dist[]```: 시작점에서 각 정점까지의 최단 거리를 저장하는 배열
- 간선(u, v)에서 정점 v가 아직 발견되지 않은 상태라면, v까지 최단 거리는 ```dist[v] = dist[u] + w(u, v)```가 되고, 우선 순위 큐에 ```(v, dist[v])```형태로 삽입한다.
  - 아직 방문하지 않는 간선 중에 정점 v가 포함되어 있고, 위의 ```dist[v]```보다 더 짧다면 갱신될 수 있다.
- 위와 같이 한 정점이 중복된다면, 우선 순위 큐에 역시 같은 정점이 여러개 존재할 수 있다.
  - 간단한 구현을 위해, 중복된 정점을 우선 순위 큐에 삽입 하되 나중에 큐에서 꺼내질 때 해당 정점의 현재 최단 거리보다 길다면 무시한다.
- C++ STL에 포함된 우선 순위 큐를 사용할 때 주의할 점은 기본적으로 가장 큰 값을 가장 먼저 나오도록 구현되어 있으므로 거리(```dist[]```)의 부호를 바꿔서 큐에 삽입하도록 하여 간단하게 구현한다.
  - 부호가 마이너스인 숫자는 절대값이 큰 값이 더 작은 값이 되기 때문이다.
  - 큐에서 꺼낼때 역시 부호를 바꿔서 양의 숫자로 바꿔주어야 한다.

#### 구현 코드

```cpp
//정점의 개수
int V;
//그래프의 인접 리스트 (연결된 정점 번호, 간선 가중치) 쌍을 담는다.
vector<pair<int, int>> adj[MAX_V];
//다익스트라, 최단 거리 배열을 반환한다.
vector<int> dijkstra(int src) {
	//INF: 매우 큰 값
	vector<int> dist(V, INF);
	dist[src] = 0;
	//(해당 정점까지 최단 거리, 해당 정점)쌍
  	//STL내부에서 pair의 첫번째 원소부터 크기 비교를 하기 때문에, 거리값을 첫 원소로 해야 한다.
	priority_queue<pair<int, int>> pq;
	pq.push(make_pair(0, src));
	while (!pq.empty()) {
    		int here = pq.top().second;
		int cost = -pq.top().first;
		pq.pop();
		//만약 지금 꺼낸 것보다 더 짧은 경로를 알고 있다면 지금 꺼낸 것을 무시한다.
		if (dist[here] < cost) continue;
		//인접한 정점들을 모두 검사한다.
		for (int i = 0; i < adj[here].size(); ++i) {
			int there = adj[here][i].first;
			int nextDist = cost + adj[here][i].second;
			//더 짧은 경로를 발견하면, dist[]를 갱신하고 우선순위 큐에 넣는다.
			if (dist[there] > nextDist) {
				dist[there] = nextDist;
				pq.push(make_pair(-nextDist, there));
			}
		}
	}
  return dist;
}
```

### 시간 복잡도
- 각 정점마다 인접한 간선들을 모두 검사하는 작업: ```O(|E|)```
- 우선순위 큐에 원소를 넣고 삭제하는 작업
  - 너비 우선 탐색에서는 각 정점을 한번 씩만 방문하지만, 다익스트라는 각 간선을 한번 씩 방문하기 때문에 정점을 중복해서 방문한다.
  - 최대 원소의 수: ```O(|E|)```
  - 추가 및 삭제 연산: ```O(log|E|)```
  - 전체 시간 복잡도: ```O(|E|log|E|)```
- 대부분의 그래프에서 간선의 개수 |E|는 ```|V|^2```보다 작기 때문에, ```O(log|E|) == O(log|V|)```라고 할 수 있다.
- 따라서, 우선순위 큐 다익스트라 알고리즘의 전체 시간 복잡도는 ```O(|E|log|V|)```이다.

## 실제 경로 찾기
- 너비 우선 탐색에서 경로를 찾는 것과 유사하게, 스패닝 트리를 계산한 후, 스패닝 트리를 거슬러 올라가며 경로를 찾을 수 있다.

## ```O(|V|log|V|)``` 다익스트라 알고리즘
- 중복 원소를 우선순위 큐에 넣지 않도록 수정하면 ```O(|V|log|V|)```의 시간복잡도를 가질 수 있다.
- 피보나치 힙이나 이진 검색 트리를 이용해 우선순위 큐를 사용하면 중복 원소를 제거할 수 있지만, 구현이 복잡하고 실제로 시간이 더 오래 걸리는 경우가 많다.

## 참고 문헌
- 프로그래밍 대회에서 배우는 알고리즘 문제해결전략, 인사이트, 구종만 지음
