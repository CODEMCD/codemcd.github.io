---
title: "[BOJ] 1339.단어 수학"
excerpt: "완전 탐색"
search: true
sidebar_main: true
categories:
  - Algorithm
tags:
  - Algorithm_BOJ
---

# 단어 수학

## 문제 링크
- [https://www.acmicpc.net/problem/1339](https://www.acmicpc.net/problem/1339)

## 해결 방법
### 순열을 이용한 완전 탐색
- 등장하는 알파벳에 부여할 수 있는 점수의 모든 경우의 수를 순열을 통해 찾는다.
  - 가장 높은 숫자부터 알파벳에 부여해야한다.

#### 예제: GCF + ACDEB
- 등장하는 알파벳: ABCDEFG

| 알파벳 	| A 	| B 	| C 	| D 	| E 	| F 	| G 	|
|:------:	|:-:	|:-:	|:-:	|:-:	|:-:	|:-:	|:-:	|
|  숫자  	| 9 	| 8 	| 7 	| 6 	| 5 	| 4 	| 3 	|

| 알파벳 	| A 	| B 	| C 	| D 	| E 	| F 	| G 	|
|:------:	|:-:	|:-:	|:-:	|:-:	|:-:	|:-:	|:-:	|
|  숫자  	| 9 	| 8 	| 7 	| 6 	| 5 	| 3 	| 4 	|

...

#### 시간 복잡도
- 순열 계산: $P(10,10)$ = ```10!```
- 단어 계산: ```10(단어 개수) * 8(단어 길이)```
- 총 시간 복잡도: ```10! * 10 * 8```

### 자릿수 활용하기
- 주어진 알파벳 문자열은 십집수의 자릿수와 같은 취급을 하기 때문에 등장하는 알파벳들의 자릿수 합을 구하여 이 합이 큰 알파벳부터 높은 숫자를 부여한다.

#### 예제: GCF + ACDEB

- 문자열1

| 알파벳 	|  G  	|  C 	| F 	|
|:------:	|:---:	|:--:	|:-:	|
| 자릿수 	| 100 	| 10 	| 1 	|

- 문자열2

| 알파벳 	|   A   	|   C  	|  D  	|  E 	| B 	|
|:------:	|:-----:	|:----:	|:---:	|:--:	|:-:	|
| 자릿수 	| 10000 	| 1000 	| 100 	| 10 	| 1 	|

- 문자열1 + 문자열2(자리수 오름차순)

| 알파벳 	|   A   	|   C  	|  D  	|  E 	|  G 	| B 	| F 	|
|:------:	|:-----:	|:----:	|:---:	|:--:	|:--:	|:-:	|:-:	|
| 자릿수 	| 10000 	| 1010 	| 100 	| 10 	| 10 	| 1 	| 1 	|

>> 처음에 자리수의 인덱스 누적값(예를 들어, 위의 문자열 2의 A에 5를 부여한다.)을 오름차순으로 하여 순서대로 큰 숫자를 부여했는데, 이렇게 하면 숫자 중복이 실제 수 크기와 관계없이 중복되는 경우가 생겨서 틀린 것 같다. 위처럼 자릿수를 기준으로 하여 정확하게 비교해야 한다는 것을 알았다.

#### 시간 복잡도
- 자릿수 부여: ```10 * 8```
- 오름차순 정렬(퀵정렬): ```26log26```

## 결과 코드
- 순열을 이용한 완전 탐색

```cpp
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <string>
using namespace std;

//최초 등장하는 알파벳 검사
bool check[27];
//등장하는 알파벳 종류 저장
char alph[10];
//등장하는 알파벳에 해당하는 숫자 맵핑
int nalph[27];
//최대 점수를 찾기 위해 숫자 9를 우선적으로 대입하기 위한 배열
//순열을 통해 만든어진 수열을 인덱스로 맵핑
int num[10] = { 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 };
vector<int> seq;
string str[10];

int main(void)
{
	int n; scanf("%d", &n);
	//등장하는 알파벳 개수
	int idx = 0;
	for (int i = 0; i < n; ++i) {
		cin >> str[i];
		//등장하는 알파벳 갯수 세기
		for (int j = 0; j < str[i].size(); ++j)
			if (!check[str[i][j] - 'A']) {
				check[str[i][j] - 'A'] = true;
				alph[idx++] = str[i][j];
			}
	}

	//알파벳 개수만큼 순열을 사용하기 위해 초기화 0 ~ n-1
	for (int i = 0; i < idx; ++i)
		seq.push_back(i);

	int ans = 0;
	//순열 탐색
	do {
		//등장하는 알파벳에 점수 부여
		for (int i = 0; i < idx; ++i)
			nalph[alph[i] - 'A'] = num[seq[i]];
		int deci = 0;
		//주어진 모든 문자열 수 계산
		for (int i = 0; i < n; ++i) {
			int coef = 0;
			int size = str[i].size();
			for (int j = 0; j < str[i].size(); ++j) {
				coef = nalph[str[i][j] - 'A'];
				for (int k = 0; k < size - 1; ++k)
					coef *= 10;
				size--;
				deci += coef;
			}
		}
		//가장 큰 수 찾기
		ans = ans > deci ? ans : deci;
	} while (next_permutation(seq.begin(), seq.end()));

	printf("%d\n", ans);

	return 0;
}
```
