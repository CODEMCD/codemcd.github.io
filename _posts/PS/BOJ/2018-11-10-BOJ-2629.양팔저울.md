---
title: "[BOJ] 2629.양팔저울"
excerpt: "DP"
search: true
sidebar_main: true
use_math: true
categories:
  - PS
tags:
  - BOJ
---

# 양팔저울

## 문제 링크
- [https://www.acmicpc.net/problem/2629](https://www.acmicpc.net/problem/2629)

## 해결 방법
### DP
주어진 추를 양쪽 저울에 모두 올릴 수 있으므로, 추를 사용하는 모든 경우의 수는 아래와 같이 3가지로 나뉜다.
- 구슬과 같은 저울에 올린 경우: **-1**
- 올리지 않은 경우: **0**
- 구슬과 반대 저울에 올린 경우: **1**

예를 들어, 문제의 테스트 케이스와 같이 추의 무게가 1g, 4g 2개가 있을 때,
- 초기 상태: ```{0}```
- 추 1g 추가: ```{-1, 0, 1}```
- 추 4g 추가: ```{-5, -4, -3, 3, 4, 5}```

총 가능한 구슬 무게는 ```{0, 1, 3, 4, 5}```가 된다. 하지만 중간 과정의 음수 무게도 추를 추가할 때마다 사용해야 하기 때문에 저장을 해두어야 한다. 위의 예제에서 확인할 수 있듯이 추를 추가할 때마다 가능한 무게의 경우의 수는 3의 제곱수로 증가한다.

위와 같은 과정을 완전 탐색으로 구현한다면 시간 복잡도는 하나의 추마다 3가지 경우가 존재하므로 ${3}^{N}$이다. 추의 개수 N은 최대 30개가 존재하므로 실제 계산량은 ${3}^{30}$ = 205891132094649 로 시간내에 해결 불가능하다.

위의 문제점을 해결하기 위해 DP를 사용한다. DP를 사용하면 아래의 구현 코드에서 확인할 수 있듯이 시간 복잡도는 ```O(N * 2M)```이다.(N: 추 개수, M: 가능한 추의 무게)

## 구현 코드

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstdio>
using namespace std;
//계산 중간 과정에서 음수가 나올 수 있으므로
//양수로 변환하기 위해 기준을 0에서 15000으로 변경한다.
#define M 15000
//weight[n] = n 무게의 구슬은 측정 가능하다.
bool weight[30001];
//추 무게를 추가하는 과정에서 반복문이 순서대로 검사하므로
//현재 추가된 추 무게를 검사하는 현상이 발생한다. 이를 방지하기 위함.
//(현재 추가된 추 무게는 다음 추를 추가할 때 검사되어야 한다.)
bool access[30001];
int w[31], marble;


int main(void)
{
	int n; scanf("%d", &n);
	for (int i = 0; i < n; ++i)
		scanf("%d", &w[i]);

	weight[M] = true;
	for (int i = 0; i < n; ++i) {
		//현재 추를 추가했을 때 가능한 무게들을 검사하여 임의로 저장한다.
		for (int j = 0; j < 30001; ++j) {
			if (weight[j]) {
				access[j + w[i]] = true;
				access[j - w[i]] = true;
			}
		}
		//가능한 무게들을 실제로 추가하여 다음 계산에 사용할 수 있도록 한다.
		for (int j = 0; j < 30001; ++j)
			if (access[j])
				weight[j] = true;
	}

	int m; scanf("%d", &m);
	for (int i = 0; i < m; ++i) {
		scanf("%d", &marble);
		printf("%c ", weight[marble + M] ? 'Y' : 'N');
	}

	return 0;
}
```
