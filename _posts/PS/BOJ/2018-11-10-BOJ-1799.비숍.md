---
title: "[BOJ] 1799.비숍"
excerpt: "백트래킹"
search: true
sidebar_main: true
use_math: true
categories:
  - PS
tags:
  - BOJ
---

# 비숍

## 문제 링크
- [https://www.acmicpc.net/problem/1799](https://www.acmicpc.net/problem/1799)

## 해결 방법
### 백트래킹
- 순수하게 비숍을 놓는 모든 경우를 재귀 함수로 구현하면 시간 복잡도는 O(${2}^{N * N}$)이므로, 시간 제한이 10초지만 이를 훨씬 넘어선다.
- 시간 복잡도를 줄이기 위해 체스판을 아래의 그림같이 나타내보자.

![bishop table](https://user-images.githubusercontent.com/34755287/48295230-752b4a00-e4cd-11e8-934a-f0d37443ecd6.jpg)

- 흰색과 검은색은 각각 대각선으로 모두 연결되는 것을 알 수 있다. 하지만 흰색과 검은색은 서로 대각선 관계가 아니기 때문에 흰색에 비숍을 놓고 검은색에 연속해서 비숍을 놓을 수 있다. 즉, 흰색과 검은색은 서로 독립적이므로 둘을 나눠서 생각할 수 있다.
- 흰색과 검은색을 둘로 나누어 재귀 함수를 구현하면 시간 복잡도는 O(${2}^{N/2 * N/2}%)로 대폭 줄일 수 있다.

## 시간 복잡도 더 줄이기
- 재귀 구현에 방식에 따라 시간 복잡도를 더 줄일 수 있다.
> 현재 수준에서 이해할 수 있는 코드를 참고하여 구현하였는데, 비숍을 놓을 수 있는 모든 좌표마다 재귀 함수를 돌리고 재귀 함수내에서는 현재 좌표 이후에 놓을 수 있는 비숍을 검사한다.

## 결과 코드

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
int board[11][11];
//한 대각선에 비숍이 있는지를 판단하는 배열
//check[][0]: \ 방향
//check[][1]: / 방향
bool check[21][2];
int n;

//ans: 검은색 부분과 흰색 부분의 비숍을 놓을 수 있는 최대값을 저장한다.
int ans1, bn1, ans2, bn2;
//검은색 부분에서 비숍을 놓을 수 있는 최대값을 계산한다.
void dfs(int y, int x) {
	//기저 사례: 현재 좌표가 포함되어있는 2개의 대각선 중 어느 한 대각선이라도 비숍이
	//있다면 반환한다.
	if (check[y - x + n][0] || check[y + x][1])
		return;

	//현재 좌표가 포함된 대각선에 비숍이 있다는 것을 표시한다.
	check[y - x + n][0] = check[y + x][1] = true;
	//비숍 개수를 갱신한다.
	bn1++;
	ans1 = ans1 > bn1 ? ans1 : bn1;

	//현재 x좌표 이후 부터 비숍을 놓을 수 있는지 검사한다.
	for (int j = x + 1; j < n; ++j) {
		if (y % 2 == 0 && j % 2 == 0 && board[y][j])
			dfs(y, j);
		else if (y % 2 == 1 && j % 2 == 1 && board[y][j])
			dfs(y, j);
	}

	for (int i = y + 1; i < n; ++i)
		for (int j = 0; j < n; ++j) {
			if (i % 2 == 0 && j % 2 == 0 && board[i][j])
				dfs(i, j);
			else if (i % 2 == 1 && j % 2 == 1 && board[i][j])
				dfs(i, j);
		}

	bn1--;
	check[y - x + n][0] = check[y + x][1] = false;
}

void dfs2(int y, int x) {
	if (check[y - x + n][0] || check[y + x][1])
		return;

	check[y - x + n][0] = check[y + x][1] = true;
	bn2++;
	ans2 = ans2 > bn2 ? ans2 : bn2;

	for (int j = x + 1; j < n; ++j) {
		if (y % 2 == 0 && j % 2 == 1 && board[y][j])
			dfs2(y, j);
		else if (y % 2 == 1 && j % 2 == 0 && board[y][j])
			dfs2(y, j);
	}

	for (int i = y + 1; i < n; ++i)
		for (int j = 0; j < n; ++j) {
			if (i % 2 == 0 && j % 2 == 1 && board[i][j])
				dfs2(i, j);
			else if (i % 2 == 1 && j % 2 == 0 && board[i][j])
				dfs2(i, j);
		}

	bn2--;
	check[y - x + n][0] = check[y + x][1] = false;
}

int main(void)
{
	scanf("%d", &n);
	for (int i = 0; i < n; ++i)
		for (int j = 0; j < n; ++j)
			scanf("%d", &board[i][j]);

	//검은색 부분
	for (int i = 0; i < n; ++i)
		for (int j = 0; j < n; ++j)
			if (i % 2 == 0 && j % 2 == 0 && board[i][j] == 1)
				dfs(i, j);
			else if (i % 2 == 1 && j % 2 == 1 && board[i][j] == 1)
				dfs(i, j);

	//흰색 부분
	for (int i = 0; i < n; ++i)
		for (int j = 0; j < n; ++j)
			if (i % 2 == 0 && j % 2 == 1 && board[i][j] == 1)
				dfs2(i, j);
			else if (i % 2 == 1 && j % 2 == 0 && board[i][j] == 1)
				dfs2(i, j);

	printf("%d\n", ans1 + ans2);

	return 0;
}
```
