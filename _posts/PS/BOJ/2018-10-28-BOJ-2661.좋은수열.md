---
title: "[BOJ] 2661.좋은수열"
excerpt: "백트래킹"
search: true
sidebar_main: true
use_math: true
categories:
  - PS
tags:
  - BOJ
---

# 좋은수열

## 문제 링크
- [https://www.acmicpc.net/problem/2661](https://www.acmicpc.net/problem/2661)

## 해결 방법
### 백트래킹
#### 1. 좋은 수열 검사하기
- 한 수열의 시작점기준으로 부분 수열을 만들어 바로 다음 부분 수열과 같은지 비교한다.
  - 시작점은 수열의 끝까지 옮겨간다.
  - 부분 수열의 최대 크기는 전체 수열 크기의 ${\frac{1}{2}}$ 만큼 이다.

예제: 123123
1) **1** 23123 -> '2' 비교 -> 다름
2) **12** 3123 -> '31' 비교 -> 다름
3) **123** 123 -> '123' 비교 -> 같음

#### 2. 수열 만들기
- 문제에서 요구하는 주어진 수열 크기에서 수로 표현했을 때 가장 작은 수열을 찾아야한다.
- 사용 가능한 숫자의 종류는 1, 2, 3이므로, 가장 작은 수를 찾을려면 수열의 시작 숫자는 ```1```이서만 찾으면 된다.
- 가능한 모든 수열을 만들어 놓고 좋은 수열인지 검사하면 시간복잡도 O($3^{N-1}$) 이고, N의 최대 크기는 ```80```이므로 시간안에 풀 수 없다.
- 수열 크기 1부터 하나씩 늘려 주어진 N의 크기를 만들어야 한다.
  1. 현재 수열에서 숫자 1을 추가한다.
  2. 좋은 수열인지 검사한다.
  3. 좋은 수열이 만족하면 1번 단계로 가며, 만족하지 않으면 숫자 1을 지우고 숫자 2를 추가하여 2번 단계로 간다.
  (숫자 2도 만족하지 않으면 숫자 3을 추가하고 2번 단계)
- 위와 같이 작은 숫자부터 그리디하게 추가하면 시간복잡도를 크게 줄일 수 있다.

## 결과 코드

```cpp
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <string>
using namespace std;
int n;

//나쁜 수열인지 검사하는 플래그
bool badFlag = false;
void check(string s, int sIdx) {
	int size = s.size();
	//기저 사례: 나쁜 수열로 판단되거나 시작 인덱스가 끝에 도달할 경우
	if (badFlag || sIdx == (size - 1)) return;

	string cur, next;
	int nextSIdx;
	//현재 시작 인덱스에서 나타날 수 있는 나쁜 수열인 경우를 탐색한다.
	for (int i = 1; i <= size / 2; ++i) {
		//현재 시작 인덱스 부분 수열
		cur = s.substr(sIdx, i);
		//현재 시작 인덱스 부분 수열과 오른쪽에 인접한 부분 수열
		nextSIdx = sIdx + i;
		if (nextSIdx >= size || (nextSIdx + i) > size) continue;
		next = s.substr(nextSIdx, i);
		if (cur == next) {
			badFlag = true;
			return;
		}
	}
	//다음 시작 인덱스 검사
	check(s, sIdx + 1);
}

//정답을 찾았는지 검사하는 플래그
bool ansFlag = false;
string ans;
//수열의 크기를 하나씩 늘려가며 수열을 만든다.
void makeSequence(string str, int len) {
	//기저 사례1: 정답을 찾았다면 검사할 필요가 없으므로 반환한다.
	if (ansFlag) return;
	//기저 사례2: 좋은 수열을 유지하여 정답을 찾았다면 저장하고 반환한다.
	if (len == n) {
		ans = str;
		ansFlag = true;
		return;
	}
	else {
		//숫자 1, 2, 3을 차례로 추가한다.
		for (int i = 1; i < 4; ++i) {
			badFlag = false;
			//char 변환
			char num[2];
			num[0] = i + '1' - 1;
			num[1] = '\0';
			string next = str.append(num);
			//좋은 수열인지 검사한다.
			check(next, 0);
			//좋은 수열이라면 해당 숫자를 추가하고 다음 단계로 넘어간다.
			if (!badFlag)
				makeSequence(next, len + 1);
			//좋은 수가 아니라면 해당 숫자를 제거한다.
			str.pop_back();
		}
	}
}

int main(void)
{
	scanf("%d", &n);

	makeSequence("1", 1);
	cout << ans << endl;

	return 0;
}
```
