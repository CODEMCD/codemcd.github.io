---
title: "[BOJ] 15683.감시"
excerpt: "완전 탐색"
search: true
categories:
  - PS
tags:
  - BOJ
---

# 감시

## 문제 링크
- [https://www.acmicpc.net/problem/15683](https://www.acmicpc.net/problem/15683)
- 삼성 SW 역량 테스트 기출 문제

## 해결 방법
### 중복 순열을 이용한 완전 탐색
- 각각의 카메라는 총 4번 회전할 수 있으므로 카메라마다 어떤 방향을 설정해줄지에 대해 중복 순열을 사용하여 모든 경우의 수를 계산하였다.
- 경우의 수마다 사각지대의 개수를 검사하여 최소값을 갱신해준다.

> 이 문제는 DFS로도 풀이가 가능한데, 코드가 복잡해지는 대신 대체적으로 중복 순열을 사용하는 것보다 시간이 더 빠른 것으로 보인다.

## 시간 복잡도
- 최대 카메라 개수: ```8```
- 최대 사무실 크기: ```8 X 8```
- ```4^8 * (8 * 8) = 4,194,304```

## 결과 코드

```cpp
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <vector>
using namespace std;
const int INF = 987654321;

typedef struct _camerainfo {
	int n;     //카메라 종류
	int y, x;  //카메라 위치
} cameraInfo;

int dy[4] = { 0, 1, 0, -1 };
int dx[4] = { 1, 0, -1, 0 };
//카메라 종류에 따른 방향 정보
vector<int> camera[5];
//각 카메라 정보
cameraInfo ci[8];
int map[9][9], tmp[9][9];
int n, m;
int ans = INF;

//카메라 종류에 따른 방향 저장
void initCameraDir() {
	//1번 카메라
	camera[0].push_back(0);
	//2번 카메라
	camera[1].push_back(0);
	camera[1].push_back(2);
	//3번 카메라
	camera[2].push_back(0);
	camera[2].push_back(3);
	//4번 카메라
	camera[3].push_back(0);
	camera[3].push_back(2);
	camera[3].push_back(3);
	//5번 카메라
	camera[4].push_back(0);
	camera[4].push_back(1);
	camera[4].push_back(2);
	camera[4].push_back(3);
}

//중복 순열
void rperm(int *set, int size, int nn, int r) {
	if (size == r) {
		int res = 0;

		/*for (int i = 0; i < r; ++i)
		printf("%d ", set[i]);
		printf("\n");*/

		//사각 지대 계산을 위해 임의로 맵을 저장한다.
		for (int i = 0; i < n; ++i)
			for (int j = 0; j < m; ++j)
				tmp[i][j] = map[i][j];

		//현재 순열의 번호에 따라 카메라들의 방향을 설정하여
		//카메라가 볼 수 있는 위치를 좌표에 모두 표시한다.
		for (int i = 0; i < r; ++i) {
			int nowCN = ci[i].n;
			for (int j = 0; j < camera[nowCN].size(); ++j) {
				int nowdy = (camera[nowCN][j] + set[i]) % 4;
				int nowdx = (camera[nowCN][j] + set[i]) % 4;
				int nexty = ci[i].y, nextx = ci[i].x;
				for (int k = 0; k < 8; ++k) {
					nexty += dy[nowdy];
					nextx += dx[nowdx];
					if (nexty < 0 || nexty >= n || nextx < 0 || nextx >= m ||
						map[nexty][nextx] == 6)
						break;
					tmp[nexty][nextx] = 7;
				}
			}
		}

		//카메라 사각지대 개수를 계산한다.
		for (int i = 0; i < n; ++i)
			for (int j = 0; j < m; ++j)
				if (!tmp[i][j])
					res++;
		ans = ans < res ? ans : res;
		//printf("%d\n", ans);
		return;
	}
	for (int i = 0; i < nn; ++i) {
		set[size] = i;
		rperm(set, size + 1, nn, r);
	}
}

int main()
{
	initCameraDir();
	scanf("%d %d", &n, &m);
	int csize = 0;
	for (int i = 0; i < n; ++i)
		for (int j = 0; j < m; ++j) {
			scanf("%d", &map[i][j]);
			if (map[i][j] > 0 && map[i][j] < 6) {
				ci[csize].n = map[i][j] - 1;
				ci[csize].y = i;
				ci[csize++].x = j;
			}
		}

	//중복 순열을 위한 초기화
	int arr[9] = { 0, };
	for (int i = 0; i < 4; ++i)
		arr[i] = i;
	//사각지대 계산
	rperm(arr, 0, 4, csize);
	printf("%d\n", ans);

	return 0;
}
```
