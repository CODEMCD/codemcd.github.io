---
title: "[BOJ] 1342.행운의 문자열"
excerpt: "순열 or 백트래킹"
search: true
sidebar_main: true
categories:
  - Algorithm
tags:
  - Algorithm_BOJ
---

# 행운의 문자열

## 문제 링크
- [https://www.acmicpc.net/problem/1342](https://www.acmicpc.net/problem/1342)

## 해결 방법
### 순열(next_permutation STL 함수)
문자열의 길이가 **10** 이하이므로 순열을 사용하여 모든 문자열의 경우의 수(10! = 3,628,800)를 구할 수 있다.

문자열을 만들 때마다 인접한 문자들이 같은지 다른지 검사하고, 모두 다르면 행운의 문자열 개수에 추가한다.

여기서 ```next_permutation``` 함수를 사용하였는데, 이 함수는 다음 경우의 수열을 사전 순서대로 만들기 때문에 현재의 수열이 이전의 수열보다 사전 순서에서 빠르면 ```false```를 반환한다. 그러므로, 오름차순의 수열은 정상적으로 모든 순열의 경우를 찾지만 오름차순이 아니라면 중간에 끝나서 모든 경우를 찾지 못할 수도 있다.(일반적인 ```while()``` 문의 조건문으로 사용한 경우)

이를 2가지로 해결할 수 있다.
1. 입력받은 문자열을 오름차순으로 정렬한다.
2. ```while``` 문의 조건문에 ```next_permutation``` 함수를 쓰지 않고, 중간에 사용하고 조건문에는 원래의 문자열과 같은지를 검사하여 같으면 ```while``` 문을 빠져나간다.(원래 문자열과 같아진 경우, 그 다음에는 이전과 반복되기 때문이다.)

### 백트래킹
모든 경우의 문자열을 만드는 것은 백트래킹으로도 가능하다. 하지만 현재 문자열은 중복 문자가 포함되어 있으므로, 같은 문자열을 여러개 만들어, 행운의 문자열 개수에 중복이 포함된다.

이 중복을 없애는 방법은 중복 원소를 포함한 순열 찾기에서와 같은 공식을 사용할 수 있다.

예제 테스트 케이스에서 문자열 ```aabbbaa```가 만들 수 있는 모든 문자열의 개수는 7!이다. 여기서 중복 원소는 총 2가지로 ```aaaa```, ```bbb``` 이다. ```aaaa```가 만들 수 있는 모든 문자열의 개수는 4! 이고, ```bbb```는 3! 이다. 그러므로 총 중복되는 개수는 4! * 3! 이라는 것을 알 수 있다. 결과적으로 중복을 제거해주기 위해서는 ```4! * 3!```으로 나누어 주어야 한다.

백트래킹이 재귀 함수이므로 위의 ```next_permutation``` 함수를 사용하는 것보다는 시간이 훨씬 오래 걸리는 것을 확인할 수 있었다.

## 결과 코드
### 순열

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <string>
using namespace std;

int main(void)
{
	string buf, tmp;
	cin >> buf;
	int size = buf.size();
	tmp = buf;

	int ans = 0;
	int iter = 0;

	do {
		bool flag = true;
		for (int i = 0; i < size - 1; ++i)
			if (buf[i] == buf[i + 1]) {
				flag = false;
				break;
			}
		ans += flag;
		iter++;
		next_permutation(buf.begin(), buf.end());
	} while (iter > 0 && tmp != buf);

	printf("%d\n", ans);

	return 0;
}
```

### 백트래킹

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <string>
using namespace std;
int ssize, ans = 0;
bool check[11];
//알파벳이 얼마나 중복되는 지 저장하는 배열
int alpha_count[27];
string str, tmp;

//팩토리얼 계산
int calFacto(int n) {
	if (n == 0) return 1;
	int ret = 1;
	for (int i = 1; i <= n; ++i)
		ret *= i;
	return ret;
}

//행운의 문자열인지 아닌지 검사
bool lucky(string source) {
	int size = source.size();
	for (int i = 0; i < size - 1; ++i)
		if (source[i] == source[i + 1])
			return false;
	return true;
}

//모든 문자열 생성
void dfs(int len) {
	if (len == ssize) {
		//cout << tmp << endl;
		if (lucky(tmp))
			ans++;
		return;
	}

	for (int i = 0; i < ssize; ++i) {
		if (!check[i]) {
			check[i] = true;
			tmp.push_back(str[i]);
			dfs(len + 1);
			tmp.pop_back();
			check[i] = false;
		}
	}
	return;
}

int main(void)
{
	cin >> str;
	ssize = str.size();
	for (int i = 0; i < ssize; ++i)
		alpha_count[str[i] - 'a']++;

	dfs(0);
	//중복을 없애기 위해 중복되는 문자열이 만드는 경우의 수를 모두 나눠준다.
	for (int i = 0; i < 27; ++i)
		ans /= calFacto(alpha_count[i]);

	printf("%d\n", ans);

	return 0;
}
```
