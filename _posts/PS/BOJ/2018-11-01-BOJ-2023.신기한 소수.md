---
title: "[BOJ] 2023.신기한 소수"
excerpt: "백트래킹"
search: true
sidebar_main: true
use_math: true
categories:
  - Algorithm
tags:
  - Algorithm_BOJ
---

# 신기한 소수

## 문제 링크
- [https://www.acmicpc.net/problem/2023](https://www.acmicpc.net/problem/2023)

## 해결 방법
### 백트래킹
- 시간 제한과 메모리 제한으로 볼 때 에라토스테네스의 체는 사용할 수 없다.
- 문제에서는 한 자리부터 N자리 모두 소수가 되야 하므로 첫 번째 자리 수부터 소수인 숫자로 시작하여 자릿수를 늘려나가는 방식으로 구현하였다.
  - 첫 번째 자리가 소수가 될 수 있는 경우는 ```2, 3, 5, 7```이다.
  - 두 번째 자리부터 소수가 될 수 있는 경우는 홀수(```1, 3, 5, 7, 9```)인 경우이다. 짝수인 경우는 무조건 2의 배수이므로 소수가 될 수 없다.
- 재귀 함수 입력을 string으로 받아 자릿수를 간단하게 늘려주고 이를 ```atoi``` 함수로 int형으로 변경하여 해당 숫자가 소수인지 판단한다.

### 시간 복잡도 줄이기
- 재귀 함수가 실행되는 수는 최대 8자리에서 ${4} * {5}^{7}$ 으로 고정이다.
- 재귀 함수내에서 소수를 판단하는 반복문에 따라 시간복잡도 차이가 난다.
  - 현재 수가 N일 때, 가장 간단한 방법은 ```2 ~ N - 1```까지 나누어 떨어지지 않으면 소수이다.

  ```cpp
  for (int i = 2; i < rn; ++i)
    if (rn % i == 0)  //소수가 아닌 경우
      return;
  ```

  - 위의 식을 좀 더 생각해보면 N을 나눌 때 나누는 수의 제곱이 N보다 작거나 같을 때만 나누면 된다. 예를 들어 ```16```의 약수는 ```1, 2, 4, 8, 16```이다. 여기서 ```16```을 만드는 곱셈 쌍은 ```(1, 16), (2, 8), (4, 4)```이다. 이것을 보면 앞의 숫자 ```1, 2, 4```는 각각 제곱하면 ```16```보다 작거나 같고 이 3개의 숫자로 나누면 ```16```의 모든 약수를 구할 수 있다. 즉, 각 숫자의 약수를 나열했을 때 앞에서 부터 중간지점 숫자까지만 나누어 보면 되는데 이 중간 지점 숫자의 최대값이 $\sqrt {N}$ 작거나 같기 때문이다.

  ```cpp
  for (int i = 2; i * i <= rn; ++i)
			if (rn % i == 0)  //소수가 아닌 경우
				return;
  ```

  > 이는 효율높은 코드를 보면서 내 방식대로 분석하여 내린 결론이다. 이 생각이 틀릴수도 있음...

- 실제 채점에서 시간은 ```764ms``` 에서 ```0ms```로 크게 준 것을 확인할 수 있다.


## 결과 코드

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <string>
using namespace std;
int n;
vector<int> ans;

//모든 1 ~ N 자리수가 소수인 숫자를 찾는다.
void solve(string num) {
	//현재 숫자 자릿수
	int size = num.size();
	//int형으로 변환
	int rn = atoi(num.c_str());
	if (size > 1) {
		//현재 숫자가 소수인지 찾는다.
		//이 부분을 더 빠르게 고칠 수 있다면 시간복잡도가 줄어들 것 같다.(위 설명 참고)
		for (int i = 2; i < rn; ++i)
			if (rn % i == 0)
				return;  //소수가 아니면 빠져나간다.
		//현재 자릿수가 입력된 자릿수와 일치한다면 추가한다.
		if (size == n) {
			ans.push_back(rn);
			return;
		}
	}
	char an[2];
	string next;
	//소수가 될 수 있는 홀수를 추가한다.(짝수는 무조건 2의 배수이다.)
	for (int i = 1; i < 10; i += 2) {
		next = num;
		//숫자 추가
		an[0] = i + '1' - 1;
		an[1] = '\0';
		next.append(an);
		solve(next);
	}
}

int main(void)
{
	scanf("%d", &n);
	//첫째 자리로 시작할 수 있는 소수
	int start[4] = { 2, 3, 5, 7 };
	//한 자리수인 경우
	if (n == 1) {
		for (int i = 0; i < 4; ++i)
			printf("%d\n", start[i]);
	}
	//두 자리수 이상인 경우
	else {
		solve("2");
		solve("3");
		solve("5");
		solve("7");
	}
	for (int i = 0; i < ans.size(); ++i)
		printf("%d\n", ans[i]);

	return 0;
}

```
