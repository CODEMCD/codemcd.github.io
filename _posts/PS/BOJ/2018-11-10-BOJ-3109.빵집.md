---
title: "[BOJ] 3109.빵집"
excerpt: "그리디 + 백트래킹"
search: true
sidebar_main: true
use_math: true
categories:
  - PS
tags:
  - BOJ
---

# 빵집

## 문제 링크
- [https://www.acmicpc.net/problem/3109](https://www.acmicpc.net/problem/3109)

## 해결 방법
### 그리디 + 백트래킹
주어진 최대 격자 크기가 ```10000 x 500```이므로, 백트래킹으로 완전 탐색을 할 수 없다는 것을 알 수 있다.

문제에서 파이프라인은 왼쪽에서 오른쪽 방향 **한 방향** 으로 움직이며 어느 한 칸에서 다음 칸으로 가는 경우의 수는 ```대각선 위, 수평, 대각선 아래```이다. 이것으로 볼 때, 파이프라인을 대각선 위부터 순서대로 그리디하게 검사한다면 갈 수 있는 최대를 구할 수 있을 것이다.

또 하나, 중요한 점은 어느 한 칸에서 다음 칸으로 넘어갈 수 없는 경우를 발견했다면 이 칸은 어느 파이프라인이 온다고 해도 다음 칸으로 넘어갈 수 없다.

```
1 X X . 1
2 1 X 1 2
3 2 1 2 .
. 3 2 X .
. . 3 X .
```

위의 배열은 문제 테스트 케이스에서 파이프라인을 만드는 과정을 보여준다. 1번과 2번 파이프는 완전히 만들어진 상황이고 3번 파이프라인을 만들고 있다. 하지만 가장 아래의 3번에서 볼 수 있듯이, 더이상 앞으로 진행할 수 없다. 이 때 저 칸은 어느 파이프라인이라도 진행할 수 없으므로 이를 표시해두어 다음부터는 예외처리를 해야 한다.

## 결과 코드

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <string>
using namespace std;
int my[3] = { -1, 0, 1 };
int mx[3] = { 1, 1, 1 };
int map[10001][501];
int r, c, pn;

int dfs(int y, int x) {
	//기저 사례: 자신의 빵집에 도착한 경우(파이프라인이 만들어진 경우)
	if (x == c - 1) return 1;
	map[y][x] = pn;

	//갈 수 있는 경우 탐색
	for (int i = 0; i < 3; ++i) {
		int nexty = y + my[i];
		int nextx = x + mx[i];
		if (nexty < 0 || nexty >= r || nextx < 0 || nextx >= c)
			continue;
		if (map[nexty][nextx] == 0) {
			//파이프라인을 만들었다면 모든 재귀 함수를 빠져나간다.
			if (dfs(nexty, nextx))  //greedy
				return 1;
		}
	}

  //키포인트
	//한번 갈 수 없는 파이프라인이면 다음 파이프라인도 가지 못한다.
	//map[y][x] = 0;

	return 0;
}

int main(void)
{
	scanf("%d %d", &r, &c);
	for (int i = 0; i < r; ++i) {
		string input;
		cin >> input;
		for (int j = 0; j < c; ++j)
			if (input[j] == '.')
				map[i][j] = 0;
			else
				map[i][j] = -1;
	}

	int ans = 0;
	for (int i = 0; i < r; ++i) {
		//한 칸앞으로 가는길이 있는 경우에 파이프라인을 계산한다.
		if (!map[i + my[0]][1] || !map[i + my[1]][1]
			|| !map[i + my[2]][1]) {
			pn = ans + 1;
			ans += dfs(i, 0);
		}
	}

	printf("%d\n", ans);

	return 0;
}
```
