---
title: "[BOJ] 1941.소문난 칠공주"
excerpt: "BFS"
search: true
sidebar_main: true
use_math: true
categories:
  - PS
tags:
  - BOJ
---

# 소문난 칠공주

## 문제 링크
- [https://www.acmicpc.net/problem/1941](https://www.acmicpc.net/problem/1941)

## 해결 방법
### 조합 + BFS
문제를 읽고 처음에 바로 드는 생각은 DFS를 사용하여 각 인덱스마다 모두 탐색하면 해결할 수 있을 것이라 생각했다. 하지만 DFS를 사용하면 아래와 같은 구성에서는 찾을 수 없다.

```
S Y S Y S
  Y
  S
```

위는 문제 테스트 케이스에서의 한 구성이다. 이와 같이 십자 형태는 DFS를 사용한다면 지나온 길은 모두 ```FALSE```로 변경하거나 ```TRUE```인 칸은 지나지 못하기 때문에 탐색할 수 없다.

그러므로 다른 방법을 찾아야 한다. 문제에서 학생 수는 25명으로 고정되어 있고, 뽑아야 하는 학생 수도 7명으로 고정되어 있다. 이러한 상황에서 조합을 쓰기에 알맞다. 그리고 뽑은 7명의 구성이 가로나 세로로 인접하고 '이다솜파' 학생이 4명 이상인지 검사한다면 문제는 해결된다.

시간 복잡도는 25명에서 7명을 뽑는 경우의 수 ${25} \choose {7} = 480,700$ 이고, 서로 인접한지 검사를 BFS를 사용하면 배열 크기가 ```5 X 5```이므로 25이다. 총 480,700 * 25 = 12,017,500로 시간안에 해결 가능하다.

## 결과 코드

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <string>
#include <cstring>
#include <queue>
using namespace std;
int my[4] = { 0, 1, 0, -1 };
int mx[4] = { 1, 0, -1, 0 };
string classroom[6];
//check: 조합으로 계산한 7명을 표시하는 배열
//visited: 방문한 것을 표시하는 배열
bool check[6][6], visited[6][6];
queue<pair<int, int>> q;

int main(void)
{
	for (int i = 0; i < 5; ++i)
		cin >> classroom[i];

	int ans = 0;
	//조합 설정
	vector<bool> flag;
	for (int i = 0; i < 25 - 7; ++i)
		flag.push_back(0);
	for (int i = 0; i < 7; ++i)
		flag.push_back(1);
	//조합 탐색
	do {
		//초기화
		memset(check, false, sizeof(check));
		memset(visited, false, sizeof(visited));

		int sn = 0;
		pair<int, int> pos;
		//계산된 7명 표시 및 '이다솜파' 수 계산
		for (int i = 0; i < 25; ++i)
			if (flag[i]) {
				pos = { i / 5, i % 5 };
				check[i / 5][i % 5] = true;
				if (classroom[i / 5][i % 5] == 'S') sn += 1;
			}

		//이다솜파가 4명보다 적으면 다음으로 넘어간다.
		if (sn < 4) continue;

		//7명이 모두 인접한지 BFS를 통해 구한다.
		q.push(pos);
		int cn = 1;
		visited[pos.first][pos.second] = true;
		//BFS
		while (!q.empty()) {
			int nowy = q.front().first;
			int nowx = q.front().second;
			q.pop();
			for (int i = 0; i < 4; ++i) {
				int nexty = nowy + my[i];
				int nextx = nowx + mx[i];
				if (nexty < 0 || nexty >= 5 || nextx < 0 || nextx >= 5)
					continue;
				//7명 중의 하나이고 아직 방문하지 않은 경우
				if (check[nexty][nextx] && !visited[nexty][nextx]) {
					cn += 1;
					visited[nexty][nextx] = true;
					q.push({ nexty, nextx });
				}
			}
		}

		//인접한 학생이 7명인 경우
		if (cn == 7) ans++;
	} while (next_permutation(flag.begin(), flag.end()));
	printf("%d\n", ans);

	return 0;
}
```
