---
title: "[BOJ] 15684.사다리 조작"
excerpt: "완전 탐색"
search: true
sidebar_main: true
categories:
  - Algorithm
tags:
  - Algorithm_BOJ
---

# 사다리 조작

## 문제 링크
- [https://www.acmicpc.net/problem/15684](https://www.acmicpc.net/problem/15684)
- 삼성 SW 역량 테스트 기출 문제

## 해결 방법
### 완전 탐색
- 가로선을 0개, 1개, 2개, 3개 순서대로 모든 경우의 수마다 세로선에서 출발하여 같은 세로선에 도착하는지 검사한다.
- 사다리를 내려오는 시뮬레이션은 2차원 배열에서 행이 가로선이고 열을 세로선으로 둔다. 그리고 각각의 인덱스에서 가로선이 있다면 두 세로선을 연결한다는 의미이므로, 두 세로선 역할을 하는 두 열에서 앞 인덱스는 ```+1```값을 넣어주고 뒤 인덱스에 ```-1```값을 넣어준다. 문제의 예제 3번의 사다리를 배열로 나타내면 아래와 같다.

|   	| 1 	|  2 	|  3 	|  4 	|  5 	|
|:-:	|:-:	|:--:	|:--:	|:--:	|:--:	|
| **1** 	| 1 	| -1 	|  0 	|  0 	|  0 	|
| **2** 	| 0 	|  0 	|  1 	| -1 	|  0 	|
| **3** 	| 0 	|  1 	| -1 	|  0 	|  0 	|
| **4** 	| 0 	|  0 	|  0 	|  0 	|  0 	|
| **5** 	| 1 	| -1 	|  0 	|  1 	| -1 	|
| **6** 	| 0 	|  0 	|  0 	|  0 	|  0 	|

- 사다리 타기는 한 열에서 바로 아래의 행으로 내려가면서 그 인덱스를 더하여 나오는 값이 그 다음 열 번호이다.
- 가로선을 추가하는 알고리즘은 문제의 조건을 맞추고, 셀 필요없는 경우를 가지치기하여 시간을 줄여야 한다.
  - 먼저, 문제의 조건에서는 연속해서 가로선을 놓을 수 없으므로 현재 열 인덱스와 한 칸 뒤 열 인덱스 모두 ```0```일 때 가로선을 만들 수 있다.
  - 가로선을 2개 만드는 경우부터는 이미 만들어진 가로선의 행 인덱스 이후부터 만들면 된다.

  > 시간이 더 짧게 걸린 코드들을 봤을 때, 현재 조건보다 더 추가할 것이 있는 것으로 보인다.

## 결과 코드

```cpp
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;

int ladder[32][12];
int n, m, h;

bool ladderSimul() {
	bool flag = true;
	for (int i = 1; i <= n; ++i) {
		int move = i;
		for (int j = 0; j <= h; ++j)
			move += ladder[j][move];
		if (move != i) {
			flag = false;
			break;
		}
	}
	return flag;
}

int main()
{
	scanf("%d %d %d", &n, &m, &h);
	for (int i = 0; i < m; ++i) {
		int a, b; scanf("%d %d", &a, &b);
		ladder[a][b] = 1;
		ladder[a][b + 1] = -1;
	}

	//가로선 0개 설치
	if (ladderSimul()) {
		printf("0\n");
		return 0;
	}

	//가로선 1개 설치
	for (int i = 1; i <= h; ++i) {
		for (int j = 1; j < n; ++j) {
			//가로선이 연속한지 검사
			if (!ladder[i][j] && !ladder[i][j + 1]) {
				//사다리를 만든다.
				ladder[i][j] = 1;
				ladder[i][j + 1] = -1;
				//사다리 타기
				if (ladderSimul()) {
					printf("1\n");
					return 0;
				}
				//사다리를 지운다.
				ladder[i][j] = 0;
				ladder[i][j + 1] = 0;
			}
		}
	}

	//가로선 2개 설치
	for (int i = 1; i <= h; ++i) {
		for (int j = 1; j < n; ++j) {
			if (!ladder[i][j] && !ladder[i][j + 1]) {
				ladder[i][j] = 1;
				ladder[i][j + 1] = -1;

				//이미 만들어진 가로선 이후부터 만든다.
				for (int i2 = i; i2 <= h; ++i2) {
					for (int k = 1; k < n; ++k) {
						if (!ladder[i2][k] && !ladder[i2][k + 1]) {
							ladder[i2][k] = 1;
							ladder[i2][k + 1] = -1;
							if (ladderSimul()) {
								printf("2\n");
								return 0;
							}
							ladder[i2][k] = 0;
							ladder[i2][k + 1] = 0;
						}
					}
				}

				ladder[i][j] = 0;
				ladder[i][j + 1] = 0;
			}
		}
	}

	//가로선 3개 설치
	for (int i = 1; i <= h; ++i) {
		for (int j = 1; j < n; ++j) {
			if (!ladder[i][j] && !ladder[i][j + 1]) {
				ladder[i][j] = 1;
				ladder[i][j + 1] = -1;

				for (int i2 = i; i2 <= h; ++i2) {
					for (int k = 1; k < n; ++k) {
						if (!ladder[i2][k] && !ladder[i2][k + 1]) {
							ladder[i2][k] = 1;
							ladder[i2][k + 1] = -1;

							for (int i3 = i2; i3 <= h; ++i3) {
								for (int l = 1; l < n; ++l) {
									if (!ladder[i3][l] && !ladder[i3][l + 1]) {
										ladder[i3][l] = 1;
										ladder[i3][l + 1] = -1;
										if (ladderSimul()) {
											printf("3\n");
											return 0;
										}
										ladder[i3][l] = 0;
										ladder[i3][l + 1] = 0;
									}
								}
							}

							ladder[i2][k] = 0;
							ladder[i2][k + 1] = 0;
						}
					}
				}

				ladder[i][j] = 0;
				ladder[i][j + 1] = 0;
			}
		}
	}

	printf("-1\n");

	return 0;
}
```
