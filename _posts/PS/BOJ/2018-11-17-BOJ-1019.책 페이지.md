---
title: "[BOJ] 1019.책 페이지"
excerpt: "수학"
search: true
sidebar_main: true
categories:
  - PS
tags:
  - BOJ
---

# 책 페이지

## 문제 링크
- [https://www.acmicpc.net/problem/1019](https://www.acmicpc.net/problem/1019)

## 해결 방법
### 수학
문제는 입력 값이 주어지면 1 ~ 입력 값까지 숫자 0 ~ 9까지 총 몇 번나오는지 출력하는 문제이다. 입력 값이 10억이하의 숫자이므로 1 부터 순차 탐색하면 최소 10억 번 계산을 해야 하기 때문에 시간 초과이다.

시간 초과를 해결하기 위해 자릿 수마다 숫자가 얼만큼 나왔는지 탐색한다.

예를 들어, ```2345``` 숫자가 입력 값으로 주어졌다고 가정하자.

- 일의 자리: ```5```
- 십의 자리: ```4```
- 백의 자리: ```3```
- 천의 자리: ```2```

위와 같이 자릿 수 별로 나눌 수 있다. 각 자리 수를 계산할 때는 1부터 2345가 가질 수 있는 모든 해당 자리 수를 구한다.

일의 자리 수를 구한다고 하면, [1, 2339(= 2345 / 10 - 1)] 범위에서는 1 ~ 9까지 각각 **234** 번이 나오는 것을 알 수 있다. 그리고 0은 1부터 시작하므로 총 **233** 나온다. 이를 수식으로 나타내면 아래와 같다.
- ```0```: 2345 / 10 - 1 번
- ```1```: 2345 / 10 번
- ```2```: 2345 / 10 번
- ...

아직 [2340 ~ 2345] 범위가 남아 있다. 이는 0, 1, 2, 3, 4, 5 가 각각 한 번 씩 나온다.
- 2345 % 10 = 5 를 계산하면 0 ~ 5까지 한 번씩 더 남아있는 것을 알 수 있다.

십의 자리는 일의 자리를 구할 때와 조금 다르다. 예를 들어, [10, 19]에서 십의 자리가 1인 숫자는 총 10번 나온다. 이는 2 ~ 9까지도 마찬 가지이다. 그리고 십의 자리수에서 0으로 시작하는 숫자는 없으며, 백의 자리 수부터 0으로 시작하는 십의 자리가 존재한다.

숫자 [1, 2229(= 2345 / 100 - 1)] 에서 십의 자리가 0일 때는 0이 출현하는 횟수는 ```100, 200, 300, ... 2200```이고 각각 마다 총 10개가 있으므로, **22 * 10** 개가 존재한다. 십의 자리가 1일 때는 ```10, 110, 210, 310, ... 2210```으로 **23 * 10** 개가 있다.
- ```0```: (2345 / 100 - 1) * **10** 번
- ```1```: 2345 / 100 * **10** 번
- ```2```: 2345 / 100 * **10** 번
- ...

그리고 2300 ~ 2345까지는 [2300, 2309], [2310, 2319], [2320, 2329], [2330, 2339], [2340, 2345]로 0, 1, 2, 3이 각각 10개씩있고, 4가 5개 나오는 것을 알 수 있다.

백의 자리는 십의 자리와 똑같이 구할 수 있다.

마지막으로 천의 자리 숫자는 2이므로 1과 2인 경우 2가지가 있다.
- ```1```: [1000, 1999] 로 **1000** 개가 존재한다.
- ```2```: [2000, 2345] 로 346 개가 존재한다.

총 정리하면 각 자리수의 출현 횟수를 구하는 것은 자릿수 마다 **정확히 나누어 떨어진 경우** 를 제외하면 3가지로 나눌 수 있다.
1. 가장 오른쪽 자릿수(일의 자리)
2. 중간 자릿수(가장 오른쪽과 가장 왼쪽 자릿수를 제외한 자릿수)
3. 가장 왼쪽 자릿수


## 결과 코드

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstdio>
#include <string>
using namespace std;
//각 숫자가 몇 번 나오는지 저장하는 배열
int num_count[10] = { 0, };

//제곱근 계산
int Pow(int n, int d) {
	int ret = 1;
	for (int i = 0; i < d; ++i)
		ret *= n;
	return ret;
}
int main(void)
{
	string num;
	cin >> num;
	int len = num.size();
	int n = atoi(num.c_str());
	//각 자리수일 때 해당 숫자가 몇번 나오는지 계산
	//i = 0: 일의 자리에서 해당 숫자가 몇 번 나왔는지 계산 ...
	for (int i = 0; i < len; ++i) {
		int div = Pow(10, i + 1);
		int tenAmp = i == 0 ? 1 : Pow(10, i);
		int share = n / div;
		int remainder = n % div;
		// 0)
		if (share > 0) {
			num_count[0] += (share - 1) * tenAmp;
			for (int j = 1; j < 10; ++j)
				num_count[j] += (share * tenAmp);
			// 1)
			if (i == 0) {
				for (int j = 0; j <= remainder; ++j)
					num_count[j] += tenAmp;
			}
			// 2)
			else {
				div = Pow(10, i);
				int nextShare = remainder / div;
				int nextRem = n % div;
				for (int j = 0; j < nextShare; ++j)
					num_count[j] += tenAmp;
				num_count[nextShare] += (nextRem + 1);
			}
		}
		// 3)
		else if(share == 0 && remainder > 0) {
			div = Pow(10, i);
			int nextShare = n / div;
			int nextRem = n % div;
			num_count[nextShare] += (nextRem + 1);
			for (int j = 1; j < nextShare; ++j)
				num_count[j] += tenAmp;
		}
	}

	for (int i = 0; i < 10; ++i)
		printf("%d ", num_count[i]);
	printf("\n");

	return 0;
}
```
