---
title: "[DataStructure]배열과 리스트"
excerpt: "동적 배열과 연결 리스트 차이"
search: true
categories:
  - Algorithm
tags:
  - Algorithm_DataStructure
toc: true
sidebar_main: true
---

# 선형 자료 구조

## 동적 배열(dynamic array)
- 동적 배열은 일반 배열을 이용해 만든 별도의 자료구조이다.
  - 대부분 언어의 표준 라이브러리에 포함되어 있다.
- 일반 배열의 특징(동적 배열 포함)
  - 원소들은 메모리의 연속된 위치에 저장된다.
  - 주어진 위치의 원소를 반환하거나 변경하는 동작을 ```O(1)```에 할 수 있다.
- 동적 배열만의 특징
  - 배열의 크기를 변경하는 ```reaize()``` 연산이 가능하다.
    - 이 동작을 수행하는데 배열의 크기 N에 비례하는 시간이 소요된다.
  - 주어진 원소를 배열의 맨 끝에 추가함으로써 크기를 1 늘리는 ```append()``` 연산을 지원한다.
    - 이 동작을 수행하는데 상수 시간 1이 소요된다.
- ```append()``` 연산의 원리
  - ```append()```연산이 상수 시간이 걸리는 이유
    - 메모리를 할당받을 때 배열의 크기가 커질때를 대비해서 여유분의 메모리를 미리 할당받아 둔다.
  - capacity: 이미 할당받은 메모리의 크기(배열의 용량)
  - size:  실제 원소 개수(배열의 크기), 프로그램이 실제 인식하는 배열의 크기

  ![append1](https://user-images.githubusercontent.com/34755287/43872286-f21984ec-9bbb-11e8-8991-2c705dbe8e59.JPG)

  - 미리 할당해둔 메모리가 꽉 찼을 때, ```append()```연산을 할 경우 재할당이 필요하다.
    - 일반적인 재할당 코드의 시간 복잡도는 ```O(N + M)```으로 선형 시간이 소요된다.(M: 추가할 메모리 크기)
    - 하지만, 재할당을 할때 정해진 개수(M)로 추가하는 것이 아니라 **현재 가진 원소의 개수에 비례해서 여유분을 확보**하면 평균적으로 ```O(1)```의 시간 복잡도로 ```append()```연산을 수행할 수 있다.
  - ```append()```를 여러 번 수행할 때, 배열의 최종 크기를 미리 알 수 있다면, 동적 배열의 용량(capacity)를 미리 늘려둠으로써 재할당에 드는 비용을 없애는것이 좋다.
    - 동적 배열을 사용했을 때 느려지는 대부분의 이유이다.
- 동적 배열은 c++의 ```vector```, C#과 Java에서 ```ArrayList```로 표준 라이브러리에서 제공한다.

## 연결 리스트(linked list)
- 연결 리스트는 배열과 달리 원소들이 메모리 여기저기 흩어져 있고, 각 원소들이 이전과 다음 원소를 가르키는 포인터(양방향 리스트) 방식으로 구현된다.
- 일반적인 노드(node) 구조체

```cpp
struct ListNode {
  int element;            //담고 있는 원소
  ListNode *prev, *next;  //이전 노드, 다음 노드의 포인터
}
```

- 연결 리스트는 첫 번째 노드와 마지막 노드에 대한 포인트를 가지는데, 이들을 각각 머리(head)와 꼬리(tail)이라고 부른다.
  - 머리와 꼬리를 포인터가 아니라 값이 정의되지 않는 텅 빈 노드(더미 노드)로 두면, 항상 이전 노드와 다음 노드가 존재한다고 가정할 수 있기 때문에 구현이 더욱 간단해진다.
- 연결 리스트의 특징
  - 노드들이 메모리 여기저기에 흩어져 있기 때문에 특정 위치 값을 찾기 힘들다.
    - 리스트의 머리부터 꼬리까지 포인터를 따라 가며 탐색해야 하기 때문에 선형 시간이 소요된다.
  - 노드의 삽입, 삭제가 간단하다.
    - 삽입, 삭제될 해당 노드의 이전 노드와 다음 노드의 포인트만 바꿔주면 된다.
- 연결 리스트 응용 연산들
  - 잘라 붙이기 연산(splicing): 두 개의 서로 다른 리스트에서 각각의 일부 리스트를 서로 잘라서 붙이는 연산이다.
    - 시간 복잡도는 리스트의 길이인 선형 시간에 비례하며, 잘라 붙였을 때의 크기를 알 수 없어 불안정하다.
  - 삭제했던 원소 돌려놓기(undo)
  - 두 연산은 대부분 표준 라이브러리에서 제공하지 않는다.
- 연결 리스트는 C++의 ```list```, C#과 java의 ```LinkedList```로 표준 라이브러리에서 제공한다.

## 동적 배열과 연결 리스트 비교
- 동적 배열
  - 임의의 원소에 빠르게 접근 가능하다.
  - 원소들이 메모리에 연속해 배치되어 있어 CPU 캐시의 효율을 높여준다.
  - 삽입과 삭제가 거의 없고, 끝에 추가만 하면 될 경우에 활용하기 좋다.
- 연결 리스트
  - 삽입과 삭제가 빠르다.
  - 삽입과 삭제가 많이 수행하는 작업에 활용하기 좋다.

  |                  작업                  | 동적 배열 |         연결 리스트        |
  |:--------------------------------------:|:---------:|:--------------------------:|
  |        이전 원소/다음 원소 찾기        |    O(1)   |            O(1)            |
  |       맨 뒤에 원소 추가/삭제하기       |    O(1)   |            O(1)            |
  | 맨 뒤 이외의 위치에 원소 추가/삭제하기 |    O(N)   |            O(1)            |
  |         임의의 위치의 원소 찾기        |    O(1)   |            O(N)            |
  |               크기 구하기              |    O(1)   | O(N), 구현에 따라 O(1)가능 |
