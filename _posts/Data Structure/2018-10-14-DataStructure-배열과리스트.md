---
title: "[DataStructure]동적 배열과 연결 리스트"
excerpt: "동적 배열과 연결 리스트의 각 특징 및 차이"
categories:
  - Algorithm
tags:
  - Algorithm_DataStructure
search: true
sidebar_main: true
toc: true
use_math: true
---

# 선형 자료 구조

## 동적 배열(dynamic array)
일반 배열의 가장 큰 문제점은 배열의 크기가 고정되어 그 이상의 자료를 집어넣을 수 없다는 점이다. 이를 해결하기 위해 고안된 것이 자료의 개수가 변함에 따라 크기가 변경되는 동적 배열이다. 동적 배열은 언어 차원에서 지원하는 것이 아니라 일반 배열을 이용하여 만들어 낸 별도의 자료 구조이다. 때문에 동적 배열은 대부분 언어의 표준 라이브러리에 포함되어 있다. 동적 배열의 특징은 다음과 같다.

- 일반 배열과 동적 배열의 공통적인 특징
  - 원소들은 메모리의 연속된 위치에 저장된다. (이는 캐시 효율성을 높여준다.)
  - 주어진 위치의 원소를 반환하거나 변경하는 동작을 O(1)에 수행가능하다.
- 동적 배열만의 특징
  - 배열의 크기를 변경하는 ```resize()``` 연산이 가능하다. 이 동작은 수행하는 데 배열의 크기 N에 비례하는 시간이 걸린다.
  - 주어진 원소를 배열의 맨 끝에 추가함으로써 크기를 1 늘리는 ```append()``` 연산을 지원한다. 이 동작은 수행하는 데는 상수 시간이 걸린다.

이와 같은 동작을 위해 동적 배열은 내부적으로 동적으로 할당 받은 배열(new 나 malloc 으로 할당받은 배열)을 사용한다.

- ```resize()```
배열 크기를 변경하는 ```resize()``` 연산은 단순하게 새 배열을 동적으로 할당받은 뒤 기존 원소들을 복사하고, 새 배열을 참조하도록 바꿔치기한다. 따라서 동적 배열 클래스는 아래와 같은 정보를 저장하고 있어야 한다.

```cpp
int size;             //배열 크기
ElementType* array;   //실제 배열을 가리키는 포인터
```

새 배열을 할당받고 기존 자료를 복사하는 데는 배열의 크기에 비례하는 시간이 걸리므로, 시간복잡도는 O(N) 이다.

- ```append()```
이 연산이 상수 시간으로 구현하기 위해서는 몇 가지 전략이 필요하다. 기본적으로 동적 배열은 메모리를 할당받을 때 배열의 크기가 커질 때를 대비하여 여유분의 메모리를 미리 할당받는다.

![append1](https://user-images.githubusercontent.com/34755287/43872286-f21984ec-9bbb-11e8-8991-2c705dbe8e59.JPG)

위의 그림에서 볼 수 있듯이 실제 배열의 크기는 size 이고, 여유분의 메모리까지 합친 배열의 용량은 capacity 로 표현한다. 이러한 전략으로 ```append()``` 연산은 아래와 같이 상수 시간으로 간단히 구현할 수 있다.

```cpp
array[size++] = newValue;
```

하지만, 문제는 capacity 까지 배열이 찬 상태에서 ```append()``` 연산을 수행하는 것이다. 이러한 상황에서는 필수적으로 기존 배열보다 큰 배열로 옮겨주는 작업이 필요하다.

```cpp
//배열 용량이 꽉 찬  경우 재할당받는다.
if (size == capacity) {
  //용량을 M 만큼 늘린 새 배열을 할당받는다.
  int newCapacity = capacity + M;
  int* newArray = new int[newCapacity];

  //기존의 자료를 복사한다.
  for (int i = 0; i < size; ++i)
    newArray[i] = array[i]

  //기존 배열을 삭제하고 새 배열로 바꾼다.
  if (array) delete [] array;
  array = newArray;
  capacity = newCapacity;
}

//배열의 끝에 원소를 삽입한다.
array[size++] = newValue;
```

여기서 M 을 어떻게 설정할지에 따라 시간복잡도가 결정된다. 먼저, 단순하게 M 을 100, 1000 으로 설정하는 것과 같이 정해진 개수로 늘린다고 하자. 이 경우는 재할당마다 복사하는 원소의 수는 M개, 2M개, ..., KM개로 증가하므로, N번의 ```append()``` 연산은 총 O($N^2$) 이 소요된다. 이를 한 번의 ```append()``` 연산에 드는 시간은 평균적으로 O(N) 이 된다. 따라서 이런 재할당 전략은 상수 시간에 해결할 수 없다. 상수 시간에 ```append()``` 를 구현하기 위해서는 재할당을 할 때마다 정해진 개수의 여유분이 아니라, **현재 가진 원소의 개수에 비례해서 여유분을 확보** 하는 것이다. 예를 들어, 재할당을 할 때마다 현재 용량의 두 배로 늘리는 것이다. 이러한 방법을 사용하면 ```append()``` 연산을 N번 실행하는 수행 시간은 O(N)이 되고, 한 번 연산에 드는 시간은 평균적으로 O(1)이 된다.

대표적으로 C 언어를 제외한 대부분의 언어는 동적 배열을 표준 라이브러리에서 제공한다. C++의 vector, 자바나 C#의 ArrayList 등이 그 예이다. 이들은 내부적으로 배열을 사용하므로 배열과 속도에서 차이가 거의 없다.

동적 배열 사용에서 한 가지 팁은, ```append()``` 연산을 여러 번 수행할 때 배열의 최종 크기가 얼마일지 미리 짐작할 수 있다면, 동적 배열의 용량(capacity)을 미리 늘려둠으로써 재할당 비용을 없앨 수 있다. 대부분의 동적 배열 구현체들은 이와 같은 연산을 지원한다. (이는 일반 배열에서 동적 배열로 교체했을 때, 훨씬 느려지는 현상을 해결하는 하나의 방법으로 볼 수 있다.)


## 연결 리스트(Linked List)
배열은 원소들의 순서를 유지하면서 임의의 위치에 원소를 삽입하거나, 삭제하는 작업 시간이 오래 걸린다. 해당 위치 뒤에 있는 원소들을 한 칸 앞 또는 뒤로 옮겨야 하기 때문이다. 즉, 선형 시간에 비례한다. 이를 해결하기 위해 고안된 자료 구조가 연결 리스트이다. 배열과 다르게 특정 위치에서 삽입, 삭제를 상수 시간에 할 수 있다. 이는 연결 리스트가 원소들이 메모리 여기 저기 흩어져 있고 서로 포인터로 연결되어 있기 때문이다. 연결 리스트의 원소는 실제 값 뿐아니라 자신의 이전 원소와 다음 원소를 가리켜야 하므로 그에 대한 포인터 정보 역시 가지고 있어야 한다. 이러한 집합을 노드(node)라고 부르며, 아래와 같다.

```c
struct ListNode {
  int element;             //담고 있는 원소
  ListNode *prev, *next;   //이전 노드, 다음 노드의 포인터
};
```

연결 리스트는 대부분 첫 번재 노드와 마지막 노드를 가리키는 포인터인 head, tail 을 가지고 있다.(구현에 따라 다르지만, 편의성을 위해 head, tail 이 텅 빈 노드를 가리키게 구현하기도 한다. 이는 항상 이전 노드와 다음 노드가 존재하는 것을 보장한다.)

이러한 구현적 특징 때문에 연결 리스트는 다음과 같은 특징을 갖는다.
- 노드들이 메모리 여기저기 흩어져 있기 때문에 특정 위치를 찾으려면, head 부터 시작해 하나씩 포인터를 따라가야 한다. 이는 리스트의 길이에 선형 비례하게 된다.
- 리스트의 순서를 유지하면서 새 노드를 삽입하거나 기존 노드를 삭제하는 작업은 매우 간단하다. 해당 노드 앞, 뒤 노드의 포인터만 바꿔주면 되므로 상수 시간에 이루어진다.

연결 리스트 역시 대부분 언어의 표준 라이브러리에서 제공한다. C++은 list, C#은 LinkedList 가 있다.

연결 리스트의 구현적 특징을 이용해 몇 가지 응용 연산이 가능하다. 이는 사용 범위가 매우 제한적이고 트릭에 가깝기 때문에 대부분 표준 라이브러리에서 제공하지는 않는다. 간단히 무엇이 있고, 특징만을 알아보자.
- 잘라 붙이기 연산(splicing): 두 개의 서로 다른 리스트에서 각각의 일부 리스트를 서로 잘라서 붙이는 연산이다. 이 연산의 문제점은 결과 리스트의 크기를 상수 시간에 알 수 없다는 것이다. 즉, 모든 리스트를 순회하여 알아내야 한다.
- 삭제했던 원소 돌려놓기(undo): 연결 리스트는 한 번 삭제했던 원소를 제자리에 쉽게 돌려 놓을 수 있다. 연결 리스트의 삭제는 포인터의 연결만 해제할 뿐 노드의 정보는 변하기 않기 때문이다. 한 가지 주의할 점은 항상 삭제한 순서의 반대로 복구를 해야한다.(리스트가 망가질 수 있으므로)

```
// node 이전/이후 노드의 포인터를 바꿔서 node를 리스트에서 삭제한다.
void deleteNode(ListNode* node) {
  node->prev->next = node->next;
  node->next->prev = node->prev;
}
// node 이전/이후 노드의 포인터를 바꿔서 자기 자신을 다시 리스트에 삽입한다.
void recoverNode(ListNode* node) {
  node->prev->next = node;
  node->next->prev = node;
}
```

## 동적 배열과 연결 리스트 비교
- 동적 배열
  - 임의의 원소에 빠르게 접근 가능하다.
  - 원소들이 메모리에 연속해 배치되어 있어 CPU 캐시의 효율을 높여준다.
  - 삽입과 삭제가 거의 없고, 끝에 추가만 하면 될 경우에 활용하기 좋다.
- 연결 리스트
  - 삽입과 삭제가 빠르다.
  - 모든 원소들을 순회하며 삽입과 삭제를 많이 수행하는 작업에 활용하기 좋다.

  |                  작업                  | 동적 배열 |         연결 리스트        |
  |:--------------------------------------:|:---------:|:--------------------------:|
  |        이전 원소/다음 원소 찾기        |    O(1)   |            O(1)            |
  |       맨 뒤에 원소 추가/삭제하기       |    O(1)   |            O(1)            |
  | 맨 뒤 이외의 위치에 원소 추가/삭제하기 |    O(N)   |            O(1)            |
  |         임의의 위치의 원소 찾기        |    O(1)   |            O(N)            |
  |               크기 구하기              |    O(1)   | O(N), 구현에 따라 O(1)가능 |
