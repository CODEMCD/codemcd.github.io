---
title: "[운영체제] # 3 이중모드와 보호"
excerpt: "최신 업데이트 날짜: 2019-03-06"
date: 2019-03-06 14:09:00
categories:
  - Study
tags:
  - Study_OperatingSystem
search: true
toc: true
sidebar_main: true
---

현재 컴퓨터 환경은 여러 사람이 동시에 한 컴퓨터를 사용하는 경우가 많다.(서버 컴퓨터) 그리고 그 외에도 한 컴퓨터내에서 여러 프로그램을 수행하는 것이 일반적이다. 이 때 한 컴퓨터나 한 프로그램에서 잘못된 동작으로 인해 다른 컴퓨터(프로그램)가 영향을 받는다면 이는 매우 위험하다.

예를 들어, 한 프로그램에서 고의 또는 실수로 ```STOP```, ```HALT```, ```RESET``` 과 같은 명령어로 전체 컴퓨터의 동작이 멈추거나 꺼지는 경우가 있다.

이런 문제점을 해결하기 위해 일반 사용자가 위와 같은 치명적인 명령어들을 요청하는 것을 막을 필요가 생겼다. 여기서 **이중 모드** 라는 것이 나왔다.

# 이중 모드(Dual mode)
이중 모드는 말 그대로 모드를 아래와 같이 둘로 나누는 것이다.
- **사용자(User) 모드**
- **관리자(Supervisor) 모드** = 시스템(system) 모드 = 모니터(monitor) 모드 = 특권(privileged) 모드

특권 모드에서만 내릴 수 있는 명령을 **특권 명령(privileged instruction)** 이라고 하며, ```STOP```, ```HALT```, ```RESET```, ```SET_TIMER``` 등이 있다. 만약 사용자 모드에서 특권 명령을 사용하려고 하면 CPU에서 내부 인터럽트를 발생시켜 해당 명령어를 요청한 프로그램을 강제로 종료시킨다.

이중 모드는 CPU 내부의 레지스터(register)의 비트(bit)를 활용하여 플래그(flag)로 나타낸다. 예를 들어 특권 모드일 때는 비트 값이 ```0``` 이고, 사용자 모드일 때는 비트  값을 ```1``` 로 설정하여 구분한다.

컴퓨터가 켜진 뒤에 한 사용자 애플리케이션을 실행시키는 동안 모드가 어떻게 변하는지 살펴보자.
1. 컴퓨터 부팅 과정            - 관리자 모드
2. 애플리케이션 실행 과정      - 관리자 모드
3. 애플리케이션 실행중         - 사용자 모드
4. 인터럽트 발생 후 처리 과정  - 관리자 모드
5. 인터럽트 처리 후            - 사용자 모드

사용자가 하드웨어의 자원에 접근하는 것은 매우 위험한 동작이다. 그러므로 이러한 경우에는 **모두 관리자 모드로 운영체제에서 처리하도록 한다.** (프로그램에서 소프트웨어 인터럽트를 발생시켜 운영체제에 위임한다.)

위의 4번 과정을 하드웨어 인터럽트로 가정하고 자세히 살펴보면 아래와 같다.
- 하드웨어 인터럽트 발생 후 CPU로 인터럽트 신호 요청 (사용자 모드)
- CPU에서 모드 플래그를 **관리자 모드** 값으로 설정
- 해당 하드웨어 인터럽트 서비스 루틴(ISR)으로 이동 (관리자 모드)
- 인터럽트 처리 (관리자 모드)
- 인터럽트 처리 완료 후 CPU의 모드 플래그를 다시 **사용자 모드** 값으로 설정
- 원래의 애플리케이션 위치로 복귀 (사용자 모드)

![os03-1](https://user-images.githubusercontent.com/34755287/53879654-5c353e80-4052-11e9-9f5a-275642a1ed1d.png)

애플리케이션이 실행하는 동안에는 위와 같은 모드 변경이 반복적으로 일어나는 것을 볼 수 있다. 대부분의 CPU는 이중 모드를 지원한다.


# 하드웨어 보호
이중 모드는 운영체제 기능 중에서 보호에 해당된다. 운영체제에서 보호할 대상은 입출력 장치, 메모리, CPU 총 세 가지가 존재한다.

## 입출력 장치 보호
여러 정보들은 입출력 장치를 통해 컴퓨터로 입력되고, 외부 장치로 출력이 된다. 여기서 크게 두 가지의 문제점이 발생한다.
- 여러 입출력 장치의 사용으로 인한 혼선
- 사용자가 자신의 데이터가 아닌 다른 사용자의 데이터에 입출력을 하는 일
위와 같이 입출력 장치에 여러 사용자의 데이터가 뒤엉켜서 들어오거나 다른 사용자의 데이터에 접근하려는 경우를 막아야 한다.

이를 해결하기 위해 ```in```, ```out``` 과 같은 **입출력 명령을 특권 명령으로** 설정하는 것이다. 즉, 사용자 애플리케이션에서 입출력을 사용하려면 운영체제를 통해서 수행해야한다.(소프트웨어 인터럽트) 여러 프로그램이 동시에 입출력을 사용하려고 하면 운영체제 내부에서 순서를 정하여 혼선을 막아줄 수 있다.

만약 A, B 사용자가 있는 상황에서 A가 B의 데이터를 읽기 위해 운영체제에게 소프트웨어 인터럽트를 발생하였다고 하자. 그러면 운영체제 내부의 해당 ISR로 이동하게 되는데, 여기서 현재 사용자가 해당 데이터가 접근할 수 있는 여부를 판단하는 과정이 있으므로 이는 거부된다.

## 메모리 보호
메모리에는 운영체제뿐만 아니라 여러 개의 사용자 애플리케이션이 존재한다. 한 애플리케이션이 자신의 메모리 영역이 아닌 운영체제나 다른 애플리케이션의 메모리 영역에 침범하려하면 매우 위험하다.

![os03-2](https://user-images.githubusercontent.com/34755287/53879655-5c353e80-4052-11e9-8ec6-8b247850f347.png)

메모리는 일반적으로 위와 같이 구성되어 있을 것이다. 여기서 user1이 OS나 user2, user3에 접근하는 것을 막아야 한다. CPU는 address bus를 통해 메모리 주소에 접근하게 되는데, user1 프로그램이 실행되는 동안에는 user1이 할당되어 있는 메모리 주소 범위 안인 경우에만 접근하면 될 것이다. 이를 address bus에서 검사하는 것이 가장 효율적일 것이다.

![os03-3](https://user-images.githubusercontent.com/34755287/53879656-5c353e80-4052-11e9-901c-8fcf9c2b5e56.png)

위의 생각으로 나온 것이 **MMU(Memory Management Unit)** 이다. MMU는 위의 그림처럼 address bus 중간에 설치된 하드웨어 칩으로서 두 개의 레지스터를 통해 해당 프로그램의 주소 범위를 저장한다.

예를 들어, User1의 시작 주소는 1024, 끝 주소는 4048이라고 하자. User1이 수행되는 동안 운영체제는 해당 프로그램의 주소 범위를 MMU에 설정(**특권 명령**)하는데, base는 1024, limit는 4048이 될 것이다. 결과적으로 user1이 수행되는 동안에는 이 범위 안의 주소값인 경우에만 address bus를 통과시킨다.

만약 해당 프로그램의 주소 범위 밖의 주소값이 MMU에 들어온다면, MMU에서 **내부 인터럽트** 를 발생시켜 CPU에 신호를 준다. 그러면 CPU는 그에 맞는 ISR로 이동하여 해당 프로그램을 강제로 종료시킨다. 이과 같은 잘못된 메모리 접근을 Segment violation 이라 한다.

## CPU 보호
CPU 보호는 사용자의 실수 또는 고의로 인한 CPU 독점을 방지해야 한다. 하나의 프로그램이 CPU를 독점하게 되면 다른 프로그램은 수행되지 못한다.

```cpp
while(n = 1)
{
  // ...
}
```

CPU를 독점하는 가장 대표적인 예는 **무한 반복** 이다. 위의 코드를 보면 while문의 조건문이 잘못된 것을 볼 수 있다. 비교 연산자가 아닌 대입 연산자를 사용하여 n값이 1이 되므로 while문의 조건은 TRUE가 된다. 이는 n값이 변하지 않는 이상 무한으로 반복된다.

이를 해결하는 방법은 **Timer를 두어 일정 시간이 지나면 타이머 인터럽트** 를 발생시킨다. 인터럽트가 발생하면 반드시 운영체제 내의 ISR로 이동하므로, 해당 ISR에서 각 프로그램의 CPU 점유 시간을 측정하여 적절히 분배되도록 조정한다.

예를 들어, 한 프로그램의 CPU 점유 시간이 비정상적으로 오래 걸리는 경우, 강제로 다른 프로그램으로 CPU를 전환시켜 줄 수 있다.
