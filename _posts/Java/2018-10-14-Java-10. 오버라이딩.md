---
title: "[Java]10. 오버라이딩(Overriding)"
excerpt: "Java 객체지향프로그래밍"
search: true
categories:
  - Language
tags:
  - Language_Java
toc: true
sidebar_main: true
---

# 10. 오버라이딩(Overriding)

## 정의
- 조상 래스로부터 상속받은 메서드의 내용을 변경하는 것을 오버라이딩이라고 한다.
- 예제

___예제 코드___

```java
class Point {
	int x;
	int y;
	String getLocation() {
		return "x: " + x + ", y: " + y;
	}
}

class Point3D extends Point {
	int z;
	String getLocation() {
		return "x: " + x + ", y: " + y + ", z: " + z;
	}
}
```

## 조건
- 자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 매서드와
	- 이름이 같아야 한다.
	- 매개변수가 같아야 한다.
	- 반환타입이 같아야 한다.
		- JDK1.5부터 '공변 반환타입(covariant return type)'이 추가되어, 반환타입을 자손 클래스의 타입으로 변경 가능하게 완화되었다.

- 조상 클래스의 메서드를 자손 클래스에서 오버라이딩할 때
	- 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
		- 범위 순서(넓은 순): public > protected > (default) > private
	- 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.
	- 인스턴스메서드를 static메서드로 또는 그 반대로 변경할 수 없다.

## 오버로딩 vs 오버라이딩
- 오버로딩(overloading): 기존에 없는 새로운 메서드를 정의하는 것
- 오버라이딩(overriding): 상속받은 메서드의 내용을 변경하는 것
- 예제

___예제 코드___

```java
class Parent {
	void parentMethod() { }
}

class Child extends Parent {
	void parentMethod() { }       //오버라이딩
	void parentMethod(int i) { }  //오버로딩

	void childMethod() { }
	void childMethod(int i) { }   //오버라이딩
	void childMethod() { }        //중복정의 에러('already defined in Child')
}
```

## super

### 1. 정의
- 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는 참조변수이다.

### 2. 특징
- super대신 this를 사용할 수 있으며, 조상 클래스 멤버와 자손 클래스 멤버가 중복 정의되어 서로 구별을 해야 하는 경우에만 super를 사용한다.
	- 위의 기능을 제외하고는 super와 this는 근본적으로 같다.
- static메서드에서는 사용할 수 없고, 오직 인스턴스메서드에서만 사용가능하다.
- 예제1: super멤버변수

___예제 코드___

```java
class SuperTest {
	public static void main(String args[]) {
		Child c = new Child();
		c.method();
	}
}

class Parent {
	int x = 10;
}

//super == this 경우
class Child extents Parent {
	void method() {
		System.out.println("x = " + x);
		System.out.println("this.x = " + this.x);
		System.out.println("super.x = " + super.x);
	}
}

//super != this 경우
class Child extents Parent {
	int x = 20;

	void method() {
		System.out.println("x = " + x);
		System.out.println("this.x = " + this.x);
		System.out.println("super.x = " + super.x);
	}
}
```

___실행 결과___

```
//super == this
x = 10
this.x = 10
super.x = 10
//super != this
x = 20
this.x = 20
super.x = 10
```

- 예제2: super메서드

___예제 코드___

```java
class Point {
	int x;
	int y;

	String getLocation() {
		return "x: " + x + ", y: " + y;
	}
}

class Point3D extends Point {
	int z;

	String getLocation() {
		//return "x: " + x + ", y: " + y + ", z: " + z;
		return super.getLocation() + ", z: " + z;
	}
}
```

## super() - 조상 클래스의 생성자
- this()와 마찬가지로 super()도 생성자이다.
- 자손 클래스의 인스턴스를 생성하면, 자손의 멤버와 조상의 멤버가 모두 합쳐진 하나의 인스턴스가 생성된다.
- 자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수 있으므로 메서드 첫 줄에 super() 생성자를 선언해주어야 한다.
	- 그렇지 않으면 컴파일러가 자동적으로 'super()'를 생성자의 첫 줄에 삽입한다.
- 예제

___예제 코드___

```java
class PointTest {
	public static void main(String args[]) {
		Point3D p3 = new Point3D();
		System.out.println("p3.x = " + p3.x);
		System.out.println("p3.y = " + p3.y);
		System.out.println("p3.z = " + p3.z);
	}
}

class Point {
	int x;
	int y;

	Point(int x, int y) {
		//super()(=Object())를 컴파일러가 자동으로 추가한다.
		this.x = x;
		this.y = y;
	}

	String getLocation() {
		return "x: " + x + ", y: " + y;
	}
}

class Point3D extends Point {
	int z;

	Point3D() {
		this(100, 200, 300);    //Point3D(int x, int y, int z) 호출
	}

	Point3D(int x, int y, int z) {
		super(x,y);    //Point(int x, int y) 호출
		this.z = z;
	}
}
```

___실행 결과___

```
p3.x = 100
p3.y = 200
p3.z = 300
```

- **Point3D p3 = new Point3D();** 인스턴스 생성시, 생성자 호출 순서
	- Point3D()
	- Point3D(int x, int y, int z)
	- Point(int x, int y)
	- Object()
