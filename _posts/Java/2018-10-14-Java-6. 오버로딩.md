---
title: "[Java]6. 오버로딩(Overloading)"
excerpt: "Java 객체지향프로그래밍"
search: true
categories:
  - Study
tags:
  - Study_Java
toc: true
sidebar_main: true
---

# 6. 오버로딩(Overloading)

## 정의
- 한 클래스내에 같은 이름의 메서드를 여러 개 정의하는 것을 말한다.
	- 이름이 같지만 매개변수의 개수 또는 타입으로 구분한다.
- 메서드 오버로딩(method overloading)을 간단히 줄여서 오버로딩이라고 한다.

## 조건
- 메서드 이름이 같아야 한다.
- 매개변수의 개수 또는 타입이 달라야 한다.
	- 컴파일러는 같은 이름의 메서드라면 오직 매개변수로만 구분하며, 타입은 영향을 끼치지 않는다.
	- 메서드 이름과 매개변수가 같다면 컴파일러는 중복 정의로 간주하여 에러를 발생시킨다.

## 예제
1. 잘못된 예제
- 매개변수의 이름만 다른 경우
	- 컴파일할 경우, 'add(int, int) is already defined'라는 에러 메시지가 나타난다.

```java
int add(int a, int b) { return a + b; }
int add(int x, int y) { return x + y; }
```

- 리턴 타입만 다른 경우

```java
int add(int a, int b) { return a + b; }
long add(int  a, int b) {return (long)(a + b); }
```

2. 올바른 예제
- 타입이 다른 두 매개변수의 순서만 다른 경우
	- 이는 사용할 때 순서가 헷갈릴 수 있어 추천하는 방법은 아니다.

```java
long add(int a, long b) { return a + b; }
long add(long a, int b) { return a + b; }
```

- 추천하는 방식

```java
int add(int a, int b) { return a + b; }
long add(long a, long b) { return a + b; }
long add(int[] a} {
	long result = 0;
	for(int i=0; i < a.length; i++) {
		result += a[i];
	}
	return result;
}
```

- 대표적인 사용 예제(println)

```java
void println()
void println(boolean x)
void println(char x)
void println(char[] x)
void println(double x)
void println(float x)
void println(int x)
void println(long x)
void println(object x)
void println(String x)
```

## 장점
- 하나의 메서드로 여러 기능을 사용할 수 있으므로, 기억하기 쉽고 오류를 줄일 수 있다.
- 메서드의 이름을 절약할 수 있다.

## 가변인자(varargs)와 오버로딩
- 가변인자: 메서드의 매개변수 개수를 동적으로 지정하는 인자
	- '타입... 변수명' 형식
	- 가변인자는 매개변수 중 가장 마지막에 선언되어야 한다. (그렇지 않으면 컴파일 에러)

```java
public PrintStream printf(String format, Object... args) {...}
```

- 장점
	- 매개변수의 개수를 다르게 사용하기위해 간단히 선언할 수 있다.
	- 인자가 아예 없어도 되고, 배열도 인자가 될 수 있다.
		- 매개변수를 배열로 할 시 인자를 무조건 지정해주어야 하는 단점이 있다.(길이가 0인 배열(JAVA에서만 가능), null을 사용해야함)

```java
String concatenate(String... str) {...}
System.out.println(concatenate());
System.out.println(concatenate("a"));
System.out.println(concatenate("a", "b"));
System.out.println(concatenate(new String[] {"A", "B"}));
```

- 단점
	- 가변인자는 내부적으로 배열을 이용하기 때문에 서언된 메서드를 호출할 때마다 배열이 새로 생성되므로 비효율적이다.
	- 가변인자를 선언한 메서드를 오버로딩하면, 메서드를 호출했을 때 구분하지 못하는 경우가 쉽게 발생하므로 오버로딩을 사용하지 않는 것이 좋다.
		- 매개변수를 다르게 선언한다 해도 에러가 발생할 확률이 높다.
