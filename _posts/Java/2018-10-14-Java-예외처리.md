---
title: "[Java]예외처리(exception handing)"
excerpt: "Java 개념"
search: true
categories:
  - Java
tags:
  - 개념 정리
toc: true
sidebar_main: true
---

# 예외처리(exception handing)

## 프로그램 오류
- 컴파일 에러(compile-time error): 컴파일 시에 발생하는 에러
- 런타임 에러(runtime error): 실행 시에 발생하는 에러
- 논리적 에러(logical error): 실행은 되지만, 의도와는 다르게 동작하는 것
- 자바에서는 실행 시(runtime)에 발생할 수 있는 프로그램 오류를 두 가지로 구분한다.
  - 에러(error): 프로그램 코드에 의해서 수습될 수 없는 심각한 오류를 말한다.
    - 예를들어, 메모리 부족(OutOfMemoryError)나 스택오버플로우(StackOverflowError)가 있다.
  - 예외(exception): 프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류를 말한다.

## 예외 클래스의 계층구조
- Exception과 Error클래스 역시 Object클래스의 자손들이다.
- 밑의 그림은 예외클래스 계층도를 주요 클래스들만을 나열한 모습이다.

![exceptionclasshierarchy](https://user-images.githubusercontent.com/34755287/44071623-3ff72644-9fc5-11e8-808d-0d1b5c6b9c07.jpg)

- Exception클래스는 두 개의 그룹으로 구분할 수 있다.
  - RuntimeException클래스와 그 자손클래스들
    - 자손클래스는 ArithmeticException, ClassCastException, NullPointerException, ..., IndexOutOfBoundException 클래스 등이 있다.
    - 해당 클래스들은 주로 프로그래머의 실수에 의해 발생될 수 있는 예외들로 자바의 프로그래밍 요소들과 관계가 깊다.
    - IndexOutOfBoundException: 배열의 범위를 벗어난 경우
    - NullPointerException: null인 참조변수의 멤버를 호출한 경우
    - ClassCastException: 클래스의 형변환이 잘못된 경우
    - ArithmeticException: 정수를 0으로 나누려고하는 경우
  - Exception클래스와 그 자손클래스들(RuntimeException과 자손들 제외)
    - 자손클래스는 IOException, ClassNotFoundException 클래스 등이 있다.
    - 프로그램의 사용자의 실수와 같은 외적인 요인에 의해 발생하는 예외이다.
    - FileNotFoundException: 존재하지 않은 파일의 이름을 입력한 경우
    - ClassNotFoundException: 실수로 클래스의 이름을 잘못된 경우
    - DataFormatException: 입력한 데이터 형식이 잘못된 경우

## 예외처리하기
### 1. try-catch문
- 예외처리: 프로그램 실행 시 발생할 수 있는 예기치 못한 예외의 발생에 대비한 코드를 작성하는 것이다.
- 예외처리의 목적은 예외의 발생으로 인한 프로그램의 비정상적인 종료를 막고, 정상적인 실행상태를 유지하는 것이다.
- 예외를 처리하지 못하면, 프로그램은 비정상적으로 종료되며, JVM의 예외처리기(UncaughtExceptionHandler)에서 처리하지 못한 예외(uncaught exception)를 받아서 그 원인을 출력한다.
- try-catch문의 구조

```java
try {
  //예외가 발생할 가능성이 있는 문장들을 넣는다.
} catch(Exception e1) {
  //Exception1이 발생했을 경우, 이를 처리하기 위한 문장을 적는다.
} catch(Exception e2) {
  //Exception2이 발생했을 경우, 이를 처리하기 위한 문장을 적는다.
}
... catch(Exception eN) {
  //ExceptionN이 발생했을 경우, 이를 처리하기 위한 문장을 적는다.
}
```

- 여러 개의 catch블럭이 올 수 있지만, 이 중 발생한 예외의 종류와 일치하는 단 하나의 catch블럭만 실행된다.
- if문과 같은 문법과 달리, 괄호({ })를 절대 생략할 수 없다.
- try-catch문은 여러개 반복해서 사용할 수 있고, try-catch문 안에 또 다른 try-catch문의 선언도 가능하다.
  - 중첩된 try-catch문을 사용할 때 같은 이름의 참조변수를 사용해서는 안된다.

### 2. try-catch문 흐름
- try블럭 내에서 예외가 발생한 경우
  - 발생한 예외와 일치하는 catch블럭이 있는지 확인한다.
  - 일치하는 catch블럭을 찾으면, 그 catch블럭 내의 문장들을 수행하고 전체 try-catch문을 빠져나가서 그 다음 문장을 계속해서 수행한다.
  (try블럭 내의 예외 발생 시점 밑의 코드들은 수행하지 않는다.)
  - 일치하는 catch블럭을 찾지 못하면, 예외는 처리되지 못한다.
- tyr블럭 내에서 예외가 발생하지 않은 경우
  - catch블럭을 거치지 않고 전체 try-catch문을 빠져나가서 계속해서 수행한다.

### 3. catch블럭
- 예외가 발생했을 때, 생성되는 예외 클래스의 인스턴스에는 발생한 예외에 대한 정보가 담겨져 있으며, getMessage()와 printStackTrace()를 통해서 이 정보에 접근가능하다.
- printStackTrace(): 예외발생 당시의 호출스택(Call Stack)에 있었던 메서드의 정보와 예외 메시지를 화면에 출력한다.
  - printStackTrace(PrintStream s)나 printStackTrace(PrintWriter s)를 통해 예외에 대한 정보를 파일에 저장할 수도 있다.
- getMessage(): 발생한 예외클래스의 인스턴스에 저장된 메시지를 얻을 수 있다.
- 멀티 catch블럭: JDK1.7부터 여러 catch블럭을 '|'기호를 이용해서 하나의 catch블럭으로 합칠 수 있다.
  - 조상과 자손 관계를 연결 시킬수는 없다.
  - 예외 클래스들의 공통 분모인 조상 예외 클래스에 선언된 멤버만을 사용할 수 있고, 참조변수는 'e'로 고정된다.

  ___기존 catch 블럭 코드___

  ```java
  try {
    ...
  } catch (ExceptionA e) {
    e.printStackTrace();
  } catch (ExceptionB e2) {
    e2.printStackTrace();
  }
  ```

  ___멀티 catch 블럭 코드___

  ```java
  try {
    ...
  } catch (ExceptionA | ExceptionB e) {
    e.printStackTrace();
  }
  ```

## 예외 발생시키기
- 키워드 'throw'를 사용해서 프로그래머가 고의로 예외를 발생시킬 수 있다.
- 사용 방법
  - 연산자 new를 이용해서 발생시키려는 예외 클래스의 객체를 만든다. ```Exception e = new Exception("고의로 발생시킴");```
  - 키워드 throw를 이용해서 예외를 발생시킨다. ```throw e;```
- 예외를 고의로 발생시켰다면, 반드시 그 예외에 대한 처리를 해주어야 한다.(try-catch문)
  - Exception 클래스(checked 예외)의 경우, 처리를 해주지 않으면 컴파일 단계에서 오류가 발생한다.
  - RuntimeException 클래스(unchecked 예외)의 경우, 컴파일에는 성공하지만 비정상적으로 종료된다.

## 메서드에 예외 선언하기
- try-catch문 외에, 메서드의 선언부에 키워드 'throws'를 사용해서 메서드 내에서 발생할 수 있는 예외를 선언해주면 된다.
  - 예외가 여러개일 경우, 쉼표(,)로 구분하고, 키워드 'throw'와 구분해야 한다.

```java
void method() throws Exception1, Exception2, ... ExceptionN {
  //메서드 내용
}
```

- 메서드의 선언부에 예외를 선언함으로써, 메서드를 사용하려는 사람이 해당 메서드를 사용하기 위해 어떠한 예외들을 처리해야 하는지 알려 줄 수 있다.
  - 예외 발생 가능성을 예측해야 하는 프로그래머들의 수고를 덜어주고, 보다 견고한 프로그램 코드를 작성할 수 있다.
  - 특히, JAVA API 작성된 메서드를 사용할때 보다 정확히 사용할 수 있다.
- 대부분 RuntimeException클래스는 적어 주지 않고, 반드시 처리해주어야 하는 예외들만 선언한다.
- 예외가 발생한 메서드에서 예외처리를 해주지 않으면, 그 메서드를 호출한 메서드에게 예외를 넘겨준다.
  - 예외가 발생하면, 해당 메서드나 호출한 메서드 둘 중 한 곳에서는 예외 처리를 해주어야 한다.

## finally 블럭
- finally블럭은 try-catch문과 함께 예외의 발생여부에 상관없이 실행되어야할 코드를 포함 시킬 목적으로 사용한다.

```java
try {
  //예외가 발생할 가능성이 있는 문장들
} catch(Exception1 e1) {
  //예외처리를 위한 문장
} finally {
  //예외의 발생여부에 관계없이 항상 수행되어야하는 문장들
}
```

- finally블럭은 try-catch문의 맨 마지막에 위치해야 한다.
- 실행 순서는 다음과 같다.
  - 예외 발생: try -> catch -> finally
  - 그 외: try -> finally
- try블럭에 return문이 있은 경우에도, finally블럭을 실행한 후에 return문이 실행된다.

## 자동 자원 반환 - try-with-resourced문
- JDK1.7부터 try-with-resourced문이라는 try-catch문 번형이 새로 추가되었다.
- 주로 입출력(I/O)과 관련된 클래스를 사용할 때 주로 사용된다.
  - 입출력이 끝난 자원을 반환할 때, finally문을 사용한다고 해도 여기서 오류가 발생하면 처리해줄 수 없기 때문에 try-with-resourced문을 사용한다.
- 예제

```java
try(fis = new FileInputStream("score.dat");
    dis = new DataInputStream(fis)) {
  while(true) {
    score = dis.readInt();
    System.out.println(score);
    sum += score;
  }
} catch(EOFException e) {
  System.out.println("점수의 총합은 ", + sum + "입니다.");
} catch(IOException ie) {
  ie.printStackTrace();
}
```

- try-with-resourced문dml 괄호()안에 객체를 생성하는 문장을 넣으면, 이 객체는 따로 close()를 호출하지 않아도 try블럭을 벗어나는 순간 자동으로 close()가 호출된다.
  - 그 다음에 catch블럭 또는 finally블럭이 수행된다.
- 괄호()안에 두 문장 이상을 넣을 경우 세미콜론(;)으로 구분해주고, 변수 선언도 가능하다.
  - 선언된 변수는 try블럭안에서만 사용가능하다.

## 사용자 정의 예외
- 프로그래머가 직접 Exception클래스로부터 상속을 받아 클래스를 만들거나, 필요에 따라 새로운 예외 클래스를 만들 수 있다.
  - 기존 예외 클래스를 상속받아 만드는 것을 추천한다.
- 예제

```java
class MyException extends Exception {
  privatee final int ERR_CODE;

  //생성자
  MyException(String msg, int errCode) {
    super(mag);            //조상인 Excepton클래스의 생성자를 호출한다.
    ERR_CODE = errCode;
  }

  //생성자
  MyException(String msg) {
    this(msg, 100);        //ERR_CODE를 100을 기본값으로 초기화한다.
  }

  //에러 코드를 얻을 수 있는 메서드
  public int getErrCode() {
    return ERR_CODE;
  }
}
```

## 예외 되던지기(exception re-throwin)
- 하나의 예외에 대해서 예외가 발생한 메서드와 호출한 메서드 양쪽에서 처리하고자 할때, 예외 되던지기 방법을 사용한다.
- 예외 되던지기는 예외를 처리한 후에 인위적으로 다시 발생시키는 것을 말한다.
- 예외가 발생한 메서드에서는 try-catch문으로 예외를 처리해줌과 동시에 메서드의 선언부에 발생할 예외를 throws에 지정해줘야 한다.
- 예제

```java
class ExceptionEX {
  public static void main(String[] args) {
    try {
      method1();
    } catch(Exception e) {
      System.out.println("main메서드에서 예외가 처리되었습니다.");
    }
  }

  static void method1() throws Exception {
    try {
      throw new Exception();
    } catch(Exception e) {
      System.out.println("method1메서드에서 예외가 처리되었습니다.");
      throw e;   //다시 예외를 발생시킨다.
    }
  }
}
```

___결과 화면___

```
method1메서드에서 예외가 처리되었습니다.
main메서드에서 예외가 처리되었습니다.
```

## 연결된 예외(chained exception)
- 한 예외가 다른 예외를 발생시킬 수 있다.
  - 예를 들어, A가 예외 B를 발생시켰다면, A를 B의 '원인 예외(cause exception)'라고 한다.

```java
Throwable initCause(Throwable cause)   //지정한 예외를 원인 예외로 등록
Throwable getCause()                   //원인 예외를 반환
```
- 연결된 예외를 사용하는 이유
  - 여러가지 예외를 하나의 큰 분류의 예외로 묶어서 다루기 위함이다.
  - checked예외를 unchecked예외로 바꾸기 위함이다.
