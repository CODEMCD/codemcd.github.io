---
title: "[Java]12. 제어자(Modifier)"
excerpt: "Java 객체지향프로그래밍"
search: true
categories:
  - Study
tags:
  - Study_Java
toc: true
sidebar_main: true
---

# 12. 제어자(Modifier)

## 정의
- 클래스, 변수, 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다.

## 종류
- 접근 제어자: public, protected, default, private
- 그 외: static, final, abstract, native, transient, synchronized, volatile, strictfp

## 특징
- 하나의 대상에 대해서 여러 제어자를 조합하여 사용하는 것이 가능하지만, 접근 제어자는 하나만 사용할 수 있다.
- 제어자들간의 순서는 관계없지만 주로 접근 제어자를 제일 왼쪽에 선언한다.

## static - 클래스의, 공통적인
- static은 '클래스의', '공통적인'의 의미를 가지고 있다.
- 클래스변수(static멤버변수)는 모든 인스턴스가 하나의 변수를 공유하기 때문에 인스턴스와 관계없이 같은 값을 갖는다.
- static은 멤버변수, 클래스, 초기화 블럭에 사용될 수 있으며, 인스턴스를 생성하지 않고도 사용할 수 있다.

| 제어자 |     대상    |                                                                            의미                                                                            |
|:------:|:-----------:|:----------------------------------------------------------------------------------------------------------------------------------------------------------:|
| static |   멤버변수  | - 모든 인스턴스에 공통적으로 사용되는 클래스변수가 된다.</br> - 클래스 변수는 인스턴스를 생성하지 않고도 사용 가능하다.</br> - 클래스가 메모리에 로드될 때 생성된다. |
| static |    메서드   | - 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다.</br> - static 메서드 내에서는 인스턴스 멤버들을 직접 사용할 수 없다.                           |
| static | 초기화 블럭 | - 클래스가 메모리에 로드될 때 단 한번만 수행된다.</br> - 주로 클래스변수를 초기화 하는데 사용된다.                                                              |

## final - 마지막의, 변경될 수 없는
- final은 '마지막의', '변경될 수 없는'의 의미를 가진다.
- 클래스, 메서드, 멤버변수, 지역변수에 사용가능하다.

| 제어자 |   대상   |                                                 의미                                                |
|:------:|:--------:|:---------------------------------------------------------------------------------------------------:|
|  final |  클래스  | 변경될 수 없는 클래스, 확장될 수 없는 클래스가 되며, final 클래스는 다른 클래스의 조상이 될 수 없다. |
|  final |  메서드  | 변경될 수 없는 메섣, final 메서드는 오버라이딩을 통해 재정의 될 수 없다.                             |
|  final | 멤버변수 | 변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다.                                          |
| final  | 지역변수 | 변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다.                                          |

- 일반적으로 final이 붙은 변수는 선언과 동시에 초기화를 하지만, 인스턴스 변수의 경우에는 생성자에서 초기화가 가능하다.
	- 각 인스턴스마다 final이 붙은 멤버변수가 각각 다른 값을 갖도록 하는 것이 가능하다.

## abstract - 추상의, 미완성의
- abstract는 '미완성'의 의미를 가진다.
- 클래스, 메서드에 사용가능하다.

|   제어자  |  대상  |                               의미                               |
|:---------:|:------:|:----------------------------------------------------------------:|
|  abstract | 클래스 | 클래스 내에 추상 메서드가 선언되어 있음을 의미한다.(추상 클래스)              |
| abstraact | 메서드 | 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알린다. |


```java
abstract class AbstractTest {     // 추상 클래스(추상 메서드를 포함한 클래스)
	abstract void move();     // 추상 메서드(구현부가 없는 메서드)
}
```

- 추상 클래스는 미완성이므로, 인스턴스를 생성할 수 없다.
- 완성된 클래스도 abstract를 선언하여 추상 클래스로 만드는 경우가 있다.
	- 메서드들에 아무 내용이 없어 인스턴스 자체를 생성하지 못하게 하기 위함이다.
	- 이 경우, 주로 원하는 메서드만 오버라이딩을 해서 쓰기 위해 사용된다.

## 접근 제어자(access modifier)
### 1. 정의와 특징
- 접근 제어자는 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.
- 클래스, 멤버변수, 메서드, 생성자에 사용된다.
- O: 접근 가능, X: 접근 불가능

|   제어자  | 같은 클래스 | 같은 패키지 | 자손 클래스 | 전 체 |
|:---------:|:-----------:|:-----------:|:-----------:|:-----:|
|   public  |      O      |      O      |      O      |   O   |
| protected |      O      |      O      |      O      |   X   |
| (default) |      O      |      O      |      X      |   X   |
|  private  |      O      |      X      |      X      |   X   |

- default는 접근 제어자를 선언하지 않으면 자동으로 지정된다.
- protected는 패키지에 관계없이 상속관계에 있는 자손클래스와 같은 패키지내에 있는 모든 클래스에서 접근 가능하다.

|   대 상  |         사용가능한 접근 제어자        |
|:--------:|:-------------------------------------:|
|  클래스  |           public, (default)           |
|  메서드  | public, protected, (default), private |
| 멤버변수 | public, protected, (default), private |
| 지역변수 |                 없 음                 |

### 2. 접근 제어자를 이용한 캡슐화
- 접근 제어자를 사용하는 이유 = 캡슐화(encapsulation)를 하는 이유
	- 외부로부터 데이터를 보호하기 위해(data hiding)
		- 데이터가 유효한 값을 유지하며, 외부로부터 함부로 변경하는 것을 막는다.
	- 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서
		- 복잡성을 줄이고, 접근 범위를 최소화한다.
		- 에러 테스트 상황에서 public은 모든 범위, default는 패키지 내부, private는 클래스 내부만 확인하면 된다.
- 올바른 사용 예제
	- 상속을 통해 확장될 것이 예상된다면, 멤버 변수 접근 제어자를 protected로 하며, 그렇지 않다면 private로 한다.
	- 멤버변수의 값을 읽는 메서드의 이름은 'get멤버변수이름' 값을 변경하는 메서드의 이름은 'set멤버변수이름'을 주로 사용한다.

___예제 코드___

```java
public class Time {
	// 접근 제어자를 private로 하여 외부에서 직접 접근하지 못하도록 한다.
	private int hour;
	private int minute;
	private int second;

	//getter
	public int getHour() { return hour; }
	public int getMinute() { return minute; }
	public int getSecond() { return second; }

	//setter
	public void setHour(int hour) {
		if (hour < 0 || hour > 23) return;
		this.hour = hour;
	}
	public void setMinute(int minute) {
		if (minute < 0 || minute > 59) return;
		this.minute = minute;
	}
	public void setSecond(int second) {
		if (second < 0 || second > 23) return;
		this.second = second;
	}
}
```

- 하나의 소스파일(.java)에는 public클래스가 단 하나만 존재할 수 있으며, 소스파일 이름은 반드시 public클래스의 이름과 같아야 한다.

### 3. 생성자의 접근 제어자
- 생성자에 접근 제어자를 사용하여 인스턴스의 생성을 제한할 수 있다.
- 사용 예제
	- 생성자의 접근 제어자를 private(또는 protected)로 지정하여, 클래스 내부에서 인스턴스를 생성한다. (인스턴스 개수 제한)
	- 인스턴스를 생성해서 반환해주는 메서드의 접근 제어자는 public으로 해야하며, 동시에 static이어야 한다.
		- 인스턴스를 생성하지 않고도 호출할 수 있어야 하기 때문에 static을 사용한다.

___예제 코드___

```java
class Singleton {
	// getInstance()에서 사용될 수 있도록 인스턴스가 미리 생성되어야 하므로 static을 사용한다.
	private static Singleton s = new Singleton();

	private Singleton() {
		...
	}

	// 인스턴스를 생성하지 않고도 호출할 수 있어야 하기 때문에 static을 사용한다.
	public static Singleton getInstance() {
		return s;
	}

	...
}
```

## 제어자의 조합

|   대 상  |                        사용가능한 제어자                       |
|:--------:|:--------------------------------------------------------------:|
|  클래스  |               public, (default), final, abstract               |
|  메서드  | public, protected, (default), private, final, abstract, static |
| 멤버변수 |      public, protected, (default), private, final, static      |
| 지역변수 |                              final                             |

- 제어자 조합시 주의사항
	- 메서드에 static과 abstract를 동시에 사용할 수 없다.
		- static메서드는 몸통이 있는 메서드에만 사용할 수 있기 때문이다.
	- 클래스에 abstract와 final을 동시에 사용할 수 없다.
		- final 클래스는 확장할 수 없다는 의미이고, abstract는 상속을 통해서 완성되어야 하는 의미이므로 서로 모순된다.
	- abstract 메서드의 접근 제어자가 private일 수 없다.
		- abstract 메서드는 자손클래스에서 구현해주어야 하는데 접근 제어자가 private이면, 자손클래스에서 접근할 수 없다.
	- 메서드에 private와 final을 같이 사용할 수 없다.
		- 접근 제어자가 private인 메서드는 오버라이딩될 수 없기 때문에, 이 둘 중 하나만 사용하면 된다.
