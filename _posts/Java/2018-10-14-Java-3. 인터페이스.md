---
title: "[Java]3. 인터페이스(interface)"
excerpt: "Java 객체지향프로그래밍"
search: true
categories:
  - Java
tags:
  - 개념 정리
toc: true
sidebar_main: true
---

# 3. 인터페이스(interface)

## 정의 및 특징
- 인터페이스는 일종의 추상 클래스이다.
- 추상클래스보다 추상화 정도가 높다.
  - 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다.
  - 추상메서드와 상수만을 멤버로 가질 수 있다.

## 인터페이스 작성
- 인터페이스를 작성하는 것은 클래스를 작성하는 것과 같다
  - 키워드 'class' 대신 'interface'를 사용해야 한다.
  - 접근제어자를 사용할 수 있다.

```java
interface 인터페이스이름 {
  public static final 타입 상수이름 = 값;
  public abstract 메서드이름(매개변수목록);
}
```

- 인터페이스 멤버들의 제약사항
  - 모든 멤버변수는 public static final 이어야 하며, 이를 생략할 수 있다.
  - 모든 메서드는 public abstract 이어야 하며, 이를 생략할 수 있다.
  - JDK1.8부터 static메서드와 디폴트 메서드를 사용할 수 있다.
- 인터페이스에 정의된 모든 멤버에게 적용되기 때문에 생략될 수 있으며, 컴파일 시에 자동으로 추가해준다.

## 인터페이스 상속
- 인터페이스는 인터페이스로부터만 상속이 가능하다.
- 클래스와 달리 다중상속이 가능하다.
- 인터페이스는 Object클래스와 같은 최고 조상이 없다.
- 예제

___예제 코드___

```java
interface Movable {
  /** 지정된 위치 (x,y)로 이동하는 기능의 메서드 */
  void move(int x, int y);
}
interfave Attackable {
  /** 지정된 대상 (u)를 공격하는 기능의 메서드 */
  void attack(Unit u);
}
interface Fightable extends Movable, Attackable { }
```

## 인터페이스 구현
- 인터페이스도 추상클래스와 같이 그 자체로는 인스턴스를 생성하지 못한다.
  - 인터페이스 자신을 상속받는 클래스를 선언하여 메서드의 몸통을 오버라이딩을 통해 만들어주어야한다.
- 인터페이스를 상속할 때는 키워드 'extends'(확장하다) 대신 'implements'(구현하다)를 사용해야 한다.

```java
class 클래스이름 implements 인터페이스이름 {
  // 인터페이스에 정의된 추상메서드를 구현해야 한다.
}

class Fighter implements Fightable {
  public void move(int x, int y) { ... }
  public void attack(Unit u) { ... }
}
```

- 만일 구현하는 인터페이스의 메서드 중 일부만 구현한다면, 'abstract'를 붙여 추상클래스로 선언해야 한다.

```java
abstract class Fighter implements Fightable {
  public void move(int x, int y) { ... }
}
```

- 상속과 구현을 동시에 할 수 있다.

```java
class Fighter extends Unit implements Fightable {
  ...
}
```
- 인터페이스의 이름에는 주로 '~able'(할 수 있는) 이라는 키워드를 붙인다.
  - 반드시 붙는 것은 아니기 때문에 위의 키워드가 붙었다면 인터페이스라고 추측만 할 수 있다.
- 예제

___예제 코드___

```java
class FighterTest {
	public static void main(String[] args) {
		Fighter f = new Fighter();

		if(f instanceof Unit) {
			System.out.println("f는 Unit클래스의 자손입니다.");
		}
		if(f instanceof Fightable) {
			System.out.println("f는 Fightable인터페이스를 구현했습니다.");
		}
		if(f instanceof Movable) {
			System.out.println("f는 Movable인터페이스를 구현했습니다.");
		}
		if(f instanceof Attackable) {
			System.out.println("f는 Attackable인터페이스를 구현했습니다.");
		}
		if(f instanceof Object) {
			System.out.println("f는 Object클래스의 자손입니다.");
		}
	}
}

class Fighter extends Unit implements Fightable {
	public void move(int x, int y) { /*내용 생략*/ }
	public void attack(Unit u) { /*내용 생략*/ }
}

class Unit {
	int currentHP;  //유닛의 체력
	int x;          //유닛의 x좌표
	int y;          //유닛의 y좌표
}

interface Fightable extends Movable, Attackable { }
interface Movable { void move(int x, int y); }
interface Attackable { void attack(Unit u); }
```

___결과___

```
f는 Unit클래스의 자손입니다.
f는 Fightable인터페이스를 구현했습니다.
f는 Movable인터페이스를 구현했습니다.
f는 Attackable인터페이스를 구현했습니다.
f는 Object클래스의 자손입니다.
```

- 클래스와 인터페이스간의 관계도

![fighter hierarchy](https://user-images.githubusercontent.com/34755287/43456719-8c3e5ebc-94ff-11e8-9921-1fe040860548.JPG)

- Moavable인터페이스에서 move메서드의 접근 제어자는 'public abstract'가 생략되었다.
  - Fighter클래스에서 move메서드의 접근 제어자가 public인 이유이다.

## 인터페이스를 이용한 다중상속
- 자바에서는 일반적으로 다중상속의 단점이 더 크다고 판단되어 허용하지 않는다.
- C++에서는 다중상속이 가능하므로 자바에서는 인터페이스를 이용하여 다중상속이 가능하도록 만들었다.
  - 하지만 인터페이스가 다중상속을 위한 것이 아니고 여전히 단점이 크므로 다중상속으로 구현하는 경우는 거의 없다.

## 인터페이스를 이용한 다형성
- 인터페이스 역시 클래스와 같이 다형성을 제공한다.
  - 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있다.
  - 인터페이스 타입으로 형변환이 가능하다.
	- 인터페이스의 타입을 매개변수 타입으로 사용할 수 있다.
	- 메서드의 리턴타입으로 인터페이스의 타입을 지정할 수 있다.
		- **리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인터페이스를 반환한다는 것을 의미한다.**
- 예제

___예제 코드___

```java
interface Parseable {
	//구문 분석작업을 수행한다.
	public abstract void parse(String fileName);
}

class ParserManager {
	//리턴타입이 Parseable인터페이스이다.
	public static Parseable getParser(String type) {
		if(type.equals("XML")) {
			/*
			Parseable p = new XMLParser();
			return p;
			*/
			return new XMLParser();
		}
		else {
			/*
			Parseable p = new HTMLParser();
			return p;
			*/
			return new HTMLParser();
		}
	}
}

class XMLParser implements Parseable {
	public void parse(String fileName) {
		/* 구문 분석작업을 수행하는 코드를 적는다. */
		System.out.println(fileName + " - XML parsing completed.");
	}
}

class HTMLParser implements Parseable {
	public void parse(String fileName) {
		/* 구문 분석작업을 수행하는 코드를 적는다. */
		System.out.println(fileName + " - HTML parsing completed.");
	}
}

class ParserTest {
	public static void main(String args[]) {
		Parseable parser = ParserManager.getParser("XML");
		parser.parse("document.xml");
		parser = ParserManager.getParser("HTML");
		parser.parse("document2.html");
	}
}
```

___출력 결과___

```
document.xml - XML parsing completed.
document2.html - HTMLparsing completed.
```

- 밑의 예제코드를 통해 분산환경 프로그래밍에서 큰 장점을 가진다.
	- 사용자 컴퓨터에 설치된 프로그램을 변경하지 않고 서버측의 변경만으로도 사용자가 새로 개정된 프로그램을 사용할 수 있다.
	- 예를들어, ParserManager클래스의 getParser메서드에서 'return new XMLParser(); 대신 'return new NEWXMLParser();'로 변경하기만 하면 된다.

## 인터페이스의 장점
- 개발시간을 단축시킬 수 있다.
	- 인터페이스가 작성되면, 이를 사용해서 프로그램을 작성하는 것이 가능하다. 메서드를 호출하는 쪽에서는 메서드의 내용에 관계없이 선언부만 알면되기 때문이다.
	- 동시에 다른 한 쪽에서는 인터페이스를 구현하는 클래스를 작성하도록 하여, 인터페이스를 구현하는 클래스가 작성할 때까지 기다리지 않고 양쪽에서 동시에 개발이 가능하다.
- 표준화가 가능하다.
	- 프로젝트에 사용되는 기본 틀을 인터페이스로 작성한 다음, 개발자들에게 인터페이스를 구현하여 프로그램을 작성하도록 함으로써 보다 일관되고 정형화된 프로그램 개발이 가능하다.
- 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.
	- 서로 상속관계에 있지 않고, 같은 조상클래스를 가지고 있지 않은 서로 아무런 관계가 없느느 클래스들에게 하나의 인터페이스를 공통으로 구현하도록 하여 관계를 맺어 줄 수 있다.
- 독립적인 프로그래밍이 가능하다.
	- 인터페이스를 이용하면 클래스의 선언과 구현을 분리시킬 수 있어 독립적인 프로그램을 작성할 수 있다.
	- 클래스간의 직접적인 관계를 인터페이스를 이용해서 간접적인 관계로 변경하면, 한 클래스의 변경이 관련된 다른 클래스에 영향을 미치지 않는다.

## 인터페이스의 의해
- 클래스를 사용하는 쪽(User)과 클래스를 제공하는 쪽(Provider)이 있다.
- 메서드를 사용(호출)하는 쪽(User)에서는 사용하려는 메서드(Provider)의 선언부만 알면 된다.
- 예제

___예제 코드___

```java
class A {
	public void methodA(B b) {
		b.methodB();
	}
}

class B {
	public void methodB() {
		System.out.println("methodB()");
	}
}

class InterfaceTest {
	public static void main(Sting args[]) {
		A a = new A();
		a.methodA(new B());
	}
}
```

___출력 결과___

```
methodB()
```

- 위 예제 코드의 클래스간의 관계는 ```A(User) -> B(Provider)```와 같이 서로 직접적인 관계에 있다.
	- 이 경우, 클래스 A를 작성하기 위해서는 클래스 B가 이미 작성되어 있어야 한다.
	- 클래스 B의 methodB()의 선언부가 변경되면, 이를 사용하는 클래스 A도 변경되어야 한다.
- 위의 단점을 개선하기 위해 2가지를 생각해보자.
	- Provider 클래스는 인터페이스를 활용하여 구현한다.
		- 클래스 A를 작성하는데 클래스 B가 관련되지 않는다.
	- 클래스 A가 매개변수를 통해서 인터페이스를 구현한 클래스의 인스턴스를 동적으로 생성하는 것보다 제 3의 클래스를 활용한다.
		- 나중에 다른 클래스의 인스턴스로 변경되어도 클래스 A는 변경할 필요가 없다.

___예제 코드___

```java
class InterfaceTest {
	public static void main(String args[]) {
		A a = new A();
		a.methodA();
	}
}

class A {
	void methodA() {
		//제 3의 클래스의 메서드를 통해서 인터페이스 I를 구현한 클래스의 인스턴스를 얻어온다.
		I i = InstanceManager.getInstance();
		i.methodB();
		//인터페이스 I 타입의 참조변수 i로도 Object클래스에 정의된 메서드들을 호출 가능하다.
		System.out.println(i.toString());
	}
}

interface I {
	public abstract void mathodB();
}

class B implements I {
	public void methodB() {
		System.out.println("methodB int B class");
	}
	public String toString() { return "class B"; }
}

class InstanceManager {
	public static I getInstance() {
		return new B();
	}
}
```

___출력 결과___

```
methodB in B class
class B
```

## 디폴트 메서드와 static 메서드
- JDK1.8부터 인터페이스에 디폴트 메서드와 static 메서드도 추가할 수 있게 되었다.
- 디폴트 메서드: 추상 메서드의 기본적인 구현을 제공하는 메서드
	- 추상 메서드가 아니기 때문에, 새로 추가되어도 해당 인터페이스를 구현한 클래스를 변경하지 않아도 된다.
	- 메서드 앞에 키워드 'default'를 붙이며, 일반 메서드처럼 몸통 {}이 있어야 한다.
	- 접근 제어자는 'public'이며, 생략할 수 있다.
- 새로 추가된 디폴트 메서드는 기존의 메서드와 이름이 중복되어 충돌하는 경우가 생긴다.
	- 여러 인터페이스의 디폴트 메서드 간의 충돌
		- 인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩해야 한다.
	- 디폴트 메서드와 조상 클래스의 메서드 간의 충돌
		- 조상 클래스의 메서드가 상속되고, 디폴트 메서드는 무시된다.
