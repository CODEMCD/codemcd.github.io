---
title: "[Kotlin]4. 클래스 및 인터페이스"
excerpt: "Kotlin 개념"
search: true
categories:
  - Kotlin
tags:
  - 개념 정리
toc: true
---

# 클래스 및 인터페이스

## 클래스와 인터페이스의 선언 및 인스턴스 생성
### 1. 클래스
- 클래스를 선언하는 방법은 자바와 거의 동일하다.
- 예제

___예제 코드___

```
//패키지 foo.bar에 포함된 클래스 Baz선언
package foo.bar
class Baz {
  ---
}

//클래스 본체 없이 클래스를 선언할 수 있다.
class Foo
```

- 코틀린에서 접근 제한자를 지정하지 않는 경우 public으로 간주한다.
- 코틀린에서는 키워드 'new'없이 인스턴스 생성이 가능하다.
- 예제

___예제 코드___

```
val foo: Foo = Foo()
//인자 하나를 받는 생성자로 인스턴스 생성
val bar: Bar = Bar(1);
```

### 2. 인터페이스
- 인터페이스의 생성은 자바와 비슷하지만, 인터페이스의 인스턴스 생성은 조금 다르다.
- 예제

___예제 코드___

```
//인터페이스 선언
interface Bar {
  fun baz()
}
//인터페이스의 인스턴스 생성
//object: [인터페이스 이름] 형태
val bar = object: Bar {
  override fun baz() {
    //함수 구현
  }
}
```

### 추상 클래스(abstract class)
- 추상 클래스의 선언 방법은 자바와 동일하지만, 인스턴스 생성은 다르며, 코틀린의 인터페이스의 인스턴스 생성과 유사하다.
- 추상 클래스에서는 인스턴스 생성 시 생성자를 사용하지만, 생성자가 없는 인스턴스는 인스턴스 이름만 사용한다.
- 예제

___예제 코드___

```
//추상 클래스 선언
abstract class Foo {
  abstract fun bar()
}
//추상 클래스의 인스턴스 생성
//object: [생성자] 형태
val foo = object: Foo() {
  override fun bar() {
    //함수 구현
  }
}
```
## 프로퍼티(property)
- 프로퍼티는 자료를 저장할 수 있는 필드(field)와 이에 상응하는 Getter/Setter 메서드를 함께 제공하며, 자바의 필드와 유사한 형태로 선안한다.
  - 자바는 클래스내의 멤버함수에 접근하기 위해 Getter/Setter 메서드를 직접 추가해주어야 하기 때문에 코드의 양이 불필요하게 늘어난다.
- 프로퍼티 역시 'val'와 'var' 중 하나로 선언해야 한다.
  - val: Getter 메서드만 존재한다.
  - var: Getter/Setter 메서드 모두 존재한다.
- 프로퍼티는 초기값을 명시적으로 지정해야 하며, 그렇지 않은 경우 컴파일 에러가 발생한다.
- 프로퍼티 선언 시점이나 생성자 호출 시점에 값을 할당하지 않을 경우 'lateinit' 키워드를 사용하여 초기 할당없이 사용할 수 있다.
  - 키워드 'lateinit'은 프로퍼티 값을 나중에 할당할 것이라고는 것을 명시하는 것으로서, 'var' 프로퍼티에만 사용가능하다.
- 프로퍼티 역시 타입 추론이 가능하기 때문에 타입 선언을 생략할 수 있다.
- 예제

___예제 코드___

```
class Person {
  //기본 예제
  val name: String? = null
  var address: String? = null

  //lateinit
  lateinit var adderss: String?

  //타입 추론
  var name = "No Name"
  var address: String? = null  //null만으로는 타입을 추론할 수 없기 때문에 타입 선언이 필요하다.
}
```

## 접근 제한자
- 접근 제한자는 자바와 거의 동일하다.
  - 제한자가 없으면 자동으로 public으로 간주한다.
- 자바와 다르게 'internal' 접근 제한자가 존재한다.
  - 자바에서 public의 접근 범위는 동일한 패키지 안이다. 하지만 외부 모듈이라도 패키지 이름이 같다면 접근이 가능하다.
  - 위를 보완하기 위해 코틀린에서는 internal 접근 제한자를 제공한다.
- 'internal' 접근 제한자의 범위는 동일한 모듈 내이다.
  - IntelliJ IDEA 모듈
  - Maven/Gradle 프로젝트
  - 하나의 Ant 태스크 내에서 함께 컴파일되는 파일들

## 생성자
### 1. 기본 생성자
- 코틀린의 기본 생성자는 자바보다 더욱 직관적으로 정의한다.
  - init {} 사용
- 예제

___ 예제 코드___

```
class Foo {
  init {
    //생성자에서 수행할 작업들...
  }
}
```

### 2. 주 생성자(primary constructor)
- 생성자에 인자가 필요한 경우 주 생성자를 활용한다.
- 주 생성자로 클래스 내부의 프로퍼티를 대신해서 사용할 수 있으므로, 프로퍼티를 생략할 수 있다.
- 예제

___예제 코드___

```
//기본 생성자에서 주 생성자의 인자를 사용할 수 있다.
class Foo(a: Int) {
  init {
    Log.d("Foo", "Number: $a")
  }
}

//프로퍼티 대신 주 생성자를 사용할 수 있다.
class Foo(val a: Int, var b: Char)
```

### 3. 추가 생성자
- 주 생성자 외에 다른 형태의 생성자가 필요한 경우 'constructor' 키워드를 사용하여 추가 생성자를 선언할 수 있다.
- 추가 생성자를 정의하는 경우 주 생성자를 반드시 호출해야 한다.
- 추가 생성자에서는 인자와 프로퍼티를 함께 선언할 수 없다.
  - 프로퍼티 선언이 필요한 인자인 경우 반드시 주 생성자에서 이를 처리해야 한다.
  - 예제

  ___예제 코드___

  ```
  class Foo(val a: Int, var b: Char) {
    //a값만 인자로 받는 추가 생성자
    constructor(a: Int) : this(a, 0)

    //두 인자의 값을 모두 0으로 지정하는 생성자
    constructor() : this(0, 0)
  }
  ```

### 4. 생상자의 접근 제한자
- 생성자의 가시성을 변경하려면 constructor 키워드 앞에 접근 제한자를 추가하면 된다.
- 주 생성자는 생략하였던 constructor 키워드를 추가하고 그 앞에 접근 제한자를 추가해야 한다.
- 예제

___예제 코드___

```
class Foo internal constructor(val a: Int, var b: Char) {
  private constructor(a: Int) this(a, 0)

  // 접근 제한자를 지정하지 않았으므로 public
  constructor(): this(0, 0)
}
```

## 함수(function)
- 코틀린은 자바의 클래스 내 메서드를 함수로 표현한다.
- 함수에서 특별한 값을 반환하지 않는다면 '함수 자체'를 의미하는 Unit 타입을 반환하며, 이는 생략 할 수 있다.
- 예제

___예제 코드___

```
class Foo {
  //아무 값도 반환하지 않는 함수, 생략 가능
  fun foo(): Unit { }

  //정수 값을 반환하는 함수
  private fun bar(): Int {
    return 0
  }
}
```

## 상속 및 인터페이스 구현
- 코틀린에서 상속 및 인터페이스는 키워드로 구분하는 자바와 달리 콜론(:) 뒤에 상속한 클래스나 구현한 인터페이스를 표기한다.
- 클래스를 상속하는 경우 반드시 부모 클래스의 생성자를 호출해야 한다.
  - 부모 클래스의 생성자가 여러 개일 경우, 클래스의 선언부가 아닌 내부에서 호출할 수도 있다.
- 코틀린에서 부모 클래스의 메서드 재정의, 인터페이스 구현한 메서드는 앞에 'override' 키워드를 반드시 붙여야 한다.
  - 자바에서 이를 '@Override' 어노테이션으로 구분하는데, 이는 선택 사항이다.
- 코틀린에서는 'open' 키워드를 붙인 클래스나 함수만이 상속이나 재정의를 할 수 있다.
  - 자바에서는 'final' 키워드로 더 이상 상속이나 재정의를 할 수 없도록 한다.
- 예제

___예제 코드___

```
// AppCompatActivity 상속: AppCompatActivity()로 기본 생성자를 바로 호출한다.
// View.OnClickListener 구현
class MyActivity: AppCompatActivity(), View.OnClickListener {
  // AppCompatActivity의 onCreate() 메서드 상속
  override fun onCreate(savedInstanceState: Bundle?) {
    super.oncreate(savedInstanceState)
  }

  // View.OnClickListener 인터페이스 구현
  override fun onClick(v: View) { }
}

// 'open' 키워드 사용 예제
open class OpenClass {
  open val openProperty = "foo"
  val finalProperty = "bar"
  open fun openFunc() { }
  fun finalFunc() { }
}

// 성공: OpenClass 앞에 'open' 키워드가 있으므로 상속 가능한 클래스이다.
class FinalClass : OpenClass() {
  // 성공: '부모 클래스의 openProperty 변수 앞에 'open' 키워드가 있으므로 재정의가 가능한 프로퍼티이다.
  override val openProperty = "FOO"
  // 실패: 해당 프로퍼티에 'open' 키워드가 없다.
  override val finalProperty = "BAR"
  // 성공: '부모 클래스의 openFunc 함수 앞에 'open' 키워드가 있으므로 재정의가 가능한 함수이다.
  override open fun openFunc() { }
  // 실패: 해당 함수에 'open' 키워드가 없다.
  override fun finalFunc() { }
}

// 실패: 해당 클래스에 'open' 키워드가 없다.
class Foo : FinalClass()
```

## this
- 코틀린의 this 키워드는 자바와 거의 동일하다.
- 자바에서 ```{클래스 이름}.this```를 코틀린에서는 ```this@{클래스 이름}``` 형태로 사용된다.

## 정적 필드 및 메서드
- 코틀린에서는 자바와 달리 정적 필드와 메서드를 사용하여, 클래스 내에 상수를 정의하거나 static 메서드(인스턴스 생성 없이 사용할 수 있는 메서드)를 정의할 수 없다.
- 일반적인 경우 클래스 내에 선언했던 정적 필드나 메서드는 패키지 단위(package-level)로 선언할 수 있다.
- 패키지 단위로 선언한 값이나 함수는 패키지에 종속되므로 ```import {패키지 이름}.{값 혹은 함수 이름}```으로 사용해야 한다.
- 예제

___자바 코드___

```
//Foo.java
package foo.bar;
public class Foo {
  //정적 필드 상수 선언
  public static final int FOO = 123;
  //정적(static) 메서드 선언
  public static void foo() { }
  //인스턴스 메서드: 인스턴스를 생성해야 사용할 수 있는 메서드
  public void bar() { }
}
```
```
import foo.bar.Foo;
public class Bar {
  public void bar() {
    //Foo클래스 내의 정적 필드 FOO의 값을 참조한다.
    int foo = foo.Foo;
    //Foo 클래스 내의 정적 메서드 foo를 호출한다.
    Foo.foo();
  }
}
```

___코틀린 코드___

```
//Foo.kt
package foo.bar

//값 FOO를 패키지 foo.bar에 선언한다.
const val FOO = 123

//함수 foo를 패키지 foo.bar에 선언한다.
fun foo()

class Foo {
  //함수 bar는 Foo의 인스턴스를 생성해야 사용할 수 있다.
  fun bar() { }
}
```
```
import foo.bar.Foo
import foo.bar.foo

clas Bar {
  //foo.bar 패키지 내의 FOO 값을 참조한다.
  val foo = Foo

  //foo.bar 패키지 내의 함수 foo를 호출한다.
  foo()
}
```

- 클래스 내 private로 선언된 멤버에 접근해야 하는 팩토리 메서드(factory method)는 패키지 단위 함수로 구현할 수 없다.
  - 동반 객체(companion object)를 사용하면 클래스 내 모든 멤버에 접근할 수 있고, 인스턴스 생성 없이 호출가능한 함수를 작성할 수 있다.
  - 동반 객체: 클래스별로 하나씩 클래스의 인스턴스 생성 없이 사용할 수 있는 오브젝트(object)를 정의할 수 있는데, 이를 동반 객체라 한다.
  - 예제

  ```
  class User private constructor(val name: String, val registerTime: Long) {
    companion object {
      //동반 객체는 클래스 내부에 존재하므로, private로 선언된 생성자에 접근할 수 있다.
      fun create(name: String) : User {
        return User(name, System.currentTimeMillis())
      }
    }
  }
  ```

## 싱글톤(singleton)
- 싱글톤은 단 하나의 인스턴스만 생성되도록 제약을 둔 디자인 패턴이다.
- 코틀린에서는 이를 단 한줄로 간편하게 선언할 수 있다.
- 예제

```
object singleton
```

## enum 클래스
## 어노테이션 클래스(annotation class)
## 중첩 클래스(nested class)
